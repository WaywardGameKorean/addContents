"use strict";
var __decorate = this && this.__decorate || function(e, t, a, i) {
    var n = arguments.length, o = n < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, a) : i, r;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        o = Reflect.decorate(e, t, a, i);
    else
        for (var s = e.length - 1; s >= 0; s--)
            (r = e[s]) && (o = (n < 3 ? r(o) : n > 3 ? r(t, a, o) : r(t, a)) || o);
    return n > 3 && o && Object.defineProperty(t, a, o),
    o
}
;
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("entity/IStats", ["require", "exports"], function(e, t) {
    var a, i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Health = 0] = "Health",
        e[e.Stamina = 1] = "Stamina",
        e[e.Hunger = 2] = "Hunger",
        e[e.Thirst = 3] = "Thirst",
        e[e.Weight = 4] = "Weight",
        e[e.Attack = 5] = "Attack",
        e[e.Benignity = 6] = "Benignity",
        e[e.Malignity = 7] = "Malignity",
        e[e.Defense = 8] = "Defense",
        e[e.Reputation = 9] = "Reputation",
        e[e.Metabolism = 10] = "Metabolism",
        e[e.Strength = 11] = "Strength",
        e[e.Produce = 12] = "Produce",
        e[e.Happiness = 13] = "Happiness",
        e[e.Tamed = 14] = "Tamed"
    }(a = t.Stat || (t.Stat = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Auto = 1] = "Auto",
        e[e.Attribute = 2] = "Attribute",
        e[e.Statbar = 3] = "Statbar"
    }(i = t.StatDisplayType || (t.StatDisplayType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("save/ISerializer", ["require", "exports"], function(e, t) {
    var a;
    function i() {
        return function(e, t) {
            const a = e.constructor;
            a._saveProperties || (a._saveProperties = []),
            a._saveProperties.push(t)
        }
    }
    function n() {
        return function(e) {
            e._saveAllProperties = !0
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Invalid = 0] = "Invalid",
        e[e.Undefined = 1] = "Undefined",
        e[e.Null = 2] = "Null",
        e[e.Boolean = 3] = "Boolean",
        e[e.ByteSigned = 4] = "ByteSigned",
        e[e.ByteUnsigned = 5] = "ByteUnsigned",
        e[e.ShortSigned = 6] = "ShortSigned",
        e[e.ShortUnsigned = 7] = "ShortUnsigned",
        e[e.IntegerSigned = 8] = "IntegerSigned",
        e[e.IntegerUnsigned = 9] = "IntegerUnsigned",
        e[e.Float32 = 10] = "Float32",
        e[e.Float64 = 11] = "Float64",
        e[e.String = 12] = "String",
        e[e.Array = 13] = "Array",
        e[e.Object = 14] = "Object",
        e[e.ArrayBuffer = 15] = "ArrayBuffer",
        e[e.Item = 16] = "Item",
        e[e.Creature = 17] = "Creature",
        e[e.TimeManager = 18] = "TimeManager",
        e[e.Player = 19] = "Player",
        e[e.ArrayV2 = 20] = "ArrayV2",
        e[e.Doodad = 21] = "Doodad",
        e[e.NPC = 22] = "NPC",
        e[e.Map = 23] = "Map",
        e[e.DoodadV2 = 24] = "DoodadV2",
        e[e.MessageManager = 25] = "MessageManager",
        e[e.Function = 26] = "Function",
        e[e.ClientStore = 27] = "ClientStore",
        e[e.Vector3 = 28] = "Vector3",
        e[e.Vector2 = 29] = "Vector2"
    }(a = t.Types || (t.Types = {})),
    t.SaveProperty = i,
    t.SaveAllProperties = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/math/IVector", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/math/Math2", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.π = Math.PI,
    t.τ = 2 * Math.PI,
    function(e) {
        function t(e, t, a) {
            return a > t ? t : a < e ? e : a
        }
        function a(e, t) {
            return Math.round(Math.round(e * Math.pow(10, t + 1)) / Math.pow(10, 1)) / Math.pow(10, t)
        }
        function i(e, t) {
            return Math.round(e) % t == 0 ? Math.round(e) : Math.round((e + t / 2) / t) * t
        }
        function n(e, t, a) {
            return (1 - a) * e + a * t
        }
        function o(e, t) {
            return (e % t + t) % t
        }
        e.clamp = t,
        e.clamp1 = t.bind(null, 0, 1),
        e.clamp255 = t.bind(null, 0, 255),
        e.roundNumber = a,
        e.roundNumberToMultiple = i,
        e.lerp = n,
        e.mod = o
    }(a || (a = {})),
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/math/Vector3", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const a = 1e-6;
    class i {
        constructor(e, t, a) {
            this.values = new Float32Array(3),
            "number" == typeof t ? "object" == typeof e ? (this.z = t,
            this.y = e.y,
            this.x = e.x) : (this.z = a,
            this.y = t,
            this.x = e) : "number" == typeof e ? this.x = this.y = this.z = e : e && (Array.isArray(e) ? this.xyz = e : (this.x = e.x,
            this.y = e.y,
            this.z = e.z))
        }
        static get ZERO() {
            return new i(0)
        }
        static get ONE() {
            return new i(1)
        }
        static get UP() {
            return new i(0,1,0)
        }
        static get RIGHT() {
            return new i(1,0,0)
        }
        static get FORWARD() {
            return new i(0,0,1)
        }
        static cross(e, t, a=new i) {
            const n = e.x
              , o = e.y
              , r = e.z
              , s = t.x
              , l = t.y
              , u = t.z;
            return a.x = o * u - r * l,
            a.y = r * s - n * u,
            a.z = n * l - o * s,
            a
        }
        static dot(e, t) {
            const a = e.x
              , i = e.y
              , n = e.z
              , o = t.x
              , r = t.y
              , s = t.z;
            return a * o + i * r + n * s
        }
        static distance(e, t) {
            return Math.sqrt(this.squaredDistance(e, t))
        }
        static squaredDistance(e, t) {
            const a = t.x - e.x
              , i = t.y - e.y
              , n = t.z - e.z;
            return a * a + i * i + n * n
        }
        static direction(e, t, a=new i) {
            const n = e.x - t.x
              , o = e.y - t.y
              , r = e.z - t.z;
            let s = Math.sqrt(n * n + o * o + r * r);
            return 0 === s ? (a.x = 0,
            a.y = 0,
            a.z = 0,
            a) : (s = 1 / s,
            a.x = n * s,
            a.y = o * s,
            a.z = r * s,
            a)
        }
        static mix(e, t, a, n=new i) {
            return n.x = e.x + a * (t.x - e.x),
            n.y = e.y + a * (t.y - e.y),
            n.z = e.z + a * (t.z - e.z),
            n
        }
        static sum(e, t, a=new i) {
            return a.x = e.x + t.x,
            a.y = e.y + t.y,
            a.z = e.z + t.z,
            a
        }
        static difference(e, t, a=new i) {
            return a.x = e.x - t.x,
            a.y = e.y - t.y,
            a.z = e.z - t.z,
            a
        }
        static product(e, t, a=new i) {
            return a.x = e.x * t.x,
            a.y = e.y * t.y,
            a.z = e.z * t.z,
            a
        }
        static quotient(e, t, a=new i) {
            return a.x = e.x / t.x,
            a.y = e.y / t.y,
            a.z = e.z / t.z,
            a
        }
        static is(e) {
            return "object" == typeof e && !!e && "number" == typeof e.x && "number" == typeof e.y && "number" == typeof e.z
        }
        get x() {
            return this.values[0]
        }
        set x(e) {
            this.values[0] = e
        }
        get y() {
            return this.values[1]
        }
        set y(e) {
            this.values[1] = e
        }
        get z() {
            return this.values[2]
        }
        set z(e) {
            this.values[2] = e
        }
        get xy() {
            return [this.values[0], this.values[1]]
        }
        set xy(e) {
            this.values[0] = e[0],
            this.values[1] = e[1]
        }
        get xz() {
            return [this.values[0], this.values[2]]
        }
        set xz(e) {
            this.values[0] = e[0],
            this.values[2] = e[1]
        }
        get yz() {
            return [this.values[1], this.values[2]]
        }
        set yz(e) {
            this.values[1] = e[0],
            this.values[2] = e[1]
        }
        get xyz() {
            return [this.values[0], this.values[1], this.values[2]]
        }
        set xyz(e) {
            this.values[0] = e[0],
            this.values[1] = e[1],
            this.values[2] = e[2]
        }
        at(e) {
            return this.values[e]
        }
        reset() {
            this.x = 0,
            this.y = 0,
            this.z = 0
        }
        copy(e=new i) {
            return e.x = this.x,
            e.y = this.y,
            e.z = this.z,
            e
        }
        negate(e=new i) {
            return e.x = -1 * this.x,
            e.y = -1 * this.y,
            e.z = -1 * this.z,
            e
        }
        equals(e, t=a) {
            return !(Math.abs(this.x - e.x) > t) && (!(Math.abs(this.y - e.y) > t) && !(Math.abs(this.z - e.z) > t))
        }
        length() {
            return Math.sqrt(this.squaredLength())
        }
        squaredLength() {
            const e = this.x
              , t = this.y
              , a = this.z;
            return e * e + t * t + a * a
        }
        add(e) {
            return this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this
        }
        subtract(e) {
            return this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this
        }
        multiply(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this
        }
        divide(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this.z /= e.z,
            this
        }
        scale(e, t=this) {
            return t.x *= e,
            t.y *= e,
            t.z *= e,
            t
        }
        normalize(e=this) {
            let t = this.length();
            return 1 === t ? this : 0 === t ? (e.x = 0,
            e.y = 0,
            e.z = 0,
            e) : (t = 1 / t,
            e.x *= t,
            e.y *= t,
            e.z *= t,
            e)
        }
        raw() {
            return {
                x: this.x,
                y: this.y,
                z: this.z
            }
        }
        toString() {
            return `Vector3(${this.x}, ${this.y}, ${this.z})`
        }
        serializeObject(e) {
            e.dataView.setFloat32(e.byteOffset, this.x),
            e.byteOffset += 4,
            e.dataView.setFloat32(e.byteOffset, this.y),
            e.byteOffset += 4,
            e.dataView.setFloat32(e.byteOffset, this.z),
            e.byteOffset += 4
        }
        deserializeObject(e) {
            this.x = e.dataView.getFloat32(e.byteOffset),
            e.byteOffset += 4,
            this.y = e.dataView.getFloat32(e.byteOffset),
            e.byteOffset += 4,
            this.z = e.dataView.getFloat32(e.byteOffset),
            e.byteOffset += 4
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/math/Vector2", ["require", "exports", "utilities/math/Math2", "utilities/math/Vector3"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const n = 1e-6;
    class o {
        constructor(e, t) {
            this.values = new Float32Array(2),
            "number" == typeof t ? (this.y = t,
            this.x = e) : "number" == typeof e ? this.x = this.y = e : e && (Array.isArray(e) ? this.xy = e : (this.x = e.x,
            this.y = e.y))
        }
        static get ZERO() {
            return new o(0)
        }
        static get ONE() {
            return new o(1)
        }
        static cross(e, t, a=new i.default ) {
            return a.x = 0,
            a.y = 0,
            a.z = e.x * t.y - e.y * t.x,
            a
        }
        static dot(e, t) {
            return e.x * t.x + e.y * t.y
        }
        static isDistanceWithin(e, t, a) {
            return o.squaredDistance(e, t) <= a * a
        }
        static distance(e, t) {
            return Math.sqrt(this.squaredDistance(e, t))
        }
        static squaredDistance(e, t) {
            const a = t.x - e.x
              , i = t.y - e.y;
            return a * a + i * i
        }
        static direction(e, t, a=new o) {
            const i = e.x - t.x
              , n = e.y - t.y;
            let r = Math.sqrt(i * i + n * n);
            return 0 === r ? (a.x = 0,
            a.y = 0,
            a) : (r = 1 / r,
            a.x = i * r,
            a.y = n * r,
            a)
        }
        static mix(e, t, a, i=new o) {
            const n = e.x
              , r = e.y;
            return i.x = n + a * (t.x - n),
            i.y = r + a * (t.y - r),
            i
        }
        static sum(e, t, a=new o) {
            return a.x = e.x + t.x,
            a.y = e.y + t.y,
            a
        }
        static difference(e, t, a=new o) {
            return a.x = e.x - t.x,
            a.y = e.y - t.y,
            a
        }
        static product(e, t, a=new o) {
            return a.x = e.x * t.x,
            a.y = e.y * t.y,
            a
        }
        static quotient(e, t, a=new o) {
            return a.x = e.x / t.x,
            a.y = e.y / t.y,
            a
        }
        static*range(e, t) {
            const a = Math.min(e.x, t.x)
              , i = Math.max(e.x, t.x)
              , n = Math.min(e.y, t.y)
              , o = Math.max(e.y, t.y);
            for (let e = a; e < i; e++)
                for (let t = n; t < o; t++)
                    yield[e, t]
        }
        static is(e) {
            return "object" == typeof e && !!e && "number" == typeof e.x && "number" == typeof e.y
        }
        get x() {
            return this.values[0]
        }
        set x(e) {
            this.values[0] = e
        }
        get y() {
            return this.values[1]
        }
        set y(e) {
            this.values[1] = e
        }
        get xy() {
            return [this.values[0], this.values[1]]
        }
        set xy(e) {
            this.values[0] = e[0],
            this.values[1] = e[1]
        }
        at(e) {
            return this.values[e]
        }
        reset() {
            this.x = 0,
            this.y = 0
        }
        copy(e=new o) {
            return e.x = this.x,
            e.y = this.y,
            e
        }
        negate(e=new o) {
            return e.x = -1 * this.x,
            e.y = -1 * this.y,
            e
        }
        equals(e, t=n) {
            return !!o.is(e) && (!(Math.abs(this.x - e.x) > t) && !(Math.abs(this.y - e.y) > t))
        }
        length() {
            return Math.sqrt(this.squaredLength())
        }
        squaredLength() {
            const e = this.x
              , t = this.y;
            return e * e + t * t
        }
        add(e) {
            return this.x += e.x,
            this.y += e.y,
            this
        }
        subtract(e) {
            return this.x -= e.x,
            this.y -= e.y,
            this
        }
        multiply(e) {
            return this.x *= "number" == typeof e ? e : e.x,
            this.y *= "number" == typeof e ? e : e.y,
            this
        }
        divide(e) {
            return this.x /= "number" == typeof e ? e : e.x,
            this.y /= "number" == typeof e ? e : e.y,
            this
        }
        floor(e=this) {
            return e.x = Math.floor(this.x),
            e.y = Math.floor(this.y),
            e
        }
        lerp(e, t) {
            return this.x = a.default.lerp(this.x, e.x, t),
            this.y = a.default.lerp(this.y, e.y, t),
            this
        }
        mod(e) {
            return this.x = a.default.mod(this.x, e),
            this.y = a.default.mod(this.y, e),
            this
        }
        scale(e, t=this) {
            return t.x *= e,
            t.y *= e,
            t
        }
        normalize(e=this) {
            let t = this.length();
            return 1 === t ? this : 0 === t ? (e.x = 0,
            e.y = 0,
            e) : (t = 1 / t,
            e.x *= t,
            e.y *= t,
            e)
        }
        toRadians() {
            return Math.atan2(this.y, this.x)
        }
        raw() {
            return {
                x: this.x,
                y: this.y
            }
        }
        clamp(e, t) {
            return this.x = a.default.clamp(Math.min(e.x, t.x), Math.max(e.x, t.x), this.x),
            this.y = a.default.clamp(Math.min(e.y, t.y), Math.max(e.y, t.y), this.y),
            this
        }
        toString() {
            return `Vector2(${this.x}, ${this.y})`
        }
        serializeObject(e) {
            e.dataView.setFloat32(e.byteOffset, this.x),
            e.byteOffset += 4,
            e.dataView.setFloat32(e.byteOffset, this.y),
            e.byteOffset += 4
        }
        deserializeObject(e) {
            this.x = e.dataView.getFloat32(e.byteOffset),
            e.byteOffset += 4,
            this.y = e.dataView.getFloat32(e.byteOffset),
            e.byteOffset += 4
        }
    }
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("doodad/DoodadInfo", ["require", "exports", "utilities/math/Vector2"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i {
        constructor(e, t, i, n, o) {
            this.type = e,
            this.tall = t,
            this.animated = o,
            this.topLeft = new a.default(i,n),
            this.topRight = new a.default(i + 1,n),
            this.bottomLeft = new a.default(i,n + 1),
            this.bottomRight = new a.default(i + 1,n + 1)
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("entity/StatFactory", ["require", "exports", "entity/IStats"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i {
        constructor(e, t=0) {
            this.result = {
                type: e,
                value: t
            }
        }
        setMax(e, t) {
            return this.result.max = e,
            t && (this.result.canExceedMax = !0),
            this
        }
        setChangeTimer(e, t=1) {
            return this.result.changeTimer = this.result.nextChangeTimer = e,
            this.result.changeAmount = t,
            this
        }
        setBonus(e) {
            return this.result.bonus = e,
            this
        }
        initializeOn(e) {
            e.initStat(this)
        }
        get() {
            return this.result
        }
    }
    !function(e) {
        function t(...e) {
            const t = {};
            for (const i of e) {
                if (!i)
                    continue;
                const e = i.get();
                t[a.Stat[e.type]] = e
            }
            return t
        }
        e.getStats = t
    }(i || (i = {})),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/dictionary/Message", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Aberrant = 1] = "Aberrant",
        e[e.AboutHours = 2] = "AboutHours",
        e[e.AddedFuelToFire = 3] = "AddedFuelToFire",
        e[e.AddedFuelToTorch = 4] = "AddedFuelToTorch",
        e[e.AddFuel = 5] = "AddFuel",
        e[e.AddToQuickslot = 6] = "AddToQuickslot",
        e[e.Advanced = 7] = "Advanced",
        e[e.All = 8] = "All",
        e[e.AllEquipmentUnEquipped = 9] = "AllEquipmentUnEquipped",
        e[e.AlreadyDesalinatedWaterInStill = 10] = "AlreadyDesalinatedWaterInStill",
        e[e.AlreadyFullyRepaired = 11] = "AlreadyFullyRepaired",
        e[e.AlreadyPreserved = 12] = "AlreadyPreserved",
        e[e.AlreadyWaterInStill = 13] = "AlreadyWaterInStill",
        e[e.AnUnknownItem = 14] = "AnUnknownItem",
        e[e.AppearedNotEffectiveForGathering = 15] = "AppearedNotEffectiveForGathering",
        e[e.AppearsToBeAberrant = 16] = "AppearsToBeAberrant",
        e[e.ArmorAppeared = 17] = "ArmorAppeared",
        e[e.ArmorProtectedFromInjuryAgainst = 18] = "ArmorProtectedFromInjuryAgainst",
        e[e.Attack = 19] = "Attack",
        e[e.AttemptedToDropAllIntoFire = 20] = "AttemptedToDropAllIntoFire",
        e[e.AttemptedToPlaceAllOnGround = 21] = "AttemptedToPlaceAllOnGround",
        e[e.AttemptToTill = 22] = "AttemptToTill",
        e[e.Back = 23] = "Back",
        e[e.BadlyBurnedLostHealth = 24] = "BadlyBurnedLostHealth",
        e[e.BarteringSkillsProvided = 25] = "BarteringSkillsProvided",
        e[e.BasedOnItSeems = 26] = "BasedOnItSeems",
        e[e.BeenPoisoned = 27] = "BeenPoisoned",
        e[e.BeginSleeping = 28] = "BeginSleeping",
        e[e.BeginUsingRaft = 29] = "BeginUsingRaft",
        e[e.Belt = 30] = "Belt",
        e[e.Best = 31] = "Best",
        e[e.BleedingHasStopped = 32] = "BleedingHasStopped",
        e[e.BleedingProfusely = 33] = "BleedingProfusely",
        e[e.BleedingToDeathLostHealth = 34] = "BleedingToDeathLostHealth",
        e[e.Blunt = 35] = "Blunt",
        e[e.BookBlank = 36] = "BookBlank",
        e[e.BookContains = 37] = "BookContains",
        e[e.BookCrumbles = 38] = "BookCrumbles",
        e[e.BookDiagrams = 39] = "BookDiagrams",
        e[e.BookEmpty = 40] = "BookEmpty",
        e[e.BookNothing = 41] = "BookNothing",
        e[e.BookOpen = 42] = "BookOpen",
        e[e.BookScribbles = 43] = "BookScribbles",
        e[e.BothEffectiveIneffective = 44] = "BothEffectiveIneffective",
        e[e.BothHands = 45] = "BothHands",
        e[e.BrokeIntoPieces = 46] = "BrokeIntoPieces",
        e[e.BrokenOnImpact = 47] = "BrokenOnImpact",
        e[e.BrokenWhileFiring = 48] = "BrokenWhileFiring",
        e[e.Build = 49] = "Build",
        e[e.Burned = 50] = "Burned",
        e[e.CannotAddAnyMoreFuel = 51] = "CannotAddAnyMoreFuel",
        e[e.CannotBePerformedOverWater = 52] = "CannotBePerformedOverWater",
        e[e.CannotBePreserved = 53] = "CannotBePreserved",
        e[e.CannotBeReinforced = 54] = "CannotBeReinforced",
        e[e.CannotBeRepaired = 55] = "CannotBeRepaired",
        e[e.CannotBeTamed = 56] = "CannotBeTamed",
        e[e.CannotBuildHere = 57] = "CannotBuildHere",
        e[e.CannotDoThatHere = 58] = "CannotDoThatHere",
        e[e.CannotDropHere = 59] = "CannotDropHere",
        e[e.CannotEquipThatThere = 60] = "CannotEquipThatThere",
        e[e.CannotFishFor = 61] = "CannotFishFor",
        e[e.CannotHere = 62] = "CannotHere",
        e[e.CannotInWater = 63] = "CannotInWater",
        e[e.CannotLeave = 64] = "CannotLeave",
        e[e.CannotPickupWhenFull = 65] = "CannotPickupWhenFull",
        e[e.CannotPickUpWhileLit = 66] = "CannotPickUpWhileLit",
        e[e.CannotPickUpWithItemsInside = 67] = "CannotPickUpWithItemsInside",
        e[e.CannotPlaceContainerInItself = 68] = "CannotPlaceContainerInItself",
        e[e.CannotPlaceHere = 69] = "CannotPlaceHere",
        e[e.CannotPlaceThatFromHere = 70] = "CannotPlaceThatFromHere",
        e[e.CannotPlaceThatHere = 71] = "CannotPlaceThatHere",
        e[e.CannotPlantHereTilled = 72] = "CannotPlantHereTilled",
        e[e.CannotRepairWhileLit = 73] = "CannotRepairWhileLit",
        e[e.CannotRestHere = 74] = "CannotRestHere",
        e[e.CannotSeeHere = 75] = "CannotSeeHere",
        e[e.CannotSleepHere = 76] = "CannotSleepHere",
        e[e.CannotStartFireHere = 77] = "CannotStartFireHere",
        e[e.CannotToTellTime = 78] = "CannotToTellTime",
        e[e.CarryingTooMuchWeight = 79] = "CarryingTooMuchWeight",
        e[e.CartographyDirection = 80] = "CartographyDirection",
        e[e.CartographyDirectionUnsure = 81] = "CartographyDirectionUnsure",
        e[e.CartographyDistanceHighSkillExactDistance = 82] = "CartographyDistanceHighSkillExactDistance",
        e[e.CartographyDistanceHighSkillFarAway = 83] = "CartographyDistanceHighSkillFarAway",
        e[e.CartographyDistanceHighSkillInRegion = 84] = "CartographyDistanceHighSkillInRegion",
        e[e.CartographyDistanceHighSkillNearby = 85] = "CartographyDistanceHighSkillNearby",
        e[e.CartographyDistanceLowSkillNearby = 86] = "CartographyDistanceLowSkillNearby",
        e[e.CartographyDistanceLowSkillUnsure = 87] = "CartographyDistanceLowSkillUnsure",
        e[e.CartographyDistanceMedSkillFarAway = 88] = "CartographyDistanceMedSkillFarAway",
        e[e.CartographyDistanceMedSkillNearby = 89] = "CartographyDistanceMedSkillNearby",
        e[e.CartographyDistanceMedSkillVeryClose = 90] = "CartographyDistanceMedSkillVeryClose",
        e[e.CarvedUpCorpse = 91] = "CarvedUpCorpse",
        e[e.CarveWithTool = 92] = "CarveWithTool",
        e[e.Carving = 93] = "Carving",
        e[e.CastYourLine = 94] = "CastYourLine",
        e[e.Category = 95] = "Category",
        e[e.CaughtFish = 96] = "CaughtFish",
        e[e.ChatBanCommand = 97] = "ChatBanCommand",
        e[e.ChatBannedCommand = 98] = "ChatBannedCommand",
        e[e.ChatCommandsCommand = 99] = "ChatCommandsCommand",
        e[e.ChatPingCommand = 100] = "ChatPingCommand",
        e[e.ChatPlayerMessage = 101] = "ChatPlayerMessage",
        e[e.ChatPlayersCommand = 102] = "ChatPlayersCommand",
        e[e.ChatServerMessage = 103] = "ChatServerMessage",
        e[e.ChatUnbanCommand = 104] = "ChatUnbanCommand",
        e[e.ChatUnknownCommand = 105] = "ChatUnknownCommand",
        e[e.Chest = 106] = "Chest",
        e[e.ClearMessages = 107] = "ClearMessages",
        e[e.Clockwise = 108] = "Clockwise",
        e[e.CloseContainer = 109] = "CloseContainer",
        e[e.CloseDoor = 110] = "CloseDoor",
        e[e.CloseToBeingDestroyed = 111] = "CloseToBeingDestroyed",
        e[e.CollectObjectWithHands = 112] = "CollectObjectWithHands",
        e[e.Consumed = 113] = "Consumed",
        e[e.Container = 114] = "Container",
        e[e.Cook = 115] = "Cook",
        e[e.Cooked = 116] = "Cooked",
        e[e.CopySelectedText = 117] = "CopySelectedText",
        e[e.CorpseOf = 118] = "CorpseOf",
        e[e.CorpseOfNamed = 119] = "CorpseOfNamed",
        e[e.CouldNotDecipher = 120] = "CouldNotDecipher",
        e[e.Counterclockwise = 121] = "Counterclockwise",
        e[e.Craft = 122] = "Craft",
        e[e.Crafted = 123] = "Crafted",
        e[e.Crafts = 124] = "Crafts",
        e[e.CreatureAngered = 125] = "CreatureAngered",
        e[e.CreatureAppears = 126] = "CreatureAppears",
        e[e.CreatureAppeased = 127] = "CreatureAppeased",
        e[e.CreatureIdolAttractedCreature = 128] = "CreatureIdolAttractedCreature",
        e[e.CreatureUntamed = 129] = "CreatureUntamed",
        e[e.CuredYourPoison = 130] = "CuredYourPoison",
        e[e.Cut = 131] = "Cut",
        e[e.DamageAppeared = 132] = "DamageAppeared",
        e[e.DamagedByPouring = 133] = "DamagedByPouring",
        e[e.DayQuarter1 = 134] = "DayQuarter1",
        e[e.DayQuarter2 = 135] = "DayQuarter2",
        e[e.DayQuarter3 = 136] = "DayQuarter3",
        e[e.DayQuarter4 = 137] = "DayQuarter4",
        e[e.DealtNoDamageToYou = 138] = "DealtNoDamageToYou",
        e[e.DeathBy = 139] = "DeathBy",
        e[e.DeathByBleeding = 140] = "DeathByBleeding",
        e[e.DeathByBurning = 141] = "DeathByBurning",
        e[e.DeathByChallengeWinner = 142] = "DeathByChallengeWinner",
        e[e.DeathByConsumption = 143] = "DeathByConsumption",
        e[e.DeathByDrowning = 144] = "DeathByDrowning",
        e[e.DeathByExhaustion = 145] = "DeathByExhaustion",
        e[e.DeathByFistByPlayer = 146] = "DeathByFistByPlayer",
        e[e.DeathByPoison = 147] = "DeathByPoison",
        e[e.DeathBySteppingOn = 148] = "DeathBySteppingOn",
        e[e.DeathByTrap = 149] = "DeathByTrap",
        e[e.DeathByWeaponByPlayer = 150] = "DeathByWeaponByPlayer",
        e[e.Decay = 151] = "Decay",
        e[e.DestroyedFromUse = 152] = "DestroyedFromUse",
        e[e.Dexterity = 153] = "Dexterity",
        e[e.DexterityIncreasing = 154] = "DexterityIncreasing",
        e[e.DidNotSeemToBeHurting = 155] = "DidNotSeemToBeHurting",
        e[e.Dig = 156] = "Dig",
        e[e.DigAway = 157] = "DigAway",
        e[e.Digging = 158] = "Digging",
        e[e.DigWithHands = 159] = "DigWithHands",
        e[e.Disabled = 160] = "Disabled",
        e[e.Disassemble = 161] = "Disassemble",
        e[e.DisassembleAction = 162] = "DisassembleAction",
        e[e.Disassembling = 163] = "Disassembling",
        e[e.DiscoveredCaveEntrance = 164] = "DiscoveredCaveEntrance",
        e[e.DiscoveredInTheBottle = 165] = "DiscoveredInTheBottle",
        e[e.DiscoveredLavaPassage = 166] = "DiscoveredLavaPassage",
        e[e.Dismantle = 167] = "Dismantle",
        e[e.DismantleAction = 168] = "DismantleAction",
        e[e.DismantleLabel = 169] = "DismantleLabel",
        e[e.Dismantling = 170] = "Dismantling",
        e[e.DismantlingRequires = 171] = "DismantlingRequires",
        e[e.DoNotHaveTreasureMaps = 172] = "DoNotHaveTreasureMaps",
        e[e.DoNotProduceAnyResources = 173] = "DoNotProduceAnyResources",
        e[e.DoodadAppearsDamaged = 174] = "DoodadAppearsDamaged",
        e[e.DoodadAppearsOnVergeOfBreaking = 175] = "DoodadAppearsOnVergeOfBreaking",
        e[e.DoodadAppearsUnscathed = 176] = "DoodadAppearsUnscathed",
        e[e.DoodadCauseStatus = 177] = "DoodadCauseStatus",
        e[e.DoodadShowsSignsOfWear = 178] = "DoodadShowsSignsOfWear",
        e[e.DrewSurroundings = 179] = "DrewSurroundings",
        e[e.Drink = 180] = "Drink",
        e[e.Drop = 181] = "Drop",
        e[e.DropAll = 182] = "DropAll",
        e[e.DropAllOfSameQuality = 183] = "DropAllOfSameQuality",
        e[e.DroppedIntoDepths = 184] = "DroppedIntoDepths",
        e[e.DroppedIntoFire = 185] = "DroppedIntoFire",
        e[e.DueToDehydration = 186] = "DueToDehydration",
        e[e.DueToStarvation = 187] = "DueToStarvation",
        e[e.DugTreasureOut = 188] = "DugTreasureOut",
        e[e.DumpContentsOfContainerInInventory = 189] = "DumpContentsOfContainerInInventory",
        e[e.Durability = 190] = "Durability",
        e[e.DyingOfDehydration = 191] = "DyingOfDehydration",
        e[e.EarnedMilestone = 192] = "EarnedMilestone",
        e[e.East = 193] = "East",
        e[e.EastNortheast = 194] = "EastNortheast",
        e[e.EastSoutheast = 195] = "EastSoutheast",
        e[e.Effective = 196] = "Effective",
        e[e.Enabled = 197] = "Enabled",
        e[e.EquipmentPreventedStatusEffects = 198] = "EquipmentPreventedStatusEffects",
        e[e.EquipTo = 199] = "EquipTo",
        e[e.ErrorHasOccured = 200] = "ErrorHasOccured",
        e[e.Expert = 201] = "Expert",
        e[e.ExtinguishedFire = 202] = "ExtinguishedFire",
        e[e.ExtinguishedTorch = 203] = "ExtinguishedTorch",
        e[e.FailedToAddFuelToTorch = 204] = "FailedToAddFuelToTorch",
        e[e.FailedToCatchFish = 205] = "FailedToCatchFish",
        e[e.FailedToCauseDamage = 206] = "FailedToCauseDamage",
        e[e.FailedToCauseYouDamage = 207] = "FailedToCauseYouDamage",
        e[e.FailedToDrawMap = 208] = "FailedToDrawMap",
        e[e.FailedToIgniteTorch = 209] = "FailedToIgniteTorch",
        e[e.FailedToPickLock = 210] = "FailedToPickLock",
        e[e.FailedToPlant = 211] = "FailedToPlant",
        e[e.FailedToPreserve = 212] = "FailedToPreserve",
        e[e.FailedToReinforce = 213] = "FailedToReinforce",
        e[e.FailedToRepair = 214] = "FailedToRepair",
        e[e.FailedToStartFire = 215] = "FailedToStartFire",
        e[e.FailedToTame = 216] = "FailedToTame",
        e[e.FailedToTransmogrify = 217] = "FailedToTransmogrify",
        e[e.Feet = 218] = "Feet",
        e[e.FeltBurningPainLostHealth = 219] = "FeltBurningPainLostHealth",
        e[e.FewMinutes = 220] = "FewMinutes",
        e[e.Filled = 221] = "Filled",
        e[e.FilledFrom = 222] = "FilledFrom",
        e[e.Fire = 223] = "Fire",
        e[e.FireAlmostExtinguished = 224] = "FireAlmostExtinguished",
        e[e.FireAroundYouIsWarm = 225] = "FireAroundYouIsWarm",
        e[e.FiredIntoObstacle = 226] = "FiredIntoObstacle",
        e[e.FireIsHealthy = 227] = "FireIsHealthy",
        e[e.FireIsRaging = 228] = "FireIsRaging",
        e[e.FireIsStruggling = 229] = "FireIsStruggling",
        e[e.FireOverflowed = 230] = "FireOverflowed",
        e[e.FireReducedToEmbers = 231] = "FireReducedToEmbers",
        e[e.FireSource = 232] = "FireSource",
        e[e.FishingWithNoBait = 233] = "FishingWithNoBait",
        e[e.FullyDecodedMap = 234] = "FullyDecodedMap",
        e[e.GainedHealth = 235] = "GainedHealth",
        e[e.GainedHunger = 236] = "GainedHunger",
        e[e.GainedStamina = 237] = "GainedStamina",
        e[e.GainedThirst = 238] = "GainedThirst",
        e[e.GameHasBeenSavedIsTakingUpMB = 239] = "GameHasBeenSavedIsTakingUpMB",
        e[e.Gather = 240] = "Gather",
        e[e.GatherDestroy = 241] = "GatherDestroy",
        e[e.Gathering = 242] = "Gathering",
        e[e.GatherWithHands = 243] = "GatherWithHands",
        e[e.GhostNoActions = 244] = "GhostNoActions",
        e[e.GhostOf = 245] = "GhostOf",
        e[e.GoatHasNoMilk = 246] = "GoatHasNoMilk",
        e[e.GrabAll = 247] = "GrabAll",
        e[e.Group = 248] = "Group",
        e[e.HackAway = 249] = "HackAway",
        e[e.HandProtectionPreventedInjury = 250] = "HandProtectionPreventedInjury",
        e[e.Hands = 251] = "Hands",
        e[e.HandsNotEffectiveForDigging = 252] = "HandsNotEffectiveForDigging",
        e[e.Harvest = 253] = "Harvest",
        e[e.Harvesting = 254] = "Harvesting",
        e[e.HarvestWithHands = 255] = "HarvestWithHands",
        e[e.HasBeenHurtByATrap = 256] = "HasBeenHurtByATrap",
        e[e.HasDecayed = 257] = "HasDecayed",
        e[e.HasHitYouForDamage = 258] = "HasHitYouForDamage",
        e[e.HasNoEffect = 259] = "HasNoEffect",
        e[e.HasSetTrapOffNoDamage = 260] = "HasSetTrapOffNoDamage",
        e[e.HasSplit = 261] = "HasSplit",
        e[e.Head = 262] = "Head",
        e[e.Held = 263] = "Held",
        e[e.Help = 264] = "Help",
        e[e.HelpGrow = 265] = "HelpGrow",
        e[e.Here = 266] = "Here",
        e[e.Hints = 267] = "Hints",
        e[e.HintsDisabled = 268] = "HintsDisabled",
        e[e.HintsEnabled = 269] = "HintsEnabled",
        e[e.Hitch = 270] = "Hitch",
        e[e.HitchAttempt = 271] = "HitchAttempt",
        e[e.HitchCreature = 272] = "HitchCreature",
        e[e.HitchDisabled = 273] = "HitchDisabled",
        e[e.HitchInUse = 274] = "HitchInUse",
        e[e.HitForDamage = 275] = "HitForDamage",
        e[e.HitYouForDamage = 276] = "HitYouForDamage",
        e[e.Hour = 277] = "Hour",
        e[e.Hours = 278] = "Hours",
        e[e.HurtHandsHittingWithoutWeapons = 279] = "HurtHandsHittingWithoutWeapons",
        e[e.HurtHandsWithNoTool = 280] = "HurtHandsWithNoTool",
        e[e.Ignite = 281] = "Ignite",
        e[e.IgnitedTorch = 282] = "IgnitedTorch",
        e[e.Ineffective = 283] = "Ineffective",
        e[e.InjuredFromTrap = 284] = "InjuredFromTrap",
        e[e.InNeedOfRepair = 285] = "InNeedOfRepair",
        e[e.Intermediate = 286] = "Intermediate",
        e[e.Inventory = 287] = "Inventory",
        e[e.IsInTheWayOfPickingUp = 288] = "IsInTheWayOfPickingUp",
        e[e.It = 289] = "It",
        e[e.ItAlsoReveals = 290] = "ItAlsoReveals",
        e[e.ItAlsoSeems = 291] = "ItAlsoSeems",
        e[e.ItContains = 292] = "ItContains",
        e[e.ItsWeightCapacity = 293] = "ItsWeightCapacity",
        e[e.JoinedAServer = 294] = "JoinedAServer",
        e[e.Jump = 295] = "Jump",
        e[e.Killed = 296] = "Killed",
        e[e.KnowledgeHasIncreased = 297] = "KnowledgeHasIncreased",
        e[e.LabelAdditionalRequirements = 298] = "LabelAdditionalRequirements",
        e[e.LabelAttackFromTactics = 299] = "LabelAttackFromTactics",
        e[e.LabelBase = 300] = "LabelBase",
        e[e.LabelCanIncrease = 301] = "LabelCanIncrease",
        e[e.LabelCraftingReputation = 302] = "LabelCraftingReputation",
        e[e.LabelCraftingSkillReputation = 303] = "LabelCraftingSkillReputation",
        e[e.LabelDecay = 304] = "LabelDecay",
        e[e.LabelDefense = 305] = "LabelDefense",
        e[e.LabelDurability = 306] = "LabelDurability",
        e[e.LabelEquip = 307] = "LabelEquip",
        e[e.LabelGrouping = 308] = "LabelGrouping",
        e[e.LabelHave = 309] = "LabelHave",
        e[e.LabelLeftHandAttack = 310] = "LabelLeftHandAttack",
        e[e.LabelLevel = 311] = "LabelLevel",
        e[e.LabelLightSourceWhenLit = 312] = "LabelLightSourceWhenLit",
        e[e.LabelOnCure = 313] = "LabelOnCure",
        e[e.LabelOnDrink = 314] = "LabelOnDrink",
        e[e.LabelOnEat = 315] = "LabelOnEat",
        e[e.LabelOnEquip = 316] = "LabelOnEquip",
        e[e.LabelOnHeal = 317] = "LabelOnHeal",
        e[e.LabelOnOtherHeal = 318] = "LabelOnOtherHeal",
        e[e.LabelProtected = 319] = "LabelProtected",
        e[e.LabelRange = 320] = "LabelRange",
        e[e.LabelRanged = 321] = "LabelRanged",
        e[e.LabelRangedAttack = 322] = "LabelRangedAttack",
        e[e.LabelRangedDamage = 323] = "LabelRangedDamage",
        e[e.LabelReputationImpact = 324] = "LabelReputationImpact",
        e[e.LabelRequires = 325] = "LabelRequires",
        e[e.LabelResists = 326] = "LabelResists",
        e[e.LabelRightHandAttack = 327] = "LabelRightHandAttack",
        e[e.LabelSkill = 328] = "LabelSkill",
        e[e.LabelStokeFireStrength = 329] = "LabelStokeFireStrength",
        e[e.LabelThrowDamageType = 330] = "LabelThrowDamageType",
        e[e.LabelTrapDamage = 331] = "LabelTrapDamage",
        e[e.LabelUse = 332] = "LabelUse",
        e[e.LabelUses = 333] = "LabelUses",
        e[e.LabelVulnerabilities = 334] = "LabelVulnerabilities",
        e[e.LabelWeight = 335] = "LabelWeight",
        e[e.LabelWeightCapacity = 336] = "LabelWeightCapacity",
        e[e.LabelWeightReduction = 337] = "LabelWeightReduction",
        e[e.LabelWorth = 338] = "LabelWorth",
        e[e.LastPlaceYouLeftOff = 339] = "LastPlaceYouLeftOff",
        e[e.LearnedHowToCreate = 340] = "LearnedHowToCreate",
        e[e.LeftHand = 341] = "LeftHand",
        e[e.LeftHandEquip = 342] = "LeftHandEquip",
        e[e.Legs = 343] = "Legs",
        e[e.LikelyFailures = 344] = "LikelyFailures",
        e[e.LostHealth = 345] = "LostHealth",
        e[e.LostHunger = 346] = "LostHunger",
        e[e.LostStamina = 347] = "LostStamina",
        e[e.LostThirst = 348] = "LostThirst",
        e[e.MapNotOfThisArea = 349] = "MapNotOfThisArea",
        e[e.MaterialsDestroyed = 350] = "MaterialsDestroyed",
        e[e.Metabolism = 351] = "Metabolism",
        e[e.MetabolismSlowed = 352] = "MetabolismSlowed",
        e[e.Milk = 353] = "Milk",
        e[e.Milking = 354] = "Milking",
        e[e.MissedWith = 355] = "MissedWith",
        e[e.MissedYouWith = 356] = "MissedYouWith",
        e[e.MoreInformation = 357] = "MoreInformation",
        e[e.MoveAllOfSameQualityToFacingContainer = 358] = "MoveAllOfSameQualityToFacingContainer",
        e[e.MoveAllOfSameQualityToInventory = 359] = "MoveAllOfSameQualityToInventory",
        e[e.MoveAllOfSameQualityToLastOpenedContainer = 360] = "MoveAllOfSameQualityToLastOpenedContainer",
        e[e.MoveAllOfSameQualityToOpenedContainer = 361] = "MoveAllOfSameQualityToOpenedContainer",
        e[e.MoveAllToFacingContainer = 362] = "MoveAllToFacingContainer",
        e[e.MoveAllToInventory = 363] = "MoveAllToInventory",
        e[e.MoveAllToLastOpenedContainer = 364] = "MoveAllToLastOpenedContainer",
        e[e.MoveAllToOpenedContainer = 365] = "MoveAllToOpenedContainer",
        e[e.MovedItem = 366] = "MovedItem",
        e[e.MoveOverTrapButDoNotSetOff = 367] = "MoveOverTrapButDoNotSetOff",
        e[e.MoveToFacingContainer = 368] = "MoveToFacingContainer",
        e[e.MoveToInventory = 369] = "MoveToInventory",
        e[e.MoveToLastOpenedContainer = 370] = "MoveToLastOpenedContainer",
        e[e.MoveToOpenedContainer = 371] = "MoveToOpenedContainer",
        e[e.MultiplayerGamePaused = 372] = "MultiplayerGamePaused",
        e[e.MultiplayerGameResumed = 373] = "MultiplayerGameResumed",
        e[e.MultiplayerPlayerConnected = 374] = "MultiplayerPlayerConnected",
        e[e.MultiplayerPlayerDied = 375] = "MultiplayerPlayerDied",
        e[e.MultiplayerPlayerDisconnected = 376] = "MultiplayerPlayerDisconnected",
        e[e.MultiplayerPlayerJoined = 377] = "MultiplayerPlayerJoined",
        e[e.MustBeEquippedToIgnite = 378] = "MustBeEquippedToIgnite",
        e[e.MustCastIntoWater = 379] = "MustCastIntoWater",
        e[e.Mysteriously = 380] = "Mysteriously",
        e[e.Name = 381] = "Name",
        e[e.NearlyBurnedEquipmentProtectedYou = 382] = "NearlyBurnedEquipmentProtectedYou",
        e[e.Neck = 383] = "Neck",
        e[e.NeedAShovelToDigTreasure = 384] = "NeedAShovelToDigTreasure",
        e[e.NeedFishingNetForTreasure = 385] = "NeedFishingNetForTreasure",
        e[e.NeedFreeHandToShoot = 386] = "NeedFreeHandToShoot",
        e[e.NeedToEquipToShoot = 387] = "NeedToEquipToShoot",
        e[e.NeedToStartTravelsOutside = 388] = "NeedToStartTravelsOutside",
        e[e.NeedWaterForRaft = 389] = "NeedWaterForRaft",
        e[e.Negatively = 390] = "Negatively",
        e[e.NightQuarter1 = 391] = "NightQuarter1",
        e[e.NightQuarter2 = 392] = "NightQuarter2",
        e[e.NightQuarter3 = 393] = "NightQuarter3",
        e[e.NightQuarter4 = 394] = "NightQuarter4",
        e[e.NoAmmunitionForThatWeapon = 395] = "NoAmmunitionForThatWeapon",
        e[e.NoBlackPowderToFireWeapon = 396] = "NoBlackPowderToFireWeapon",
        e[e.NoFireToStokeWith = 397] = "NoFireToStokeWith",
        e[e.NoFishAtLocation = 398] = "NoFishAtLocation",
        e[e.NoGroundWater = 399] = "NoGroundWater",
        e[e.NoInkToDrawMap = 400] = "NoInkToDrawMap",
        e[e.NoKindlingOrFuelItemsToStartFire = 401] = "NoKindlingOrFuelItemsToStartFire",
        e[e.NoKindlingToStartFire = 402] = "NoKindlingToStartFire",
        e[e.NoLongerFeelPainOfBeingBurned = 403] = "NoLongerFeelPainOfBeingBurned",
        e[e.NoLongerHostile = 404] = "NoLongerHostile",
        e[e.NoMoreRoomInContainer = 405] = "NoMoreRoomInContainer",
        e[e.NoNeedToStokeFire = 406] = "NoNeedToStokeFire",
        e[e.NoReturnWithoutCompletingChallenges = 407] = "NoReturnWithoutCompletingChallenges",
        e[e.NoRoomForImprovement = 408] = "NoRoomForImprovement",
        e[e.NoRoomToDrop = 409] = "NoRoomToDrop",
        e[e.North = 410] = "North",
        e[e.Northeast = 411] = "Northeast",
        e[e.NorthNortheast = 412] = "NorthNortheast",
        e[e.NorthNorthwest = 413] = "NorthNorthwest",
        e[e.Northwest = 414] = "Northwest",
        e[e.NotAvailable = 415] = "NotAvailable",
        e[e.NotEnoughPurifiedWaterYet = 416] = "NotEnoughPurifiedWaterYet",
        e[e.NotEnoughTreasureToReturn = 417] = "NotEnoughTreasureToReturn",
        e[e.NotFacingCreatureToOfferThisTo = 418] = "NotFacingCreatureToOfferThisTo",
        e[e.NotFacingLockedObject = 419] = "NotFacingLockedObject",
        e[e.NotFacingOtherToHeal = 420] = "NotFacingOtherToHeal",
        e[e.NotFacingValidItem = 421] = "NotFacingValidItem",
        e[e.NothingHereToCarve = 422] = "NothingHereToCarve",
        e[e.NothingHereToFill = 423] = "NothingHereToFill",
        e[e.NothingHereToGrasp = 424] = "NothingHereToGrasp",
        e[e.NothingToGetFromThis = 425] = "NothingToGetFromThis",
        e[e.NothingToHarvestFromThisGather = 426] = "NothingToHarvestFromThisGather",
        e[e.NothingToSmother = 427] = "NothingToSmother",
        e[e.NothingUsefulToHarvestYet = 428] = "NothingUsefulToHarvestYet",
        e[e.NoTinderToStartFire = 429] = "NoTinderToStartFire",
        e[e.NotInRangeOfTreasure = 430] = "NotInRangeOfTreasure",
        e[e.NotSuitableToPlant = 431] = "NotSuitableToPlant",
        e[e.NoWaterInStill = 432] = "NoWaterInStill",
        e[e.NPCStartingDialog1 = 433] = "NPCStartingDialog1",
        e[e.NPCStartingDialog2 = 434] = "NPCStartingDialog2",
        e[e.NPCStartingDialog3 = 435] = "NPCStartingDialog3",
        e[e.NPCStartingDialog4 = 436] = "NPCStartingDialog4",
        e[e.NPCWelcome = 437] = "NPCWelcome",
        e[e.NPCWelcomeCredit = 438] = "NPCWelcomeCredit",
        e[e.NumberEight = 439] = "NumberEight",
        e[e.NumberFive = 440] = "NumberFive",
        e[e.NumberFour = 441] = "NumberFour",
        e[e.NumberNine = 442] = "NumberNine",
        e[e.NumberOne = 443] = "NumberOne",
        e[e.NumberSeven = 444] = "NumberSeven",
        e[e.NumberSix = 445] = "NumberSix",
        e[e.NumberTen = 446] = "NumberTen",
        e[e.NumberThree = 447] = "NumberThree",
        e[e.NumberTwo = 448] = "NumberTwo",
        e[e.ObjectIsLocked = 449] = "ObjectIsLocked",
        e[e.ObjectIsLockedAttemptToBreakIt = 450] = "ObjectIsLockedAttemptToBreakIt",
        e[e.Offer = 451] = "Offer",
        e[e.OfferAberrantFail = 452] = "OfferAberrantFail",
        e[e.OfferAberrantFailButTamed = 453] = "OfferAberrantFailButTamed",
        e[e.OpenDoor = 454] = "OpenDoor",
        e[e.OverEatingLostStamina = 455] = "OverEatingLostStamina",
        e[e.OverHydratingLostStamina = 456] = "OverHydratingLostStamina",
        e[e.Pack = 457] = "Pack",
        e[e.PaperTurnedToMush = 458] = "PaperTurnedToMush",
        e[e.PartiallyDecodedMap = 459] = "PartiallyDecodedMap",
        e[e.PastExperiencesProvideBenefits = 460] = "PastExperiencesProvideBenefits",
        e[e.PenultimateAnd = 461] = "PenultimateAnd",
        e[e.PetCreature = 462] = "PetCreature",
        e[e.PickAway = 463] = "PickAway",
        e[e.PickupAllItems = 464] = "PickupAllItems",
        e[e.PickupItem = 465] = "PickupItem",
        e[e.Piercing = 466] = "Piercing",
        e[e.Place = 467] = "Place",
        e[e.PlacedOnGround = 468] = "PlacedOnGround",
        e[e.Plant = 469] = "Plant",
        e[e.PlantCouldBeHarvested = 470] = "PlantCouldBeHarvested",
        e[e.PlantedInGround = 471] = "PlantedInGround",
        e[e.PlantGatheringWillDestroy = 472] = "PlantGatheringWillDestroy",
        e[e.PlantHasResourcesToGather = 473] = "PlantHasResourcesToGather",
        e[e.PlantHasResourcesToHarvest = 474] = "PlantHasResourcesToHarvest",
        e[e.PlantHighlyFertile = 475] = "PlantHighlyFertile",
        e[e.Planting = 476] = "Planting",
        e[e.PlantIsDead = 477] = "PlantIsDead",
        e[e.PlantIsFertile = 478] = "PlantIsFertile",
        e[e.PlantIsInStage = 479] = "PlantIsInStage",
        e[e.PlantIsNotFertile = 480] = "PlantIsNotFertile",
        e[e.PlantNotReadyToHarvest = 481] = "PlantNotReadyToHarvest",
        e[e.PlantReadyToGather = 482] = "PlantReadyToGather",
        e[e.PlantReadyToGatherNotMaximal = 483] = "PlantReadyToGatherNotMaximal",
        e[e.PlantReadyToHarvest = 484] = "PlantReadyToHarvest",
        e[e.PlantReadyToHarvestNotMaximal = 485] = "PlantReadyToHarvestNotMaximal",
        e[e.Player = 486] = "Player",
        e[e.PlayerHasCompletedChallengeRequirement = 487] = "PlayerHasCompletedChallengeRequirement",
        e[e.PlayerHasWonChallenge = 488] = "PlayerHasWonChallenge",
        e[e.Poisoned = 489] = "Poisoned",
        e[e.PoisonedLostHealth = 490] = "PoisonedLostHealth",
        e[e.PoisonWorkedItsCourse = 491] = "PoisonWorkedItsCourse",
        e[e.Positively = 492] = "Positively",
        e[e.PouredOut = 493] = "PouredOut",
        e[e.PouredOutOnYourself = 494] = "PouredOutOnYourself",
        e[e.PouredWaterIntoStill = 495] = "PouredWaterIntoStill",
        e[e.PourHarmedPlant = 496] = "PourHarmedPlant",
        e[e.PourHealedPlant = 497] = "PourHealedPlant",
        e[e.PourHealedPlantFully = 498] = "PourHealedPlantFully",
        e[e.PourHealedPlantPartially = 499] = "PourHealedPlantPartially",
        e[e.PourIncreasedFertility = 500] = "PourIncreasedFertility",
        e[e.Preservation = 501] = "Preservation",
        e[e.Preserve = 502] = "Preserve",
        e[e.PreservedFood = 503] = "PreservedFood",
        e[e.PurifiedWaterInStill = 504] = "PurifiedWaterInStill",
        e[e.Quality = 505] = "Quality",
        e[e.Recent = 506] = "Recent",
        e[e.ReduceLength = 507] = "ReduceLength",
        e[e.RefusedToBeTamed = 508] = "RefusedToBeTamed",
        e[e.Reinforce = 509] = "Reinforce",
        e[e.Reinforcement = 510] = "Reinforcement",
        e[e.Release = 511] = "Release",
        e[e.RemovedBlood = 512] = "RemovedBlood",
        e[e.RemoveFromQuickslot = 513] = "RemoveFromQuickslot",
        e[e.Repair = 514] = "Repair",
        e[e.RequiredForDisassembleLabel = 515] = "RequiredForDisassembleLabel",
        e[e.RequiredForDisassembly = 516] = "RequiredForDisassembly",
        e[e.RequiresFireToBeLit = 517] = "RequiresFireToBeLit",
        e[e.RequiresYouFacingFireSource = 518] = "RequiresYouFacingFireSource",
        e[e.RequiresYouToBeAround = 519] = "RequiresYouToBeAround",
        e[e.Resistant = 520] = "Resistant",
        e[e.ResistOrVuln = 521] = "ResistOrVuln",
        e[e.ResistOrVulnAll = 522] = "ResistOrVulnAll",
        e[e.Rest = 523] = "Rest",
        e[e.Rested = 524] = "Rested",
        e[e.Resting = 525] = "Resting",
        e[e.RestingOnGroundNotEffective = 526] = "RestingOnGroundNotEffective",
        e[e.RestInterrupted = 527] = "RestInterrupted",
        e[e.RestInterruptedDamage = 528] = "RestInterruptedDamage",
        e[e.RestInterruptedLoudNoise = 529] = "RestInterruptedLoudNoise",
        e[e.RestInterruptedPain = 530] = "RestInterruptedPain",
        e[e.RestInterruptedStirring = 531] = "RestInterruptedStirring",
        e[e.RestLongTime = 532] = "RestLongTime",
        e[e.RestModerateTime = 533] = "RestModerateTime",
        e[e.RestOnGround = 534] = "RestOnGround",
        e[e.RestShortTime = 535] = "RestShortTime",
        e[e.RestTime = 536] = "RestTime",
        e[e.ReturnedToCivilization = 537] = "ReturnedToCivilization",
        e[e.ReturningToCivilizationSetOffAgain = 538] = "ReturningToCivilizationSetOffAgain",
        e[e.ReturnsToLife = 539] = "ReturnsToLife",
        e[e.Reveals = 540] = "Reveals",
        e[e.RevealsEntityAppearsHurt = 541] = "RevealsEntityAppearsHurt",
        e[e.RevealsEntityAppearsUnharmed = 542] = "RevealsEntityAppearsUnharmed",
        e[e.RevealsEntityAppearsVeryHurt = 543] = "RevealsEntityAppearsVeryHurt",
        e[e.RevealsEntityIsAtPercentHealth = 544] = "RevealsEntityIsAtPercentHealth",
        e[e.RevealsEntityIsInjured = 545] = "RevealsEntityIsInjured",
        e[e.RevealsEntityIsMostlyUninjured = 546] = "RevealsEntityIsMostlyUninjured",
        e[e.RevealsEntityIsOnTheVergeOfDeath = 547] = "RevealsEntityIsOnTheVergeOfDeath",
        e[e.RevealsEntityIsSeverelyInjured = 548] = "RevealsEntityIsSeverelyInjured",
        e[e.RevealsEntitySeemsInjured = 549] = "RevealsEntitySeemsInjured",
        e[e.RevealsEntitySeemsUninjured = 550] = "RevealsEntitySeemsUninjured",
        e[e.RevealsNumberOfResistancesAndVulnerabilities = 551] = "RevealsNumberOfResistancesAndVulnerabilities",
        e[e.RevealsResistancesAndVulnerabilities = 552] = "RevealsResistancesAndVulnerabilities",
        e[e.RevealsSomeResistancesAndVulnerabilities = 553] = "RevealsSomeResistancesAndVulnerabilities",
        e[e.RightHand = 554] = "RightHand",
        e[e.RightHandEquip = 555] = "RightHandEquip",
        e[e.ScrollMaster = 556] = "ScrollMaster",
        e[e.ScrollProvidedNoUsefulInsight = 557] = "ScrollProvidedNoUsefulInsight",
        e[e.SeaweedFromWater = 558] = "SeaweedFromWater",
        e[e.SeemsToHaveDrawnEnergy = 559] = "SeemsToHaveDrawnEnergy",
        e[e.SetTrapOffButNoDamage = 560] = "SetTrapOffButNoDamage",
        e[e.SetUp = 561] = "SetUp",
        e[e.ShadowInTheWater = 562] = "ShadowInTheWater",
        e[e.Simple = 563] = "Simple",
        e[e.Skill = 564] = "Skill",
        e[e.SkillHasRaised = 565] = "SkillHasRaised",
        e[e.Skills = 566] = "Skills",
        e[e.Slashing = 567] = "Slashing",
        e[e.Sleep = 568] = "Sleep",
        e[e.Sleeping = 569] = "Sleeping",
        e[e.Slept = 570] = "Slept",
        e[e.SlitherSuckerConstricts = 571] = "SlitherSuckerConstricts",
        e[e.SlitherSuckerJumpedOnHead = 572] = "SlitherSuckerJumpedOnHead",
        e[e.Some = 573] = "Some",
        e[e.SomethingInTheWayOf = 574] = "SomethingInTheWayOf",
        e[e.SomethingInTheWayOfCarveFirst = 575] = "SomethingInTheWayOfCarveFirst",
        e[e.SomethingInTheWayOfFire = 576] = "SomethingInTheWayOfFire",
        e[e.SomethingInTheWayOfFishing = 577] = "SomethingInTheWayOfFishing",
        e[e.SomethingInTheWayOfPerforming = 578] = "SomethingInTheWayOfPerforming",
        e[e.SomethingInTheWayOfPlacing = 579] = "SomethingInTheWayOfPlacing",
        e[e.SomethingInTheWayOfPlanting = 580] = "SomethingInTheWayOfPlanting",
        e[e.SomethingInWayOfClosingDoor = 581] = "SomethingInWayOfClosingDoor",
        e[e.SoothedTheirBurnInjuries = 582] = "SoothedTheirBurnInjuries",
        e[e.SoothedYourBurnInjuries = 583] = "SoothedYourBurnInjuries",
        e[e.Sort = 584] = "Sort",
        e[e.SortedByBest = 585] = "SortedByBest",
        e[e.SortedByCategory = 586] = "SortedByCategory",
        e[e.SortedByDecay = 587] = "SortedByDecay",
        e[e.SortedByDurability = 588] = "SortedByDurability",
        e[e.SortedByGroup = 589] = "SortedByGroup",
        e[e.SortedByName = 590] = "SortedByName",
        e[e.SortedByQuality = 591] = "SortedByQuality",
        e[e.SortedByRecent = 592] = "SortedByRecent",
        e[e.SortedBySkill = 593] = "SortedBySkill",
        e[e.SortedByUnlockedTime = 594] = "SortedByUnlockedTime",
        e[e.SortedByWeight = 595] = "SortedByWeight",
        e[e.South = 596] = "South",
        e[e.Southeast = 597] = "Southeast",
        e[e.SouthSoutheast = 598] = "SouthSoutheast",
        e[e.SouthSouthwest = 599] = "SouthSouthwest",
        e[e.Southwest = 600] = "Southwest",
        e[e.StaminaIsFull = 601] = "StaminaIsFull",
        e[e.StartedFire = 602] = "StartedFire",
        e[e.StartTravelInWater = 603] = "StartTravelInWater",
        e[e.StarvingToDeath = 604] = "StarvingToDeath",
        e[e.SteppingOnHasInjuredYouForDamage = 605] = "SteppingOnHasInjuredYouForDamage",
        e[e.StillHasNoWaterToPurify = 606] = "StillHasNoWaterToPurify",
        e[e.StirredUpClawWorm = 607] = "StirredUpClawWorm",
        e[e.StirredUpCreature = 608] = "StirredUpCreature",
        e[e.StoppedYourBleeding = 609] = "StoppedYourBleeding",
        e[e.StopUsingRaft = 610] = "StopUsingRaft",
        e[e.Strength = 611] = "Strength",
        e[e.StrengthIncreasing = 612] = "StrengthIncreasing",
        e[e.SummonedGuardiansByDiggingTreasure = 613] = "SummonedGuardiansByDiggingTreasure",
        e[e.SunNotBrightEnoughToStartFire = 614] = "SunNotBrightEnoughToStartFire",
        e[e.TakenFromGroundBecomeTamed = 615] = "TakenFromGroundBecomeTamed",
        e[e.Tame = 616] = "Tame",
        e[e.TamedAppearsAngered = 617] = "TamedAppearsAngered",
        e[e.TamedAppearsContended = 618] = "TamedAppearsContended",
        e[e.TamedAppearsHappy = 619] = "TamedAppearsHappy",
        e[e.TamedAppearsUpset = 620] = "TamedAppearsUpset",
        e[e.TamedCreature = 621] = "TamedCreature",
        e[e.TeleportBlocked = 622] = "TeleportBlocked",
        e[e.Teleported = 623] = "Teleported",
        e[e.ThanksBuying = 624] = "ThanksBuying",
        e[e.ThanksSelling = 625] = "ThanksSelling",
        e[e.The = 626] = "The",
        e[e.TheCreature = 627] = "TheCreature",
        e[e.TheirFist = 628] = "TheirFist",
        e[e.ThePlant = 629] = "ThePlant",
        e[e.ThereIsNoSunToStartFire = 630] = "ThereIsNoSunToStartFire",
        e[e.ThereIsNothingToMilk = 631] = "ThereIsNothingToMilk",
        e[e.ThisCannotBeMilked = 632] = "ThisCannotBeMilked",
        e[e.Throw = 633] = "Throw",
        e[e.ThrownIntoDepths = 634] = "ThrownIntoDepths",
        e[e.ThrownIntoObstacle = 635] = "ThrownIntoObstacle",
        e[e.Till = 636] = "Till",
        e[e.Tilling = 637] = "Tilling",
        e[e.TimeIs = 638] = "TimeIs",
        e[e.TimeIsDawn = 639] = "TimeIsDawn",
        e[e.TimeIsDaytime = 640] = "TimeIsDaytime",
        e[e.TimeIsDusk = 641] = "TimeIsDusk",
        e[e.TimeIsNighttime = 642] = "TimeIsNighttime",
        e[e.TimeIsSunrise = 643] = "TimeIsSunrise",
        e[e.TimeIsSunset = 644] = "TimeIsSunset",
        e[e.ToDamageAChest = 645] = "ToDamageAChest",
        e[e.ToFight = 646] = "ToFight",
        e[e.TooDamaged = 647] = "TooDamaged",
        e[e.TooExhaustedToJump = 648] = "TooExhaustedToJump",
        e[e.TradeBarterCreditForItem = 649] = "TradeBarterCreditForItem",
        e[e.TradeItemForBarterCredit = 650] = "TradeItemForBarterCredit",
        e[e.TradingWith = 651] = "TradingWith",
        e[e.TrampledFire = 652] = "TrampledFire",
        e[e.TrampledIntoGround = 653] = "TrampledIntoGround",
        e[e.TrampleIntoGround = 654] = "TrampleIntoGround",
        e[e.Trampling = 655] = "Trampling",
        e[e.Transmogrification = 656] = "Transmogrification",
        e[e.Transmogrified = 657] = "Transmogrified",
        e[e.TrapMissed = 658] = "TrapMissed",
        e[e.TrapStoppedYou = 659] = "TrapStoppedYou",
        e[e.TravelToFarOffLands = 660] = "TravelToFarOffLands",
        e[e.TreasureIsBlocked = 661] = "TreasureIsBlocked",
        e[e.True = 662] = "True",
        e[e.UnEquip = 663] = "UnEquip",
        e[e.UnEquipAll = 664] = "UnEquipAll",
        e[e.Unhitch = 665] = "Unhitch",
        e[e.UnhitchCreature = 666] = "UnhitchCreature",
        e[e.Unknown = 667] = "Unknown",
        e[e.UnknownItem = 668] = "UnknownItem",
        e[e.UnlockedChest = 669] = "UnlockedChest",
        e[e.UnlockedTime = 670] = "UnlockedTime",
        e[e.UnpurifiedFreshWater = 671] = "UnpurifiedFreshWater",
        e[e.UnpurifiedWaterInStill = 672] = "UnpurifiedWaterInStill",
        e[e.UsingBareHands = 673] = "UsingBareHands",
        e[e.Vulnerable = 674] = "Vulnerable",
        e[e.WaitUntilFireCooledToGetWater = 675] = "WaitUntilFireCooledToGetWater",
        e[e.Water = 676] = "Water",
        e[e.WaterGathering = 677] = "WaterGathering",
        e[e.WaterPutOutFire = 678] = "WaterPutOutFire",
        e[e.Weight = 679] = "Weight",
        e[e.WeightCapacity = 680] = "WeightCapacity",
        e[e.WellIsDry = 681] = "WellIsDry",
        e[e.WellIsFull = 682] = "WellIsFull",
        e[e.West = 683] = "West",
        e[e.WestNorthwest = 684] = "WestNorthwest",
        e[e.WestSouthwest = 685] = "WestSouthwest",
        e[e.WildGoatRefusedToBeMilked = 686] = "WildGoatRefusedToBeMilked",
        e[e.WillNotTrade = 687] = "WillNotTrade",
        e[e.With = 688] = "With",
        e[e.WithYouSee = 689] = "WithYouSee",
        e[e.WorkingYourselfIntoExhaustion = 690] = "WorkingYourselfIntoExhaustion",
        e[e.WorkingYourselfIntoExhaustionAndDrowning = 691] = "WorkingYourselfIntoExhaustionAndDrowning",
        e[e.YouApplied = 692] = "YouApplied",
        e[e.YouAte = 693] = "YouAte",
        e[e.YouBeginResting = 694] = "YouBeginResting",
        e[e.YouCannotDoThatYet = 695] = "YouCannotDoThatYet",
        e[e.YouCooledLava = 696] = "YouCooledLava",
        e[e.YouCrafted = 697] = "YouCrafted",
        e[e.YouDied = 698] = "YouDied",
        e[e.YouDisassembled = 699] = "YouDisassembled",
        e[e.YouDismantled = 700] = "YouDismantled",
        e[e.YouDrank = 701] = "YouDrank",
        e[e.YouDropTheTorch = 702] = "YouDropTheTorch",
        e[e.YouEquip = 703] = "YouEquip",
        e[e.YouFailedTo = 704] = "YouFailedTo",
        e[e.YouFailedToExtinguishedFireFully = 705] = "YouFailedToExtinguishedFireFully",
        e[e.YouFailedToHeal = 706] = "YouFailedToHeal",
        e[e.YouFailedToHealOther = 707] = "YouFailedToHealOther",
        e[e.YouFire = 708] = "YouFire",
        e[e.YouGathered = 709] = "YouGathered",
        e[e.YouGatheredAndDropped = 710] = "YouGatheredAndDropped",
        e[e.YouHardenedCooledLava = 711] = "YouHardenedCooledLava",
        e[e.YouHarvested = 712] = "YouHarvested",
        e[e.YouHarvestedAndDropped = 713] = "YouHarvestedAndDropped",
        e[e.YouHaveAlreadyLearned = 714] = "YouHaveAlreadyLearned",
        e[e.YouHaveDied = 715] = "YouHaveDied",
        e[e.YouHaveEnabledDisabled = 716] = "YouHaveEnabledDisabled",
        e[e.YouHaveHealedOther = 717] = "YouHaveHealedOther",
        e[e.YouHaveKilled = 718] = "YouHaveKilled",
        e[e.YouHaveReleased = 719] = "YouHaveReleased",
        e[e.YouHaveTamed = 720] = "YouHaveTamed",
        e[e.YouNeedMoreCredit = 721] = "YouNeedMoreCredit",
        e[e.YouNoticeBecomeEnraged = 722] = "YouNoticeBecomeEnraged",
        e[e.YouNoticeDying = 723] = "YouNoticeDying",
        e[e.YouNoticeFertilityDecreasing = 724] = "YouNoticeFertilityDecreasing",
        e[e.YouNoticeFertilityIncreasing = 725] = "YouNoticeFertilityIncreasing",
        e[e.YouNoticeGrowing = 726] = "YouNoticeGrowing",
        e[e.YouNoticeLavaCooling = 727] = "YouNoticeLavaCooling",
        e[e.YouNoticeLavaHardening = 728] = "YouNoticeLavaHardening",
        e[e.YouNoticePerish = 729] = "YouNoticePerish",
        e[e.YouNoticeStumbleInjureItself = 730] = "YouNoticeStumbleInjureItself",
        e[e.YouNoticeTakeFromGround = 731] = "YouNoticeTakeFromGround",
        e[e.YouNoticeWoundsClosing = 732] = "YouNoticeWoundsClosing",
        e[e.YouNoticeZombieHorde = 733] = "YouNoticeZombieHorde",
        e[e.YouOfferedToCreature = 734] = "YouOfferedToCreature",
        e[e.YouOpen = 735] = "YouOpen",
        e[e.YouPacked = 736] = "YouPacked",
        e[e.YouPickedUp = 737] = "YouPickedUp",
        e[e.YouRepair = 738] = "YouRepair",
        e[e.YourFist = 739] = "YourFist",
        e[e.YourHands = 740] = "YourHands",
        e[e.YourHighSkill = 741] = "YourHighSkill",
        e[e.YourInventory = 742] = "YourInventory",
        e[e.YourLowSkill = 743] = "YourLowSkill",
        e[e.YourModerateSkill = 744] = "YourModerateSkill",
        e[e.YourRubbingNoEffect = 745] = "YourRubbingNoEffect",
        e[e.YouRub = 746] = "YouRub",
        e[e.YouSalvaged = 747] = "YouSalvaged",
        e[e.YouSee = 748] = "YouSee",
        e[e.YouSeeAnAberrant = 749] = "YouSeeAnAberrant",
        e[e.YouSeeDrop = 750] = "YouSeeDrop",
        e[e.YouSeeEngulfFire = 751] = "YouSeeEngulfFire",
        e[e.YouSeeHelpingPlant = 752] = "YouSeeHelpingPlant",
        e[e.YouSeeLay = 753] = "YouSeeLay",
        e[e.YouSeeLayingTrap = 754] = "YouSeeLayingTrap",
        e[e.YouSeeSpewLava = 755] = "YouSeeSpewLava",
        e[e.YouSeeSpitAcid = 756] = "YouSeeSpitAcid",
        e[e.YouSeeSpringForth = 757] = "YouSeeSpringForth",
        e[e.YouSeeSummon = 758] = "YouSeeSummon",
        e[e.YouSeeSwampFlood = 759] = "YouSeeSwampFlood",
        e[e.YouSeeTrampling = 760] = "YouSeeTrampling",
        e[e.YouSeparate = 761] = "YouSeparate",
        e[e.YouSetTheTrapOff = 762] = "YouSetTheTrapOff",
        e[e.YouThrew = 763] = "YouThrew",
        e[e.YouTilled = 764] = "YouTilled",
        e[e.YouUnequip = 765] = "YouUnequip",
        e[e.YouUsed = 766] = "YouUsed"
    }(a || (a = {})),
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/dictionary/UiTranslation", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.GameActionGather = 0] = "GameActionGather",
        e[e.GameDialogMessagesName = 1] = "GameDialogMessagesName",
        e[e.GameDialogMessagesOptionTimestamp = 2] = "GameDialogMessagesOptionTimestamp",
        e[e.GameDialogMessagesOptionShowSendButton = 3] = "GameDialogMessagesOptionShowSendButton",
        e[e.GameDialogMessagesOptionShowOptionsButton = 4] = "GameDialogMessagesOptionShowOptionsButton",
        e[e.GameDialogMessagesOptionMaxMessages = 5] = "GameDialogMessagesOptionMaxMessages",
        e[e.GameDialogMessagesEditFiltersName = 6] = "GameDialogMessagesEditFiltersName",
        e[e.GameDialogMessagesEditFiltersLabelName = 7] = "GameDialogMessagesEditFiltersLabelName",
        e[e.GameDialogMessagesEditFiltersButtonDelete = 8] = "GameDialogMessagesEditFiltersButtonDelete",
        e[e.GameDialogMessagesEditFiltersButtonSave = 9] = "GameDialogMessagesEditFiltersButtonSave",
        e[e.GameDialogMessagesEditFiltersButtonReset = 10] = "GameDialogMessagesEditFiltersButtonReset",
        e[e.GameDialogMessagesEditFiltersButtonNew = 11] = "GameDialogMessagesEditFiltersButtonNew",
        e[e.GameDialogMessagesEditFiltersInterruptSaveOverExisting = 12] = "GameDialogMessagesEditFiltersInterruptSaveOverExisting",
        e[e.GameDialogMessagesEditFiltersInterruptSaveOverExistingDescription = 13] = "GameDialogMessagesEditFiltersInterruptSaveOverExistingDescription",
        e[e.GameDialogMessagesEditFiltersInterruptResetConfirm = 14] = "GameDialogMessagesEditFiltersInterruptResetConfirm",
        e[e.GameDialogMessagesEditFiltersInterruptResetConfirmDescription = 15] = "GameDialogMessagesEditFiltersInterruptResetConfirmDescription",
        e[e.GameDialogNotesName = 16] = "GameDialogNotesName",
        e[e.GameDialogNotesNoteTime = 17] = "GameDialogNotesNoteTime",
        e[e.GameDialogNotesNoteNumber = 18] = "GameDialogNotesNoteNumber",
        e[e.GameDialogNotesNoteLockedTitle = 19] = "GameDialogNotesNoteLockedTitle",
        e[e.GameDialogNotesNoteLockedDescription = 20] = "GameDialogNotesNoteLockedDescription",
        e[e.GameDialogNotesLinkId = 21] = "GameDialogNotesLinkId",
        e[e.GameDialogNotesLinkLearnMore = 22] = "GameDialogNotesLinkLearnMore",
        e[e.GameDialogNotesSettingsPinUnreadNotesAutomatically = 23] = "GameDialogNotesSettingsPinUnreadNotesAutomatically",
        e[e.GameDialogQuickSettingsName = 24] = "GameDialogQuickSettingsName",
        e[e.GameDialogMilestonesName = 25] = "GameDialogMilestonesName",
        e[e.GameDialogMilestonesInvisibleMilestone = 26] = "GameDialogMilestonesInvisibleMilestone",
        e[e.GameDialogMilestonesProgress = 27] = "GameDialogMilestonesProgress",
        e[e.GameDialogMilestonesProgressHidden = 28] = "GameDialogMilestonesProgressHidden",
        e[e.GameDialogMilestonesMilestone = 29] = "GameDialogMilestonesMilestone",
        e[e.GameDialogMilestonesTooltipHidden = 30] = "GameDialogMilestonesTooltipHidden",
        e[e.GameDialogMilestonesTooltipInvisible = 31] = "GameDialogMilestonesTooltipInvisible",
        e[e.GameDialogMilestonesSortName = 32] = "GameDialogMilestonesSortName",
        e[e.GameDialogMilestonesSortProgress = 33] = "GameDialogMilestonesSortProgress",
        e[e.GameDialogSkillsName = 34] = "GameDialogSkillsName",
        e[e.GameDialogSkillsSkill = 35] = "GameDialogSkillsSkill",
        e[e.GameDialogSkillsTooltipReputationImpact = 36] = "GameDialogSkillsTooltipReputationImpact",
        e[e.GameDialogSkillsTooltipCanIncrease = 37] = "GameDialogSkillsTooltipCanIncrease",
        e[e.GameDialogSkillsSortName = 38] = "GameDialogSkillsSortName",
        e[e.GameDialogSkillsSortLevel = 39] = "GameDialogSkillsSortLevel",
        e[e.GameDialogBookName = 40] = "GameDialogBookName",
        e[e.GameDialogMapName = 41] = "GameDialogMapName",
        e[e.GameDialogMapTooltipDecode = 42] = "GameDialogMapTooltipDecode",
        e[e.GameDialogQuestsName = 43] = "GameDialogQuestsName",
        e[e.GameDialogQuestsLink = 44] = "GameDialogQuestsLink",
        e[e.GameDialogQuestsChildQuests = 45] = "GameDialogQuestsChildQuests",
        e[e.GameDialogQuestsRequirements = 46] = "GameDialogQuestsRequirements",
        e[e.GameDialogQuestsActiveQuests = 47] = "GameDialogQuestsActiveQuests",
        e[e.GameDialogQuestsCompletedQuests = 48] = "GameDialogQuestsCompletedQuests",
        e[e.GameDialogQuestsCompleteQuest = 49] = "GameDialogQuestsCompleteQuest",
        e[e.GameTooltipShowMoreInformation = 50] = "GameTooltipShowMoreInformation",
        e[e.GameTooltipLegendaryMaxWeightLabel = 51] = "GameTooltipLegendaryMaxWeightLabel",
        e[e.GameStatsPercentage = 52] = "GameStatsPercentage",
        e[e.GameStatsStatAttack = 53] = "GameStatsStatAttack",
        e[e.GameStatsStatGeneric = 54] = "GameStatsStatGeneric",
        e[e.GameStatsStatGenericWithMax = 55] = "GameStatsStatGenericWithMax",
        e[e.GameStatsStatbar = 56] = "GameStatsStatbar",
        e[e.GameStatsStatHealthTooltip = 57] = "GameStatsStatHealthTooltip",
        e[e.GameStatsStatStaminaTooltip = 58] = "GameStatsStatStaminaTooltip",
        e[e.GameStatsStatHungerTooltip = 59] = "GameStatsStatHungerTooltip",
        e[e.GameStatsStatThirstTooltip = 60] = "GameStatsStatThirstTooltip",
        e[e.GameStatsStatReputationTooltipDifficulty = 61] = "GameStatsStatReputationTooltipDifficulty",
        e[e.GameStatsStatReputationTooltipDifficultyEasy = 62] = "GameStatsStatReputationTooltipDifficultyEasy",
        e[e.GameStatsStatReputationTooltipDifficultyHard = 63] = "GameStatsStatReputationTooltipDifficultyHard",
        e[e.GameStatsStatReputationTooltipDifficultyInsane = 64] = "GameStatsStatReputationTooltipDifficultyInsane",
        e[e.GameStatsStatReputationTooltipDifficultyMedium = 65] = "GameStatsStatReputationTooltipDifficultyMedium",
        e[e.GameStatsStatReputationTooltipDifficultySimple = 66] = "GameStatsStatReputationTooltipDifficultySimple",
        e[e.GameStatsStatReputationTooltipDifficultyVeryEasy = 67] = "GameStatsStatReputationTooltipDifficultyVeryEasy",
        e[e.GameStatsStatReputationTooltipDifficultyVeryHard = 68] = "GameStatsStatReputationTooltipDifficultyVeryHard",
        e[e.GameStatsStatReputationTooltipBenignity = 69] = "GameStatsStatReputationTooltipBenignity",
        e[e.GameStatsStatReputationTooltipMalignity = 70] = "GameStatsStatReputationTooltipMalignity",
        e[e.GameStatsStatReputationTooltipScore = 71] = "GameStatsStatReputationTooltipScore",
        e[e.GameStatsStatReputationTooltipTurn = 72] = "GameStatsStatReputationTooltipTurn",
        e[e.GameStatsStatReputationTooltipTicks = 73] = "GameStatsStatReputationTooltipTicks",
        e[e.GameStatsStatWeightTooltip = 74] = "GameStatsStatWeightTooltip",
        e[e.GameStatsStatAttackTooltipTactics = 75] = "GameStatsStatAttackTooltipTactics",
        e[e.GameStatsStatAttackTooltipLeftHand = 76] = "GameStatsStatAttackTooltipLeftHand",
        e[e.GameStatsStatAttackTooltipRightHand = 77] = "GameStatsStatAttackTooltipRightHand",
        e[e.GameStatsStatDefenseTooltipBase = 78] = "GameStatsStatDefenseTooltipBase",
        e[e.GameStatsStatDefenseTooltipBlunt = 79] = "GameStatsStatDefenseTooltipBlunt",
        e[e.GameStatsStatDefenseTooltipParrying = 80] = "GameStatsStatDefenseTooltipParrying",
        e[e.GameStatsStatDefenseTooltipFire = 81] = "GameStatsStatDefenseTooltipFire",
        e[e.GameStatsStatDefenseTooltipPiercing = 82] = "GameStatsStatDefenseTooltipPiercing",
        e[e.GameStatsStatDefenseTooltipSlashing = 83] = "GameStatsStatDefenseTooltipSlashing",
        e[e.GameQuadrantElementStats = 84] = "GameQuadrantElementStats",
        e[e.GameQuadrantElementMenuBar = 85] = "GameQuadrantElementMenuBar",
        e[e.GameQuadrantElementQuickslots = 86] = "GameQuadrantElementQuickslots",
        e[e.GameQuadrantElementMessages = 87] = "GameQuadrantElementMessages",
        e[e.GameQuadrantElementContextMenuMoveTo = 88] = "GameQuadrantElementContextMenuMoveTo",
        e[e.GameQuadrantElementContextMenuSwitchWith = 89] = "GameQuadrantElementContextMenuSwitchWith",
        e[e.GameItemBarterCredit = 90] = "GameItemBarterCredit",
        e[e.GameItemBarterCreditTrade = 91] = "GameItemBarterCreditTrade",
        e[e.GameInterruptItemMayBeDestroyedInCraft = 92] = "GameInterruptItemMayBeDestroyedInCraft",
        e[e.GameInterruptItemMayBeDestroyedInCraftDescription = 93] = "GameInterruptItemMayBeDestroyedInCraftDescription",
        e[e.GameInterruptItemMayBeDestroyedOnUse = 94] = "GameInterruptItemMayBeDestroyedOnUse",
        e[e.GameInterruptItemMayBeDestroyedOnUseDescription = 95] = "GameInterruptItemMayBeDestroyedOnUseDescription",
        e[e.GameInterruptLoadingQuitting = 96] = "GameInterruptLoadingQuitting",
        e[e.GameInterruptLoadingQuittingDescription = 97] = "GameInterruptLoadingQuittingDescription",
        e[e.GameInterruptLoadingSaving = 98] = "GameInterruptLoadingSaving",
        e[e.GameInterruptLoadingSavingDescription = 99] = "GameInterruptLoadingSavingDescription",
        e[e.GameInterruptReleaseCreature = 100] = "GameInterruptReleaseCreature",
        e[e.GameInterruptReleaseCreatureDescription = 101] = "GameInterruptReleaseCreatureDescription",
        e[e.GameInterruptRenameCreature = 102] = "GameInterruptRenameCreature",
        e[e.GameInterruptRenameCreatureDescription = 103] = "GameInterruptRenameCreatureDescription",
        e[e.GameInterruptRenameDoodad = 104] = "GameInterruptRenameDoodad",
        e[e.GameInterruptRenameDoodadDescription = 105] = "GameInterruptRenameDoodadDescription",
        e[e.GameInterruptRenameItem = 106] = "GameInterruptRenameItem",
        e[e.GameInterruptRenameItemDescription = 107] = "GameInterruptRenameItemDescription",
        e[e.GameInterruptReturnToTitleScreen = 108] = "GameInterruptReturnToTitleScreen",
        e[e.GameInterruptReturnToTitleScreenChallenge = 109] = "GameInterruptReturnToTitleScreenChallenge",
        e[e.GameInterruptReturnToTitleScreenChallengeDescription = 110] = "GameInterruptReturnToTitleScreenChallengeDescription",
        e[e.GameInterruptReturnToTitleScreenDescription = 111] = "GameInterruptReturnToTitleScreenDescription",
        e[e.GameInterruptLoadingWorld = 112] = "GameInterruptLoadingWorld",
        e[e.GameInterruptLoadingWorldDescription = 113] = "GameInterruptLoadingWorldDescription",
        e[e.GameInterruptLoadingGeneratingWorld = 114] = "GameInterruptLoadingGeneratingWorld",
        e[e.GameInterruptLoadingGeneratingWorldDescription = 115] = "GameInterruptLoadingGeneratingWorldDescription",
        e[e.GameInterruptLoadingFinalizingWorld = 116] = "GameInterruptLoadingFinalizingWorld",
        e[e.GameInterruptLoadingFinalizingWorldDescription = 117] = "GameInterruptLoadingFinalizingWorldDescription",
        e[e.GameInterruptSailAwayEnd = 118] = "GameInterruptSailAwayEnd",
        e[e.GameInterruptSailAwayEndDescription = 119] = "GameInterruptSailAwayEndDescription",
        e[e.GameInterruptSailAwayReturnable = 120] = "GameInterruptSailAwayReturnable",
        e[e.GameInterruptSailAwayReturnableDescription = 121] = "GameInterruptSailAwayReturnableDescription",
        e[e.GameInterruptTravelAway = 122] = "GameInterruptTravelAway",
        e[e.GameInterruptTravelAwayDescription = 123] = "GameInterruptTravelAwayDescription",
        e[e.GameInterruptLoadingResting = 124] = "GameInterruptLoadingResting",
        e[e.GameInterruptLoadingRestingDescription = 125] = "GameInterruptLoadingRestingDescription",
        e[e.GameInterruptLoadingSleeping = 126] = "GameInterruptLoadingSleeping",
        e[e.GameInterruptLoadingSleepingDescription = 127] = "GameInterruptLoadingSleepingDescription",
        e[e.GameInterruptLoadingTraveling = 128] = "GameInterruptLoadingTraveling",
        e[e.GameInterruptLoadingTravelingDescription = 129] = "GameInterruptLoadingTravelingDescription",
        e[e.GameInterruptLoadingLostGLContext = 130] = "GameInterruptLoadingLostGLContext",
        e[e.GameInterruptLoadingAutoSaving = 131] = "GameInterruptLoadingAutoSaving",
        e[e.GameInterruptLoadingAutoSavingDescription = 132] = "GameInterruptLoadingAutoSavingDescription",
        e[e.GameInterruptLoadingLostGLContextDescription = 133] = "GameInterruptLoadingLostGLContextDescription",
        e[e.GameInterruptLoadingMods = 134] = "GameInterruptLoadingMods",
        e[e.GameInterruptLoadingModsDescription = 135] = "GameInterruptLoadingModsDescription",
        e[e.GameInterruptLoadingMultiplayerPlayerConnecting = 136] = "GameInterruptLoadingMultiplayerPlayerConnecting",
        e[e.GameInterruptLoadingMultiplayerSyncing = 137] = "GameInterruptLoadingMultiplayerSyncing",
        e[e.GameInterruptLoadingReloadingWebGl = 138] = "GameInterruptLoadingReloadingWebGl",
        e[e.GameInterruptDangerousStep = 139] = "GameInterruptDangerousStep",
        e[e.GameInterruptDangerousStepDescription = 140] = "GameInterruptDangerousStepDescription",
        e[e.GameInterruptSaveFailure = 141] = "GameInterruptSaveFailure",
        e[e.GameInterruptSaveFailureDescription = 142] = "GameInterruptSaveFailureDescription",
        e[e.GameInterruptLoadFailure = 143] = "GameInterruptLoadFailure",
        e[e.GameInterruptLoadFailureDescription = 144] = "GameInterruptLoadFailureDescription",
        e[e.GameInterruptDesalinationNoNeed = 145] = "GameInterruptDesalinationNoNeed",
        e[e.GameInterruptDesalinationNoNeedDescription = 146] = "GameInterruptDesalinationNoNeedDescription",
        e[e.GameInterruptWellConvert = 147] = "GameInterruptWellConvert",
        e[e.GameInterruptWellConvertDescription = 148] = "GameInterruptWellConvertDescription",
        e[e.GameInterruptNoHealingRequired = 149] = "GameInterruptNoHealingRequired",
        e[e.GameInterruptNoHealingRequiredDescription = 150] = "GameInterruptNoHealingRequiredDescription",
        e[e.GameInterruptConfirmationActionOnFire = 151] = "GameInterruptConfirmationActionOnFire",
        e[e.GameInterruptConfirmationActionOnFireDescription = 152] = "GameInterruptConfirmationActionOnFireDescription",
        e[e.GameInterruptConfirmationDestroyOnGather = 153] = "GameInterruptConfirmationDestroyOnGather",
        e[e.GameInterruptConfirmationDestroyOnGatherDescription = 154] = "GameInterruptConfirmationDestroyOnGatherDescription",
        e[e.GameInterruptLoadingGame = 155] = "GameInterruptLoadingGame",
        e[e.GameInterruptLoadingGameDescription = 156] = "GameInterruptLoadingGameDescription",
        e[e.GameInterruptLoadingSprites = 157] = "GameInterruptLoadingSprites",
        e[e.GameInterruptLoadingSpritesDescription = 158] = "GameInterruptLoadingSpritesDescription",
        e[e.GameInterruptMultiplayerSynchronizing = 159] = "GameInterruptMultiplayerSynchronizing",
        e[e.GameInterruptMultiplayerSynchronizingDescription = 160] = "GameInterruptMultiplayerSynchronizingDescription",
        e[e.GameInterruptNoSaveOnDeath = 161] = "GameInterruptNoSaveOnDeath",
        e[e.GameInterruptNoSaveOnDeathDescription = 162] = "GameInterruptNoSaveOnDeathDescription",
        e[e.GameInterruptItemsMayBeDestroyedOnUse = 163] = "GameInterruptItemsMayBeDestroyedOnUse",
        e[e.GameInterruptItemsMayBeDestroyedOnUseDescription = 164] = "GameInterruptItemsMayBeDestroyedOnUseDescription",
        e[e.GameMenuBarButtonTooltipBindable = 165] = "GameMenuBarButtonTooltipBindable",
        e[e.GameMenuBarButtonTooltipMenu = 166] = "GameMenuBarButtonTooltipMenu",
        e[e.GameMenuBarButtonTooltipSave = 167] = "GameMenuBarButtonTooltipSave",
        e[e.GameMenuBarButtonTooltipNotes = 168] = "GameMenuBarButtonTooltipNotes",
        e[e.GameMenuBarButtonTooltipMilestones = 169] = "GameMenuBarButtonTooltipMilestones",
        e[e.GameMenuBarButtonTooltipMessages = 170] = "GameMenuBarButtonTooltipMessages",
        e[e.GameMenuBarButtonTooltipHelp = 171] = "GameMenuBarButtonTooltipHelp",
        e[e.GameMenuBarButtonTooltipQuickSettings = 172] = "GameMenuBarButtonTooltipQuickSettings",
        e[e.GameMenuBarButtonTooltipActions = 173] = "GameMenuBarButtonTooltipActions",
        e[e.GameMenuBarButtonTooltipInventory = 174] = "GameMenuBarButtonTooltipInventory",
        e[e.GameMenuBarButtonTooltipCrafting = 175] = "GameMenuBarButtonTooltipCrafting",
        e[e.GameMenuBarButtonTooltipEquipment = 176] = "GameMenuBarButtonTooltipEquipment",
        e[e.GameMenuBarButtonTooltipSkills = 177] = "GameMenuBarButtonTooltipSkills",
        e[e.GameMenuBarButtonTooltipQuests = 178] = "GameMenuBarButtonTooltipQuests",
        e[e.GameMessagesButtonSend = 179] = "GameMessagesButtonSend",
        e[e.GameMessagesContextMenuShowAsDialog = 180] = "GameMessagesContextMenuShowAsDialog",
        e[e.GameMessagesContextMenuClear = 181] = "GameMessagesContextMenuClear",
        e[e.GameMessagesContextMenuCopy = 182] = "GameMessagesContextMenuCopy",
        e[e.GameMessagesContextMenuExport = 183] = "GameMessagesContextMenuExport",
        e[e.GameMessagesContextMenuClearInterrupt = 184] = "GameMessagesContextMenuClearInterrupt",
        e[e.GameMessagesContextMenuClearInterruptDescription = 185] = "GameMessagesContextMenuClearInterruptDescription",
        e[e.GameMessagesFilter = 186] = "GameMessagesFilter",
        e[e.GameMessagesFilterAll = 187] = "GameMessagesFilterAll",
        e[e.GameMessagesFilterGame = 188] = "GameMessagesFilterGame",
        e[e.GameMessagesFilterChat = 189] = "GameMessagesFilterChat",
        e[e.GameMessagesFiltersEdit = 190] = "GameMessagesFiltersEdit",
        e[e.GameMessagesNewNote = 191] = "GameMessagesNewNote",
        e[e.GameMessagesTurn = 192] = "GameMessagesTurn",
        e[e.GameMultiplayerInterruptBanned = 193] = "GameMultiplayerInterruptBanned",
        e[e.GameMultiplayerInterruptConnected = 194] = "GameMultiplayerInterruptConnected",
        e[e.GameMultiplayerInterruptConnectedDescriptionDownloadingWorldData = 195] = "GameMultiplayerInterruptConnectedDescriptionDownloadingWorldData",
        e[e.GameMultiplayerInterruptConnectedDescriptionWaitingForWorldData = 196] = "GameMultiplayerInterruptConnectedDescriptionWaitingForWorldData",
        e[e.GameMultiplayerInterruptConnecting = 197] = "GameMultiplayerInterruptConnecting",
        e[e.GameMultiplayerInterruptConnectingDescription = 198] = "GameMultiplayerInterruptConnectingDescription",
        e[e.GameMultiplayerInterruptFailedToConnect = 199] = "GameMultiplayerInterruptFailedToConnect",
        e[e.GameMultiplayerInterruptFailedToLoadMods = 200] = "GameMultiplayerInterruptFailedToLoadMods",
        e[e.GameMultiplayerInterruptKicked = 201] = "GameMultiplayerInterruptKicked",
        e[e.GameMultiplayerInterruptLostConnection = 202] = "GameMultiplayerInterruptLostConnection",
        e[e.GameMultiplayerInterruptRequiredModIsDisabled = 203] = "GameMultiplayerInterruptRequiredModIsDisabled",
        e[e.GameMultiplayerInterruptRequiredModNotInstalled = 204] = "GameMultiplayerInterruptRequiredModNotInstalled",
        e[e.GameMultiplayerInterruptRequiredModNotMultiplayerCompatible = 205] = "GameMultiplayerInterruptRequiredModNotMultiplayerCompatible",
        e[e.GameMultiplayerInterruptRequiredModUnableToLoad = 206] = "GameMultiplayerInterruptRequiredModUnableToLoad",
        e[e.GameMultiplayerInterruptRequiredModVersionMismatch = 207] = "GameMultiplayerInterruptRequiredModVersionMismatch",
        e[e.GameMultiplayerInterruptRestartServerAfterLoadingSave = 208] = "GameMultiplayerInterruptRestartServerAfterLoadingSave",
        e[e.GameMultiplayerInterruptRestartServerAfterLoadingSaveDescription = 209] = "GameMultiplayerInterruptRestartServerAfterLoadingSaveDescription",
        e[e.GameMultiplayerInterruptServerShutdown = 210] = "GameMultiplayerInterruptServerShutdown",
        e[e.GameMultiplayerInterruptSynchronizationError = 211] = "GameMultiplayerInterruptSynchronizationError",
        e[e.GameMultiplayerInterruptSynchronizationErrorDescription = 212] = "GameMultiplayerInterruptSynchronizationErrorDescription",
        e[e.GameMultiplayerInterruptUnableToJoinGame = 213] = "GameMultiplayerInterruptUnableToJoinGame",
        e[e.GameMultiplayerInterruptUnableToJoinGameBuildMismatch = 214] = "GameMultiplayerInterruptUnableToJoinGameBuildMismatch",
        e[e.GameMultiplayerInterruptUnableToJoinGameDuplicateIdentifier = 215] = "GameMultiplayerInterruptUnableToJoinGameDuplicateIdentifier",
        e[e.GameMultiplayerInterruptUnableToJoinGameFriendsOnly = 216] = "GameMultiplayerInterruptUnableToJoinGameFriendsOnly",
        e[e.GameMultiplayerInterruptUnableToJoinGameServerFull = 217] = "GameMultiplayerInterruptUnableToJoinGameServerFull",
        e[e.GameMultiplayerInterruptUnableToJoinGameSteamRequired = 218] = "GameMultiplayerInterruptUnableToJoinGameSteamRequired",
        e[e.GameMultiplayerInterruptUnableToJoinGameUnknownError = 219] = "GameMultiplayerInterruptUnableToJoinGameUnknownError",
        e[e.GameMultiplayerInterruptUnableToJoinGameVersionMismatch = 220] = "GameMultiplayerInterruptUnableToJoinGameVersionMismatch",
        e[e.MenuAboutTitle = 221] = "MenuAboutTitle",
        e[e.MenuAboutDescription = 222] = "MenuAboutDescription",
        e[e.MenuAboutGameDescription = 223] = "MenuAboutGameDescription",
        e[e.MenuAboutSectionTeam = 224] = "MenuAboutSectionTeam",
        e[e.MenuAboutTeamMemberResponsibilities = 225] = "MenuAboutTeamMemberResponsibilities",
        e[e.MenuAboutTeamMemberName = 226] = "MenuAboutTeamMemberName",
        e[e.MenuAboutTeamMemberNickname = 227] = "MenuAboutTeamMemberNickname",
        e[e.MenuAboutSectionContributors = 228] = "MenuAboutSectionContributors",
        e[e.MenuAboutSectionSpecialThanks = 229] = "MenuAboutSectionSpecialThanks",
        e[e.MenuAboutTextSpecialThanksTestorsAndDonators = 230] = "MenuAboutTextSpecialThanksTestorsAndDonators",
        e[e.MenuAboutSectionLibraries = 231] = "MenuAboutSectionLibraries",
        e[e.MenuAboutSectionLibrariesDescription = 232] = "MenuAboutSectionLibrariesDescription",
        e[e.MenuBindings = 233] = "MenuBindings",
        e[e.MenuBindingsDescription = 234] = "MenuBindingsDescription",
        e[e.MenuChangelogTitle = 235] = "MenuChangelogTitle",
        e[e.MenuChangelogDescription = 236] = "MenuChangelogDescription",
        e[e.MenuChangelogHeadingFailedLoad = 237] = "MenuChangelogHeadingFailedLoad",
        e[e.MenuChangelogHeadingChangeCount = 238] = "MenuChangelogHeadingChangeCount",
        e[e.MenuChangelogInterruptLoadingChangelog = 239] = "MenuChangelogInterruptLoadingChangelog",
        e[e.MenuChangelogInterruptLoadingChangelogDescription = 240] = "MenuChangelogInterruptLoadingChangelogDescription",
        e[e.MenuCharacterCreationButtonRandomizeName = 241] = "MenuCharacterCreationButtonRandomizeName",
        e[e.MenuCharacterCreationButtonExportTooltip = 242] = "MenuCharacterCreationButtonExportTooltip",
        e[e.MenuCharacterCreationButtonImportTooltip = 243] = "MenuCharacterCreationButtonImportTooltip",
        e[e.MenuCharacterCreationButtonStartGame = 244] = "MenuCharacterCreationButtonStartGame",
        e[e.MenuCharacterCreationButtonJoinGame = 245] = "MenuCharacterCreationButtonJoinGame",
        e[e.MenuCharacterCreationDescription = 246] = "MenuCharacterCreationDescription",
        e[e.MenuCharacterCreationHeadingHairColor = 247] = "MenuCharacterCreationHeadingHairColor",
        e[e.MenuCharacterCreationHeadingHairStyle = 248] = "MenuCharacterCreationHeadingHairStyle",
        e[e.MenuCharacterCreationHeadingSkinTone = 249] = "MenuCharacterCreationHeadingSkinTone",
        e[e.MenuCharacterCreationLabelName = 250] = "MenuCharacterCreationLabelName",
        e[e.MenuCharacterCreationTitle = 251] = "MenuCharacterCreationTitle",
        e[e.MenuCharacterCreationInterruptImportCharacterFailure = 252] = "MenuCharacterCreationInterruptImportCharacterFailure",
        e[e.MenuCharacterCreationInterruptImportCharacterFailureDescription = 253] = "MenuCharacterCreationInterruptImportCharacterFailureDescription",
        e[e.MenuCharacterCreationButtonRotateLeftTooltip = 254] = "MenuCharacterCreationButtonRotateLeftTooltip",
        e[e.MenuCharacterCreationButtonRotateRightTooltip = 255] = "MenuCharacterCreationButtonRotateRightTooltip",
        e[e.MenuCharacterCreationButtonRandomizeTooltip = 256] = "MenuCharacterCreationButtonRandomizeTooltip",
        e[e.MenuCharacterSelectionButtonNewCharacter = 257] = "MenuCharacterSelectionButtonNewCharacter",
        e[e.MenuCharacterSelectionDescription = 258] = "MenuCharacterSelectionDescription",
        e[e.MenuCharacterSelectionHeadingNoCharacters = 259] = "MenuCharacterSelectionHeadingNoCharacters",
        e[e.MenuCharacterSelectionTitle = 260] = "MenuCharacterSelectionTitle",
        e[e.MenuCharacterSelectionLabelLastUse = 261] = "MenuCharacterSelectionLabelLastUse",
        e[e.MenuCharacterSelectionLabelUseCount = 262] = "MenuCharacterSelectionLabelUseCount",
        e[e.MenuCharacterSelectionCharacterButtonDeleteTooltip = 263] = "MenuCharacterSelectionCharacterButtonDeleteTooltip",
        e[e.MenuCharacterSelectionCharacterButtonCustomizeTooltip = 264] = "MenuCharacterSelectionCharacterButtonCustomizeTooltip",
        e[e.MenuCharacterSelectionInterruptDeleteCharacter = 265] = "MenuCharacterSelectionInterruptDeleteCharacter",
        e[e.MenuMultiplayerDescription = 266] = "MenuMultiplayerDescription",
        e[e.MenuMultiplayerTitle = 267] = "MenuMultiplayerTitle",
        e[e.MenuMultiplayerButtonJoinById = 268] = "MenuMultiplayerButtonJoinById",
        e[e.MenuMultiplayerServerLabelReputation = 269] = "MenuMultiplayerServerLabelReputation",
        e[e.MenuMultiplayerServerLabelDays = 270] = "MenuMultiplayerServerLabelDays",
        e[e.MenuMultiplayerButtonNewGame = 271] = "MenuMultiplayerButtonNewGame",
        e[e.MenuMultiplayerButtonLoadGame = 272] = "MenuMultiplayerButtonLoadGame",
        e[e.MenuMultiplayerServerTooltipPVP = 273] = "MenuMultiplayerServerTooltipPVP",
        e[e.MenuMultiplayerServerTooltipModsLabel = 274] = "MenuMultiplayerServerTooltipModsLabel",
        e[e.MenuMultiplayerServerTooltipFriendsLabel = 275] = "MenuMultiplayerServerTooltipFriendsLabel",
        e[e.MenuMultiplayerServerPlayers = 276] = "MenuMultiplayerServerPlayers",
        e[e.MenuMultiplayerServerRegion = 277] = "MenuMultiplayerServerRegion",
        e[e.MenuMultiplayerServerHost = 278] = "MenuMultiplayerServerHost",
        e[e.MenuMultiplayerServerDedicated = 279] = "MenuMultiplayerServerDedicated",
        e[e.MenuMultiplayerHeadingPlayersOnline = 280] = "MenuMultiplayerHeadingPlayersOnline",
        e[e.MenuGameEndTitleDead = 281] = "MenuGameEndTitleDead",
        e[e.MenuGameEndTitleWon = 282] = "MenuGameEndTitleWon",
        e[e.MenuGameEndShareFacebook = 283] = "MenuGameEndShareFacebook",
        e[e.MenuGameEndShareTwitter = 284] = "MenuGameEndShareTwitter",
        e[e.MenuGameEndContinueAsGhost = 285] = "MenuGameEndContinueAsGhost",
        e[e.MenuGameEndReturnToIsland = 286] = "MenuGameEndReturnToIsland",
        e[e.MenuGameEndExitToMenu = 287] = "MenuGameEndExitToMenu",
        e[e.MenuGameEndInterruptGhostDeleteSave = 288] = "MenuGameEndInterruptGhostDeleteSave",
        e[e.MenuGameEndInterruptWonDeleteSave = 289] = "MenuGameEndInterruptWonDeleteSave",
        e[e.MenuGameEndInterruptDeleteSaveDescription = 290] = "MenuGameEndInterruptDeleteSaveDescription",
        e[e.MenuGameEndInterruptReturnToTitleScreen = 291] = "MenuGameEndInterruptReturnToTitleScreen",
        e[e.MenuGameEndInterruptReturnToTitleScreenChallengeMultiplayerDescription = 292] = "MenuGameEndInterruptReturnToTitleScreenChallengeMultiplayerDescription",
        e[e.MenuGameEndInterruptReturnToTitleScreenChallengeDescription = 293] = "MenuGameEndInterruptReturnToTitleScreenChallengeDescription",
        e[e.MenuGameEndInterruptReturnToTitleScreenMultiplayerDescription = 294] = "MenuGameEndInterruptReturnToTitleScreenMultiplayerDescription",
        e[e.MenuHelpTitle = 295] = "MenuHelpTitle",
        e[e.MenuHelpDescription = 296] = "MenuHelpDescription",
        e[e.MenuHelpLabelSearch = 297] = "MenuHelpLabelSearch",
        e[e.MenuHighscoresTitle = 298] = "MenuHighscoresTitle",
        e[e.MenuHighscoresDescription = 299] = "MenuHighscoresDescription",
        e[e.MenuHighscoresDifficultyFilterAll = 300] = "MenuHighscoresDifficultyFilterAll",
        e[e.MenuHighscoresHighscoreLabelDifficulty = 301] = "MenuHighscoresHighscoreLabelDifficulty",
        e[e.MenuHighscoresHighscoreLabelTurns = 302] = "MenuHighscoresHighscoreLabelTurns",
        e[e.MenuHighscoresHighscoreLabelScore = 303] = "MenuHighscoresHighscoreLabelScore",
        e[e.MenuHighscoresHighscoreLabelPlace = 304] = "MenuHighscoresHighscoreLabelPlace",
        e[e.MenuHighscoresHighscoreLabelDate = 305] = "MenuHighscoresHighscoreLabelDate",
        e[e.MenuHighscoresHighscoreLabelDeathBy = 306] = "MenuHighscoresHighscoreLabelDeathBy",
        e[e.MenuHighscoresHighscoreTitle = 307] = "MenuHighscoresHighscoreTitle",
        e[e.MenuHighscoresCharacterNameUnknown = 308] = "MenuHighscoresCharacterNameUnknown",
        e[e.MenuLoadGameButtonNewGame = 309] = "MenuLoadGameButtonNewGame",
        e[e.MenuLoadGameButtonNewGameButtonImportTooltip = 310] = "MenuLoadGameButtonNewGameButtonImportTooltip",
        e[e.MenuLoadGameDescription = 311] = "MenuLoadGameDescription",
        e[e.MenuLoadGameSaveButtonDeleteTooltip = 312] = "MenuLoadGameSaveButtonDeleteTooltip",
        e[e.MenuLoadGameSaveButtonEditNameTooltip = 313] = "MenuLoadGameSaveButtonEditNameTooltip",
        e[e.MenuLoadGameSaveButtonExportTooltip = 314] = "MenuLoadGameSaveButtonExportTooltip",
        e[e.MenuLoadGameSaveTooltipLabelCreatedTime = 315] = "MenuLoadGameSaveTooltipLabelCreatedTime",
        e[e.MenuLoadGameSaveTooltipLabelSaveTime = 316] = "MenuLoadGameSaveTooltipLabelSaveTime",
        e[e.MenuLoadGameSaveTooltipLabelDifficulty = 317] = "MenuLoadGameSaveTooltipLabelDifficulty",
        e[e.MenuLoadGameSaveTooltipLabelScore = 318] = "MenuLoadGameSaveTooltipLabelScore",
        e[e.MenuLoadGameSaveTooltipLabelSeed = 319] = "MenuLoadGameSaveTooltipLabelSeed",
        e[e.MenuLoadGameSaveTooltipLabelTurns = 320] = "MenuLoadGameSaveTooltipLabelTurns",
        e[e.MenuLoadGameSaveTooltipLabelMods = 321] = "MenuLoadGameSaveTooltipLabelMods",
        e[e.MenuLoadGameSaveTooltipLabelOriginalVersion = 322] = "MenuLoadGameSaveTooltipLabelOriginalVersion",
        e[e.MenuLoadGameSaveTooltipMod = 323] = "MenuLoadGameSaveTooltipMod",
        e[e.MenuLoadGameSlotsRemaining = 324] = "MenuLoadGameSlotsRemaining",
        e[e.MenuLoadGameTitle = 325] = "MenuLoadGameTitle",
        e[e.MenuLoadGameInterruptDeleteSave = 326] = "MenuLoadGameInterruptDeleteSave",
        e[e.MenuLoadGameInterruptDeleteSaveDescription = 327] = "MenuLoadGameInterruptDeleteSaveDescription",
        e[e.MenuLoadGameInterruptLoadingExportingSave = 328] = "MenuLoadGameInterruptLoadingExportingSave",
        e[e.MenuLoadGameInterruptLoadingExportingSaveDescription = 329] = "MenuLoadGameInterruptLoadingExportingSaveDescription",
        e[e.MenuLoadGameInterruptLoadingImportingSave = 330] = "MenuLoadGameInterruptLoadingImportingSave",
        e[e.MenuLoadGameInterruptLoadingImportingSaveDescription = 331] = "MenuLoadGameInterruptLoadingImportingSaveDescription",
        e[e.MenuLoadGameInterruptImportSaveFailure = 332] = "MenuLoadGameInterruptImportSaveFailure",
        e[e.MenuLoadGameInterruptImportSaveFailureDescription = 333] = "MenuLoadGameInterruptImportSaveFailureDescription",
        e[e.MenuLoadGameInterruptExportType = 334] = "MenuLoadGameInterruptExportType",
        e[e.MenuLoadGameInterruptExportTypeDescription = 335] = "MenuLoadGameInterruptExportTypeDescription",
        e[e.MenuLoadGameInterruptPublishingSave = 336] = "MenuLoadGameInterruptPublishingSave",
        e[e.MenuLoadGameInterruptPublishingSaveDescription = 337] = "MenuLoadGameInterruptPublishingSaveDescription",
        e[e.MenuLoadGameInterruptMissingMod = 338] = "MenuLoadGameInterruptMissingMod",
        e[e.MenuLoadGameInterruptMissingModDescription = 339] = "MenuLoadGameInterruptMissingModDescription",
        e[e.MenuLoadGameInterruptMissingModDescriptionLabelModsMissing = 340] = "MenuLoadGameInterruptMissingModDescriptionLabelModsMissing",
        e[e.MenuLoadGameInterruptMissingModDescriptionLabelModsDisabled = 341] = "MenuLoadGameInterruptMissingModDescriptionLabelModsDisabled",
        e[e.MenuLoadGameInterruptLoading = 342] = "MenuLoadGameInterruptLoading",
        e[e.MenuLoadGameInterruptLoadingDescription = 343] = "MenuLoadGameInterruptLoadingDescription",
        e[e.MenuMainButtonAbout = 344] = "MenuMainButtonAbout",
        e[e.MenuMainButtonChangelog = 345] = "MenuMainButtonChangelog",
        e[e.MenuMainButtonContinueGame = 346] = "MenuMainButtonContinueGame",
        e[e.MenuMainButtonMultiplayer = 347] = "MenuMainButtonMultiplayer",
        e[e.MenuMainButtonHighscores = 348] = "MenuMainButtonHighscores",
        e[e.MenuMainButtonLoadGame = 349] = "MenuMainButtonLoadGame",
        e[e.MenuMainButtonMods = 350] = "MenuMainButtonMods",
        e[e.MenuMainButtonNewGame = 351] = "MenuMainButtonNewGame",
        e[e.MenuMainButtonNews = 352] = "MenuMainButtonNews",
        e[e.MenuMainButtonOptions = 353] = "MenuMainButtonOptions",
        e[e.MenuMainButtonQuitGame = 354] = "MenuMainButtonQuitGame",
        e[e.MenuMainInterruptLoadingNews = 355] = "MenuMainInterruptLoadingNews",
        e[e.MenuMainInterruptLoadingNewsDescription = 356] = "MenuMainInterruptLoadingNewsDescription",
        e[e.MenuMainInterruptLoadingChangelog = 357] = "MenuMainInterruptLoadingChangelog",
        e[e.MenuMainInterruptLoadingChangelogDescription = 358] = "MenuMainInterruptLoadingChangelogDescription",
        e[e.MenuMainInterruptWelcomeToVersion = 359] = "MenuMainInterruptWelcomeToVersion",
        e[e.MenuMainInterruptWelcomeToVersionDescription = 360] = "MenuMainInterruptWelcomeToVersionDescription",
        e[e.MenuMainInterruptOldVersionWarning = 361] = "MenuMainInterruptOldVersionWarning",
        e[e.MenuMainInterruptOldVersionWarningDescription = 362] = "MenuMainInterruptOldVersionWarningDescription",
        e[e.MenuModsButtonDisableAll = 363] = "MenuModsButtonDisableAll",
        e[e.MenuModsButtonEnableAll = 364] = "MenuModsButtonEnableAll",
        e[e.MenuModsButtonModdingGuide = 365] = "MenuModsButtonModdingGuide",
        e[e.MenuModsButtonOpenFolder = 366] = "MenuModsButtonOpenFolder",
        e[e.MenuModsButtonOpenWorkshop = 367] = "MenuModsButtonOpenWorkshop",
        e[e.MenuModsDescription = 368] = "MenuModsDescription",
        e[e.MenuModsInterruptConfirmPublish = 369] = "MenuModsInterruptConfirmPublish",
        e[e.MenuModsInterruptConfirmPublishUpdate = 370] = "MenuModsInterruptConfirmPublishUpdate",
        e[e.MenuModsInterruptModEnableMultipleLanguages = 371] = "MenuModsInterruptModEnableMultipleLanguages",
        e[e.MenuModsInterruptModEnableMultipleLanguagesDescription = 372] = "MenuModsInterruptModEnableMultipleLanguagesDescription",
        e[e.MenuModsInterruptModEnableUseLanguage = 373] = "MenuModsInterruptModEnableUseLanguage",
        e[e.MenuModsInterruptModEnableUseLanguageDescription = 374] = "MenuModsInterruptModEnableUseLanguageDescription",
        e[e.MenuModsInterruptPublishedReminderRequiredModsOnWorkshop = 375] = "MenuModsInterruptPublishedReminderRequiredModsOnWorkshop",
        e[e.MenuModsInterruptPublishedReminderRequiredModsOnWorkshopDescription = 376] = "MenuModsInterruptPublishedReminderRequiredModsOnWorkshopDescription",
        e[e.MenuModsInterruptConfirmPublishDescription = 377] = "MenuModsInterruptConfirmPublishDescription",
        e[e.MenuModsInterruptConfirmPublishUpdateDescription = 378] = "MenuModsInterruptConfirmPublishUpdateDescription",
        e[e.MenuModsInterruptPublishingMod = 379] = "MenuModsInterruptPublishingMod",
        e[e.MenuModsInterruptPublishingModDescription = 380] = "MenuModsInterruptPublishingModDescription",
        e[e.MenuModsInterruptPublishError = 381] = "MenuModsInterruptPublishError",
        e[e.MenuModsInterruptPublishErrorDescription = 382] = "MenuModsInterruptPublishErrorDescription",
        e[e.MenuModsInterruptUpdatingMod = 383] = "MenuModsInterruptUpdatingMod",
        e[e.MenuModsInterruptUpdatingModDescription = 384] = "MenuModsInterruptUpdatingModDescription",
        e[e.MenuModsInterruptPublishUpdateError = 385] = "MenuModsInterruptPublishUpdateError",
        e[e.MenuModsInterruptPublishUpdateErrorDescription = 386] = "MenuModsInterruptPublishUpdateErrorDescription",
        e[e.MenuModsInterruptInfoMissingDependencies = 387] = "MenuModsInterruptInfoMissingDependencies",
        e[e.MenuModsInterruptInfoMissingDependenciesDescription = 388] = "MenuModsInterruptInfoMissingDependenciesDescription",
        e[e.MenuModsInterruptConfirmEnableDisabledDependencies = 389] = "MenuModsInterruptConfirmEnableDisabledDependencies",
        e[e.MenuModsInterruptConfirmEnableDisabledDependenciesDescription = 390] = "MenuModsInterruptConfirmEnableDisabledDependenciesDescription",
        e[e.MenuModsInterruptConfirmDisableDependents = 391] = "MenuModsInterruptConfirmDisableDependents",
        e[e.MenuModsInterruptConfirmDisableDependentsDescription = 392] = "MenuModsInterruptConfirmDisableDependentsDescription",
        e[e.MenuModsInterruptConfirmUninstallMod = 393] = "MenuModsInterruptConfirmUninstallMod",
        e[e.MenuModsInterruptConfirmUninstallModDescription = 394] = "MenuModsInterruptConfirmUninstallModDescription",
        e[e.MenuModsInterruptUnloadableSaveGameMod = 395] = "MenuModsInterruptUnloadableSaveGameMod",
        e[e.MenuModsInterruptUnloadableSaveGameModDescription = 396] = "MenuModsInterruptUnloadableSaveGameModDescription",
        e[e.MenuModsTitle = 397] = "MenuModsTitle",
        e[e.MenuModsTooltipLabelAuthor = 398] = "MenuModsTooltipLabelAuthor",
        e[e.MenuModsTooltipLabelTags = 399] = "MenuModsTooltipLabelTags",
        e[e.MenuModsTooltipLabelDependencies = 400] = "MenuModsTooltipLabelDependencies",
        e[e.MenuModsTooltipLabelProvides = 401] = "MenuModsTooltipLabelProvides",
        e[e.MenuModsTooltipLabelVersion = 402] = "MenuModsTooltipLabelVersion",
        e[e.MenuModsTooltipLabelDescription = 403] = "MenuModsTooltipLabelDescription",
        e[e.MenuModsTooltipLabelInstallDate = 404] = "MenuModsTooltipLabelInstallDate",
        e[e.MenuModsTooltipLabelCreatedDate = 405] = "MenuModsTooltipLabelCreatedDate",
        e[e.MenuModsTooltipLabelLastUpdatedDate = 406] = "MenuModsTooltipLabelLastUpdatedDate",
        e[e.MenuModsTooltipMultiplayerCompatibility = 407] = "MenuModsTooltipMultiplayerCompatibility",
        e[e.MenuModsTooltipModOptions = 408] = "MenuModsTooltipModOptions",
        e[e.MenuModsTooltipProvidesCustomizations = 409] = "MenuModsTooltipProvidesCustomizations",
        e[e.MenuModsTooltipProvidesImageOverrides = 410] = "MenuModsTooltipProvidesImageOverrides",
        e[e.MenuModsTooltipProvidesLanguage = 411] = "MenuModsTooltipProvidesLanguage",
        e[e.MenuModsTooltipProvidesLanguageExtensions = 412] = "MenuModsTooltipProvidesLanguageExtensions",
        e[e.MenuModsTooltipProvidesScript = 413] = "MenuModsTooltipProvidesScript",
        e[e.MenuModsTooltipProvidesStylesheet = 414] = "MenuModsTooltipProvidesStylesheet",
        e[e.MenuModsTooltipPublishMod = 415] = "MenuModsTooltipPublishMod",
        e[e.MenuModsTooltipUninstallMod = 416] = "MenuModsTooltipUninstallMod",
        e[e.MenuModsTooltipViewInSteamWorkshop = 417] = "MenuModsTooltipViewInSteamWorkshop",
        e[e.MenuModsButtonEditInternalMods = 418] = "MenuModsButtonEditInternalMods",
        e[e.MenuModsSectionHeading = 419] = "MenuModsSectionHeading",
        e[e.MenuModsSubmenuEditInternalModsTitle = 420] = "MenuModsSubmenuEditInternalModsTitle",
        e[e.MenuModsSubmenuEditInternalModsDescription = 421] = "MenuModsSubmenuEditInternalModsDescription",
        e[e.MenuModsSubmenuEditInternalModsInterruptModsListChangeReload = 422] = "MenuModsSubmenuEditInternalModsInterruptModsListChangeReload",
        e[e.MenuModsSubmenuEditInternalModsInterruptModsListChangeReloadDescription = 423] = "MenuModsSubmenuEditInternalModsInterruptModsListChangeReloadDescription",
        e[e.MenuModsSubmenuEditInternalModsPlaceholderAddNewInternalMod = 424] = "MenuModsSubmenuEditInternalModsPlaceholderAddNewInternalMod",
        e[e.MenuNewGameButtonNext = 425] = "MenuNewGameButtonNext",
        e[e.MenuNewGameButtonStartServer = 426] = "MenuNewGameButtonStartServer",
        e[e.MenuNewGameDescription = 427] = "MenuNewGameDescription",
        e[e.MenuNewGameLabelEditName = 428] = "MenuNewGameLabelEditName",
        e[e.MenuNewGameLabelEditSeed = 429] = "MenuNewGameLabelEditSeed",
        e[e.MenuNewGamePlaceholderEditSeed = 430] = "MenuNewGamePlaceholderEditSeed",
        e[e.MenuNewGameTitle = 431] = "MenuNewGameTitle",
        e[e.MenuNewGameChoiceDifficulty = 432] = "MenuNewGameChoiceDifficulty",
        e[e.MenuNewGameChoiceSingleplayer = 433] = "MenuNewGameChoiceSingleplayer",
        e[e.MenuNewGameChoiceSingleplayerDescription = 434] = "MenuNewGameChoiceSingleplayerDescription",
        e[e.MenuNewGameChoiceMultiplayer = 435] = "MenuNewGameChoiceMultiplayer",
        e[e.MenuNewGameChoiceMultiplayerDescription = 436] = "MenuNewGameChoiceMultiplayerDescription",
        e[e.MenuNewGameChoiceTurnModeManual = 437] = "MenuNewGameChoiceTurnModeManual",
        e[e.MenuNewGameChoiceTurnModeManualDescription = 438] = "MenuNewGameChoiceTurnModeManualDescription",
        e[e.MenuNewGameChoiceTurnModeRealTime = 439] = "MenuNewGameChoiceTurnModeRealTime",
        e[e.MenuNewGameChoiceTurnModeRealTimeDescription = 440] = "MenuNewGameChoiceTurnModeRealTimeDescription",
        e[e.MenuNewGameChoiceTurnModeSimulated = 441] = "MenuNewGameChoiceTurnModeSimulated",
        e[e.MenuNewGameChoiceTurnModeSimulatedDescription = 442] = "MenuNewGameChoiceTurnModeSimulatedDescription",
        e[e.MenuNewGameChoiceDifficultyTooltipMaxSaves = 443] = "MenuNewGameChoiceDifficultyTooltipMaxSaves",
        e[e.MenuNewGameChoiceDifficultyTooltipCustomGameOptions = 444] = "MenuNewGameChoiceDifficultyTooltipCustomGameOptions",
        e[e.MenuNewGameChoiceDifficultyChallengeDaily = 445] = "MenuNewGameChoiceDifficultyChallengeDaily",
        e[e.MenuNewGameChoiceDifficultyChallengeDailyTooltip = 446] = "MenuNewGameChoiceDifficultyChallengeDailyTooltip",
        e[e.MenuCustomGameOptionsTitle = 447] = "MenuCustomGameOptionsTitle",
        e[e.MenuCustomGameOptionsDescription = 448] = "MenuCustomGameOptionsDescription",
        e[e.MenuCustomGameOptionsPeaceful = 449] = "MenuCustomGameOptionsPeaceful",
        e[e.MenuCustomGameOptionsPeacefulDescription = 450] = "MenuCustomGameOptionsPeacefulDescription",
        e[e.MenuCustomGameOptionsRespawnOnDeath = 451] = "MenuCustomGameOptionsRespawnOnDeath",
        e[e.MenuCustomGameOptionsRespawnOnDeathDescription = 452] = "MenuCustomGameOptionsRespawnOnDeathDescription",
        e[e.MenuCustomGameOptionsBenignityInitial = 453] = "MenuCustomGameOptionsBenignityInitial",
        e[e.MenuCustomGameOptionsBenignityMultiplier = 454] = "MenuCustomGameOptionsBenignityMultiplier",
        e[e.MenuCustomGameOptionsBenignityMultiplierTooltip = 455] = "MenuCustomGameOptionsBenignityMultiplierTooltip",
        e[e.MenuCustomGameOptionsMalignityInitial = 456] = "MenuCustomGameOptionsMalignityInitial",
        e[e.MenuCustomGameOptionsMalignityMultiplier = 457] = "MenuCustomGameOptionsMalignityMultiplier",
        e[e.MenuCustomGameOptionsMalignityMultiplierTooltip = 458] = "MenuCustomGameOptionsMalignityMultiplierTooltip",
        e[e.MenuCustomGameOptionsStatMultiplier = 459] = "MenuCustomGameOptionsStatMultiplier",
        e[e.MenuCustomGameOptionsStatMultiplierTooltip = 460] = "MenuCustomGameOptionsStatMultiplierTooltip",
        e[e.MenuCustomGameOptionsStatRegenerationMultiplierTooltip = 461] = "MenuCustomGameOptionsStatRegenerationMultiplierTooltip",
        e[e.MenuCustomGameOptionsHeadingGeneral = 462] = "MenuCustomGameOptionsHeadingGeneral",
        e[e.MenuCustomGameOptionsHeadingTime = 463] = "MenuCustomGameOptionsHeadingTime",
        e[e.MenuCustomGameOptionsHeadingStats = 464] = "MenuCustomGameOptionsHeadingStats",
        e[e.MenuCustomGameOptionsHeadingReputation = 465] = "MenuCustomGameOptionsHeadingReputation",
        e[e.MenuCustomGameOptionsHeadingInventory = 466] = "MenuCustomGameOptionsHeadingInventory",
        e[e.MenuCustomGameOptionsHeadingSkills = 467] = "MenuCustomGameOptionsHeadingSkills",
        e[e.MenuCustomGameOptionsHeadingStatusEffects = 468] = "MenuCustomGameOptionsHeadingStatusEffects",
        e[e.MenuCustomGameOptionsEternalNight = 469] = "MenuCustomGameOptionsEternalNight",
        e[e.MenuCustomGameOptionsTimeFrozen = 470] = "MenuCustomGameOptionsTimeFrozen",
        e[e.MenuCustomGameOptionsTimeInitial = 471] = "MenuCustomGameOptionsTimeInitial",
        e[e.MenuCustomGameOptionsTimeDayLength = 472] = "MenuCustomGameOptionsTimeDayLength",
        e[e.MenuCustomGameOptionsTimeDayLengthTooltip = 473] = "MenuCustomGameOptionsTimeDayLengthTooltip",
        e[e.MenuCustomGameOptionsTimeDayPercent = 474] = "MenuCustomGameOptionsTimeDayPercent",
        e[e.MenuCustomGameOptionsTimeDayPercentTooltip = 475] = "MenuCustomGameOptionsTimeDayPercentTooltip",
        e[e.MenuCustomGameOptionsEternalNightDescription = 476] = "MenuCustomGameOptionsEternalNightDescription",
        e[e.MenuCustomGameOptionsStatStarting = 477] = "MenuCustomGameOptionsStatStarting",
        e[e.MenuCustomGameOptionsStatMax = 478] = "MenuCustomGameOptionsStatMax",
        e[e.MenuCustomGameOptionsStatStartingDisplay = 479] = "MenuCustomGameOptionsStatStartingDisplay",
        e[e.MenuCustomGameOptionsStatMaxDisplay = 480] = "MenuCustomGameOptionsStatMaxDisplay",
        e[e.MenuCustomGameOptionsStatNoChange = 481] = "MenuCustomGameOptionsStatNoChange",
        e[e.MenuCustomGameOptionsStatStrengthTooltip = 482] = "MenuCustomGameOptionsStatStrengthTooltip",
        e[e.MenuCustomGameOptionsStatusEffectPassChanceMultiplier = 483] = "MenuCustomGameOptionsStatusEffectPassChanceMultiplier",
        e[e.MenuCustomGameOptionsStatusEffectPassChanceMultiplierTooltip = 484] = "MenuCustomGameOptionsStatusEffectPassChanceMultiplierTooltip",
        e[e.MenuCustomGameOptionsStatusEffectStartWith = 485] = "MenuCustomGameOptionsStatusEffectStartWith",
        e[e.MenuCustomGameOptionsStatusEffectUntreatable = 486] = "MenuCustomGameOptionsStatusEffectUntreatable",
        e[e.MenuCustomGameOptionsStatusEffectUntreatableTooltip = 487] = "MenuCustomGameOptionsStatusEffectUntreatableTooltip",
        e[e.MenuCustomGameOptionsSkillsGenerateRandom = 488] = "MenuCustomGameOptionsSkillsGenerateRandom",
        e[e.MenuCustomGameOptionsSkillsGenerateRandomDescription = 489] = "MenuCustomGameOptionsSkillsGenerateRandomDescription",
        e[e.MenuCustomGameOptionsSkillNone = 490] = "MenuCustomGameOptionsSkillNone",
        e[e.MenuCustomGameOptionsSkillConfigure = 491] = "MenuCustomGameOptionsSkillConfigure",
        e[e.MenuCustomGameOptionsSkillInitial = 492] = "MenuCustomGameOptionsSkillInitial",
        e[e.MenuCustomGameOptionsSkillMultiplier = 493] = "MenuCustomGameOptionsSkillMultiplier",
        e[e.MenuCustomGameOptionsSkillMultiplierTooltip = 494] = "MenuCustomGameOptionsSkillMultiplierTooltip",
        e[e.MenuCustomGameOptionsRandomItems = 495] = "MenuCustomGameOptionsRandomItems",
        e[e.MenuCustomGameOptionsRandomItemsDescription = 496] = "MenuCustomGameOptionsRandomItemsDescription",
        e[e.MenuNewsButtonDiscord = 497] = "MenuNewsButtonDiscord",
        e[e.MenuNewsButtonFacebook = 498] = "MenuNewsButtonFacebook",
        e[e.MenuNewsButtonReddit = 499] = "MenuNewsButtonReddit",
        e[e.MenuNewsButtonTwitter = 500] = "MenuNewsButtonTwitter",
        e[e.MenuNewsDescription = 501] = "MenuNewsDescription",
        e[e.MenuNewsHeadingSocial = 502] = "MenuNewsHeadingSocial",
        e[e.MenuNewsTitle = 503] = "MenuNewsTitle",
        e[e.MenuNewsHeadingUnableToLoad = 504] = "MenuNewsHeadingUnableToLoad",
        e[e.MenuNewsButtonAllNews = 505] = "MenuNewsButtonAllNews",
        e[e.MenuOptionsInterruptLoading = 506] = "MenuOptionsInterruptLoading",
        e[e.MenuOptionsInterruptLoadingDescription = 507] = "MenuOptionsInterruptLoadingDescription",
        e[e.MenuOptionsButtonDitherFogOfWar = 508] = "MenuOptionsButtonDitherFogOfWar",
        e[e.MenuOptionsButtonDisableCustomCursor = 509] = "MenuOptionsButtonDisableCustomCursor",
        e[e.MenuOptionsButtonFullscreen = 510] = "MenuOptionsButtonFullscreen",
        e[e.MenuOptionsButtonDeveloperMode = 511] = "MenuOptionsButtonDeveloperMode",
        e[e.MenuOptionsButtonDeveloperModeContextMenu = 512] = "MenuOptionsButtonDeveloperModeContextMenu",
        e[e.MenuOptionsButtonPixelFont = 513] = "MenuOptionsButtonPixelFont",
        e[e.MenuOptionsButtonReloadGame = 514] = "MenuOptionsButtonReloadGame",
        e[e.MenuOptionsButtonExportGlobalSaveData = 515] = "MenuOptionsButtonExportGlobalSaveData",
        e[e.MenuOptionsButtonImportGlobalSaveData = 516] = "MenuOptionsButtonImportGlobalSaveData",
        e[e.MenuOptionsButtonSaveDataClearAll = 517] = "MenuOptionsButtonSaveDataClearAll",
        e[e.MenuOptionsButtonSaveDataClearCharacters = 518] = "MenuOptionsButtonSaveDataClearCharacters",
        e[e.MenuOptionsButtonSaveDataClearHighscores = 519] = "MenuOptionsButtonSaveDataClearHighscores",
        e[e.MenuOptionsButtonSaveDataClearMilestones = 520] = "MenuOptionsButtonSaveDataClearMilestones",
        e[e.MenuOptionsButtonSaveDataClearOptions = 521] = "MenuOptionsButtonSaveDataClearOptions",
        e[e.MenuOptionsButtonSaveDataClearCraftingRecipes = 522] = "MenuOptionsButtonSaveDataClearCraftingRecipes",
        e[e.MenuOptionsButtonSaveDataClearSaves = 523] = "MenuOptionsButtonSaveDataClearSaves",
        e[e.MenuOptionsButtonSkipSplash = 524] = "MenuOptionsButtonSkipSplash",
        e[e.MenuOptionsButtonToggleDevTools = 525] = "MenuOptionsButtonToggleDevTools",
        e[e.MenuOptionsButtonTooltipsCreatures = 526] = "MenuOptionsButtonTooltipsCreatures",
        e[e.MenuOptionsButtonOpenLogsFolder = 527] = "MenuOptionsButtonOpenLogsFolder",
        e[e.MenuOptionsButtonTooltipsDoodads = 528] = "MenuOptionsButtonTooltipsDoodads",
        e[e.MenuOptionsButtonTooltipsItems = 529] = "MenuOptionsButtonTooltipsItems",
        e[e.MenuOptionsButtonTooltipsTerrain = 530] = "MenuOptionsButtonTooltipsTerrain",
        e[e.MenuOptionsButtonDropLocationFacing = 531] = "MenuOptionsButtonDropLocationFacing",
        e[e.MenuOptionsButtonDropLocationFeet = 532] = "MenuOptionsButtonDropLocationFeet",
        e[e.MenuOptionsButtonDropLocationFeetWhenFacingBlocked = 533] = "MenuOptionsButtonDropLocationFeetWhenFacingBlocked",
        e[e.MenuOptionsDescription = 534] = "MenuOptionsDescription",
        e[e.MenuOptionsHeadingAudio = 535] = "MenuOptionsHeadingAudio",
        e[e.MenuOptionsHeadingDeveloper = 536] = "MenuOptionsHeadingDeveloper",
        e[e.MenuOptionsHeadingGameplayOptions = 537] = "MenuOptionsHeadingGameplayOptions",
        e[e.MenuOptionsHeadingGeneralOptions = 538] = "MenuOptionsHeadingGeneralOptions",
        e[e.MenuOptionsHeadingControls = 539] = "MenuOptionsHeadingControls",
        e[e.MenuOptionsHeadingLanguage = 540] = "MenuOptionsHeadingLanguage",
        e[e.MenuOptionsHeadingPowerPreference = 541] = "MenuOptionsHeadingPowerPreference",
        e[e.MenuOptionsHeadingModOptions = 542] = "MenuOptionsHeadingModOptions",
        e[e.MenuOptionsHeadingOther = 543] = "MenuOptionsHeadingOther",
        e[e.MenuOptionsHeadingSaveData = 544] = "MenuOptionsHeadingSaveData",
        e[e.MenuOptionsHeadingTooltips = 545] = "MenuOptionsHeadingTooltips",
        e[e.MenuOptionsHeadingVideo = 546] = "MenuOptionsHeadingVideo",
        e[e.MenuOptionsInterruptReloadGame = 547] = "MenuOptionsInterruptReloadGame",
        e[e.MenuOptionsInterruptSaveDataClearAll = 548] = "MenuOptionsInterruptSaveDataClearAll",
        e[e.MenuOptionsInterruptSaveDataClearAllDescription = 549] = "MenuOptionsInterruptSaveDataClearAllDescription",
        e[e.MenuOptionsInterruptSaveDataClearCharacters = 550] = "MenuOptionsInterruptSaveDataClearCharacters",
        e[e.MenuOptionsInterruptSaveDataClearHighscores = 551] = "MenuOptionsInterruptSaveDataClearHighscores",
        e[e.MenuOptionsInterruptSaveDataClearMilestones = 552] = "MenuOptionsInterruptSaveDataClearMilestones",
        e[e.MenuOptionsInterruptSaveDataClearOptions = 553] = "MenuOptionsInterruptSaveDataClearOptions",
        e[e.MenuOptionsInterruptSaveDataClearSaves = 554] = "MenuOptionsInterruptSaveDataClearSaves",
        e[e.MenuOptionsInterruptSaveDataClearCraftingRecipes = 555] = "MenuOptionsInterruptSaveDataClearCraftingRecipes",
        e[e.MenuOptionsLabelInterfaceScale = 556] = "MenuOptionsLabelInterfaceScale",
        e[e.MenuOptionsLabelDirectionTurnDelay = 557] = "MenuOptionsLabelDirectionTurnDelay",
        e[e.MenuOptionsLabelMouseTurnDelay = 558] = "MenuOptionsLabelMouseTurnDelay",
        e[e.MenuOptionsTooltipTurnDelay = 559] = "MenuOptionsTooltipTurnDelay",
        e[e.MenuOptionsTooltipMouseTurnDelay = 560] = "MenuOptionsTooltipMouseTurnDelay",
        e[e.MenuOptionsTooltipUiScaleClamped = 561] = "MenuOptionsTooltipUiScaleClamped",
        e[e.MenuOptionsTooltipControlsFilter = 562] = "MenuOptionsTooltipControlsFilter",
        e[e.MenuOptionsLabelVolumeEffects = 563] = "MenuOptionsLabelVolumeEffects",
        e[e.MenuOptionsLabelVolumeMusic = 564] = "MenuOptionsLabelVolumeMusic",
        e[e.MenuOptionsTabAudio = 565] = "MenuOptionsTabAudio",
        e[e.MenuOptionsTabDeveloper = 566] = "MenuOptionsTabDeveloper",
        e[e.MenuOptionsTabGameplay = 567] = "MenuOptionsTabGameplay",
        e[e.MenuOptionsTabGeneral = 568] = "MenuOptionsTabGeneral",
        e[e.MenuOptionsTabControls = 569] = "MenuOptionsTabControls",
        e[e.MenuOptionsTabMods = 570] = "MenuOptionsTabMods",
        e[e.MenuOptionsTabSaveData = 571] = "MenuOptionsTabSaveData",
        e[e.MenuOptionsTabVideo = 572] = "MenuOptionsTabVideo",
        e[e.MenuOptionsTitle = 573] = "MenuOptionsTitle",
        e[e.MenuOptionsTooltipMusicNextTrack = 574] = "MenuOptionsTooltipMusicNextTrack",
        e[e.MenuOptionsBindChoose = 575] = "MenuOptionsBindChoose",
        e[e.MenuOptionsBindChooseAdd = 576] = "MenuOptionsBindChooseAdd",
        e[e.MenuOptionsBindLabelModifier = 577] = "MenuOptionsBindLabelModifier",
        e[e.MenuOptionsBindButtonResetTooltip = 578] = "MenuOptionsBindButtonResetTooltip",
        e[e.MenuOptionsBindButtonDeleteTooltip = 579] = "MenuOptionsBindButtonDeleteTooltip",
        e[e.MenuOptionsBindButtonAddTooltip = 580] = "MenuOptionsBindButtonAddTooltip",
        e[e.MenuOptionsButtonAlternatingDirectionMovement = 581] = "MenuOptionsButtonAlternatingDirectionMovement",
        e[e.MenuOptionsButtonAllowAlternatingDirectionMovementTooltip = 582] = "MenuOptionsButtonAllowAlternatingDirectionMovementTooltip",
        e[e.MenuOptionsButtonAlwaysShowMoreInformation = 583] = "MenuOptionsButtonAlwaysShowMoreInformation",
        e[e.MenuOptionsButtonAlwaysShowMoreInformationTooltip = 584] = "MenuOptionsButtonAlwaysShowMoreInformationTooltip",
        e[e.MenuOptionsButtonAutoGatherHarvest = 585] = "MenuOptionsButtonAutoGatherHarvest",
        e[e.MenuOptionsButtonAutoGatherHarvestTooltip = 586] = "MenuOptionsButtonAutoGatherHarvestTooltip",
        e[e.MenuOptionsButtonAutoPickup = 587] = "MenuOptionsButtonAutoPickup",
        e[e.MenuOptionsButtonAutoPickupTooltip = 588] = "MenuOptionsButtonAutoPickupTooltip",
        e[e.MenuOptionsButtonDropOnGatherHarvest = 589] = "MenuOptionsButtonDropOnGatherHarvest",
        e[e.MenuOptionsButtonDropOnGatherHarvestTooltip = 590] = "MenuOptionsButtonDropOnGatherHarvestTooltip",
        e[e.MenuOptionsButtonKeepSortActive = 591] = "MenuOptionsButtonKeepSortActive",
        e[e.MenuOptionsButtonKeepSortActiveTooltip = 592] = "MenuOptionsButtonKeepSortActiveTooltip",
        e[e.MenuOptionsButtonProtectCraftingItemsInInventory = 593] = "MenuOptionsButtonProtectCraftingItemsInInventory",
        e[e.MenuOptionsButtonProtectCraftingItemsInInventoryTooltip = 594] = "MenuOptionsButtonProtectCraftingItemsInInventoryTooltip",
        e[e.MenuOptionsButtonProtectCraftingItemContainers = 595] = "MenuOptionsButtonProtectCraftingItemContainers",
        e[e.MenuOptionsButtonProtectCraftingItemsContainersTooltip = 596] = "MenuOptionsButtonProtectCraftingItemsContainersTooltip",
        e[e.MenuOptionsButtonUseAdjacentContainers = 597] = "MenuOptionsButtonUseAdjacentContainers",
        e[e.MenuOptionsButtonUseAdjacentContainersTooltip = 598] = "MenuOptionsButtonUseAdjacentContainersTooltip",
        e[e.MenuOptionsButtonHideEquippedHeadgear = 599] = "MenuOptionsButtonHideEquippedHeadgear",
        e[e.MenuOptionsButtonHideEquippedHeadgearTooltip = 600] = "MenuOptionsButtonHideEquippedHeadgearTooltip",
        e[e.MenuOptionsButtonEnableAutoSave = 601] = "MenuOptionsButtonEnableAutoSave",
        e[e.MenuOptionsButtonEnableAutoSaveTooltip = 602] = "MenuOptionsButtonEnableAutoSaveTooltip",
        e[e.MenuOptionsButtonWarnOnDangerousActions = 603] = "MenuOptionsButtonWarnOnDangerousActions",
        e[e.MenuOptionsButtonWarnOnDangerousActionsTooltip = 604] = "MenuOptionsButtonWarnOnDangerousActionsTooltip",
        e[e.MenuOptionsButtonWarnWhenBreakingItemsOnCraft = 605] = "MenuOptionsButtonWarnWhenBreakingItemsOnCraft",
        e[e.MenuOptionsButtonWarnWhenBreakingItemsOnCraftTooltip = 606] = "MenuOptionsButtonWarnWhenBreakingItemsOnCraftTooltip",
        e[e.MenuOptionsButtonWarnWhenBreakingItemsOnUse = 607] = "MenuOptionsButtonWarnWhenBreakingItemsOnUse",
        e[e.MenuOptionsButtonWarnWhenBreakingItemsOnUseTooltip = 608] = "MenuOptionsButtonWarnWhenBreakingItemsOnUseTooltip",
        e[e.MenuOptionsHeadingWarnWhenBreakingItems = 609] = "MenuOptionsHeadingWarnWhenBreakingItems",
        e[e.MenuOptionsButtonSaveDataClearBindings = 610] = "MenuOptionsButtonSaveDataClearBindings",
        e[e.MenuOptionsInterruptSaveDataClearBindings = 611] = "MenuOptionsInterruptSaveDataClearBindings",
        e[e.MenuOptionsTooltipDialogOpacity = 612] = "MenuOptionsTooltipDialogOpacity",
        e[e.MenuOptionsLabelDialogOpacity = 613] = "MenuOptionsLabelDialogOpacity",
        e[e.MenuOptionsDeveloperLogSourceFilterHeading = 614] = "MenuOptionsDeveloperLogSourceFilterHeading",
        e[e.MenuOptionsInterruptConfirmImportGlobalData = 615] = "MenuOptionsInterruptConfirmImportGlobalData",
        e[e.MenuOptionsInterruptConfirmImportGlobalDataDescription = 616] = "MenuOptionsInterruptConfirmImportGlobalDataDescription",
        e[e.MenuOptionsInterruptLoadingImportingGlobalData = 617] = "MenuOptionsInterruptLoadingImportingGlobalData",
        e[e.MenuOptionsInterruptLoadingImportingGlobalDataDescription = 618] = "MenuOptionsInterruptLoadingImportingGlobalDataDescription",
        e[e.MenuOptionsAudioVolumeDisplay = 619] = "MenuOptionsAudioVolumeDisplay",
        e[e.MenuOptionsMusicPlaylist = 620] = "MenuOptionsMusicPlaylist",
        e[e.MenuOptionsButtonConfigureBindings = 621] = "MenuOptionsButtonConfigureBindings",
        e[e.MenuPauseButtonContinue = 622] = "MenuPauseButtonContinue",
        e[e.MenuPauseButtonOptions = 623] = "MenuPauseButtonOptions",
        e[e.MenuPauseButtonModes = 624] = "MenuPauseButtonModes",
        e[e.MenuPauseButtonPaused = 625] = "MenuPauseButtonPaused",
        e[e.MenuPauseButtonMultiplayer = 626] = "MenuPauseButtonMultiplayer",
        e[e.MenuPauseButtonTitleScreen = 627] = "MenuPauseButtonTitleScreen",
        e[e.MenuPauseButtonStopServer = 628] = "MenuPauseButtonStopServer",
        e[e.MenuPauseHeadingPaused = 629] = "MenuPauseHeadingPaused",
        e[e.MenuPauseParagraphPaused = 630] = "MenuPauseParagraphPaused",
        e[e.MenuPauseHeadingNotPaused = 631] = "MenuPauseHeadingNotPaused",
        e[e.MenuPauseParagraphNotPaused = 632] = "MenuPauseParagraphNotPaused",
        e[e.MenuPauseHeadingDedicatedServer = 633] = "MenuPauseHeadingDedicatedServer",
        e[e.MenuPauseParagraphDedicatedServer = 634] = "MenuPauseParagraphDedicatedServer",
        e[e.MenuPauseInterruptGhostKeepSave = 635] = "MenuPauseInterruptGhostKeepSave",
        e[e.MenuPauseInterruptGhostKeepSaveDescription = 636] = "MenuPauseInterruptGhostKeepSaveDescription",
        e[e.MenuPauseInterruptReturnToTitleScreen = 637] = "MenuPauseInterruptReturnToTitleScreen",
        e[e.MenuPauseInterruptReturnToTitleScreenChallengeDescription = 638] = "MenuPauseInterruptReturnToTitleScreenChallengeDescription",
        e[e.MenuPauseInterruptReturnToTitleScreenChallengeMultiplayerDescription = 639] = "MenuPauseInterruptReturnToTitleScreenChallengeMultiplayerDescription",
        e[e.MenuPauseInterruptReturnToTitleScreenDescription = 640] = "MenuPauseInterruptReturnToTitleScreenDescription",
        e[e.MenuPauseInterruptReturnToTitleScreenMultiplayerDescription = 641] = "MenuPauseInterruptReturnToTitleScreenMultiplayerDescription",
        e[e.MenuModesTitle = 642] = "MenuModesTitle",
        e[e.MenuModesDescription = 643] = "MenuModesDescription",
        e[e.MenuMultiplayerOptionsTitle = 644] = "MenuMultiplayerOptionsTitle",
        e[e.MenuMultiplayerOptionsDescription = 645] = "MenuMultiplayerOptionsDescription",
        e[e.MenuMultiplayerOptionsOpenServer = 646] = "MenuMultiplayerOptionsOpenServer",
        e[e.MenuMultiplayerOptionsOpenServerDescription = 647] = "MenuMultiplayerOptionsOpenServerDescription",
        e[e.MenuMultiplayerOptionsCopyGameCode = 648] = "MenuMultiplayerOptionsCopyGameCode",
        e[e.MenuMultiplayerOptionsCopyGameCodeTooltip = 649] = "MenuMultiplayerOptionsCopyGameCodeTooltip",
        e[e.MenuMultiplayerOptionsInviteSteamFriends = 650] = "MenuMultiplayerOptionsInviteSteamFriends",
        e[e.MenuJoinServerTitle = 651] = "MenuJoinServerTitle",
        e[e.MenuJoinServerDescription = 652] = "MenuJoinServerDescription",
        e[e.MenuJoinServerInputPlaceholder = 653] = "MenuJoinServerInputPlaceholder",
        e[e.MenuJoinServerNext = 654] = "MenuJoinServerNext",
        e[e.MenuSharedMultiplayerChoiceLobbyTypeFriends = 655] = "MenuSharedMultiplayerChoiceLobbyTypeFriends",
        e[e.MenuSharedMultiplayerChoiceLobbyTypeFriendsDescription = 656] = "MenuSharedMultiplayerChoiceLobbyTypeFriendsDescription",
        e[e.MenuSharedMultiplayerChoiceLobbyTypePublic = 657] = "MenuSharedMultiplayerChoiceLobbyTypePublic",
        e[e.MenuSharedMultiplayerChoiceLobbyTypePublicDescription = 658] = "MenuSharedMultiplayerChoiceLobbyTypePublicDescription",
        e[e.MenuSharedMultiplayerChoiceLobbyTypePrivate = 659] = "MenuSharedMultiplayerChoiceLobbyTypePrivate",
        e[e.MenuSharedMultiplayerChoiceLobbyTypePrivateDescription = 660] = "MenuSharedMultiplayerChoiceLobbyTypePrivateDescription",
        e[e.MenuSharedMultiplayerChoicePVP = 661] = "MenuSharedMultiplayerChoicePVP",
        e[e.MenuSharedMultiplayerChoicePVPDescription = 662] = "MenuSharedMultiplayerChoicePVPDescription",
        e[e.MenuSharedMultiplayerMaxPlayers = 663] = "MenuSharedMultiplayerMaxPlayers",
        e[e.MenuSharedRealTimeTickSpeedTooltip = 664] = "MenuSharedRealTimeTickSpeedTooltip",
        e[e.MenuSharedRealTimeTickSpeedLabel = 665] = "MenuSharedRealTimeTickSpeedLabel",
        e[e.MenuSharedButtonDefault = 666] = "MenuSharedButtonDefault",
        e[e.MenuSharedValueTickSpeed = 667] = "MenuSharedValueTickSpeed",
        e[e.MenuSharedValuePercentage = 668] = "MenuSharedValuePercentage",
        e[e.MiscSortBy = 669] = "MiscSortBy",
        e[e.MiscSortDirection = 670] = "MiscSortDirection",
        e[e.MiscFilter = 671] = "MiscFilter",
        e[e.MiscPlayerNameDefault = 672] = "MiscPlayerNameDefault",
        e[e.MiscPlayerNameServer = 673] = "MiscPlayerNameServer",
        e[e.MiscSaveNameDefault = 674] = "MiscSaveNameDefault",
        e[e.MiscSaveNameDailyChallenge = 675] = "MiscSaveNameDailyChallenge",
        e[e.MiscSaveNameChallenge = 676] = "MiscSaveNameChallenge",
        e[e.MiscSaveVersionUnknown = 677] = "MiscSaveVersionUnknown",
        e[e.MiscVersion = 678] = "MiscVersion",
        e[e.MiscTime = 679] = "MiscTime",
        e[e.MiscTimeMeridiem = 680] = "MiscTimeMeridiem",
        e[e.MiscBindableOr = 681] = "MiscBindableOr",
        e[e.MiscBindableNoBindings = 682] = "MiscBindableNoBindings",
        e[e.SteamworksInterruptURLOpenedInBrowser = 683] = "SteamworksInterruptURLOpenedInBrowser",
        e[e.SteamworksInterruptURLOpenedInBrowserDescription = 684] = "SteamworksInterruptURLOpenedInBrowserDescription",
        e[e.SteamworksInterruptWorkshopOpenedInBrowser = 685] = "SteamworksInterruptWorkshopOpenedInBrowser",
        e[e.SteamworksInterruptWorkshopOpenedInBrowserDescription = 686] = "SteamworksInterruptWorkshopOpenedInBrowserDescription",
        e[e.SteamworksInterruptModWithNameAlreadyExists = 687] = "SteamworksInterruptModWithNameAlreadyExists",
        e[e.SteamworksInterruptModWithNameAlreadyExistsDescription = 688] = "SteamworksInterruptModWithNameAlreadyExistsDescription",
        e[e.SteamworksInterruptModImportSaveGameFailure = 689] = "SteamworksInterruptModImportSaveGameFailure",
        e[e.SteamworksInterruptModImportSaveGameFailureDescription = 690] = "SteamworksInterruptModImportSaveGameFailureDescription",
        e[e.SteamworksInterruptModImportedSaveGame = 691] = "SteamworksInterruptModImportedSaveGame",
        e[e.SteamworksInterruptModImportedSaveGameDescription = 692] = "SteamworksInterruptModImportedSaveGameDescription",
        e[e.SteamworksInterruptLoadingRefreshingMods = 693] = "SteamworksInterruptLoadingRefreshingMods",
        e[e.SteamworksInterruptLoadingRefreshingModsDescription = 694] = "SteamworksInterruptLoadingRefreshingModsDescription",
        e[e.SteamworksInterruptOpenFolderFailure = 695] = "SteamworksInterruptOpenFolderFailure",
        e[e.SteamworksInterruptOpenFolderFailureDescription = 696] = "SteamworksInterruptOpenFolderFailureDescription",
        e[e.DifficultyOptionsPeaceful = 697] = "DifficultyOptionsPeaceful",
        e[e.DifficultyOptionsRespawn = 698] = "DifficultyOptionsRespawn",
        e[e.DifficultyOptionsEternalNight = 699] = "DifficultyOptionsEternalNight",
        e[e.DifficultyOptionsTimeInitial = 700] = "DifficultyOptionsTimeInitial",
        e[e.DifficultyOptionsTimeFrozen = 701] = "DifficultyOptionsTimeFrozen",
        e[e.DifficultyOptionsTimeDayLength = 702] = "DifficultyOptionsTimeDayLength",
        e[e.DifficultyOptionsTimeDayPercent = 703] = "DifficultyOptionsTimeDayPercent",
        e[e.DifficultyOptionsNoItems = 704] = "DifficultyOptionsNoItems",
        e[e.DifficultyOptionsBenignityInitial = 705] = "DifficultyOptionsBenignityInitial",
        e[e.DifficultyOptionsBenignityMultiplier = 706] = "DifficultyOptionsBenignityMultiplier",
        e[e.DifficultyOptionsMalignityInitial = 707] = "DifficultyOptionsMalignityInitial",
        e[e.DifficultyOptionsMalignityMultiplier = 708] = "DifficultyOptionsMalignityMultiplier",
        e[e.DifficultyOptionsStatInitial = 709] = "DifficultyOptionsStatInitial",
        e[e.DifficultyOptionsStatMax = 710] = "DifficultyOptionsStatMax",
        e[e.DifficultyOptionsStatMultiplier = 711] = "DifficultyOptionsStatMultiplier",
        e[e.DifficultyOptionsStatusEffectStartWith = 712] = "DifficultyOptionsStatusEffectStartWith",
        e[e.DifficultyOptionsStatusEffectUntreatable = 713] = "DifficultyOptionsStatusEffectUntreatable",
        e[e.DifficultyOptionsStatusEffectPassChanceMultiplier = 714] = "DifficultyOptionsStatusEffectPassChanceMultiplier",
        e[e.DifficultyOptionsNoRandomSkills = 715] = "DifficultyOptionsNoRandomSkills",
        e[e.DifficultyOptionsSkillGainMultiplier = 716] = "DifficultyOptionsSkillGainMultiplier",
        e[e.DifficultyOptionsSkillInitial = 717] = "DifficultyOptionsSkillInitial",
        e[e.DifficultyOptionsStatusEffectPermanent = 718] = "DifficultyOptionsStatusEffectPermanent",
        e[e.DifficultyOptionsStatusEffectRateMultiplier = 719] = "DifficultyOptionsStatusEffectRateMultiplier",
        e[e.DifficultyOptionsStatusEffectMultiplier = 720] = "DifficultyOptionsStatusEffectMultiplier",
        e[e.EquipmentBack = 721] = "EquipmentBack",
        e[e.EquipmentBelt = 722] = "EquipmentBelt",
        e[e.EquipmentChest = 723] = "EquipmentChest",
        e[e.EquipmentFeet = 724] = "EquipmentFeet",
        e[e.EquipmentHands = 725] = "EquipmentHands",
        e[e.EquipmentHead = 726] = "EquipmentHead",
        e[e.EquipmentLeftHand = 727] = "EquipmentLeftHand",
        e[e.EquipmentLeftHandOption = 728] = "EquipmentLeftHandOption",
        e[e.EquipmentLegs = 729] = "EquipmentLegs",
        e[e.EquipmentNeck = 730] = "EquipmentNeck",
        e[e.EquipmentRightHand = 731] = "EquipmentRightHand",
        e[e.EquipmentRightHandOption = 732] = "EquipmentRightHandOption",
        e[e.EquipmentUse = 733] = "EquipmentUse",
        e[e.HudFilter = 734] = "HudFilter",
        e[e.QuickSlot1 = 735] = "QuickSlot1",
        e[e.QuickSlot2 = 736] = "QuickSlot2",
        e[e.QuickSlot3 = 737] = "QuickSlot3",
        e[e.QuickSlot4 = 738] = "QuickSlot4",
        e[e.QuickSlot5 = 739] = "QuickSlot5",
        e[e.QuickSlot6 = 740] = "QuickSlot6",
        e[e.QuickSlot7 = 741] = "QuickSlot7",
        e[e.QuickSlot8 = 742] = "QuickSlot8",
        e[e.QuickSlot9 = 743] = "QuickSlot9",
        e[e.TabCrafting = 744] = "TabCrafting",
        e[e.TabDismantle = 745] = "TabDismantle",
        e[e.Version = 746] = "Version",
        e[e.WindowTitleContainer = 747] = "WindowTitleContainer",
        e[e.WindowTitleCrafting = 748] = "WindowTitleCrafting",
        e[e.WindowTitleEquipment = 749] = "WindowTitleEquipment",
        e[e.WindowTitleInventory = 750] = "WindowTitleInventory"
    }(a || (a = {})),
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("game/TimeManager", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "save/ISerializer", "utilities/math/Math2"], function(e, t, a, i, n, o, r) {
    var s, l, u;
    function d(e) {
        const t = Math.floor(24 * e)
          , a = Math.floor(60 * (24 * e - t));
        return {
            hour: t,
            minute: a
        }
    }
    function p(e) {
        const t = e.match(/^([01][0-9]|2[0-3]):([0-5][0-9])$/) || e.match(/^(0?[1-9]|1[0-2]):([0-5][0-9])(am|pm)$/) || e.match(/^(0?[1-9]|1[0-2])()(am|pm)$/);
        if (!t)
            return;
        let a = +t[1]
          , i = +t[2];
        return isNaN(i) && (i = 0),
        "pm" === t[3] && a < 12 && (a += 12),
        "am" === t[3] && 12 === a && (a = 0),
        {
            hour: a,
            minute: i
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.PartOfDay = 0] = "PartOfDay",
        e[e.TwelveHour = 1] = "TwelveHour",
        e[e.TwentyFourHour = 2] = "TwentyFourHour",
        e[e.TwelveHourNoMinute = 3] = "TwelveHourNoMinute",
        e[e.TwentyFourHourNoMinute = 4] = "TwentyFourHourNoMinute"
    }(s = t.TimeFormat || (t.TimeFormat = {})),
    function(e) {
        e[e.Nighttime = 0] = "Nighttime",
        e[e.Dawn = 1] = "Dawn",
        e[e.Sunrise = 2] = "Sunrise",
        e[e.Daytime = 3] = "Daytime",
        e[e.Sunset = 4] = "Sunset",
        e[e.Dusk = 5] = "Dusk"
    }(l = t.PartOfDay || (t.PartOfDay = {})),
    function(e) {
        e[e.Day1 = 0] = "Day1",
        e[e.Day2 = 1] = "Day2",
        e[e.Day3 = 2] = "Day3",
        e[e.Day4 = 3] = "Day4",
        e[e.Night1 = 4] = "Night1",
        e[e.Night2 = 5] = "Night2",
        e[e.Night3 = 6] = "Night3",
        e[e.Night4 = 7] = "Night4"
    }(u = t.DayQuarter || (t.DayQuarter = {}));
    class c {
        constructor(e) {
            this.dayLength = 3200,
            this.dayPercent = .625,
            this._ticks = 0,
            this.transitionPercent = .5,
            this._ticks = e
        }
        get dayStart() {
            return this.dayLength * this.dayPercent * (this.transitionPercent / 2)
        }
        get ticks() {
            return this._ticks
        }
        get day() {
            return Math.floor((this._ticks + this.dayStart) / this.dayLength) + 1
        }
        nextTick() {
            this._ticks++,
            this._ticks >= Number.MAX_SAFE_INTEGER && (this._ticks = 0)
        }
        getTime() {
            return void 0 !== this.frozenTime ? this.frozenTime : (this._ticks + this.dayStart) % this.dayLength / this.dayLength
        }
        isDay(e=this.getTime() ) {
            return e <= this.dayPercent
        }
        isNight(e=this.getTime() ) {
            return e > this.dayPercent
        }
        isPast(e, t=this.getTime() ) {
            const a = p(e);
            if (!a)
                return;
            const i = a.minute + 60 * a.hour
              , n = this.getHoursAndMinutes(t)
              , o = n.minute + 60 * n.hour;
            return o > i
        }
        isBefore(e, t=this.getTime() ) {
            const a = p(e);
            if (!a)
                return;
            const i = a.minute + 60 * a.hour
              , n = this.getHoursAndMinutes(t)
              , o = n.minute + 60 * n.hour;
            return o < i
        }
        isBetween(e, t, a=this.getTime() ) {
            return this.isPast(e, a) && this.isBefore(t, a)
        }
        getHoursAndMinutes(e=this.getTime() ) {
            return d(this.realignTime(e))
        }
        getHour(e=this.getTime() , t=s.TwelveHour) {
            const a = this.getHoursAndMinutes(e).hour;
            let i = 0;
            return i = t === s.TwelveHour ? 12 === a ? a : 0 === a ? 12 : a % 12 : a
        }
        getMinute(e=this.getTime() ) {
            return this.getHoursAndMinutes(e).minute
        }
        getPartOfDay(e=this.getTime() ) {
            const t = this.transitionPercent / 4;
            return e < t ? l.Dawn : e < this.dayPercent - t ? l.Daytime : e < this.dayPercent ? l.Sunset : e < this.dayPercent + t ? l.Dusk : e < 1 - t ? l.Nighttime : l.Sunrise
        }
        getDayQuarter(e=this.getTime() ) {
            if (e < this.dayPercent) {
                const t = Math.floor(e / this.dayPercent * 4 + 1);
                switch (t) {
                case 1:
                    return u.Day1;
                case 2:
                    return u.Day2;
                case 3:
                    return u.Day3;
                case 4:
                    return u.Day4
                }
            } else {
                const t = Math.floor((e - this.dayPercent) / (1 - this.dayPercent) * 4 + 1);
                switch (t) {
                case 1:
                    return u.Night1;
                case 2:
                    return u.Night2;
                case 3:
                    return u.Night3;
                case 4:
                    return u.Night4
                }
            }
            return -1
        }
        getTranslation(e=this.getTime() , t=s.TwelveHour) {
            if (t === s.PartOfDay)
                return new n.default(a.Dictionary.PartOfDay,this.getPartOfDay(e));
            if (e = this.realignTime(e),
            t === s.TwentyFourHour || t === s.TwentyFourHourNoMinute) {
                const {hour: a, minute: o} = d(e);
                let r = `${a}`;
                1 === r.length && (r = `0${r}`);
                let l = `${o}`;
                return 1 === l.length && (l = `0${l}`),
                n.default.ui(i.default.MiscTime).addArgs(a, o, t === s.TwentyFourHourNoMinute)
            }
            {
                const a = d(e);
                let o = a.hour;
                o > 12 && (o -= 12),
                0 === o && (o = 12);
                let r = `${a.minute}`;
                1 === r.length && (r = `0${r}`);
                const l = a.hour < 12;
                return n.default.ui(i.default.MiscTime).addArgs(o, r, t === s.TwelveHourNoMinute, n.default.ui(i.default.MiscTimeMeridiem).addArgs(l))
            }
        }
        getBrightness(e=this.getTime() ) {
            const t = this.transitionPercent / 4;
            return e < this.dayPercent - t ? e > t ? 0 : .5 - e / t / 2 : e > this.dayPercent + t ? e < 1 - t ? 1 : 1 - (e - (1 - t)) / t / 2 : (e - (this.dayPercent - t)) / (2 * t)
        }
        restoreFromDayNight(e, t) {
            1 === t && (e = 1 - e + 1),
            e /= 2,
            e += this.transitionPercent / 4 + this.dayPercent / 2,
            this.setTime(e)
        }
        setTime(e) {
            e = r.default.clamp1(e);
            const t = this.getTime();
            return this._ticks += Math.floor((e - t) * this.dayLength),
            this._ticks <= 0 && (this._ticks += this.dayLength),
            this
        }
        realignTime(e) {
            return (e += this.dayStart / this.dayLength + this.transitionPercent / 4) >= 1 && (e -= 1),
            e
        }
    }
    __decorate([o.SaveProperty()], c.prototype, "dayLength", void 0),
    __decorate([o.SaveProperty()], c.prototype, "dayPercent", void 0),
    __decorate([o.SaveProperty()], c.prototype, "frozenTime", void 0),
    __decorate([o.SaveProperty()], c.prototype, "_ticks", void 0),
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/dictionary/Note", ["require", "exports"], function(e, t) {
    var a, i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Name = 0] = "Name",
        e[e.Note = 1] = "Note"
    }(a = t.NoteTranslation || (t.NoteTranslation = {})),
    function(e) {
        e[e.Bleeding = 0] = "Bleeding",
        e[e.Burned = 1] = "Burned",
        e[e.Caving = 2] = "Caving",
        e[e.Combat = 3] = "Combat",
        e[e.Corpse = 4] = "Corpse",
        e[e.CreatureTaming = 5] = "CreatureTaming",
        e[e.Dehydration = 6] = "Dehydration",
        e[e.Durability = 7] = "Durability",
        e[e.Encumbered = 8] = "Encumbered",
        e[e.FailureInCrafting = 9] = "FailureInCrafting",
        e[e.Gardening = 10] = "Gardening",
        e[e.HealthIssues = 11] = "HealthIssues",
        e[e.Inedible = 12] = "Inedible",
        e[e.ItemQualities = 13] = "ItemQualities",
        e[e.Mercantile = 14] = "Mercantile",
        e[e.Nightfall = 15] = "Nightfall",
        e[e.Poisoned = 16] = "Poisoned",
        e[e.Reputation = 17] = "Reputation",
        e[e.StaminaReplenishment = 18] = "StaminaReplenishment",
        e[e.Stranded = 19] = "Stranded",
        e[e.ToolUse = 20] = "ToolUse",
        e[e.TreasureHunting = 21] = "TreasureHunting"
    }(i || (i = {})),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/help/HelpArticleDescriptions", ["require", "exports"], function(e, t) {
    var a, i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Welcome = 0] = "Welcome",
        e[e.Controls = 1] = "Controls",
        e[e.Interface = 2] = "Interface",
        e[e.InventoryManagement = 3] = "InventoryManagement",
        e[e.Quickslots = 4] = "Quickslots",
        e[e.FastPickup = 5] = "FastPickup",
        e[e.Actions = 6] = "Actions",
        e[e.Stats = 7] = "Stats",
        e[e.Doodads = 8] = "Doodads",
        e[e.ResourceGathering = 9] = "ResourceGathering",
        e[e.Milestones = 10] = "Milestones",
        e[e.HeldItems = 11] = "HeldItems",
        e[e.Crafting = 12] = "Crafting",
        e[e.ItemQualities = 13] = "ItemQualities",
        e[e.Death = 14] = "Death",
        e[e.Taming = 15] = "Taming",
        e[e.Gardening = 16] = "Gardening",
        e[e.Overweight = 17] = "Overweight",
        e[e.Merchants = 18] = "Merchants",
        e[e.Multiplayer = 19] = "Multiplayer",
        e[e.Bugs = 20] = "Bugs"
    }(a = t.HelpArticle || (t.HelpArticle = {})),
    function(e) {
        e[e.Interface = 0] = "Interface",
        e[e.Gameplay = 1] = "Gameplay",
        e[e.Other = 2] = "Other"
    }(i = t.HelpArticleSection || (t.HelpArticleSection = {}));
    const n = {
        [a.Welcome]: {
            important: !0,
            image: !0
        },
        [a.Controls]: {
            important: !0,
            image: !0,
            section: i.Interface
        },
        [a.Interface]: {
            image: !0,
            section: i.Interface
        },
        [a.InventoryManagement]: {
            image: !0,
            section: i.Interface
        },
        [a.Quickslots]: {
            image: !0,
            section: i.Interface
        },
        [a.FastPickup]: {
            image: !0,
            section: i.Interface
        },
        [a.Actions]: {
            image: !0,
            section: i.Gameplay
        },
        [a.Stats]: {
            important: !0,
            image: !0,
            section: i.Gameplay
        },
        [a.Doodads]: {
            image: !0,
            section: i.Gameplay
        },
        [a.ResourceGathering]: {
            image: !0,
            section: i.Gameplay
        },
        [a.Milestones]: {
            image: !0,
            section: i.Gameplay
        },
        [a.HeldItems]: {
            image: !0,
            section: i.Gameplay
        },
        [a.Crafting]: {
            image: !0,
            section: i.Gameplay
        },
        [a.ItemQualities]: {
            image: !0,
            section: i.Gameplay
        },
        [a.Death]: {
            image: !0,
            section: i.Gameplay
        },
        [a.Taming]: {
            important: !0,
            image: !0,
            section: i.Gameplay
        },
        [a.Gardening]: {
            image: !0,
            section: i.Gameplay
        },
        [a.Overweight]: {
            image: !0,
            section: i.Gameplay
        },
        [a.Merchants]: {
            image: !0,
            section: i.Gameplay
        },
        [a.Multiplayer]: {
            image: !0,
            section: i.Other
        },
        [a.Bugs]: {
            image: !0,
            section: i.Other
        }
    };
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/note/NoteManager", ["require", "exports", "entity/Entity", "entity/IEntity", "language/dictionary/Note", "language/Translation", "newui/screen/screens/menu/menus/help/HelpArticleDescriptions", "save/ISerializer"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.noteDescriptions = {
        [n.default.Gardening]: {
            learnMore: r.HelpArticle.Gardening
        },
        [n.default.Mercantile]: {
            learnMore: r.HelpArticle.Merchants
        },
        [n.default.Encumbered]: {
            learnMore: r.HelpArticle.Overweight
        },
        [n.default.ToolUse]: {
            learnMore: r.HelpArticle.HeldItems
        },
        [n.default.HealthIssues]: {
            learnMore: r.HelpArticle.Stats
        },
        [n.default.StaminaReplenishment]: {
            learnMore: r.HelpArticle.Stats
        },
        [n.default.Dehydration]: {
            learnMore: r.HelpArticle.Stats
        },
        [n.default.ItemQualities]: {
            learnMore: r.HelpArticle.ItemQualities
        }
    };
    const l = {
        notes: [],
        getNote: ()=>void 0,
        wasWritten: ()=>!1,
        write() {}
    };
    class u {
        constructor(e) {
            this.host = e,
            this._notes = []
        }
        static get(e) {
            return a.default.is(e, i.EntityType.Player) ? e.notes : l
        }
        get notes() {
            return [...this._notes]
        }
        getNote(e) {
            return this._notes[e]
        }
        wasWritten(e) {
            return this._notes.some(t=>t.id === n.default[e])
        }
        write(e, ...t) {
            if (this.wasWritten(e))
                return;
            const a = {
                id: n.default[e],
                time: {
                    skilled: this.host.canWriteInHours(),
                    day: game.time.day,
                    time: game.time.getTime()
                },
                args: t.map(e=>{
                    if (e instanceof o.default)
                        return e.serialize();
                    if ("object" == typeof e)
                        for (const t in e)
                            e[t]instanceof o.default && (e[t] = e[t].serialize());
                    return e
                }
                )
            };
            if (!this.host.canWriteNote(a))
                return;
            const i = this._notes.push(a) - 1;
            this.host.onWriteNote(i)
        }
    }
    __decorate([s.SaveProperty()], u.prototype, "_notes", void 0),
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("creature/corpse/ICorpse", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("creature/corpse/Corpses", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.corpseDescriptions = Array(),
    t.default = t.corpseDescriptions,
    t.corpseDescriptions[a.CreatureType.Blood] = {
        decay: 300,
        blood: !0
    },
    t.corpseDescriptions[a.CreatureType.WaterBlood] = {
        decay: 80,
        blood: !0
    },
    t.corpseDescriptions[a.CreatureType.Bear] = {
        resource: [{
            item: a.ItemType.AnimalPelt
        }, {
            item: a.ItemType.AnimalClaw
        }, {
            item: a.ItemType.AnimalFat
        }, {
            item: a.ItemType.RawMeat
        }, {
            item: a.ItemType.RawMeat
        }, {
            item: a.ItemType.AnimalSkull
        }, {
            item: a.ItemType.Offal
        }, {
            item: a.ItemType.Bone
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2800,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Rabbit] = {
        resource: [{
            item: a.ItemType.AnimalPelt
        }, {
            item: a.ItemType.RawMeat
        }, {
            item: a.ItemType.Offal
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.GiantRat] = {
        resource: [{
            item: a.ItemType.AnimalPelt
        }, {
            item: a.ItemType.AnimalClaw,
            chance: 70
        }, {
            item: a.ItemType.AnimalFat
        }, {
            item: a.ItemType.RawTaintedMeat
        }, {
            item: a.ItemType.Offal
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.GreyWolf] = {
        resource: [{
            item: a.ItemType.AnimalPelt
        }, {
            item: a.ItemType.AnimalClaw,
            chance: 80
        }, {
            item: a.ItemType.AnimalFat
        }, {
            item: a.ItemType.RawMeat
        }, {
            item: a.ItemType.Offal
        }, {
            item: a.ItemType.Bone
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2600,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.VampireBat] = {
        resource: [{
            item: a.ItemType.RawMeat
        }],
        decay: 2200,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Snake] = {
        resource: [{
            item: a.ItemType.Scales
        }, {
            item: a.ItemType.VenomGland,
            chance: 3
        }, {
            item: a.ItemType.RawReptileMeat
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Slime] = {
        resource: [{
            item: a.ItemType.SlimeGelatin
        }],
        decay: 3200
    },
    t.corpseDescriptions[a.CreatureType.JellyCube] = {
        resource: [{
            item: a.ItemType.SlimeGelatin
        }, {
            item: a.ItemType.SlimeGelatin
        }],
        decay: 3400
    },
    t.corpseDescriptions[a.CreatureType.GiantSpider] = {
        resource: [{
            item: a.ItemType.SpiderEggs,
            chance: 2
        }, {
            item: a.ItemType.SpiderMeat
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Zombie] = {
        resource: [{
            item: a.ItemType.RottenMeat
        }, {
            item: a.ItemType.Bone
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 600,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Imp] = {
        resource: [{
            item: a.ItemType.Scales
        }, {
            item: a.ItemType.AnimalClaw
        }, {
            item: a.ItemType.RawTaintedMeat
        }, {
            item: a.ItemType.FireBladder,
            chance: 2
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2600,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Bogling] = {
        resource: [{
            item: a.ItemType.PileOfCompost
        }, {
            item: a.ItemType.RottingVegetation
        }],
        decay: 1e3,
        skill: a.SkillType.Botany
    },
    t.corpseDescriptions[a.CreatureType.LivingRock] = {
        resource: [{
            item: a.ItemType.CopperOre,
            chance: 90
        }, {
            item: a.ItemType.Talc
        }, {
            item: a.ItemType.IronOre,
            chance: 50
        }, {
            item: a.ItemType.Limestone
        }],
        skill: a.SkillType.Mining
    },
    t.corpseDescriptions[a.CreatureType.Shark] = {
        resource: [{
            item: a.ItemType.SharkFin
        }, {
            item: a.ItemType.RawFishSteak
        }, {
            item: a.ItemType.RawFishSteak
        }, {
            item: a.ItemType.Offal
        }],
        decay: 800,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Rat] = {
        resource: [{
            item: a.ItemType.RawTaintedMeat
        }],
        decay: 2200,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Skeleton] = {
        resource: [{
            item: a.ItemType.Bone
        }, {
            item: a.ItemType.Bone
        }, {
            item: a.ItemType.BoneFragments
        }],
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.PirateGhost] = {
        resource: [{
            item: a.ItemType.Ectoplasm
        }],
        decay: 100
    },
    t.corpseDescriptions[a.CreatureType.TimeSkitter] = {
        resource: [{
            item: a.ItemType.SpiderMeat
        }, {
            item: a.ItemType.Offal
        }],
        decay: 2600,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Chicken] = {
        resource: [{
            item: a.ItemType.Feather
        }, {
            item: a.ItemType.Feather
        }, {
            item: a.ItemType.TailFeathers,
            chance: 1
        }, {
            item: a.ItemType.Egg,
            chance: 20
        }, {
            item: a.ItemType.RawChicken
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.TrapdoorSpider] = {
        resource: [{
            item: a.ItemType.SpiderEggs,
            chance: 2
        }, {
            item: a.ItemType.SpiderMeat
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.FireElemental] = {
        resource: [{
            item: a.ItemType.Charcoal,
            chance: 25
        }, {
            item: a.ItemType.Charcoal
        }],
        decay: 400,
        skill: a.SkillType.Mining,
        animated: !0
    },
    t.corpseDescriptions[a.CreatureType.Hobgoblin] = {
        resource: [{
            item: a.ItemType.RawMeat
        }, {
            item: a.ItemType.Offal
        }, {
            item: a.ItemType.Bone
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2600,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.LivingMushroom] = {
        resource: [{
            item: a.ItemType.ButtonMushrooms
        }, {
            item: a.ItemType.ButtonMushrooms
        }],
        aberrantResource: [{
            item: a.ItemType.FlyAmanita
        }, {
            item: a.ItemType.FlyAmanita
        }],
        decay: 3200,
        skill: a.SkillType.Mycology
    },
    t.corpseDescriptions[a.CreatureType.Kraken] = {
        resource: [{
            item: a.ItemType.Tentacles
        }, {
            item: a.ItemType.Tentacles
        }, {
            item: a.ItemType.Tentacles
        }, {
            item: a.ItemType.Offal
        }],
        decay: 3600,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Harpy] = {
        resource: [{
            item: a.ItemType.Feather
        }, {
            item: a.ItemType.Feather
        }, {
            item: a.ItemType.TailFeathers,
            chance: 3
        }, {
            item: a.ItemType.RawChicken
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2600,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.AcidSpitterDemon] = {
        resource: [{
            item: a.ItemType.MagicalEssence
        }, {
            item: a.ItemType.RawTaintedMeat
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2600,
        damage: 12,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.SkeletalMage] = {
        resource: [{
            item: a.ItemType.MageRobe
        }, {
            item: a.ItemType.Bone
        }, {
            item: a.ItemType.BoneFragments
        }],
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.ClawWorm] = {
        resource: [{
            item: a.ItemType.AnimalClaw
        }, {
            item: a.ItemType.WormMeat
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Drake] = {
        resource: [{
            item: a.ItemType.Scales
        }, {
            item: a.ItemType.AnimalClaw
        }, {
            item: a.ItemType.AnimalFat
        }, {
            item: a.ItemType.RawReptileMeat
        }, {
            item: a.ItemType.RawReptileMeat
        }, {
            item: a.ItemType.FireBladder
        }, {
            item: a.ItemType.AnimalSkull
        }, {
            item: a.ItemType.Offal
        }, {
            item: a.ItemType.Bone
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 3e3,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Sandcat] = {
        resource: [{
            item: a.ItemType.AnimalPelt
        }, {
            item: a.ItemType.AnimalClaw
        }, {
            item: a.ItemType.AnimalFat
        }, {
            item: a.ItemType.RawMeat
        }, {
            item: a.ItemType.Offal
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2600,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.LavaBeetle] = {
        resource: [{
            item: a.ItemType.LavaBeetleHelmet
        }, {
            item: a.ItemType.Obsidian
        }, {
            item: a.ItemType.Offal
        }],
        decay: 2800,
        skill: a.SkillType.Anatomy,
        lightSource: !0
    },
    t.corpseDescriptions[a.CreatureType.Goat] = {
        resource: [{
            item: a.ItemType.AnimalPelt
        }, {
            item: a.ItemType.AnimalFat
        }, {
            item: a.ItemType.RawMeat
        }, {
            item: a.ItemType.Offal
        }, {
            item: a.ItemType.Bone
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2600,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.SlitherSucker] = {
        resource: [{
            item: a.ItemType.WormMeat
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Mudskipper] = {
        resource: [{
            item: a.ItemType.RawFishSteak
        }],
        decay: 2e3,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Scorpion] = {
        resource: [{
            item: a.ItemType.ScorpionStinger,
            chance: 25
        }, {
            item: a.ItemType.DeadScorpion
        }],
        aberrantResource: [{
            item: a.ItemType.ScorpionStinger
        }, {
            item: a.ItemType.DeadAberrantScorpion
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.Rattlesnake] = {
        resource: [{
            item: a.ItemType.Scales,
            chance: 50
        }, {
            item: a.ItemType.Scales
        }, {
            item: a.ItemType.VenomGland,
            chance: 6
        }, {
            item: a.ItemType.RawReptileMeat,
            chance: 10
        }, {
            item: a.ItemType.RawReptileMeat
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    },
    t.corpseDescriptions[a.CreatureType.AntelopeJackrabbit] = {
        resource: [{
            item: a.ItemType.AnimalPelt
        }, {
            item: a.ItemType.RawMeat
        }, {
            item: a.ItemType.RawMeat
        }, {
            item: a.ItemType.Offal
        }, {
            item: a.ItemType.BoneFragments
        }],
        decay: 2400,
        skill: a.SkillType.Anatomy
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("tile/ITileEvent", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Fire = 1] = "Fire",
        e[e.HoneyFungus = 2] = "HoneyFungus",
        e[e.TumblingTumbleweed = 3] = "TumblingTumbleweed"
    }(a = t.TileEventType || (t.TileEventType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("tile/ITerrain", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.House = 0] = "House",
        e[e.Pond = 1] = "Pond",
        e[e.CavePond = 2] = "CavePond",
        e[e.Desert = 3] = "Desert",
        e[e.Beach = 4] = "Beach",
        e[e.Boat = 5] = "Boat",
        e[e.Lava = 6] = "Lava"
    }(a = t.TileTemplateType || (t.TileTemplateType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/Spliterables", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor(e, t) {
            this.preiterated = new Map,
            this.iterable = Array.isArray(e) ? e.values() : e,
            this.splitter = t
        }
        *iterate(e) {
            const t = this.preiterated.get(e) || [];
            for (const e of t)
                yield e;
            for (; ; ) {
                const t = this.iterable.next();
                if (t.done)
                    break;
                const a = this.splitter(t.value);
                if (a === e)
                    yield t.value;
                else {
                    const e = this.preiterated.get(a) || [];
                    e.length || this.preiterated.set(a, e),
                    e.push(t.value)
                }
            }
        }
        splits() {
            for (const e of this.iterate(void 0))
                ;
            return this.preiterated.entries()
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/Collectors", ["require", "exports", "utilities/iterable/Spliterables"], function(e, t, a) {
    var i, n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        function t(e) {
            return Array.from(e)
        }
        function i(e) {
            const t = new Map;
            for (const [a,i] of e)
                t.set(a, i);
            return t
        }
        function o(e) {
            return t=>{
                let a = "";
                for (const i of t)
                    a += `${i}${e}`;
                return 0 === e.length ? a : a.slice(0, -1 * e.length)
            }
        }
        function r(e) {
            return t=>{
                for (const a of t)
                    e.add(a);
                return e
            }
        }
        function s(e) {
            return t=>{
                for (const a of t)
                    e.push(a);
                return e
            }
        }
        function l(e) {
            return t=>{
                for (const [a,i] of t)
                    e.set(a, i);
                return e
            }
        }
        function u(e) {
            return t=>{
                if (Array.isArray(t))
                    return t.length ? t[0] : e;
                for (const e of t)
                    return e;
                return e
            }
        }
        function d(e) {
            return t=>{
                if (Array.isArray(t))
                    return t.length ? t[t.length - 1] : e;
                let a = e;
                for (const e of t)
                    a = e;
                return a
            }
        }
        function p(e) {
            return a=>{
                const i = Array.isArray(a) ? a : a.collect(t)
                  , n = Math.floor(Math.random() * i.length);
                return n in i ? i[n] : e
            }
        }
        function c(e, t) {
            return a=>{
                let i = 0;
                for (const t of a)
                    if (i++ === e)
                        return t;
                return t
            }
        }
        function m(e) {
            return t=>new a.default(t,e)
        }
        function h(e) {
            const t = e.next();
            return [!t.done, t.done ? e : function*() {
                yield t.value;
                for (const t of e)
                    yield t
            }()]
        }
        function y(e, t=n.First) {
            return a=>{
                if (t === n.Splat)
                    return e(...a);
                const i = t === n.First ? u()(a) : t === n.Last ? d()(a) : p()(a);
                return e(i)
            }
        }
        e.toArray = t,
        e.toMap = i,
        e.toString = o,
        e.addTo = r,
        e.pushTo = s,
        e.setTo = l,
        e.first = u,
        e.last = d,
        e.random = p,
        e.at = c,
        e.split = m,
        e.hasAny = h,
        e.passTo = y
    }(i || (i = {})),
    function(e) {
        e[e.First = 0] = "First",
        e[e.Last = 1] = "Last",
        e[e.Random = 2] = "Random",
        e[e.Splat = 3] = "Splat"
    }(n = t.PassStrategy || (t.PassStrategy = {})),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/Generators", ["require", "exports"], function(e, t) {
    function *a(e, t) {
        void 0 === t && (t = e,
        e = 0);
        for (let a = e; a < t; a++)
            yield a
    }
    function i(...e) {
        return e
    }
    function n(...e) {
        return e.values()
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.range = a,
    t.tuple = i,
    t.pipe = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Objects", ["require", "exports", "utilities/iterable/Generators"], function(e, t, a) {
    var i;
    function n(e, t, a) {
        return r(e, t, a, !0)
    }
    function o(e, t, a) {
        return r(e, t, a, !1)
    }
    function r(e, t, a, i=!0) {
        let n = a.value;
        return {
            configurable: i,
            get() {
                if (!this || this === e.prototype || this.hasOwnProperty(t) || "function" != typeof n)
                    return n;
                const a = n.bind(this);
                return Object.defineProperty(this, t, {
                    configurable: i,
                    get: ()=>a,
                    set(e) {
                        n = e,
                        delete this[t]
                    }
                }),
                a
            },
            set(e) {
                n = e
            }
        }
    }
    function s(e, t) {
        Object.defineProperty(e, "privateStore", {
            configurable: !1,
            value: new p(t)
        })
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        function t(e) {
            for (const t in e)
                if (e.hasOwnProperty(t))
                    return !1;
            return !0
        }
        function *a(e) {
            for (const t in e)
                yield t
        }
        function *i(e) {
            for (const t in e)
                yield e[t]
        }
        function *n(e) {
            for (const t in e)
                yield[t, e[t]]
        }
        function *o(e) {
            for (const t in e)
                e.hasOwnProperty(t) && (yield t)
        }
        function *r(e) {
            for (const t in e)
                e.hasOwnProperty(t) && (yield e[t])
        }
        function *s(e) {
            for (const t in e)
                e.hasOwnProperty(t) && (yield[t, e[t]])
        }
        function l(e) {
            const t = {};
            for (const [a,i] of e)
                t[a] = i;
            return t
        }
        function u(e) {
            let t = window;
            for (let a = 0; a < e.length; a++)
                t = t[e[a]];
            return t
        }
        function d(e) {
            let t = window;
            for (let a = 0; a < e.length - 1; a++)
                t = t[e[a]];
            return t
        }
        function p(e) {
            if (Array.isArray(e))
                return e.map(p);
            if (e instanceof Uint8Array)
                return e.slice(0);
            if ("object" == typeof e) {
                const t = {};
                for (const a of Object.getOwnPropertyNames(e))
                    t[a] = p(e[a]);
                return t
            }
            return e
        }
        function c(e, t) {
            return a=>(a[e] = t,
            a)
        }
        function m(e, t) {
            for (const a of t)
                if (void 0 === (e = e[a]))
                    return;
            return e
        }
        function h(e, t, a=!1) {
            const i = new Map;
            return a && "object" == typeof e && (e = Object.assign({}, e)),
            JSON.stringify(e, (t,n)=>{
                if ("object" == typeof n) {
                    if (a && n !== e)
                        return "[OBJECT]";
                    if (i.has(n))
                        return "[CIRCULAR REFERENCE]";
                    i.set(n, !0)
                }
                return n
            }
            , t)
        }
        e.isEmpty = t,
        e.keys = a,
        e.values = i,
        e.entries = n,
        e.ownKeys = o,
        e.ownValues = r,
        e.ownEntries = s,
        e.create = l,
        e.windowKeysToObject = u,
        e.windowKeysToParentObject = d,
        e.deepClone = p,
        e.addProperty = c,
        e.followDirections = m,
        e.stringify = h
    }(i || (i = {})),
    t.default = i,
    t.Bound = n,
    t.Final = o,
    t.initializePrivateStore = s;
    class l {
        constructor(e) {
            this.symbol = e
        }
    }
    const u = new Map;
    function d(e) {
        let t = u.get(e);
        return t || u.set(e, t = new l(e)),
        t
    }
    class p {
        constructor(e) {
            this.weakMap = new WeakMap(e && e.map(([e,t])=>a.tuple(d(e), t)))
        }
        set(e, t) {
            this.weakMap.set(d(e), t)
        }
        get(e) {
            return this.weakMap.get(d(e))
        }
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/string/Strings", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = "\\-_0-9\\x41-\\x5A\\x61-\\x7A\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC";
    var n;
    t.matchLanguageLetters = new RegExp(`[${i}]`,"g"),
    t.matchNotLanguageLetters = new RegExp(`[^${i}]`,"g"),
    t.matchInvalidPathLettersWindows = new RegExp('[<>:"/\\|?*]',"g"),
    t.matchInvalidPathLettersUnix = new RegExp("[/]","g"),
    function(e) {
        const t = /(^|>|\s+)\*(.*?)\*(?=\s+|[,.<]|$)/g
          , i = /(^|>|\s+)-(.*?)-(?=\s+|[,.<]|$)/g
          , n = /(^|>|\s+)&#x2F;(.*?)&#x2F;(?=\s+|[,.<]|$)/g
          , o = /(^|>|\s+)_(.*?)_(?=\s+|[,.<]|$)/g
          , r = /(^|>|\s+)\[(.+?)\]\((https?:&#x2F;&#x2F;.+?)\)(?=\s+|[,.<]|$)/g
          , s = /(^|[>(]|\s+|)&#x60;(.*?)&#x60;(?=\s+|[,.;:<)]|s\b|$)/g;
        function l(e) {
            return c(e).replace(r, (e,t,a,i)=>`${t}<a href='${i.replace(/&#x2F;/g, "/")}'>${a}</a>`).replace(n, (e,t,a)=>a.length > 0 ? `${t}<span class='italic'>${a}</span>` : `${t}/`).replace(t, (e,t,a)=>a.length > 0 ? `${t}<span class='bold'>${a}</span>` : `${t}*`).replace(i, (e,t,a)=>a.length > 0 ? `${t}<span class='strikethrough'>${a}</span>` : `${t}-`).replace(o, (e,t,a)=>a.length > 0 ? `${t}<span class='underline'>${a}</span>` : `${t}_`).replace(s, (e,t,a)=>a.length > 0 ? `${t}<span class='code'>${a}</span>` : `${t}\``)
        }
        function u(e) {
            return 0 === e.length ? "" : e[0].toUpperCase() + e.slice(1).toLowerCase()
        }
        function d(e, t) {
            if (0 === e.length)
                return e;
            if (1 === e.length)
                switch (t) {
                case a.CaseStyle.PascalCase:
                    return e.toUpperCase();
                default:
                    return e.toLowerCase()
                }
            let i = t === a.CaseStyle.PascalCase ? e[0].toUpperCase() : e[0].toLowerCase();
            for (let n = 1; n < e.length; n++) {
                if ("-" === e[n] || "_" === e[n])
                    switch (t) {
                    case a.CaseStyle.PascalCase:
                    case a.CaseStyle.CamelCase:
                        i += e[++n].toUpperCase();
                        continue;
                    case a.CaseStyle.SnakeCase:
                        i += "_";
                        continue;
                    case a.CaseStyle.KebabCase:
                        i += "-";
                        continue
                    }
                else if (e[n] === e[n].toUpperCase())
                    switch (t) {
                    case a.CaseStyle.SnakeCase:
                        i += `_${e[n].toLowerCase()}`;
                        continue;
                    case a.CaseStyle.KebabCase:
                        i += `-${e[n].toLowerCase()}`;
                        continue
                    }
                i += e[n]
            }
            return i
        }
        e.parseMarkup = l,
        e.capitalizeFirstLetter = u,
        e.formatCaseStyle = d;
        const p = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;",
            "/": "&#x2F;",
            "`": "&#x60;",
            "=": "&#x3D;"
        };
        function c(e) {
            return String(e).replace(/[&<>"'`=\/]/g, e=>p[e])
        }
        function m(e) {
            return String(e).replace(/<.*>/g, "")
        }
        function h(e, t, a=[]) {
            const i = {};
            for (const n in e) {
                const o = d(n, t);
                i[0 === a.length || a.includes(o) ? o : n] = e[n]
            }
            return i
        }
        function y(e) {
            return e.replace(/(\.\.\/)+/, "")
        }
        function g(e) {
            return encodeURIComponent(e).replace(/%2F/g, "/")
        }
        function f(e=new Date) {
            return [e.getFullYear(), `${101 + e.getMonth()}`.slice(-2), `${100 + e.getDate()}`.slice(-2), "-", `${100 + e.getHours()}`.slice(-2), `${100 + e.getMinutes()}`.slice(-2)].join("")
        }
        e.escapeHTML = c,
        e.stripHTML = m,
        e.fixObjectCaseStyle = h,
        e.stripParentDirectoryAccessorsFromPath = y,
        e.encodeURIComponentPath = g,
        e.generateTimestamp = f
    }(n || (n = {})),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/TranslationsProvider", ["require", "exports", "Enums", "language/Dictionaries", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Objects", "utilities/string/Strings"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l {
        constructor(e) {
            this.dictionaries = new Map,
            this.pluralizationRules = {
                pluralRules: [],
                singularRules: [],
                uncountables: [],
                irregularRules: [],
                articleRules: []
            },
            this.language = e
        }
        getTranslation(e, t) {
            const a = this.dictionaries.get(e);
            return a && a.get(t)
        }
        setDictionary(e, t) {
            return this.dictionaries.set(s.default.formatCaseStyle(e, a.CaseStyle.PascalCase), r.default.entries(t).map(([t,a])=>o.tuple(this.getEntryName(e, t), (Array.isArray(a) ? a : [a]).map(e=>"string" == typeof e ? e.replace(/\t/g, "") : void 0))).collect(n.default.toMap)),
            this
        }
        setIrregularRules(...e) {
            return this.pluralizationRules.irregularRules = e,
            this
        }
        setPluralizationRules(...e) {
            return this.pluralizationRules.pluralRules = e.map(([e,t])=>o.tuple(u(e), t)),
            this
        }
        setSingularizationRules(...e) {
            return this.pluralizationRules.singularRules = e.map(([e,t])=>o.tuple(u(e), t)),
            this
        }
        setUncountableRules(...e) {
            return this.pluralizationRules.uncountables = e.map(u),
            this
        }
        setArticleRules(...e) {
            return this.pluralizationRules.articleRules = e.map(([e,t,a])=>o.tuple(e, u(t), a)),
            this
        }
        getEntryName(e, t) {
            if (!isNaN(+t)) {
                const a = i.default[i.Dictionary[e]];
                t = a && a !== i.SYMBOL_ANY_DICTIONARY ? a[+t] : t
            }
            return s.default.formatCaseStyle(t, a.CaseStyle.PascalCase)
        }
    }
    function u(e) {
        return e instanceof RegExp ? e : new RegExp(e.endsWith("/") && e.startsWith("/") ? e.slice(1, -1) : `\\b${e}$`)
    }
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/IMod", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Unload = 0] = "Unload",
        e[e.Uninitialize = 1] = "Uninitialize",
        e[e.PreInitialize = 2] = "PreInitialize",
        e[e.PreLoad = 3] = "PreLoad",
        e[e.Unallocate = 4] = "Unallocate",
        e[e.Setup = 5] = "Setup"
    }(a = t.ModEvent || (t.ModEvent = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("command/ICommand", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("item/Items", ["require", "exports", "action/IAction", "creature/ICreature", "Enums"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.itemDescriptions = {},
    t.default = t.itemDescriptions,
    t.itemGroupDescriptions = {};
    for (let e = n.ItemTypeGroup.Invalid + 1; e < n.ItemTypeGroup.Last; e++)
        t.itemGroupDescriptions[e] = {
            types: new Array,
            default: n.ItemType.None
        };
    function o(e, ...a) {
        for (const i of a)
            t.itemGroupDescriptions[i].types.push(e)
    }
    function r(e, t, a, i=0, n=!1) {
        return {
            type: e,
            requiredAmount: t,
            consumedAmount: a,
            disassembleAmount: i,
            ignoreWeight: n
        }
    }
    t.itemGroupDescriptions[n.ItemTypeGroup.Sharpened].default = n.ItemType.SharpRock,
    t.itemGroupDescriptions[n.ItemTypeGroup.Carbon].default = n.ItemType.Charcoal,
    t.itemGroupDescriptions[n.ItemTypeGroup.Arrow].default = n.ItemType.WoodenArrow,
    t.itemGroupDescriptions[n.ItemTypeGroup.CookingEquipment].default = n.ItemType.WoodenTongs,
    t.itemGroupDescriptions[n.ItemTypeGroup.Fuel].default = n.ItemType.Log,
    t.itemGroupDescriptions[n.ItemTypeGroup.Medicinal].default = n.ItemType.MilkThistleFlowers,
    t.itemGroupDescriptions[n.ItemTypeGroup.Meat].default = n.ItemType.CookedMeat,
    t.itemGroupDescriptions[n.ItemTypeGroup.Food].default = n.ItemType.ButtonMushrooms,
    t.itemGroupDescriptions[n.ItemTypeGroup.Bait].default = n.ItemType.Earthworm,
    t.itemGroupDescriptions[n.ItemTypeGroup.Liquid].default = n.ItemType.WaterskinOfPurifiedFreshWater,
    t.itemGroupDescriptions[n.ItemTypeGroup.Treasure].default = n.ItemType.GoldCoins,
    t.itemGroupDescriptions[n.ItemTypeGroup.Rock].default = n.ItemType.LargeRock,
    t.itemGroupDescriptions[n.ItemTypeGroup.Compost].default = n.ItemType.Leaves,
    t.itemGroupDescriptions[n.ItemTypeGroup.Fabric].default = n.ItemType.WovenFabric,
    t.itemGroupDescriptions[n.ItemTypeGroup.Needle].default = n.ItemType.BoneNeedle,
    t.itemGroupDescriptions[n.ItemTypeGroup.Cordage].default = n.ItemType.StrippedBark,
    t.itemGroupDescriptions[n.ItemTypeGroup.SharpenedRock].default = n.ItemType.SharpRock,
    t.itemGroupDescriptions[n.ItemTypeGroup.Container].default = n.ItemType.Waterskin,
    t.itemGroupDescriptions[n.ItemTypeGroup.Pole].default = n.ItemType.WoodenPole,
    t.itemGroupDescriptions[n.ItemTypeGroup.LightSource].default = n.ItemType.BarkTorch,
    t.itemGroupDescriptions[n.ItemTypeGroup.Repair].default = n.ItemType.Grindstone,
    t.itemGroupDescriptions[n.ItemTypeGroup.Tongs].default = n.ItemType.WoodenTongs,
    t.itemGroupDescriptions[n.ItemTypeGroup.Hammer].default = n.ItemType.StoneHammer,
    t.itemGroupDescriptions[n.ItemTypeGroup.Preservative].default = n.ItemType.SlimeGelatin,
    t.itemGroupDescriptions[n.ItemTypeGroup.Reinforce].default = n.ItemType.AnimalGlue,
    t.itemGroupDescriptions[n.ItemTypeGroup.GlassBottleOfPotableWater].default = n.ItemType.GlassBottleOfPurifiedFreshWater,
    t.itemGroupDescriptions[n.ItemTypeGroup.Bullet].default = n.ItemType.StoneBullet,
    t.itemGroupDescriptions[n.ItemTypeGroup.Transmogrify].default = n.ItemType.MagicalEssence,
    t.itemGroupDescriptions[n.ItemTypeGroup.WaterskinOfPotableWater].default = n.ItemType.WaterskinOfPurifiedFreshWater,
    t.itemGroupDescriptions[n.ItemTypeGroup.Pulp].default = n.ItemType.ShreddedPaper,
    t.itemGroupDescriptions[n.ItemTypeGroup.ClayJugOfPotableWater].default = n.ItemType.ClayJugOfPurifiedFreshWater,
    t.itemGroupDescriptions[n.ItemTypeGroup.Powder].default = n.ItemType.PileOfAsh,
    t.itemGroupDescriptions[n.ItemTypeGroup.Equipment].default = n.ItemType.TatteredPants,
    t.itemGroupDescriptions[n.ItemTypeGroup.Firemaking].default = n.ItemType.HandDrill,
    t.itemGroupDescriptions[n.ItemTypeGroup.Bedding].default = n.ItemType.LeafBedroll,
    t.itemGroupDescriptions[n.ItemTypeGroup.Tool].default = n.ItemType.StoneAxe,
    t.itemGroupDescriptions[n.ItemTypeGroup.Weapon].default = n.ItemType.WoodenSpear,
    t.itemGroupDescriptions[n.ItemTypeGroup.Health].default = n.ItemType.Tourniquet,
    t.itemGroupDescriptions[n.ItemTypeGroup.Travel].default = n.ItemType.Raft,
    t.itemGroupDescriptions[n.ItemTypeGroup.Housing].default = n.ItemType.WoodenWall,
    t.itemGroupDescriptions[n.ItemTypeGroup.Heating].default = n.ItemType.StoneCampfire,
    t.itemGroupDescriptions[n.ItemTypeGroup.Storage].default = n.ItemType.SmallBag,
    t.itemGroupDescriptions[n.ItemTypeGroup.Trap].default = n.ItemType.Snare,
    t.itemGroupDescriptions[n.ItemTypeGroup.Other].default = n.ItemType.String,
    t.itemGroupDescriptions[n.ItemTypeGroup.RawMeat].default = n.ItemType.RawMeat,
    t.itemGroupDescriptions[n.ItemTypeGroup.CookedMeat].default = n.ItemType.CookedMeat,
    t.itemGroupDescriptions[n.ItemTypeGroup.ContainerOfSeawater].default = n.ItemType.WaterskinOfSeawater,
    t.itemGroupDescriptions[n.ItemTypeGroup.ContainerOfDesalinatedWater].default = n.ItemType.WaterskinOfDesalinatedWater,
    t.itemGroupDescriptions[n.ItemTypeGroup.ContainerOfMedicinalWater].default = n.ItemType.WaterskinOfMedicinalWater,
    t.itemGroupDescriptions[n.ItemTypeGroup.ContainerOfPurifiedFreshWater].default = n.ItemType.WaterskinOfPurifiedFreshWater,
    t.itemGroupDescriptions[n.ItemTypeGroup.ContainerOfUnpurifiedFreshWater].default = n.ItemType.WaterskinOfPurifiedFreshWater,
    t.itemGroupDescriptions[n.ItemTypeGroup.Campfire].default = n.ItemType.StoneCampfire,
    t.itemGroupDescriptions[n.ItemTypeGroup.Furnace].default = n.ItemType.StoneFurnace,
    t.itemGroupDescriptions[n.ItemTypeGroup.Kiln].default = n.ItemType.StoneKiln,
    t.itemGroupDescriptions[n.ItemTypeGroup.WaterStill].default = n.ItemType.StoneKiln,
    t.itemGroupDescriptions[n.ItemTypeGroup.Anvil].default = n.ItemType.StoneAnvil,
    t.itemGroupDescriptions[n.ItemTypeGroup.Seed].default = n.ItemType.BeggartickSeeds,
    t.itemGroupDescriptions[n.ItemTypeGroup.Fruit].default = n.ItemType.Raspberries,
    t.itemGroupDescriptions[n.ItemTypeGroup.Milk].default = n.ItemType.WaterskinOfGoatMilk,
    t.itemGroupDescriptions[n.ItemTypeGroup.Vegetable].default = n.ItemType.Chives,
    t.itemGroupDescriptions[n.ItemTypeGroup.Tinder].default = n.ItemType.WoodenShavings,
    t.itemGroupDescriptions[n.ItemTypeGroup.Bone].default = n.ItemType.Bone,
    t.itemGroupDescriptions[n.ItemTypeGroup.Kindling].default = n.ItemType.Twigs,
    t.itemGroupDescriptions[n.ItemTypeGroup.MortarAndPestle].default = n.ItemType.WoodenMortarAndPestle,
    t.itemGroupDescriptions[n.ItemTypeGroup.Book].default = n.ItemType.Journal,
    t.itemGroupDescriptions[n.ItemTypeGroup.CoconutContainerOfPotableWater].default = n.ItemType.CoconutContainerOfPurifiedFreshWater,
    t.itemGroupDescriptions[n.ItemTypeGroup.SandCastFlask].default = n.ItemType.WoodenSandCastFlask,
    t.itemGroupDescriptions[n.ItemTypeGroup.Glue].default = n.ItemType.AnimalGlue,
    t.itemGroupDescriptions[n.ItemTypeGroup.FireStarter].default = n.ItemType.LitPoleTorch,
    t.itemGroupDescriptions[n.ItemTypeGroup.Sand].default = n.ItemType.PileOfBeachSand,
    t.itemGroupDescriptions[n.ItemTypeGroup.Cookware].default = n.ItemType.CopperBakingTray,
    t.RecipeComponent = r,
    t.itemDescriptions[n.ItemType.Copal] = {
        weight: .5,
        onBurn: [n.ItemType.MeltedCopal],
        worth: 100
    },
    t.itemDescriptions[n.ItemType.AnimalSkull] = {
        weight: 1.5,
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        dismantle: {
            items: [[n.ItemType.BoneFragments, 2]],
            required: n.ItemTypeGroup.Hammer
        },
        worth: 15
    },
    t.itemDescriptions[n.ItemType.StoneArrow] = {
        recipe: {
            components: [r(n.ItemType.Feather, 1, 1, 1), r(n.ItemType.StoneArrowhead, 1, 1, 1), r(n.ItemType.ArrowShaft, 1, 1, 1), r(n.ItemTypeGroup.Cordage, 1, 1, 1)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Intermediate,
            reputation: -50
        },
        disassemble: !0,
        attack: 2,
        damageType: n.DamageType.Piercing,
        durability: 15,
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.StoneArrow, n.ItemTypeGroup.Arrow),
    t.itemDescriptions[n.ItemType.StoneArrowhead] = {
        reducedWeight: 1.5,
        minimumWeight: .5,
        use: [a.ActionType.Carve],
        recipe: {
            components: [r(n.ItemTypeGroup.SharpenedRock, 2, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        damageType: n.DamageType.Piercing,
        worth: 15
    },
    o(n.ItemType.StoneArrowhead, n.ItemTypeGroup.Sharpened),
    t.itemDescriptions[n.ItemType.PileOfAsh] = {
        reducedWeight: .1,
        use: [a.ActionType.SetDown, a.ActionType.SmotherFire],
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.Ash,
            [a.ActionType.SmotherFire]: n.TerrainType.Ash
        },
        worth: 5
    },
    o(n.ItemType.PileOfAsh, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.BarkLeggings] = {
        durability: 20,
        equip: n.EquipType.Legs,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Blunt,1),new n.Vulnerabilities(n.DamageType.Fire,2,n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TreeBark, 4, 4, 4), r(n.ItemType.String, 2, 2, 2)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Intermediate,
            reputation: -75
        },
        disassemble: !0,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.BarkLeggings, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.BarkShield] = {
        durability: 20,
        equip: n.EquipType.Held,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Blunt,1),new n.Vulnerabilities(n.DamageType.Fire,2,n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TreeBark, 4, 4, 4), r(n.ItemType.String, 2, 2, 2)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Intermediate,
            reputation: -75
        },
        disassemble: !0,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.BarkShield, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.BarkTunic] = {
        durability: 20,
        equip: n.EquipType.Chest,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Blunt,1),new n.Vulnerabilities(n.DamageType.Fire,2,n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TreeBark, 6, 6, 6), r(n.ItemType.String, 2, 2, 2)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Intermediate,
            reputation: -75
        },
        disassemble: !0,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.BarkTunic, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.Bone] = {
        weight: .5,
        durability: 15,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Blunt,
        use: [a.ActionType.Gather],
        onBurn: [n.ItemType.PileOfAsh],
        worth: 10,
        dismantle: {
            items: [[n.ItemType.BoneFragments, 1]],
            required: n.ItemTypeGroup.Hammer
        }
    },
    o(n.ItemType.Bone, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Bone),
    t.itemDescriptions[n.ItemType.Branch] = {
        weight: .8,
        use: [a.ActionType.StokeFire, a.ActionType.Gather],
        equip: n.EquipType.Held,
        attack: 1,
        damageType: n.DamageType.Blunt,
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.Charcoal, n.ItemType.PileOfAsh, n.ItemType.Charcoal],
        dismantle: {
            items: [[n.ItemType.StrippedBark, 1], [n.ItemType.WoodenPole, 1], [n.ItemType.Leaves, 1], [n.ItemType.Twigs, 1]],
            required: n.ItemTypeGroup.Sharpened,
            skill: n.SkillType.Woodworking
        },
        onUse: {
            [a.ActionType.StokeFire]: 14
        },
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.Branch, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.CactusSpines] = {
        weight: .2,
        onBurn: [n.ItemType.PileOfAsh],
        damageType: n.DamageType.Piercing,
        worth: 5
    },
    t.itemDescriptions[n.ItemType.Charcoal] = {
        weight: .3,
        use: [a.ActionType.StokeFire],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.StokeFire]: 4
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.Charcoal, n.ItemTypeGroup.Carbon, n.ItemTypeGroup.Fuel, n.ItemTypeGroup.Medicinal),
    t.itemDescriptions[n.ItemType.CobblestoneFlooring] = {
        use: [a.ActionType.SetDown],
        recipe: {
            components: [r(n.ItemType.Stones, 5, 5, 5)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        durability: 25,
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.CobblestoneFlooring
        },
        worth: 25
    },
    o(n.ItemType.CobblestoneFlooring, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.CookedMeat] = {
        use: [a.ActionType.Eat],
        decayMax: 4750,
        decaysInto: n.ItemType.RottenMeat,
        recipe: {
            components: [r(n.ItemType.RawMeat, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Intermediate,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 10, 8, -2]
        },
        worth: 15
    },
    o(n.ItemType.CookedMeat, n.ItemTypeGroup.Meat, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.Earthworm] = {
        weight: .1,
        use: [a.ActionType.Eat],
        decayMax: 2750,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [0, 4, 1, 0]
        },
        worth: 5
    },
    o(n.ItemType.Earthworm, n.ItemTypeGroup.Bait),
    t.itemDescriptions[n.ItemType.Feather] = {
        weight: .1,
        use: [a.ActionType.StokeFire],
        onUse: {
            [a.ActionType.StokeFire]: 2
        },
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.Feather, n.ItemTypeGroup.Tinder),
    t.itemDescriptions[n.ItemType.Fertilizer] = {
        recipe: {
            components: [r(n.ItemType.PileOfAsh, 1, 1), r(n.ItemType.BoneMeal, 1, 1), r(n.ItemType.PileOfCompost, 1, 1)],
            skill: n.SkillType.Gardening,
            level: n.RecipeLevel.Intermediate,
            reputation: 50
        },
        use: [a.ActionType.SmotherFire],
        worth: 25
    },
    t.itemDescriptions[n.ItemType.WaterskinOfSeawater] = {
        inheritWeight: n.ItemType.Waterskin,
        durability: 20,
        returnOnUse: [n.ItemType.Waterskin, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        flammable: !0,
        use: [a.ActionType.Pour, a.ActionType.PourOnYourself, a.ActionType.DrinkItem],
        onUse: {
            [a.ActionType.DrinkItem]: [0, -15, 1, -2]
        },
        worth: 50
    },
    o(n.ItemType.WaterskinOfSeawater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfSeawater),
    t.itemDescriptions[n.ItemType.FirePlough] = {
        durability: 45,
        use: [a.ActionType.StartFire],
        recipe: {
            components: [r(n.ItemType.WoodenPole, 1, 1, 1), r(n.ItemType.Log, 1, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Camping,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Sharpened],
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.FirePlough, n.ItemTypeGroup.Firemaking, n.ItemTypeGroup.FireStarter),
    t.itemDescriptions[n.ItemType.BeggartickSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Beggarticks,
            [a.ActionType.Eat]: [1, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.BeggartickSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.Fossil] = {
        weight: .8,
        worth: 100
    },
    o(n.ItemType.Fossil, n.ItemTypeGroup.Carbon),
    t.itemDescriptions[n.ItemType.GoldCoins] = {
        weight: 2,
        worth: 1e3
    },
    o(n.ItemType.GoldCoins, n.ItemTypeGroup.Treasure),
    t.itemDescriptions[n.ItemType.GoldenChalice] = {
        weight: 3,
        worth: 1e3
    },
    o(n.ItemType.GoldenChalice, n.ItemTypeGroup.Treasure),
    t.itemDescriptions[n.ItemType.GoldenRing] = {
        weight: .3,
        worth: 1e3
    },
    o(n.ItemType.GoldenRing, n.ItemTypeGroup.Treasure),
    t.itemDescriptions[n.ItemType.GoldenSword] = {
        weight: 5,
        durability: 15,
        equip: n.EquipType.Held,
        attack: 9,
        damageType: n.DamageType.Piercing | n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather],
        repairable: !1,
        worth: 1500
    },
    o(n.ItemType.GoldenSword, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Treasure),
    t.itemDescriptions[n.ItemType.GrassSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Grass,
            [a.ActionType.Eat]: [1, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.GrassSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.IronOre] = {
        weight: .7,
        worth: 25
    },
    t.itemDescriptions[n.ItemType.WoodenDowels] = {
        weight: .1,
        use: [a.ActionType.StokeFire],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.StokeFire]: 2
        },
        dismantle: {
            items: [[n.ItemType.WoodenShavings, 1]],
            required: n.ItemTypeGroup.Sharpened,
            skill: n.SkillType.Woodworking
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.WoodenDowels, n.ItemTypeGroup.Kindling),
    t.itemDescriptions[n.ItemType.LargeRock] = {
        weight: 3.2,
        dismantle: {
            items: [[n.ItemType.Stones, 3]],
            required: n.ItemTypeGroup.Hammer,
            skill: n.SkillType.Stonecrafting
        },
        worth: 5
    },
    o(n.ItemType.LargeRock, n.ItemTypeGroup.Rock),
    t.itemDescriptions[n.ItemType.LeafBedroll] = {
        durability: 25,
        use: [a.ActionType.Rest, a.ActionType.Sleep, a.ActionType.PlaceDown],
        recipe: {
            components: [r(n.ItemType.Leaves, 10, 10, 10), r(n.ItemTypeGroup.Cordage, 2, 2, 2)],
            skill: n.SkillType.Camping,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        hasSleepImage: !0,
        flammable: !0,
        worth: 50,
        doodad: {
            isFlammable: !0,
            repairItem: n.ItemType.LeafBedroll,
            particles: {
                r: 85,
                g: 168,
                b: 41
            },
            reduceDurabilityOnGather: !0
        }
    },
    o(n.ItemType.LeafBedroll, n.ItemTypeGroup.Bedding),
    t.itemDescriptions[n.ItemType.LeatherHide] = {
        weight: 1.2,
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        worth: 15,
        dismantle: {
            items: [[n.ItemType.StrippedLeather, 3]],
            required: n.ItemTypeGroup.Sharpened,
            skill: n.SkillType.Tailoring
        },
        flammable: !0
    },
    t.itemDescriptions[n.ItemType.Leaves] = {
        use: [a.ActionType.StokeFire],
        weight: .1,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.StokeFire]: 2
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.Leaves, n.ItemTypeGroup.Compost, n.ItemTypeGroup.Tinder),
    t.itemDescriptions[n.ItemType.Limestone] = {
        weight: 2.5,
        worth: 25
    },
    t.itemDescriptions[n.ItemType.Log] = {
        weight: 5,
        use: [a.ActionType.StokeFire],
        onBurn: [n.ItemType.Charcoal, n.ItemType.Charcoal, n.ItemType.Charcoal, n.ItemType.Charcoal, n.ItemType.Charcoal, n.ItemType.Charcoal, n.ItemType.Charcoal],
        dismantle: {
            items: [[n.ItemType.TreeBark, 2], [n.ItemType.WoodenPole, 5]],
            required: n.ItemTypeGroup.Sharpened,
            skill: n.SkillType.Woodworking
        },
        onUse: {
            [a.ActionType.StokeFire]: 28
        },
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.Log, n.ItemTypeGroup.Fuel),
    t.itemDescriptions[n.ItemType.StoneMortarAndPestle] = {
        reducedWeight: 2,
        recipe: {
            components: [r(n.ItemType.SmoothRock, 2, 2)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        durability: 20,
        worth: 10
    },
    o(n.ItemType.StoneMortarAndPestle, n.ItemTypeGroup.Tool, n.ItemTypeGroup.MortarAndPestle),
    t.itemDescriptions[n.ItemType.ButtonMushrooms] = {
        weight: .3,
        use: [a.ActionType.Eat, a.ActionType.Plant],
        skillUse: n.SkillType.Mycology,
        decayMax: 19e3,
        doodadType: n.DoodadType.ButtonMushrooms,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [3, 4, 2, -1],
            [a.ActionType.Plant]: n.DoodadType.ButtonMushrooms
        },
        worth: 5
    },
    o(n.ItemType.ButtonMushrooms, n.ItemTypeGroup.Food),
    t.itemDescriptions[n.ItemType.Nopal] = {
        weight: .3,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 8750,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [0, 6, 2, 1]
        },
        worth: 5
    },
    o(n.ItemType.Nopal, n.ItemTypeGroup.Food, n.ItemTypeGroup.Vegetable),
    t.itemDescriptions[n.ItemType.Peat] = {
        weight: .5,
        use: [a.ActionType.StokeFire],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.StokeFire]: 24
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.Peat, n.ItemTypeGroup.Fuel, n.ItemTypeGroup.Compost),
    t.itemDescriptions[n.ItemType.Sandstone] = {
        weight: 2,
        worth: 5
    },
    t.itemDescriptions[n.ItemType.PileOfGravel] = {
        weight: 4.1,
        use: [a.ActionType.SetDown, a.ActionType.SmotherFire],
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.Gravel,
            [a.ActionType.SmotherFire]: n.TerrainType.Gravel
        },
        dismantle: {
            items: [[n.ItemType.Stones, 1], [n.ItemType.RefinedSand, 1]]
        },
        worth: 5
    },
    t.itemDescriptions[n.ItemType.PileOfBeachSand] = {
        weight: 3,
        use: [a.ActionType.SetDown, a.ActionType.SmotherFire],
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.BeachSand,
            [a.ActionType.SmotherFire]: n.TerrainType.BeachSand
        },
        worth: 5
    },
    o(n.ItemType.PileOfBeachSand, n.ItemTypeGroup.Sand),
    t.itemDescriptions[n.ItemType.WoodenArrow] = {
        recipe: {
            components: [r(n.ItemType.WoodenPole, 1, 1, 1), r(n.ItemType.Feather, 1, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Sharpened],
        attack: 1,
        damageType: n.DamageType.Piercing,
        durability: 10,
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.WoodenArrow, n.ItemTypeGroup.Arrow),
    t.itemDescriptions[n.ItemType.StoneAxe] = {
        durability: 50,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.SharpenedRock, 2, 2, 2)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: -75
        },
        disassemble: !0,
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.StoneAxe, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.Bandage] = {
        use: [a.ActionType.Heal, a.ActionType.HealOther],
        skillUse: n.SkillType.Anatomy,
        recipe: {
            components: [r(n.ItemTypeGroup.Fabric, 1, 1, 1)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        disassemble: !0,
        onUse: {
            [a.ActionType.Heal]: [12, 0, 0, 0],
            [a.ActionType.HealOther]: 12
        },
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.Bandage, n.ItemTypeGroup.Health),
    t.itemDescriptions[n.ItemType.WovenFabric] = {
        recipe: {
            components: [r(n.ItemTypeGroup.Cordage, 8, 8, 8), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        flammable: !0,
        worth: 20
    },
    o(n.ItemType.WovenFabric, n.ItemTypeGroup.Fabric),
    t.itemDescriptions[n.ItemType.CactusNeedle] = {
        recipe: {
            components: [r(n.ItemType.CactusSpines, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        damageType: n.DamageType.Piercing,
        worth: 5
    },
    o(n.ItemType.CactusNeedle, n.ItemTypeGroup.Needle),
    t.itemDescriptions[n.ItemType.StoneShovel] = {
        durability: 50,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Dig, a.ActionType.Gather, a.ActionType.GatherTreasure, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.String, 2, 2, 2), r(n.ItemTypeGroup.SharpenedRock, 1, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        disassemble: !0,
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.StoneShovel, n.ItemTypeGroup.Tool, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.WoodenSpear] = {
        durability: 10,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.WoodenPole, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Simple,
            reputation: -50
        },
        use: [a.ActionType.Gather],
        burnsLike: [n.ItemType.WoodenPole],
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.WoodenSpear, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.Suture] = {
        use: [a.ActionType.Heal, a.ActionType.HealOther],
        skillUse: n.SkillType.Anatomy,
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Needle, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        onUse: {
            [a.ActionType.Heal]: [6, 0, 0, 0],
            [a.ActionType.HealOther]: 6
        },
        damageType: n.DamageType.Piercing,
        flammable: !0,
        worth: 15
    },
    o(n.ItemType.Suture, n.ItemTypeGroup.Health),
    t.itemDescriptions[n.ItemType.Raft] = {
        durability: 1e3,
        use: [a.ActionType.Paddle],
        recipe: {
            components: [r(n.ItemType.Rope, 2, 2, 2), r(n.ItemType.Log, 3, 3, 3), r(n.ItemType.BoatPaddle, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        disassemble: !0,
        damageModifier: 25,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.Raft, n.ItemTypeGroup.Travel),
    t.itemDescriptions[n.ItemType.RawMeat] = {
        weight: .8,
        use: [a.ActionType.Eat],
        decayMax: 2750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedMeat],
        onUse: {
            [a.ActionType.Eat]: [-2, 2, 7, -2]
        },
        worth: 5
    },
    o(n.ItemType.RawMeat, n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.Raspberries] = {
        weight: .2,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 14e3,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 2, 2, 1]
        },
        dismantle: {
            items: [[n.ItemType.RaspberrySeeds, 1]],
            skill: n.SkillType.Botany
        },
        worth: 5
    },
    o(n.ItemType.Raspberries, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.FlyAmanita] = {
        weight: .3,
        use: [a.ActionType.Eat, a.ActionType.Plant],
        skillUse: n.SkillType.Mycology,
        decayMax: 19e3,
        doodadType: n.DoodadType.FlyAmanita,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-5, 8, 2, -1],
            [a.ActionType.Plant]: n.DoodadType.FlyAmanita
        },
        worth: 5
    },
    o(n.ItemType.FlyAmanita, n.ItemTypeGroup.Food),
    t.itemDescriptions[n.ItemType.Rope] = {
        recipe: {
            components: [r(n.ItemType.String, 4, 4, 4)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        flammable: !0,
        worth: 15
    },
    o(n.ItemType.Rope, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.MapleSeeds] = {
        weight: .1,
        skillUse: n.SkillType.Botany,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 2, 1, -1],
            [a.ActionType.Plant]: n.DoodadType.MapleTree
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.MapleSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.Badderlocks] = {
        weight: .2,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 19e3,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [0, 2, 1, -1]
        },
        worth: 5
    },
    o(n.ItemType.Badderlocks, n.ItemTypeGroup.Cordage, n.ItemTypeGroup.Food),
    t.itemDescriptions[n.ItemType.SharpGlass] = {
        reducedWeight: 2.3,
        use: [a.ActionType.Carve],
        durability: 15,
        recipe: {
            components: [r(n.ItemTypeGroup.Sand, 1, 1)],
            skill: n.SkillType.Glassblowing,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: -25
        },
        damageType: n.DamageType.Piercing | n.DamageType.Slashing,
        worth: 10
    },
    o(n.ItemType.SharpGlass, n.ItemTypeGroup.Sharpened),
    t.itemDescriptions[n.ItemType.SharpRock] = {
        reducedWeight: 1.2,
        durability: 10,
        use: [a.ActionType.Carve, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.LargeRock, 2, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Simple,
            reputation: -25
        },
        dismantle: {
            items: [[n.ItemType.Stones, 1]],
            required: n.ItemTypeGroup.Hammer
        },
        damageType: n.DamageType.Piercing | n.DamageType.Slashing,
        worth: 5
    },
    o(n.ItemType.SharpRock, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.SharpenedRock),
    t.itemDescriptions[n.ItemType.Skullcap] = {
        durability: 15,
        equip: n.EquipType.Head,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1),new n.Vulnerabilities),
        recipe: {
            components: [r(n.ItemType.AnimalSkull, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Simple,
            reputation: -75
        },
        burnsLike: [n.ItemType.AnimalSkull],
        worth: 20
    },
    o(n.ItemType.Skullcap, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.SmoothRock] = {
        recipe: {
            components: [r(n.ItemType.LargeRock, 1, 1), r(n.ItemTypeGroup.SharpenedRock, 1, 1, 0, !0)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Simple,
            reputation: -25
        },
        dismantle: {
            items: [[n.ItemType.Stones, 2]],
            required: n.ItemTypeGroup.Hammer
        },
        worth: 5
    },
    o(n.ItemType.SmoothRock, n.ItemTypeGroup.Rock),
    t.itemDescriptions[n.ItemType.Soil] = {
        weight: 3,
        use: [a.ActionType.SetDown, a.ActionType.SmotherFire],
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.Dirt,
            [a.ActionType.SmotherFire]: n.TerrainType.Dirt
        },
        worth: 5
    },
    t.itemDescriptions[n.ItemType.StoneSpear] = {
        durability: 25,
        equip: n.EquipType.Held,
        attack: 4,
        damageType: n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.SharpenedRock, 1, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: -100
        },
        disassemble: !0,
        use: [a.ActionType.Gather],
        flammable: !0,
        worth: 20
    },
    o(n.ItemType.StoneSpear, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.Stones] = {
        weight: 1,
        worth: 5
    },
    o(n.ItemType.Stones, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.StoneWall] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemTypeGroup.Rock, 8, 8, 8)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        disassemble: !0,
        durability: 25,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.StoneWall
        },
        worth: 50
    },
    o(n.ItemType.StoneWall, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.String] = {
        recipe: {
            components: [r(n.ItemTypeGroup.Cordage, 2, 2, 2)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        disassemble: !0,
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.String, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.StrippedBark] = {
        weight: .1,
        use: [a.ActionType.StokeFire],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.StokeFire]: 4
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.StrippedBark, n.ItemTypeGroup.Cordage),
    t.itemDescriptions[n.ItemType.TannedLeather] = {
        recipe: {
            components: [r(n.ItemType.Tannin, 1, 1, 0, !0), r(n.ItemType.LeatherHide, 1, 1)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        burnsLike: [n.ItemType.LeatherHide],
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.TannedLeather, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.Tannin] = {
        reducedWeight: .1,
        recipe: {
            components: [r(n.ItemType.TreeBark, 1, 1), r(n.ItemTypeGroup.MortarAndPestle, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.Tannin, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.MilkThistleSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.MilkThistles,
            [a.ActionType.Eat]: [2, 0, 1, 0]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.MilkThistleSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.TreeBark] = {
        weight: .2,
        use: [a.ActionType.StokeFire],
        onBurn: [n.ItemType.Charcoal],
        onUse: {
            [a.ActionType.StokeFire]: 8
        },
        dismantle: {
            items: [[n.ItemType.StrippedBark, 2]],
            required: n.ItemTypeGroup.Sharpened,
            skill: n.SkillType.Woodworking
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.TreeBark, n.ItemTypeGroup.Kindling),
    t.itemDescriptions[n.ItemType.HoneyFungus] = {
        weight: .3,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Mycology,
        decayMax: 19e3,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [0, 14, 3, -1]
        },
        worth: 5
    },
    o(n.ItemType.HoneyFungus, n.ItemTypeGroup.Food),
    t.itemDescriptions[n.ItemType.ClematisVine] = {
        weight: .3,
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.ClematisVine, n.ItemTypeGroup.Cordage),
    t.itemDescriptions[n.ItemType.Twigs] = {
        weight: .1,
        use: [a.ActionType.StokeFire],
        onBurn: [n.ItemType.Charcoal],
        onUse: {
            [a.ActionType.StokeFire]: 4
        },
        dismantle: {
            items: [[n.ItemType.WoodenShavings, 1]],
            required: n.ItemTypeGroup.Sharpened,
            skill: n.SkillType.Woodworking
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.Twigs, n.ItemTypeGroup.Kindling),
    t.itemDescriptions[n.ItemType.Waterskin] = {
        gather: {
            milk: n.ItemType.WaterskinOfGoatMilk,
            desalinated: n.ItemType.WaterskinOfDesalinatedWater,
            unpurified: n.ItemType.WaterskinOfUnpurifiedFreshWater,
            seawater: n.ItemType.WaterskinOfSeawater
        },
        use: [a.ActionType.GatherWater, a.ActionType.GatherMilk],
        recipe: {
            components: [r(n.ItemType.TannedLeather, 1, 1, 1), r(n.ItemType.String, 2, 2, 2), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        disassemble: !0,
        durability: 20,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.Waterskin, n.ItemTypeGroup.Container),
    t.itemDescriptions[n.ItemType.WoodenPole] = {
        weight: .3,
        durability: 10,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Blunt,
        use: [a.ActionType.Ignite, a.ActionType.Gather, a.ActionType.StokeFire, a.ActionType.Build],
        lit: n.ItemType.LitPoleTorch,
        onBurn: [n.ItemType.Charcoal],
        onUse: {
            [a.ActionType.StokeFire]: 4,
            [a.ActionType.Build]: n.DoodadType.PoleTorchStand
        },
        dismantle: {
            items: [[n.ItemType.WoodenDowels, 2]],
            required: n.ItemTypeGroup.Sharpened,
            skill: n.SkillType.Woodworking
        },
        worth: 5,
        flammable: !0
    },
    o(n.ItemType.WoodenPole, n.ItemTypeGroup.Pole, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.PeatBandage] = {
        use: [a.ActionType.Heal, a.ActionType.HealOther],
        skillUse: n.SkillType.Anatomy,
        recipe: {
            components: [r(n.ItemType.Bandage, 1, 1, 1), r(n.ItemType.Peat, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        onUse: {
            [a.ActionType.Heal]: [15, 0, 0, 0],
            [a.ActionType.HealOther]: 15
        },
        flammable: !0,
        worth: 30
    },
    o(n.ItemType.PeatBandage, n.ItemTypeGroup.Health),
    t.itemDescriptions[n.ItemType.Bow] = {
        durability: 15,
        use: [a.ActionType.Shoot],
        equip: n.EquipType.Held,
        twoHanded: !0,
        attack: 1,
        damageType: n.DamageType.Blunt,
        ranged: {
            range: 5,
            attack: 1
        },
        recipe: {
            components: [r(n.ItemType.WoodenPole, 1, 1, 1), r(n.ItemType.String, 1, 1, 1)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Intermediate,
            reputation: -75
        },
        disassemble: !0,
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.Bow, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.BowDrill] = {
        durability: 50,
        use: [a.ActionType.StartFire],
        recipe: {
            components: [r(n.ItemType.Bow, 1, 1, 1), r(n.ItemType.HandDrill, 1, 1, 1)],
            skill: n.SkillType.Camping,
            level: n.RecipeLevel.Intermediate,
            reputation: -50
        },
        disassemble: !0,
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.BowDrill, n.ItemTypeGroup.Firemaking, n.ItemTypeGroup.FireStarter),
    t.itemDescriptions[n.ItemType.FishingNet] = {
        durability: 50,
        ranged: {
            range: 3,
            attack: 0
        },
        use: [a.ActionType.Cast, a.ActionType.GatherTreasure],
        recipe: {
            components: [r(n.ItemType.String, 6, 6, 6), r(n.ItemType.Stones, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.FishingNet, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.RawCod] = {
        weight: .8,
        use: [a.ActionType.Eat],
        decayMax: 2750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedCod],
        onUse: {
            [a.ActionType.Eat]: [1, 2, 5, -1]
        },
        worth: 5
    },
    o(n.ItemType.RawCod, n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.CookedCod] = {
        use: [a.ActionType.Eat],
        decayMax: 4750,
        decaysInto: n.ItemType.RottenMeat,
        recipe: {
            components: [r(n.ItemType.RawCod, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 8, 6, -1]
        },
        worth: 15
    },
    o(n.ItemType.CookedCod, n.ItemTypeGroup.Meat, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.StoneCampfire] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemTypeGroup.Rock, 5, 5, 5)],
            skill: n.SkillType.Camping,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        disassemble: !0,
        durability: 20,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.StoneCampfire
        },
        worth: 25
    },
    o(n.ItemType.StoneCampfire, n.ItemTypeGroup.Firemaking, n.ItemTypeGroup.Heating, n.ItemTypeGroup.Campfire),
    t.itemDescriptions[n.ItemType.VineWhip] = {
        durability: 10,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Slashing,
        recipe: {
            components: [r(n.ItemType.ClematisVine, 2, 2)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Simple,
            reputation: -50
        },
        burnsLike: [n.ItemType.ClematisVine, n.ItemType.ClematisVine],
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.VineWhip, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.PileOfSnow] = {
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself, a.ActionType.SmotherFire],
        weight: .3,
        decayMax: 750,
        onBurn: [n.ItemType.None],
        onUse: {
            [a.ActionType.DrinkItem]: [-4, 16, 1, 8],
            [a.ActionType.SmotherFire]: n.TerrainType.ShallowFreshWater
        },
        worth: 5
    },
    o(n.ItemType.PileOfSnow, n.ItemTypeGroup.Liquid),
    t.itemDescriptions[n.ItemType.BarkTorch] = {
        durability: 15,
        attack: 2,
        damageType: n.DamageType.Blunt,
        equip: n.EquipType.Held,
        use: [a.ActionType.Ignite, a.ActionType.Build],
        isTorch: !0,
        lit: n.ItemType.LitBarkTorch,
        recipe: {
            components: [r(n.ItemType.StrippedBark, 5, 5), r(n.ItemTypeGroup.Pole, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        onUse: {
            [a.ActionType.Build]: n.DoodadType.BarkTorchStand
        },
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.BarkTorch, n.ItemTypeGroup.LightSource, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.LitBarkTorch] = {
        inheritWeight: n.ItemType.BarkTorch,
        durability: 15,
        equip: n.EquipType.Held,
        onEquipEffect: [n.OnEquipType.LightSource, 2],
        attack: 3,
        damageType: n.DamageType.Fire | n.DamageType.Blunt,
        use: [a.ActionType.StartFire, a.ActionType.Extinguish, a.ActionType.Build],
        isTorch: !0,
        revert: n.ItemType.BarkTorch,
        decayMax: 2e3,
        decaysInto: n.ItemType.Charcoal,
        repairable: !1,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.LitBarkTorchStand
        },
        burnsLike: [n.ItemType.BarkTorch],
        flammable: !0
    },
    o(n.ItemType.LitBarkTorch, n.ItemTypeGroup.FireStarter, n.ItemTypeGroup.LitTorch, n.ItemTypeGroup.Untradable),
    t.itemDescriptions[n.ItemType.HandDrill] = {
        durability: 10,
        use: [a.ActionType.StartFire],
        recipe: {
            components: [r(n.ItemType.WoodenPole, 2, 2, 1)],
            skill: n.SkillType.Camping,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        disassemble: !0,
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.HandDrill, n.ItemTypeGroup.Firemaking, n.ItemTypeGroup.FireStarter),
    t.itemDescriptions[n.ItemType.SmallBag] = {
        durability: 10,
        weightCapacity: 25,
        use: [a.ActionType.OpenContainer],
        equip: n.EquipType.Belt,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TannedLeather, 1, 1, 1), r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        disassemble: !0,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.SmallBag, n.ItemTypeGroup.Equipment, n.ItemTypeGroup.Storage),
    t.itemDescriptions[n.ItemType.Shale] = {
        weight: .8,
        use: [a.ActionType.Carve, a.ActionType.Harvest],
        damageType: n.DamageType.Slashing,
        worth: 5
    },
    o(n.ItemType.Shale, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.SharpenedRock),
    t.itemDescriptions[n.ItemType.SharpenedBone] = {
        reducedWeight: .1,
        use: [a.ActionType.Carve, a.ActionType.Gather],
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.BonePole, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Simple,
            reputation: -25
        },
        onBurn: [n.ItemType.PileOfAsh],
        worth: 5
    },
    o(n.ItemType.SharpenedBone, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Bone, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.Grindstone] = {
        use: [a.ActionType.Repair],
        recipe: {
            components: [r(n.ItemType.Sandstone, 2, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        worth: 10
    },
    o(n.ItemType.Grindstone, n.ItemTypeGroup.Repair, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.RawFishSteak] = {
        weight: .8,
        use: [a.ActionType.Eat],
        decayMax: 2750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedFishSteak],
        onUse: {
            [a.ActionType.Eat]: [1, 2, 6, -1]
        },
        worth: 5
    },
    o(n.ItemType.RawFishSteak, n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.CookedFishSteak] = {
        use: [a.ActionType.Eat],
        decayMax: 4750,
        decaysInto: n.ItemType.RottenMeat,
        recipe: {
            components: [r(n.ItemType.RawFishSteak, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 8, 6, -1]
        },
        worth: 15
    },
    o(n.ItemType.CookedFishSteak, n.ItemTypeGroup.Meat, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.WaterskinOfDesalinatedWater] = {
        inheritWeight: n.ItemType.Waterskin,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        durability: 20,
        returnOnUse: [n.ItemType.Waterskin, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        flammable: !0,
        recipe: {
            baseComponent: n.ItemType.WaterskinOfSeawater,
            components: [r(n.ItemType.Flask, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        onUse: {
            [a.ActionType.DrinkItem]: [2, 25, 1, 11]
        },
        worth: 75
    },
    o(n.ItemType.WaterskinOfDesalinatedWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.WaterskinOfPotableWater, n.ItemTypeGroup.ContainerOfDesalinatedWater),
    t.itemDescriptions[n.ItemType.BoatPaddle] = {
        durability: 15,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Blunt,
        recipe: {
            components: [r(n.ItemType.TreeBark, 2, 2, 2), r(n.ItemType.String, 2, 2, 2), r(n.ItemTypeGroup.Pole, 1, 1, 1)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        disassemble: !0,
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.BoatPaddle, n.ItemTypeGroup.Travel, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.BullBoat] = {
        use: [a.ActionType.TraverseTheSea],
        recipe: {
            components: [r(n.ItemType.WoodenPole, 8, 8, 8), r(n.ItemType.LeatherHide, 1, 1, 1), r(n.ItemType.Rope, 2, 2, 2), r(n.ItemType.BoatPaddle, 1, 1, 1)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        disassemble: !0,
        flammable: !0,
        worth: 100
    },
    o(n.ItemType.BullBoat, n.ItemTypeGroup.Travel),
    t.itemDescriptions[n.ItemType.RefinedSand] = {
        reducedWeight: 2.3,
        recipe: {
            components: [r(n.ItemTypeGroup.Sand, 1, 1), r(n.ItemTypeGroup.MortarAndPestle, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        onBurn: [n.ItemType.SharpGlass],
        worth: 10
    },
    o(n.ItemType.RefinedSand, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.Spyglass] = {
        reducedWeight: 2.5,
        attack: 1,
        damageType: n.DamageType.Blunt,
        equip: n.EquipType.Held,
        onEquipEffect: [n.OnEquipType.Telescopy, 20, 25],
        recipe: {
            components: [r(n.ItemType.Lens, 2, 2), r(n.ItemType.Log, 1, 1), r(n.ItemType.String, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        onBurn: [n.ItemType.Lens, n.ItemType.Lens, n.ItemType.Charcoal, n.ItemType.Charcoal, n.ItemType.Charcoal, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        durability: 2e3,
        damageModifier: 50,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.Spyglass, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.Flask] = {
        recipe: {
            components: [r(n.ItemType.ClayBlowpipe, 1, 0), r(n.ItemType.RefinedSand, 2, 2), r(n.ItemType.LimestonePowder, 2, 2, 0, !0)],
            skill: n.SkillType.Glassblowing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.LitFurnace,
            reputation: 25
        },
        durability: 5,
        worth: 40
    },
    o(n.ItemType.Flask, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.RawClay] = {
        weight: 2.5,
        use: [a.ActionType.SetDown, a.ActionType.SmotherFire],
        onBurn: [n.ItemType.ClayBrick],
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.Clay,
            [a.ActionType.SmotherFire]: n.TerrainType.Clay
        },
        worth: 5
    },
    t.itemDescriptions[n.ItemType.RawClayBlowpipe] = {
        reducedWeight: .5,
        recipe: {
            components: [r(n.ItemType.RawClay, 1, 1, 1), r(n.ItemTypeGroup.Pole, 1, 0)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        onBurn: [n.ItemType.ClayBlowpipe],
        worth: 5
    },
    o(n.ItemType.RawClayBlowpipe, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.ClayBlowpipe] = {
        reducedWeight: .5,
        recipe: {
            components: [r(n.ItemType.RawClayBlowpipe, 1, 1)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.LitKiln,
            reputation: 25
        },
        durability: 15,
        worth: 10
    },
    o(n.ItemType.ClayBlowpipe, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.LeatherBelt] = {
        durability: 25,
        equip: n.EquipType.Belt,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Fire,1),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TannedLeather, 1, 1, 1), r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Simple,
            reputation: -100
        },
        disassemble: !0,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.LeatherBelt, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.LeatherTunic] = {
        durability: 25,
        equip: n.EquipType.Chest,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Fire,1),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TannedLeather, 2, 2, 2), r(n.ItemType.String, 4, 4, 4), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Advanced,
            reputation: -100
        },
        disassemble: !0,
        flammable: !0,
        worth: 75
    },
    o(n.ItemType.LeatherTunic, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.LeatherBoots] = {
        durability: 25,
        equip: n.EquipType.Feet,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Fire,1),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TannedLeather, 2, 2, 2), r(n.ItemType.String, 2, 2, 2), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Advanced,
            reputation: -100
        },
        disassemble: !0,
        flammable: !0,
        worth: 75
    },
    o(n.ItemType.LeatherBoots, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.LeatherCap] = {
        durability: 25,
        equip: n.EquipType.Head,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Fire,1),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TannedLeather, 1, 1, 1), r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Intermediate,
            reputation: -100
        },
        disassemble: !0,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.LeatherCap, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.LeatherGorget] = {
        durability: 25,
        equip: n.EquipType.Neck,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Fire,1),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TannedLeather, 1, 1, 1), r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Simple,
            reputation: -100
        },
        disassemble: !0,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.LeatherGorget, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.LeatherPants] = {
        durability: 25,
        equip: n.EquipType.Legs,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Fire,1),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TannedLeather, 2, 2, 2), r(n.ItemType.String, 4, 4, 4), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Advanced,
            reputation: -100
        },
        disassemble: !0,
        flammable: !0,
        worth: 75
    },
    o(n.ItemType.LeatherPants, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.LeatherGloves] = {
        durability: 25,
        equip: n.EquipType.Hands,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Fire,1),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TannedLeather, 2, 2, 2), r(n.ItemType.String, 3, 3, 3), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Expert,
            reputation: -100
        },
        disassemble: !0,
        flammable: !0,
        worth: 75
    },
    o(n.ItemType.LeatherGloves, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.StoneFurnace] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemTypeGroup.Rock, 8, 8, 8)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Advanced,
            reputation: -25
        },
        disassemble: !0,
        durability: 25,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.StoneFurnace
        },
        worth: 50
    },
    o(n.ItemType.StoneFurnace, n.ItemTypeGroup.Heating, n.ItemTypeGroup.Furnace),
    t.itemDescriptions[n.ItemType.SandstoneKiln] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Sandstone, 8, 8, 8)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Advanced,
            reputation: -25
        },
        disassemble: !0,
        durability: 15,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.SandstoneKiln
        },
        worth: 50
    },
    o(n.ItemType.SandstoneKiln, n.ItemTypeGroup.Heating, n.ItemTypeGroup.Kiln),
    t.itemDescriptions[n.ItemType.IronTongs] = {
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 3, 3, 3), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -100
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        durability: 100,
        use: [a.ActionType.Grasp],
        worth: 250
    },
    o(n.ItemType.IronTongs, n.ItemTypeGroup.Tongs, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.Talc] = {
        weight: .8,
        worth: 25
    },
    t.itemDescriptions[n.ItemType.TalcumPowder] = {
        reducedWeight: .1,
        recipe: {
            components: [r(n.ItemType.Talc, 1, 1), r(n.ItemTypeGroup.MortarAndPestle, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: -25
        },
        onBurn: [n.ItemType.None],
        worth: 25
    },
    o(n.ItemType.TalcumPowder, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.WoodenSandCastFlask] = {
        recipe: {
            components: [r(n.ItemType.Log, 1, 1), r(n.ItemType.GreenSand, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Intermediate,
            reputation: -50
        },
        durability: 30,
        burnsLike: [n.ItemType.Log, n.ItemType.GreenSand],
        flammable: !0,
        worth: 35
    },
    o(n.ItemType.WoodenSandCastFlask, n.ItemTypeGroup.SandCastFlask),
    t.itemDescriptions[n.ItemType.Lens] = {
        durability: 45,
        use: [a.ActionType.StartFire],
        recipe: {
            components: [r(n.ItemType.RefinedSand, 1, 1), r(n.ItemType.LimestonePowder, 1, 1, 0, !0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Glassblowing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.LitFurnace,
            reputation: -25
        },
        worth: 25
    },
    o(n.ItemType.Lens, n.ItemTypeGroup.FireStarter),
    t.itemDescriptions[n.ItemType.PlantRoots] = {
        weight: .2,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 3, 1, 0]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.PlantRoots, n.ItemTypeGroup.Cordage, n.ItemTypeGroup.Medicinal, n.ItemTypeGroup.Food),
    t.itemDescriptions[n.ItemType.LockPick] = {
        durability: 5,
        use: [a.ActionType.LockPick],
        recipe: {
            components: [r(n.ItemTypeGroup.Sharpened, 1, 0), r(n.ItemTypeGroup.Needle, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: -50
        },
        onBurn: [n.ItemType.PileOfAsh],
        damageType: n.DamageType.Piercing,
        worth: 10
    },
    o(n.ItemType.LockPick, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.BoneNeedle] = {
        reducedWeight: .1,
        recipe: {
            components: [r(n.ItemType.SharpenedBone, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        durability: 10,
        onBurn: [n.ItemType.PileOfAsh],
        damageType: n.DamageType.Piercing,
        worth: 5
    },
    o(n.ItemType.BoneNeedle, n.ItemTypeGroup.Needle),
    t.itemDescriptions[n.ItemType.Pineapple] = {
        weight: 1.3,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 8750,
        decaysInto: n.ItemType.RottingVegetation,
        returnOnUse: [n.ItemType.PineappleSeeds, !0],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [4, 10, 5, 3]
        },
        dismantle: {
            items: [[n.ItemType.PineappleSeeds, 1]],
            skill: n.SkillType.Botany,
            required: n.ItemTypeGroup.Sharpened
        },
        worth: 10
    },
    o(n.ItemType.Pineapple, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.TatteredMap] = {
        weight: .2,
        durability: 50,
        use: [a.ActionType.Decode],
        onBurn: [n.ItemType.PileOfAsh],
        repairable: !1,
        flammable: !0,
        worth: 75,
        dismantle: {
            items: [[n.ItemType.ShreddedPaper, 1]]
        }
    },
    t.itemDescriptions[n.ItemType.Coal] = {
        weight: 1,
        use: [a.ActionType.StokeFire],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.StokeFire]: 20
        },
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.Coal, n.ItemTypeGroup.Carbon, n.ItemTypeGroup.Fuel),
    t.itemDescriptions[n.ItemType.WroughtIron] = {
        recipe: {
            components: [r(n.ItemType.IronOre, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.LitFurnace,
            reputation: -50
        },
        worth: 30
    },
    o(n.ItemType.WroughtIron, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.LimestonePowder] = {
        reducedWeight: .6,
        recipe: {
            components: [r(n.ItemType.Limestone, 1, 1), r(n.ItemTypeGroup.MortarAndPestle, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: -25
        },
        onBurn: [n.ItemType.None],
        worth: 25
    },
    o(n.ItemType.LimestonePowder, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.IronIngot] = {
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.CarbonPowder, 1, 1, 0, !0), r(n.ItemType.LimestonePowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 1, 1), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.LitFurnace,
            reputation: -100
        },
        worth: 50
    },
    o(n.ItemType.IronIngot, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.Backpack] = {
        durability: 15,
        weightCapacity: 50,
        use: [a.ActionType.OpenContainer],
        equip: n.EquipType.Back,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Fire,1),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TannedLeather, 2, 2, 2), r(n.ItemType.String, 2, 2, 2), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Advanced,
            reputation: -50
        },
        flammable: !0,
        disassemble: !0,
        worth: 75
    },
    o(n.ItemType.Backpack, n.ItemTypeGroup.Equipment, n.ItemTypeGroup.Storage),
    t.itemDescriptions[n.ItemType.RottenMeat] = {
        weight: .7,
        use: [a.ActionType.Eat],
        decayMax: 4750,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-10, -20, 1, -1]
        },
        worth: 5
    },
    o(n.ItemType.RottenMeat, n.ItemTypeGroup.Compost),
    t.itemDescriptions[n.ItemType.StoneHammer] = {
        durability: 15,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Blunt,
        use: [a.ActionType.Repair, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Rock, 1, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: -50
        },
        disassemble: !0,
        flammable: !0,
        worth: 20
    },
    o(n.ItemType.StoneHammer, n.ItemTypeGroup.Hammer, n.ItemTypeGroup.Repair, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.RawChicken] = {
        weight: 1.2,
        use: [a.ActionType.Eat],
        decayMax: 2250,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedChicken],
        onUse: {
            [a.ActionType.Eat]: [-10, -10, 6, -1]
        },
        worth: 5
    },
    o(n.ItemType.RawChicken, n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.CookedChicken] = {
        use: [a.ActionType.Eat],
        decayMax: 3250,
        decaysInto: n.ItemType.RottenMeat,
        recipe: {
            components: [r(n.ItemType.RawChicken, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Advanced,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [5, 10, 8, -2]
        },
        worth: 15
    },
    o(n.ItemType.CookedChicken, n.ItemTypeGroup.Meat, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.StoneAnvil] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Log, 1, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0), r(n.ItemTypeGroup.Rock, 3, 3, 3)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: -50
        },
        disassemble: !0,
        durability: 15,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.StoneAnvil
        },
        worth: 25
    },
    o(n.ItemType.StoneAnvil, n.ItemTypeGroup.Anvil),
    t.itemDescriptions[n.ItemType.WoodenChest] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Log, 3, 3), r(n.ItemType.WoodenDowels, 2, 2), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        durability: 10,
        doodadContainer: n.DoodadType.WoodenChest,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.WoodenChest
        },
        flammable: !0,
        worth: 50,
        burnsLike: [n.ItemType.Log, n.ItemType.Log, n.ItemType.Log, n.ItemType.WoodenDowels, n.ItemType.WoodenDowels]
    },
    o(n.ItemType.WoodenChest, n.ItemTypeGroup.Storage),
    t.itemDescriptions[n.ItemType.IronSword] = {
        durability: 200,
        use: [a.ActionType.Carve, a.ActionType.Gather],
        equip: n.EquipType.Held,
        attack: 9,
        damageType: n.DamageType.Piercing | n.DamageType.Slashing,
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 8, 8, 8), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 500
    },
    o(n.ItemType.IronSword, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.IronBreastplate] = {
        durability: 200,
        equip: n.EquipType.Chest,
        defense: new n.Defense(5,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Blunt,1,n.DamageType.Piercing,1),new n.Vulnerabilities),
        recipe: {
            components: [r(n.ItemType.IronIngot, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 750
    },
    o(n.ItemType.IronBreastplate, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.IronBoots] = {
        durability: 200,
        equip: n.EquipType.Feet,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Blunt,1,n.DamageType.Piercing,1),new n.Vulnerabilities),
        recipe: {
            components: [r(n.ItemType.IronIngot, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 750
    },
    o(n.ItemType.IronBoots, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.IronHelmet] = {
        durability: 200,
        equip: n.EquipType.Head,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Blunt,1,n.DamageType.Piercing,1),new n.Vulnerabilities),
        recipe: {
            components: [r(n.ItemType.IronIngot, 8, 8, 8), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 500
    },
    o(n.ItemType.IronHelmet, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.IronGorget] = {
        durability: 200,
        equip: n.EquipType.Neck,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Blunt,1,n.DamageType.Piercing,1),new n.Vulnerabilities),
        recipe: {
            components: [r(n.ItemType.IronIngot, 6, 6, 6), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 500
    },
    o(n.ItemType.IronGorget, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.IronGreaves] = {
        durability: 200,
        equip: n.EquipType.Legs,
        defense: new n.Defense(5,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Blunt,1,n.DamageType.Piercing,1),new n.Vulnerabilities),
        recipe: {
            components: [r(n.ItemType.IronIngot, 10, 10, 10), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 500
    },
    o(n.ItemType.IronGreaves, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.IronGauntlets] = {
        durability: 200,
        equip: n.EquipType.Hands,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Blunt,1,n.DamageType.Piercing,1),new n.Vulnerabilities),
        recipe: {
            components: [r(n.ItemType.IronIngot, 8, 8, 8), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 500
    },
    o(n.ItemType.IronGauntlets, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.IronShield] = {
        durability: 200,
        equip: n.EquipType.Held,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Blunt,1,n.DamageType.Piercing,1),new n.Vulnerabilities),
        recipe: {
            components: [r(n.ItemType.IronIngot, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 750
    },
    o(n.ItemType.IronShield, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.SandstoneWall] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Sandstone, 8, 8, 8)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        disassemble: !0,
        durability: 15,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.SandstoneWall
        },
        worth: 50
    },
    o(n.ItemType.SandstoneWall, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.SandstoneFlooring] = {
        use: [a.ActionType.SetDown],
        recipe: {
            components: [r(n.ItemType.Sandstone, 5, 5, 5)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        durability: 15,
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.SandstoneFlooring
        },
        worth: 25
    },
    o(n.ItemType.SandstoneFlooring, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.SpiderSilk] = {
        weight: .1,
        onBurn: [n.ItemType.None],
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.SpiderSilk, n.ItemTypeGroup.Cordage),
    t.itemDescriptions[n.ItemType.AnimalFat] = {
        weight: .8,
        use: [a.ActionType.Eat, a.ActionType.StokeFire],
        decayMax: 4750,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [0, -6, 2, -1],
            [a.ActionType.StokeFire]: 12
        },
        worth: 5,
        flammable: !0
    },
    o(n.ItemType.AnimalFat, n.ItemTypeGroup.Fuel),
    t.itemDescriptions[n.ItemType.AnimalFatTorch] = {
        durability: 25,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Blunt,
        use: [a.ActionType.Ignite, a.ActionType.Build],
        isTorch: !0,
        lit: n.ItemType.LitAnimalFatTorch,
        recipe: {
            components: [r(n.ItemType.AnimalFat, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1), r(n.ItemTypeGroup.Fabric, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        onUse: {
            [a.ActionType.Build]: n.DoodadType.AnimalFatTorchStand
        },
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.AnimalFatTorch, n.ItemTypeGroup.LightSource, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.ClayFlakes] = {
        reducedWeight: 1.5,
        recipe: {
            components: [r(n.ItemType.RawClay, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Simple,
            reputation: -25
        },
        onBurn: [n.ItemType.PileOfAsh],
        worth: 5
    },
    o(n.ItemType.ClayFlakes, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.GreenSand] = {
        recipe: {
            components: [r(n.ItemType.ClayFlakes, 1, 1), r(n.ItemType.RefinedSand, 2, 2)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: -25
        },
        worth: 10
    },
    o(n.ItemType.GreenSand, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.OldInstructionalScroll] = {
        weight: .2,
        use: [a.ActionType.Learn],
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 75,
        dismantle: {
            items: [[n.ItemType.ShreddedPaper, 1]]
        }
    },
    t.itemDescriptions[n.ItemType.SlimeGelatin] = {
        weight: .5,
        use: [a.ActionType.Eat, a.ActionType.Preserve],
        decayMax: 4750,
        onBurn: [n.ItemType.None],
        onUse: {
            [a.ActionType.Eat]: [-1, -2, 2, -1]
        },
        worth: 5
    },
    o(n.ItemType.SlimeGelatin, n.ItemTypeGroup.Preservative),
    t.itemDescriptions[n.ItemType.SlimeGlue] = {
        use: [a.ActionType.Reinforce, a.ActionType.Eat],
        recipe: {
            components: [r(n.ItemType.SlimeGelatin, 1, 1), r(n.ItemTypeGroup.Liquid, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Intermediate,
            requiresFire: !0,
            reputation: -25
        },
        decayMax: 750,
        onBurn: [n.ItemType.None],
        onUse: {
            [a.ActionType.Eat]: [-1, -2, 1, 0]
        },
        worth: 10
    },
    o(n.ItemType.SlimeGlue, n.ItemTypeGroup.Reinforce, n.ItemTypeGroup.Glue),
    t.itemDescriptions[n.ItemType.CookedSpiderMeat] = {
        use: [a.ActionType.Eat],
        recipe: {
            components: [r(n.ItemType.SpiderMeat, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Intermediate,
            requiresFire: !0,
            reputation: 25
        },
        decayMax: 5750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [3, 10, 2, 0]
        },
        worth: 10
    },
    o(n.ItemType.CookedSpiderMeat, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.SpiderMeat] = {
        weight: .4,
        use: [a.ActionType.Eat],
        decayMax: 4750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedSpiderMeat],
        onUse: {
            [a.ActionType.Eat]: [-1, -2, 2, -1]
        },
        worth: 5
    },
    o(n.ItemType.SpiderMeat, n.ItemTypeGroup.Bait, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.IronLockPick] = {
        durability: 80,
        use: [a.ActionType.LockPick],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 1, 1, 1), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -250
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        damageType: n.DamageType.Piercing,
        worth: 75
    },
    o(n.ItemType.IronLockPick, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.RottingVegetation] = {
        weight: .5,
        use: [a.ActionType.Eat],
        decayMax: 4750,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-10, -15, 1, -1]
        },
        worth: 5
    },
    o(n.ItemType.RottingVegetation, n.ItemTypeGroup.Compost),
    t.itemDescriptions[n.ItemType.Chives] = {
        weight: .4,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 14e3,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [4, 6, 3, 0]
        },
        worth: 10
    },
    o(n.ItemType.Chives, n.ItemTypeGroup.Food, n.ItemTypeGroup.Vegetable),
    t.itemDescriptions[n.ItemType.IronHammer] = {
        durability: 120,
        attack: 5,
        damageType: n.DamageType.Blunt,
        equip: n.EquipType.Held,
        use: [a.ActionType.Repair, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 3, 3, 3), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -250
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 250
    },
    o(n.ItemType.IronHammer, n.ItemTypeGroup.Hammer, n.ItemTypeGroup.Repair, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.IronSpear] = {
        durability: 200,
        equip: n.EquipType.Held,
        attack: 7,
        damageType: n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 2, 2, 2), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        use: [a.ActionType.Gather],
        worth: 250
    },
    o(n.ItemType.IronSpear, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.IronShovel] = {
        durability: 400,
        equip: n.EquipType.Held,
        attack: 5,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Dig, a.ActionType.Gather, a.ActionType.GatherTreasure, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.String, 2, 2, 2), r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 3, 3, 3), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -250
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 250
    },
    o(n.ItemType.IronShovel, n.ItemTypeGroup.Tool, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.IronDoubleAxe] = {
        durability: 400,
        equip: n.EquipType.Held,
        attack: 8,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 8, 8, 8), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 500
    },
    o(n.ItemType.IronDoubleAxe, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.IronPickaxe] = {
        durability: 400,
        equip: n.EquipType.Held,
        attack: 5,
        damageType: n.DamageType.Blunt | n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 6, 6, 6), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        use: [a.ActionType.Gather],
        worth: 250
    },
    o(n.ItemType.IronPickaxe, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.Inkstick] = {
        recipe: {
            components: [r(n.ItemType.CarbonPowder, 2, 2), r(n.ItemTypeGroup.Glue, 1, 1), r(n.ItemTypeGroup.Liquid, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        durability: 10,
        onBurn: [n.ItemType.PileOfAsh],
        worth: 30
    },
    o(n.ItemType.Inkstick, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.Coconut] = {
        weight: 1.6,
        use: [a.ActionType.Plant],
        skillUse: n.SkillType.Botany,
        decayMax: 8750,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.CoconutTree
        },
        dismantle: {
            items: [[n.ItemType.CoconutHusk, 1], [n.ItemType.PeeledCoconut, 1]],
            skill: n.SkillType.Botany,
            required: n.ItemTypeGroup.Sharpened
        },
        worth: 25
    },
    t.itemDescriptions[n.ItemType.PalmLeaf] = {
        weight: .3,
        onBurn: [n.ItemType.PileOfAsh],
        use: [a.ActionType.StokeFire],
        onUse: {
            [a.ActionType.StokeFire]: 6
        },
        worth: 5,
        flammable: !0
    },
    o(n.ItemType.PalmLeaf, n.ItemTypeGroup.Cordage, n.ItemTypeGroup.Compost, n.ItemTypeGroup.Tinder),
    t.itemDescriptions[n.ItemType.Offal] = {
        weight: .8,
        use: [a.ActionType.Eat],
        decayMax: 750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-2, -6, 3, -1]
        },
        worth: 5
    },
    o(n.ItemType.Offal, n.ItemTypeGroup.Compost, n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.BoneFragments] = {
        weight: .4,
        onBurn: [n.ItemType.PileOfAsh],
        dismantle: {
            items: [[n.ItemType.BoneNeedle, 1]],
            required: n.ItemTypeGroup.Sharpened
        },
        damageType: n.DamageType.Piercing,
        worth: 5
    },
    o(n.ItemType.BoneFragments, n.ItemTypeGroup.Bone),
    t.itemDescriptions[n.ItemType.LitPoleTorch] = {
        inheritWeight: n.ItemType.Branch,
        durability: 10,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Fire | n.DamageType.Blunt,
        use: [a.ActionType.StartFire, a.ActionType.Extinguish, a.ActionType.Build],
        isTorch: !0,
        revert: n.ItemType.WoodenPole,
        onEquipEffect: [n.OnEquipType.LightSource, 1],
        decayMax: 250,
        decaysInto: n.ItemType.Charcoal,
        burnsLike: [n.ItemType.WoodenPole],
        repairable: !1,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.LitPoleTorchStand
        },
        flammable: !0
    },
    o(n.ItemType.LitPoleTorch, n.ItemTypeGroup.FireStarter, n.ItemTypeGroup.LitTorch, n.ItemTypeGroup.Untradable),
    t.itemDescriptions[n.ItemType.Cotton] = {
        weight: .2,
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.Cotton, n.ItemTypeGroup.Pulp),
    t.itemDescriptions[n.ItemType.CottonSeeds] = {
        weight: .1,
        skillUse: n.SkillType.Botany,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Cotton,
            [a.ActionType.Eat]: [1, 1, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.CottonSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.CottonFabric] = {
        recipe: {
            components: [r(n.ItemType.Cotton, 3, 3)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 20
    },
    o(n.ItemType.CottonFabric, n.ItemTypeGroup.Fabric),
    t.itemDescriptions[n.ItemType.BonePole] = {
        reducedWeight: .1,
        durability: 20,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Blunt,
        recipe: {
            components: [r(n.ItemType.Bone, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Simple,
            reputation: -25
        },
        use: [a.ActionType.Gather],
        onBurn: [n.ItemType.PileOfAsh],
        worth: 5
    },
    o(n.ItemType.BonePole, n.ItemTypeGroup.Pole, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Bone, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.Tourniquet] = {
        use: [a.ActionType.Heal, a.ActionType.HealOther],
        skillUse: n.SkillType.Anatomy,
        recipe: {
            components: [r(n.ItemType.String, 2, 2, 2), r(n.ItemTypeGroup.Pole, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        onUse: {
            [a.ActionType.Heal]: [2, 0, 0, 0],
            [a.ActionType.HealOther]: 2
        },
        flammable: !0,
        worth: 15
    },
    o(n.ItemType.Tourniquet, n.ItemTypeGroup.Health),
    t.itemDescriptions[n.ItemType.WroughtIronPickaxe] = {
        durability: 200,
        equip: n.EquipType.Held,
        attack: 4,
        damageType: n.DamageType.Blunt | n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 6, 6, 6), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -250
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        use: [a.ActionType.Gather],
        worth: 150
    },
    o(n.ItemType.WroughtIronPickaxe, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.WroughtIronDoubleAxe] = {
        durability: 200,
        equip: n.EquipType.Held,
        attack: 7,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 8, 8, 8), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -750
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 300
    },
    o(n.ItemType.WroughtIronDoubleAxe, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.WroughtIronShovel] = {
        durability: 200,
        equip: n.EquipType.Held,
        attack: 4,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Dig, a.ActionType.Gather, a.ActionType.GatherTreasure, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.String, 2, 2, 2), r(n.ItemType.WroughtIron, 3, 3, 3), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -175
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 150
    },
    o(n.ItemType.WroughtIronShovel, n.ItemTypeGroup.Tool, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.WroughtIronSpear] = {
        durability: 100,
        equip: n.EquipType.Held,
        attack: 6,
        damageType: n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 2, 2, 2), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        use: [a.ActionType.Gather],
        worth: 150
    },
    o(n.ItemType.WroughtIronSpear, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.WroughtIronHammer] = {
        durability: 60,
        equip: n.EquipType.Held,
        attack: 4,
        damageType: n.DamageType.Blunt,
        use: [a.ActionType.Repair, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 3, 3, 3), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -175
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 150
    },
    o(n.ItemType.WroughtIronHammer, n.ItemTypeGroup.Hammer, n.ItemTypeGroup.Repair, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.WroughtIronLockPick] = {
        durability: 40,
        use: [a.ActionType.LockPick],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 1, 1, 1), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -175
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        damageType: n.DamageType.Piercing,
        worth: 50
    },
    o(n.ItemType.WroughtIronLockPick, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.WroughtIronShield] = {
        durability: 100,
        equip: n.EquipType.Held,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Piercing,1),new n.Vulnerabilities(n.DamageType.Blunt,1)),
        recipe: {
            components: [r(n.ItemType.WroughtIron, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 450
    },
    o(n.ItemType.WroughtIronShield, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.WroughtIronGauntlets] = {
        durability: 100,
        equip: n.EquipType.Hands,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Piercing,1),new n.Vulnerabilities(n.DamageType.Blunt,1)),
        recipe: {
            components: [r(n.ItemType.WroughtIron, 8, 8, 8), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 300
    },
    o(n.ItemType.WroughtIronGauntlets, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.WroughtIronGreaves] = {
        durability: 100,
        equip: n.EquipType.Legs,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Piercing,1),new n.Vulnerabilities(n.DamageType.Blunt,1)),
        recipe: {
            components: [r(n.ItemType.WroughtIron, 10, 10, 10), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 450
    },
    o(n.ItemType.WroughtIronGreaves, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.WroughtIronGorget] = {
        durability: 100,
        equip: n.EquipType.Neck,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Piercing,1),new n.Vulnerabilities(n.DamageType.Blunt,1)),
        recipe: {
            components: [r(n.ItemType.WroughtIron, 6, 6, 6), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 300
    },
    o(n.ItemType.WroughtIronGorget, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.WroughtIronHelmet] = {
        durability: 100,
        equip: n.EquipType.Head,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Piercing,1),new n.Vulnerabilities(n.DamageType.Blunt,1)),
        recipe: {
            components: [r(n.ItemType.WroughtIron, 8, 8, 8), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 300
    },
    o(n.ItemType.WroughtIronHelmet, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.WroughtIronBoots] = {
        durability: 100,
        equip: n.EquipType.Feet,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Piercing,1),new n.Vulnerabilities(n.DamageType.Blunt,1)),
        recipe: {
            components: [r(n.ItemType.WroughtIron, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 450
    },
    o(n.ItemType.WroughtIronBoots, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.WroughtIronBreastPlate] = {
        durability: 100,
        equip: n.EquipType.Chest,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Piercing,1),new n.Vulnerabilities(n.DamageType.Blunt,1)),
        recipe: {
            components: [r(n.ItemType.WroughtIron, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 450
    },
    o(n.ItemType.WroughtIronBreastPlate, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.WroughtIronSword] = {
        durability: 100,
        equip: n.EquipType.Held,
        attack: 8,
        damageType: n.DamageType.Piercing | n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 8, 8, 8), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 300
    },
    o(n.ItemType.WroughtIronSword, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.WoodenWall] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Log, 3, 3, 3), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        durability: 15,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.WoodenWall
        },
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.WoodenWall, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.WoodenFlooring] = {
        use: [a.ActionType.SetDown],
        recipe: {
            components: [r(n.ItemType.Log, 2, 2), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        durability: 15,
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.WoodenFlooring
        },
        burnsLike: [n.ItemType.Log, n.ItemType.Log],
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.WoodenFlooring, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.WoodenDoor] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Log, 3, 3), r(n.ItemType.WoodenDowels, 2, 2), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        durability: 15,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.WoodenDoor
        },
        burnsLike: [n.ItemType.Log, n.ItemType.Log, n.ItemType.Log, n.ItemType.WoodenDowels, n.ItemType.WoodenDowels],
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.WoodenDoor, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.FishingRod] = {
        durability: 20,
        equip: n.EquipType.Held,
        attack: 1,
        damageType: n.DamageType.Slashing,
        ranged: {
            range: 6,
            attack: 0
        },
        use: [a.ActionType.Cast],
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Needle, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        disassemble: !0,
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.FishingRod, n.ItemTypeGroup.Tool, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.MessageInABottle] = {
        weight: 5.2,
        use: [a.ActionType.OpenBottle],
        worth: 75
    },
    t.itemDescriptions[n.ItemType.CarbonPowder] = {
        reducedWeight: .1,
        recipe: {
            components: [r(n.ItemTypeGroup.Carbon, 1, 1), r(n.ItemTypeGroup.MortarAndPestle, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: -25
        },
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.CarbonPowder, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.PileOfCompost] = {
        recipe: {
            components: [r(n.ItemTypeGroup.Compost, 2, 2)],
            skill: n.SkillType.Gardening,
            level: n.RecipeLevel.Intermediate,
            reputation: 50
        },
        use: [a.ActionType.SmotherFire],
        worth: 5,
        onBurn: [n.ItemType.PileOfAsh]
    },
    t.itemDescriptions[n.ItemType.MeltedCopal] = {
        use: [a.ActionType.Reinforce],
        recipe: {
            components: [r(n.ItemType.CopalResin, 1, 1)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: -25
        },
        decayMax: 100,
        decaysInto: n.ItemType.Copal,
        worth: 25
    },
    o(n.ItemType.MeltedCopal, n.ItemTypeGroup.Reinforce),
    t.itemDescriptions[n.ItemType.WoodenShavings] = {
        weight: .1,
        use: [a.ActionType.StokeFire],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.StokeFire]: 4
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.WoodenShavings, n.ItemTypeGroup.Pulp, n.ItemTypeGroup.Tinder),
    t.itemDescriptions[n.ItemType.Deadfall] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.LargeRock, 1, 1, 1), r(n.ItemTypeGroup.Pole, 3, 3, 3)],
            skill: n.SkillType.Trapping,
            level: n.RecipeLevel.Simple,
            reputation: -100
        },
        disassemble: !0,
        durability: 5,
        flammable: !0,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.SetDeadfall
        },
        worth: 15
    },
    o(n.ItemType.Deadfall, n.ItemTypeGroup.Trap),
    t.itemDescriptions[n.ItemType.Snare] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Pole, 2, 2, 2)],
            skill: n.SkillType.Trapping,
            level: n.RecipeLevel.Simple,
            reputation: -100
        },
        disassemble: !0,
        durability: 5,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.SetSnare
        },
        flammable: !0,
        worth: 15
    },
    o(n.ItemType.Snare, n.ItemTypeGroup.Trap),
    t.itemDescriptions[n.ItemType.WaterskinOfMedicinalWater] = {
        inheritWeight: n.ItemType.Waterskin,
        durability: 20,
        returnOnUse: [n.ItemType.Waterskin, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        flammable: !0,
        use: [a.ActionType.DrinkCure, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemTypeGroup.WaterskinOfPotableWater,
            components: [r(n.ItemTypeGroup.Medicinal, 2, 2)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        onUse: {
            [a.ActionType.DrinkCure]: [3, 16, 1, 9]
        },
        worth: 75
    },
    o(n.ItemType.WaterskinOfMedicinalWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfMedicinalWater),
    t.itemDescriptions[n.ItemType.CharcoalBandage] = {
        use: [a.ActionType.Heal, a.ActionType.HealOther],
        skillUse: n.SkillType.Anatomy,
        recipe: {
            components: [r(n.ItemType.Bandage, 1, 1, 1), r(n.ItemType.Charcoal, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        disassemble: !0,
        onUse: {
            [a.ActionType.Heal]: [14, 0, 0, 0],
            [a.ActionType.HealOther]: 14
        },
        flammable: !0,
        worth: 30
    },
    o(n.ItemType.CharcoalBandage, n.ItemTypeGroup.Health),
    t.itemDescriptions[n.ItemType.WoodenTongs] = {
        recipe: {
            components: [r(n.ItemType.WoodenPole, 1, 1, 1), r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        disassemble: !0,
        durability: 10,
        use: [a.ActionType.Grasp],
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.WoodenTongs, n.ItemTypeGroup.Tongs, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.WroughtIronTongs] = {
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 3, 3, 3), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -50
        },
        durability: 50,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        use: [a.ActionType.Grasp],
        worth: 150
    },
    o(n.ItemType.WroughtIronTongs, n.ItemTypeGroup.Tongs, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.SheetOfGlass] = {
        recipe: {
            components: [r(n.ItemType.RefinedSand, 3, 3), r(n.ItemType.LimestonePowder, 1, 1, 0, !0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Glassblowing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.LitFurnace,
            reputation: -25
        },
        damageType: n.DamageType.Slashing,
        worth: 50
    },
    o(n.ItemType.SheetOfGlass, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.SolarStill] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.SheetOfGlass, 1, 1, 1), r(n.ItemTypeGroup.Container, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Advanced,
            reputation: 100
        },
        disassemble: !0,
        durability: 10,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.SolarStill
        },
        worth: 75
    },
    o(n.ItemType.SolarStill, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.StoneWaterStill] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Rock, 2, 2, 1), r(n.ItemTypeGroup.Sharpened, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Container, 1, 1, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        durability: 25,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.StoneWaterStill
        },
        worth: 75
    },
    o(n.ItemType.StoneWaterStill, n.ItemTypeGroup.WaterStill),
    t.itemDescriptions[n.ItemType.Sundial] = {
        reducedWeight: 2,
        use: [a.ActionType.TellTime],
        recipe: {
            components: [r(n.ItemType.LargeRock, 1, 1), r(n.ItemTypeGroup.SharpenedRock, 1, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        durability: 50,
        worth: 20
    },
    o(n.ItemType.Sundial, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.LitAnimalFatTorch] = {
        inheritWeight: n.ItemType.AnimalFatTorch,
        durability: 25,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Fire | n.DamageType.Blunt,
        use: [a.ActionType.StartFire, a.ActionType.Extinguish, a.ActionType.Build],
        isTorch: !0,
        onEquipEffect: [n.OnEquipType.LightSource, 3],
        revert: n.ItemType.AnimalFatTorch,
        decayMax: 3500,
        decaysInto: n.ItemType.Charcoal,
        repairable: !1,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.LitAnimalFatTorchStand
        },
        burnsLike: [n.ItemType.AnimalFatTorch],
        flammable: !0
    },
    o(n.ItemType.LitAnimalFatTorch, n.ItemTypeGroup.FireStarter, n.ItemTypeGroup.LitTorch, n.ItemTypeGroup.Untradable),
    t.itemDescriptions[n.ItemType.Sinew] = {
        reducedWeight: .5,
        recipe: {
            components: [r(n.ItemType.Offal, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Simple,
            reputation: -25
        },
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.Sinew, n.ItemTypeGroup.Cordage),
    t.itemDescriptions[n.ItemType.ShortBow] = {
        durability: 25,
        use: [a.ActionType.Shoot],
        equip: n.EquipType.Held,
        twoHanded: !0,
        attack: 2,
        damageType: n.DamageType.Blunt,
        ranged: {
            range: 5,
            attack: 3
        },
        recipe: {
            components: [r(n.ItemType.WoodenPole, 1, 1), r(n.ItemType.Sinew, 1, 1)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Advanced,
            reputation: -100
        },
        burnsLike: [n.ItemType.WoodenPole, n.ItemType.Sinew],
        flammable: !0,
        worth: 15
    },
    o(n.ItemType.ShortBow, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.LongBow] = {
        durability: 30,
        use: [a.ActionType.Shoot],
        equip: n.EquipType.Held,
        twoHanded: !0,
        attack: 2,
        damageType: n.DamageType.Blunt,
        ranged: {
            range: 9,
            attack: 5
        },
        recipe: {
            components: [r(n.ItemType.WoodenPole, 1, 1), r(n.ItemType.Sinew, 2, 2), r(n.ItemTypeGroup.Glue, 1, 1)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Advanced,
            reputation: -250
        },
        burnsLike: [n.ItemType.WoodenPole, n.ItemType.Sinew, n.ItemType.Sinew],
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.LongBow, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.CompositeBow] = {
        durability: 50,
        use: [a.ActionType.Shoot],
        equip: n.EquipType.Held,
        twoHanded: !0,
        attack: 2,
        damageType: n.DamageType.Blunt,
        ranged: {
            range: 4,
            attack: 6
        },
        recipe: {
            components: [r(n.ItemType.WoodenPole, 2, 2), r(n.ItemType.Sinew, 2, 2), r(n.ItemTypeGroup.Glue, 1, 1), r(n.ItemTypeGroup.Liquid, 1, 0)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Expert,
            requiresFire: !0,
            reputation: -500
        },
        burnsLike: [n.ItemType.WoodenPole, n.ItemType.Sinew, n.ItemType.Sinew],
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.CompositeBow, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.WaterskinOfPurifiedFreshWater] = {
        inheritWeight: n.ItemType.Waterskin,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        durability: 20,
        returnOnUse: [n.ItemType.Waterskin, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        flammable: !0,
        recipe: {
            baseComponent: n.ItemType.WaterskinOfUnpurifiedFreshWater,
            components: [],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        onUse: {
            [a.ActionType.DrinkItem]: [1, 25, 1, 10]
        },
        worth: 75
    },
    o(n.ItemType.WaterskinOfPurifiedFreshWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.WaterskinOfPotableWater, n.ItemTypeGroup.ContainerOfPurifiedFreshWater),
    t.itemDescriptions[n.ItemType.WaterskinOfUnpurifiedFreshWater] = {
        inheritWeight: n.ItemType.Waterskin,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        durability: 20,
        returnOnUse: [n.ItemType.Waterskin, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        flammable: !0,
        recipe: {
            baseComponent: n.ItemType.Waterskin,
            components: [r(n.ItemType.PileOfSnow, 1, 1)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        onUse: {
            [a.ActionType.DrinkItem]: [-4, 16, 1, 8]
        },
        worth: 50
    },
    o(n.ItemType.WaterskinOfUnpurifiedFreshWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfUnpurifiedFreshWater),
    t.itemDescriptions[n.ItemType.GlassBottle] = {
        gather: {
            milk: n.ItemType.GlassBottleOfGoatMilk,
            desalinated: n.ItemType.GlassBottleOfDesalinatedWater,
            unpurified: n.ItemType.GlassBottleOfUnpurifiedFreshWater,
            seawater: n.ItemType.GlassBottleOfSeawater
        },
        use: [a.ActionType.GatherWater, a.ActionType.GatherMilk],
        recipe: {
            components: [r(n.ItemType.ClayBlowpipe, 1, 0), r(n.ItemType.RefinedSand, 2, 2), r(n.ItemType.LimestonePowder, 1, 1, 0, !0), r(n.ItemType.Cork, 1, 1)],
            skill: n.SkillType.Glassblowing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.LitFurnace,
            reputation: 25
        },
        durability: 15,
        worth: 50
    },
    o(n.ItemType.GlassBottle, n.ItemTypeGroup.Container),
    t.itemDescriptions[n.ItemType.Cork] = {
        recipe: {
            components: [r(n.ItemType.TreeBark, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.Cork, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.GlassBottleOfSeawater] = {
        inheritWeight: n.ItemType.GlassBottle,
        use: [a.ActionType.Pour, a.ActionType.PourOnYourself, a.ActionType.DrinkItem],
        durability: 15,
        returnOnUse: [n.ItemType.GlassBottle, !1],
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [0, -15, 1, -2]
        },
        worth: 50
    },
    o(n.ItemType.GlassBottleOfSeawater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfSeawater),
    t.itemDescriptions[n.ItemType.GlassBottleOfDesalinatedWater] = {
        inheritWeight: n.ItemType.GlassBottle,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemType.GlassBottleOfSeawater,
            components: [r(n.ItemType.Flask, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        durability: 15,
        returnOnUse: [n.ItemType.GlassBottle, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [2, 25, 1, 11]
        },
        worth: 75
    },
    o(n.ItemType.GlassBottleOfDesalinatedWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.GlassBottleOfPotableWater, n.ItemTypeGroup.ContainerOfDesalinatedWater),
    t.itemDescriptions[n.ItemType.GlassBottleOfMedicinalWater] = {
        inheritWeight: n.ItemType.GlassBottle,
        use: [a.ActionType.DrinkCure, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemTypeGroup.GlassBottleOfPotableWater,
            components: [r(n.ItemTypeGroup.Medicinal, 2, 2)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        durability: 15,
        returnOnUse: [n.ItemType.GlassBottle, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkCure]: [3, 16, 1, 9]
        },
        worth: 75
    },
    o(n.ItemType.GlassBottleOfMedicinalWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfMedicinalWater),
    t.itemDescriptions[n.ItemType.GlassBottleOfPurifiedFreshWater] = {
        inheritWeight: n.ItemType.GlassBottle,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemType.GlassBottleOfUnpurifiedFreshWater,
            components: [],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        durability: 15,
        returnOnUse: [n.ItemType.GlassBottle, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [1, 25, 1, 10]
        },
        worth: 75
    },
    o(n.ItemType.GlassBottleOfPurifiedFreshWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.GlassBottleOfPotableWater, n.ItemTypeGroup.ContainerOfPurifiedFreshWater),
    t.itemDescriptions[n.ItemType.GlassBottleOfUnpurifiedFreshWater] = {
        inheritWeight: n.ItemType.GlassBottle,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemType.GlassBottle,
            components: [r(n.ItemType.PileOfSnow, 1, 1)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        durability: 15,
        returnOnUse: [n.ItemType.GlassBottle, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [-4, 16, 1, 8]
        },
        worth: 50
    },
    o(n.ItemType.GlassBottleOfUnpurifiedFreshWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfUnpurifiedFreshWater),
    t.itemDescriptions[n.ItemType.WroughtIronArrow] = {
        recipe: {
            components: [r(n.ItemType.Feather, 1, 1, 1), r(n.ItemType.WroughtIronArrowhead, 1, 1, 1), r(n.ItemType.ArrowShaft, 1, 1, 1), r(n.ItemTypeGroup.Cordage, 1, 1, 1)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Advanced,
            reputation: -75
        },
        disassemble: !0,
        attack: 4,
        damageType: n.DamageType.Piercing,
        durability: 50,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.WroughtIronArrow, n.ItemTypeGroup.Arrow),
    t.itemDescriptions[n.ItemType.IronArrow] = {
        recipe: {
            components: [r(n.ItemType.Feather, 1, 1, 1), r(n.ItemType.IronArrowhead, 1, 1, 1), r(n.ItemType.ArrowShaft, 1, 1, 1), r(n.ItemTypeGroup.Cordage, 1, 1, 1)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Expert,
            reputation: -100
        },
        disassemble: !0,
        attack: 5,
        damageType: n.DamageType.Piercing,
        durability: 100,
        flammable: !0,
        worth: 75
    },
    o(n.ItemType.IronArrow, n.ItemTypeGroup.Arrow),
    t.itemDescriptions[n.ItemType.StoneBullet] = {
        reducedWeight: 2.5,
        recipe: {
            components: [r(n.ItemType.SmoothRock, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        attack: 1,
        damageType: n.DamageType.Blunt,
        durability: 10,
        worth: 10
    },
    o(n.ItemType.StoneBullet, n.ItemTypeGroup.Bullet),
    t.itemDescriptions[n.ItemType.WroughtIronBullet] = {
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 1, 1, 1), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -50
        },
        attack: 3,
        damageType: n.DamageType.Blunt,
        durability: 50,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 50
    },
    o(n.ItemType.WroughtIronBullet, n.ItemTypeGroup.Bullet),
    t.itemDescriptions[n.ItemType.IronBullet] = {
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 1, 1, 1), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -100
        },
        attack: 4,
        damageType: n.DamageType.Blunt,
        durability: 100,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 75
    },
    o(n.ItemType.IronBullet, n.ItemTypeGroup.Bullet),
    t.itemDescriptions[n.ItemType.LeatherQuiver] = {
        durability: 20,
        weightCapacity: 25,
        use: [a.ActionType.OpenContainer],
        equip: n.EquipType.Back,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Fire,1),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.TannedLeather, 1, 1, 1), r(n.ItemType.String, 2, 2, 2), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Leatherworking,
            level: n.RecipeLevel.Intermediate,
            reputation: -50
        },
        flammable: !0,
        disassemble: !0,
        worth: 50
    },
    o(n.ItemType.LeatherQuiver, n.ItemTypeGroup.Equipment, n.ItemTypeGroup.Storage),
    t.itemDescriptions[n.ItemType.Ectoplasm] = {
        weight: 0,
        decayMax: 25,
        worth: 100
    },
    t.itemDescriptions[n.ItemType.MagicalEssence] = {
        use: [a.ActionType.Transmogrify],
        decayMax: 100,
        recipe: {
            components: [r(n.ItemType.PileOfAsh, 1, 1), r(n.ItemType.Offal, 1, 1), r(n.ItemType.Ectoplasm, 1, 1)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Expert,
            reputation: -500
        },
        onBurn: [n.ItemType.Ectoplasm],
        spawnOnDecay: n.CreatureType.PirateGhost,
        spawnOnBreak: n.CreatureType.PirateGhost,
        spawnableTiles: i.SpawnableTiles.All,
        flammable: !0,
        worth: 200
    },
    o(n.ItemType.MagicalEssence, n.ItemTypeGroup.Transmogrify),
    t.itemDescriptions[n.ItemType.WoodenFence] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Log, 2, 2, 2), r(n.ItemType.WoodenPole, 1, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        durability: 10,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.WoodenFence
        },
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.WoodenFence, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.CreatureIdol] = {
        weight: 3,
        use: [a.ActionType.Build],
        onBurn: [n.ItemType.MagicalEssence, n.ItemType.Giblets, n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Build]: n.DoodadType.CreatureIdol
        },
        worth: 250
    },
    t.itemDescriptions[n.ItemType.CordedSling] = {
        durability: 20,
        use: [a.ActionType.Sling],
        equip: n.EquipType.Held,
        twoHanded: !0,
        attack: 1,
        damageType: n.DamageType.Blunt,
        ranged: {
            range: 5,
            attack: 1
        },
        recipe: {
            components: [r(n.ItemType.String, 4, 4, 4)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Intermediate,
            reputation: -50
        },
        disassemble: !0,
        flammable: !0,
        worth: 20
    },
    o(n.ItemType.CordedSling, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.LeatherSling] = {
        durability: 40,
        use: [a.ActionType.Sling],
        equip: n.EquipType.Held,
        twoHanded: !0,
        attack: 2,
        damageType: n.DamageType.Blunt,
        ranged: {
            range: 6,
            attack: 2
        },
        recipe: {
            components: [r(n.ItemType.TannedLeather, 1, 1, 1), r(n.ItemType.String, 4, 4, 4), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Advanced,
            reputation: -100
        },
        disassemble: !0,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.LeatherSling, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.WroughtIronArrowhead] = {
        use: [a.ActionType.Carve],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 1, 1, 1), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -50
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        damageType: n.DamageType.Piercing,
        worth: 50
    },
    o(n.ItemType.WroughtIronArrowhead, n.ItemTypeGroup.Sharpened),
    t.itemDescriptions[n.ItemType.IronArrowhead] = {
        use: [a.ActionType.Carve],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 1, 1, 1), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -100
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        damageType: n.DamageType.Piercing,
        worth: 50
    },
    o(n.ItemType.IronArrowhead, n.ItemTypeGroup.Sharpened),
    t.itemDescriptions[n.ItemType.Hammock] = {
        use: [a.ActionType.Rest, a.ActionType.Sleep, a.ActionType.PlaceDown],
        durability: 50,
        recipe: {
            components: [r(n.ItemType.Rope, 1, 1, 1), r(n.ItemType.String, 3, 3, 3), r(n.ItemTypeGroup.Pole, 2, 2, 2)],
            skill: n.SkillType.Camping,
            level: n.RecipeLevel.Intermediate,
            reputation: 50
        },
        disassemble: !0,
        hasSleepImage: !0,
        flammable: !0,
        worth: 50,
        doodad: {
            isTall: !0,
            isFlammable: !0,
            repairItem: n.ItemType.Hammock,
            particles: {
                r: 133,
                g: 77,
                b: 22
            },
            reduceDurabilityOnGather: !0
        }
    },
    o(n.ItemType.Hammock, n.ItemTypeGroup.Bedding),
    t.itemDescriptions[n.ItemType.CottonBedroll] = {
        use: [a.ActionType.Rest, a.ActionType.Sleep, a.ActionType.PlaceDown],
        durability: 75,
        recipe: {
            components: [r(n.ItemType.Cotton, 6, 6, 6), r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Fabric, 2, 2, 2), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Advanced,
            reputation: 50
        },
        disassemble: !0,
        hasSleepImage: !0,
        flammable: !0,
        worth: 75,
        doodad: {
            isFlammable: !0,
            repairItem: n.ItemType.CottonBedroll,
            particles: {
                r: 232,
                g: 232,
                b: 232
            },
            reduceDurabilityOnGather: !0
        }
    },
    o(n.ItemType.CottonBedroll, n.ItemTypeGroup.Bedding),
    t.itemDescriptions[n.ItemType.FeatherBedroll] = {
        use: [a.ActionType.Rest, a.ActionType.Sleep, a.ActionType.PlaceDown],
        durability: 75,
        recipe: {
            components: [r(n.ItemType.Feather, 8, 8, 8), r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Fabric, 2, 2, 2), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Intermediate,
            reputation: 50
        },
        disassemble: !0,
        hasSleepImage: !0,
        flammable: !0,
        worth: 75,
        doodad: {
            isFlammable: !0,
            repairItem: n.ItemType.FeatherBedroll,
            particles: {
                r: 246,
                g: 243,
                b: 246
            },
            reduceDurabilityOnGather: !0
        }
    },
    o(n.ItemType.FeatherBedroll, n.ItemTypeGroup.Bedding),
    t.itemDescriptions[n.ItemType.RawTaintedMeat] = {
        weight: .8,
        use: [a.ActionType.Eat],
        decayMax: 750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedTaintedMeat],
        onUse: {
            [a.ActionType.Eat]: [-8, 1, 7, -3]
        },
        worth: 5
    },
    o(n.ItemType.RawTaintedMeat, n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.CookedTaintedMeat] = {
        use: [a.ActionType.Eat],
        decayMax: 1750,
        decaysInto: n.ItemType.RottenMeat,
        recipe: {
            components: [r(n.ItemType.RawTaintedMeat, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Intermediate,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-4, 3, 8, -2]
        },
        worth: 5
    },
    o(n.ItemType.CookedTaintedMeat, n.ItemTypeGroup.Meat, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.StoneKnife] = {
        reducedWeight: .3,
        durability: 30,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Slashing | n.DamageType.Piercing,
        use: [a.ActionType.Carve, a.ActionType.Harvest, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.String, 1, 1), r(n.ItemTypeGroup.SharpenedRock, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Simple,
            reputation: -50
        },
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        worth: 15,
        flammable: !0
    },
    o(n.ItemType.StoneKnife, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.RawBlindfish] = {
        weight: .8,
        use: [a.ActionType.Eat],
        decayMax: 2500,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedBlindfish],
        onUse: {
            [a.ActionType.Eat]: [0, 4, 4, -1]
        },
        worth: 5
    },
    o(n.ItemType.RawBlindfish, n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.CookedBlindfish] = {
        use: [a.ActionType.Eat],
        decayMax: 4500,
        decaysInto: n.ItemType.RottenMeat,
        recipe: {
            components: [r(n.ItemType.RawBlindfish, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 10, 5, -1]
        },
        worth: 15
    },
    o(n.ItemType.CookedBlindfish, n.ItemTypeGroup.Meat, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.Pemmican] = {
        reducedWeight: .5,
        use: [a.ActionType.Eat],
        recipe: {
            components: [r(n.ItemTypeGroup.Meat, 2, 2), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Advanced,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 4, 4, -3]
        },
        worth: 20
    },
    o(n.ItemType.Pemmican, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.PreparedPemmican] = {
        use: [a.ActionType.Eat],
        decayMax: 5250,
        decaysInto: n.ItemType.RottenMeat,
        recipe: {
            components: [r(n.ItemType.Pemmican, 1, 1), r(n.ItemType.AnimalFat, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Advanced,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 12, 6, -1]
        },
        worth: 30
    },
    o(n.ItemType.PreparedPemmican, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.Sail] = {
        recipe: {
            components: [r(n.ItemType.String, 3, 3, 3), r(n.ItemTypeGroup.Fabric, 3, 3, 3), r(n.ItemTypeGroup.Needle, 1, 0)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        disassemble: !0,
        flammable: !0,
        worth: 75
    },
    o(n.ItemType.Sail, n.ItemTypeGroup.Travel),
    t.itemDescriptions[n.ItemType.Sailboat] = {
        use: [a.ActionType.TraverseTheSea, a.ActionType.SailToCivilization],
        recipe: {
            components: [r(n.ItemType.Sail, 1, 1, 1), r(n.ItemType.BoatPaddle, 1, 1, 1), r(n.ItemType.Rope, 2, 2, 2), r(n.ItemType.Log, 3, 3, 3), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Expert,
            reputation: 25
        },
        disassemble: !0,
        flammable: !0,
        worth: 30
    },
    o(n.ItemType.Sailboat, n.ItemTypeGroup.Travel),
    t.itemDescriptions[n.ItemType.Egg] = {
        weight: .2,
        use: [a.ActionType.Eat],
        decayMax: 6250,
        onBurn: [n.ItemType.BoiledEgg],
        spawnOnDecay: n.CreatureType.Chicken,
        spawnableTiles: i.SpawnableTiles.Ground,
        onUse: {
            [a.ActionType.Eat]: [-1, 10, 3, 1]
        },
        worth: 5
    },
    o(n.ItemType.Egg, n.ItemTypeGroup.Food),
    t.itemDescriptions[n.ItemType.BoiledEgg] = {
        use: [a.ActionType.Eat],
        decayMax: 5250,
        recipe: {
            components: [r(n.ItemType.Egg, 1, 1), r(n.ItemTypeGroup.Tongs, 1, 0), r(n.ItemTypeGroup.Liquid, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 12, 3, 0]
        },
        worth: 10
    },
    o(n.ItemType.BoiledEgg, n.ItemTypeGroup.Food),
    t.itemDescriptions[n.ItemType.SheafOfHay] = {
        weight: .1,
        use: [a.ActionType.StokeFire],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.StokeFire]: 4
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.SheafOfHay, n.ItemTypeGroup.Compost, n.ItemTypeGroup.Cordage, n.ItemTypeGroup.Tinder),
    t.itemDescriptions[n.ItemType.Niter] = {
        weight: .4
    },
    t.itemDescriptions[n.ItemType.Saltpeter] = {
        reducedWeight: .1,
        use: [a.ActionType.Preserve],
        recipe: {
            components: [r(n.ItemType.Niter, 1, 1), r(n.ItemTypeGroup.MortarAndPestle, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        onBurn: [n.ItemType.None],
        worth: 10
    },
    o(n.ItemType.Saltpeter, n.ItemTypeGroup.Preservative, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.BlackPowder] = {
        recipe: {
            components: [r(n.ItemType.Saltpeter, 1, 1), r(n.ItemType.CarbonPowder, 1, 1), r(n.ItemTypeGroup.MortarAndPestle, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Advanced,
            reputation: -50
        },
        onBurn: [n.ItemType.None],
        flammable: !0,
        worth: 20,
        durability: 3,
        repairable: !1
    },
    o(n.ItemType.BlackPowder, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.FlintlockPistol] = {
        weight: .9,
        durability: 40,
        use: [a.ActionType.Fire],
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Blunt,
        ranged: {
            range: 9,
            attack: 8
        },
        onBurn: [n.ItemType.Charcoal, n.ItemType.PileOfAsh],
        repairable: !1,
        flammable: !0,
        worth: 250
    },
    o(n.ItemType.FlintlockPistol, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.Giblets] = {
        use: [a.ActionType.Eat],
        recipe: {
            components: [r(n.ItemType.Offal, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        decayMax: 1e3,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [0, -1, 4, -1]
        },
        worth: 5
    },
    o(n.ItemType.Giblets, n.ItemTypeGroup.Compost, n.ItemTypeGroup.Meat, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.ExplosiveTrap] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Leaves, 4, 4, 4), r(n.ItemType.IronIngot, 1, 1, 1), r(n.ItemType.BlackPowder, 1, 1, 1), r(n.ItemTypeGroup.Rock, 1, 1, 1)],
            skill: n.SkillType.Trapping,
            level: n.RecipeLevel.Expert,
            reputation: -25
        },
        disassemble: !0,
        durability: 5,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.SetExplosiveTrap
        },
        flammable: !0,
        worth: 75
    },
    o(n.ItemType.ExplosiveTrap, n.ItemTypeGroup.Trap),
    t.itemDescriptions[n.ItemType.SkeletalMageWand] = {
        weight: .9,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Blunt,
        use: [a.ActionType.Teleport],
        durability: 5,
        onBurn: [n.ItemType.Charcoal, n.ItemType.MagicalEssence],
        flammable: !0,
        repairable: !1,
        worth: 100
    },
    t.itemDescriptions[n.ItemType.RawClayJug] = {
        reducedWeight: .5,
        recipe: {
            components: [r(n.ItemType.RawClay, 1, 1, 1)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        disassemble: !0,
        worth: 25
    },
    o(n.ItemType.RawClayJug, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.ClayJug] = {
        reducedWeight: .5,
        gather: {
            milk: n.ItemType.ClayJugOfGoatMilk,
            desalinated: n.ItemType.ClayJugOfDesalinatedWater,
            unpurified: n.ItemType.ClayJugOfUnpurifiedFreshWater,
            seawater: n.ItemType.ClayJugOfSeawater
        },
        use: [a.ActionType.GatherWater, a.ActionType.GatherMilk],
        recipe: {
            components: [r(n.ItemType.RawClayJug, 1, 1), r(n.ItemType.Cork, 1, 1)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.LitKiln,
            reputation: 25
        },
        durability: 10,
        worth: 50
    },
    o(n.ItemType.ClayJug, n.ItemTypeGroup.Container),
    t.itemDescriptions[n.ItemType.ClayJugOfSeawater] = {
        inheritWeight: n.ItemType.ClayJug,
        use: [a.ActionType.Pour, a.ActionType.PourOnYourself, a.ActionType.DrinkItem],
        durability: 10,
        returnOnUse: [n.ItemType.ClayJug, !1],
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [0, -15, 1, -2]
        },
        worth: 50
    },
    o(n.ItemType.ClayJugOfSeawater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfSeawater),
    t.itemDescriptions[n.ItemType.ClayJugOfDesalinatedWater] = {
        inheritWeight: n.ItemType.ClayJug,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemType.ClayJugOfSeawater,
            components: [r(n.ItemType.Flask, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        durability: 10,
        returnOnUse: [n.ItemType.ClayJug, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [2, 25, 1, 11]
        },
        worth: 75
    },
    o(n.ItemType.ClayJugOfDesalinatedWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ClayJugOfPotableWater, n.ItemTypeGroup.ContainerOfDesalinatedWater),
    t.itemDescriptions[n.ItemType.ClayJugOfMedicinalWater] = {
        inheritWeight: n.ItemType.ClayJug,
        use: [a.ActionType.DrinkCure, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemTypeGroup.ClayJugOfPotableWater,
            components: [r(n.ItemTypeGroup.Medicinal, 2, 2)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        durability: 10,
        returnOnUse: [n.ItemType.ClayJug, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkCure]: [3, 16, 1, 9]
        },
        worth: 75
    },
    o(n.ItemType.ClayJugOfMedicinalWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfMedicinalWater),
    t.itemDescriptions[n.ItemType.ClayJugOfPurifiedFreshWater] = {
        inheritWeight: n.ItemType.ClayJug,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemType.ClayJugOfUnpurifiedFreshWater,
            components: [],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        durability: 10,
        returnOnUse: [n.ItemType.ClayJug, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [1, 25, 1, 10]
        },
        worth: 75
    },
    o(n.ItemType.ClayJugOfPurifiedFreshWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ClayJugOfPotableWater, n.ItemTypeGroup.ContainerOfPurifiedFreshWater),
    t.itemDescriptions[n.ItemType.ClayJugOfUnpurifiedFreshWater] = {
        inheritWeight: n.ItemType.ClayJug,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemType.ClayJug,
            components: [r(n.ItemType.PileOfSnow, 1, 1)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        durability: 10,
        returnOnUse: [n.ItemType.ClayJug, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [-4, 16, 1, 8]
        },
        worth: 50
    },
    o(n.ItemType.ClayJugOfUnpurifiedFreshWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfUnpurifiedFreshWater),
    t.itemDescriptions[n.ItemType.RawClayBrick] = {
        recipe: {
            components: [r(n.ItemType.RawClay, 1, 1, 1)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        disassemble: !0,
        onBurn: [n.ItemType.ClayBrick],
        worth: 10
    },
    o(n.ItemType.RawClayBrick, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.ClayBrick] = {
        reducedWeight: .5,
        recipe: {
            components: [r(n.ItemType.RawClayBrick, 1, 1)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.LitKiln,
            reputation: 25
        },
        worth: 10
    },
    o(n.ItemType.ClayBrick, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.ClayBrickWall] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.ClayBrick, 8, 8, 8)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        disassemble: !0,
        durability: 20,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.ClayBrickWall
        },
        worth: 50
    },
    o(n.ItemType.ClayBrickWall, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.ClayBrickFlooring] = {
        use: [a.ActionType.SetDown],
        recipe: {
            components: [r(n.ItemType.ClayBrick, 8, 8, 8)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        durability: 20,
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.ClayBrickFlooring
        },
        worth: 25
    },
    o(n.ItemType.ClayBrickFlooring, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.PineappleSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Pineapple,
            [a.ActionType.Eat]: [1, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.PineappleSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.RaspberrySeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.RaspberryBush,
            [a.ActionType.Eat]: [1, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.RaspberrySeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.PricklyPearSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.PricklyPears,
            [a.ActionType.Eat]: [1, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.PricklyPearSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.ClematisSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Clematis,
            [a.ActionType.Eat]: [1, 0, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.ClematisSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.PaperSheet] = {
        use: [a.ActionType.DrawMap],
        recipe: {
            components: [r(n.ItemType.PaperMold, 1, 0), r(n.ItemTypeGroup.Pulp, 2, 2), r(n.ItemTypeGroup.Liquid, 1, 0)],
            skill: n.SkillType.Cartography,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        durability: 25,
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 15,
        dismantle: {
            items: [[n.ItemType.ShreddedPaper, 1]]
        }
    },
    o(n.ItemType.PaperSheet, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.PaperMold] = {
        recipe: {
            components: [r(n.ItemType.Log, 2, 2, 1), r(n.ItemTypeGroup.Cordage, 8, 8, 8), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        durability: 20,
        disassemble: !0,
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.PaperMold, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.Beggarticks] = {
        weight: .1,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.Beggarticks, n.ItemTypeGroup.Medicinal),
    t.itemDescriptions[n.ItemType.MilkThistleFlowers] = {
        weight: .2,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 2, 1, 1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.MilkThistleFlowers, n.ItemTypeGroup.Medicinal),
    t.itemDescriptions[n.ItemType.DrawnMap] = {
        weight: .2,
        durability: 25,
        use: [a.ActionType.Decode],
        onBurn: [n.ItemType.PileOfAsh],
        repairable: !1,
        flammable: !0,
        worth: 25
    },
    t.itemDescriptions[n.ItemType.TatteredShirt] = {
        durability: 15,
        equip: n.EquipType.Chest,
        recipe: {
            components: [r(n.ItemType.CottonFabric, 1, 1, 1)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        defense: new n.Defense(1,new n.Resistances,new n.Vulnerabilities(n.DamageType.Fire,2,n.DamageType.Piercing,1,n.DamageType.Blunt,1,n.DamageType.Slashing,1)),
        disassemble: !0,
        craftable: !1,
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.TatteredShirt, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.TatteredPants] = {
        durability: 15,
        equip: n.EquipType.Legs,
        recipe: {
            components: [r(n.ItemType.CottonFabric, 1, 1, 1)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        defense: new n.Defense(1,new n.Resistances,new n.Vulnerabilities(n.DamageType.Fire,2,n.DamageType.Piercing,1,n.DamageType.Blunt,1,n.DamageType.Slashing,1)),
        disassemble: !0,
        craftable: !1,
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.TatteredPants, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.WoodenGate] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Log, 3, 3), r(n.ItemType.WoodenDowels, 2, 2), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Expert,
            reputation: 25
        },
        durability: 10,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.WoodenGate
        },
        burnsLike: [n.ItemType.Log, n.ItemType.Log, n.ItemType.Log, n.ItemType.WoodenDowels, n.ItemType.WoodenDowels],
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.WoodenGate, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.PoisonIvyLeaves] = {
        weight: .1,
        use: [a.ActionType.Eat, a.ActionType.StokeFire],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-3, -2, 1, -2],
            [a.ActionType.StokeFire]: 2
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.PoisonIvyLeaves, n.ItemTypeGroup.Compost),
    t.itemDescriptions[n.ItemType.PoisonIvySeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.PoisonIvy,
            [a.ActionType.Eat]: [-2, -1, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.PoisonIvySeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.WroughtIronChest] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.WroughtIron, 15, 15, 15), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: 25
        },
        durability: 50,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        doodadContainer: n.DoodadType.WroughtIronChest,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.WroughtIronChest
        },
        worth: 750
    },
    o(n.ItemType.WroughtIronChest, n.ItemTypeGroup.Storage),
    t.itemDescriptions[n.ItemType.IronChest] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.IronIngot, 15, 15, 15), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: 25
        },
        durability: 100,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        doodadContainer: n.DoodadType.IronChest,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.IronChest
        },
        worth: 1250
    },
    o(n.ItemType.IronChest, n.ItemTypeGroup.Storage),
    t.itemDescriptions[n.ItemType.SwitchgrassSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Switchgrass,
            [a.ActionType.Eat]: [1, 1, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.SwitchgrassSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.Apple] = {
        use: [a.ActionType.Eat],
        decaysInto: n.ItemType.RottingVegetation,
        decayMax: 8e3,
        returnOnUse: [n.ItemType.AppleSeeds, !0],
        skillUse: n.SkillType.Botany,
        weight: .4,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 8, 2, 1]
        },
        dismantle: {
            items: [[n.ItemType.AppleSeeds, 1]],
            skill: n.SkillType.Botany,
            required: n.ItemTypeGroup.Sharpened
        },
        worth: 5
    },
    o(n.ItemType.Apple, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.SpiderEggs] = {
        decaysInto: n.ItemType.SpiderSilk,
        spawnOnDecay: n.CreatureType.GiantSpider,
        spawnOnBreak: n.CreatureType.GiantSpider,
        spawnableTiles: i.SpawnableTiles.Ground,
        use: [a.ActionType.Eat],
        weight: .3,
        onBurn: [n.ItemType.PileOfAsh],
        decayMax: 3e3,
        onUse: {
            [a.ActionType.Eat]: [-1, -2, 2, -1]
        },
        flammable: !0,
        worth: 25
    },
    t.itemDescriptions[n.ItemType.TailFeathers] = {
        weight: .6,
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        dismantle: {
            items: [[n.ItemType.Feather, 5]]
        },
        flammable: !0,
        worth: 25
    },
    t.itemDescriptions[n.ItemType.AppleSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-2, -2, 1, -1],
            [a.ActionType.Plant]: n.DoodadType.AppleTree
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.AppleSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.VenomGland] = {
        weight: .1,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Anatomy,
        decayMax: 4750,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-10, -20, 1, 0]
        },
        worth: 25
    },
    o(n.ItemType.VenomGland, n.ItemTypeGroup.Medicinal),
    t.itemDescriptions[n.ItemType.OrnateWoodenChest] = {
        weight: 18,
        use: [a.ActionType.Build],
        durability: 25,
        doodadContainer: n.DoodadType.OrnateWoodenChest,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.OrnateWoodenChest
        },
        flammable: !0,
        worth: 1e3,
        burnsLike: [n.ItemType.Log, n.ItemType.Log, n.ItemType.Log, n.ItemType.WoodenDowels, n.ItemType.WoodenDowels]
    },
    o(n.ItemType.OrnateWoodenChest, n.ItemTypeGroup.Storage),
    t.itemDescriptions[n.ItemType.RollOfRedCarpet] = {
        weight: 2.5,
        use: [a.ActionType.SetDown],
        durability: 15,
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.RedCarpet
        },
        flammable: !0,
        worth: 250,
        burnsLike: [n.ItemType.CottonFabric]
    },
    o(n.ItemType.RollOfRedCarpet, n.ItemTypeGroup.Housing),
    t.itemDescriptions[n.ItemType.OrnateCape] = {
        weight: .3,
        durability: 20,
        equip: n.EquipType.Back,
        defense: new n.Defense(1,new n.Resistances,new n.Vulnerabilities(n.DamageType.Fire,2)),
        flammable: !0,
        worth: 250,
        recipe: {
            components: [r(n.ItemType.CottonFabric, 1, 1, 1)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Expert,
            reputation: 25
        },
        craftable: !1,
        burnsLike: [n.ItemType.CottonFabric]
    },
    o(n.ItemType.OrnateCape, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.FireBladder] = {
        weight: .8,
        onBurn: [n.ItemType.PileOfAsh],
        use: [a.ActionType.Squeeze],
        decayMax: 1e3,
        decaysInto: n.ItemType.RottenMeat,
        damageType: n.DamageType.Blunt | n.DamageType.Fire,
        worth: 100
    },
    t.itemDescriptions[n.ItemType.GoldenKey] = {
        weight: 1,
        worth: 1e3
    },
    o(n.ItemType.GoldenKey, n.ItemTypeGroup.Treasure),
    t.itemDescriptions[n.ItemType.WoodenSword] = {
        durability: 15,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Blunt | n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.WoodenPole, 2, 2), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Intermediate,
            reputation: -50
        },
        use: [a.ActionType.Gather],
        burnsLike: [n.ItemType.WoodenPole, n.ItemType.WoodenPole],
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.WoodenSword, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.ClayKiln] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.ClayBrick, 8, 8, 8)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Advanced,
            reputation: -25
        },
        disassemble: !0,
        durability: 20,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.ClayKiln
        },
        worth: 50
    },
    o(n.ItemType.ClayKiln, n.ItemTypeGroup.Heating, n.ItemTypeGroup.Kiln),
    t.itemDescriptions[n.ItemType.ClayCampfire] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.ClayBrick, 5, 5, 5)],
            skill: n.SkillType.Camping,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        disassemble: !0,
        durability: 15,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.ClayCampfire
        },
        worth: 25
    },
    o(n.ItemType.ClayCampfire, n.ItemTypeGroup.Firemaking, n.ItemTypeGroup.Heating, n.ItemTypeGroup.Campfire),
    t.itemDescriptions[n.ItemType.ClayFurnace] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.ClayBrick, 8, 8, 8)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Advanced,
            reputation: -25
        },
        disassemble: !0,
        durability: 20,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.ClayFurnace
        },
        worth: 50
    },
    o(n.ItemType.ClayFurnace, n.ItemTypeGroup.Heating, n.ItemTypeGroup.Furnace),
    t.itemDescriptions[n.ItemType.ClayWaterStill] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemType.ClayBrick, 2, 2, 1), r(n.ItemTypeGroup.Sharpened, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Container, 1, 1, 1)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        durability: 20,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.ClayWaterStill
        },
        worth: 75
    },
    o(n.ItemType.ClayWaterStill, n.ItemTypeGroup.WaterStill),
    t.itemDescriptions[n.ItemType.SandstoneCampfire] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Sandstone, 5, 5, 5)],
            skill: n.SkillType.Camping,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        disassemble: !0,
        durability: 10,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.SandstoneCampfire
        },
        worth: 25
    },
    o(n.ItemType.SandstoneCampfire, n.ItemTypeGroup.Firemaking, n.ItemTypeGroup.Heating, n.ItemTypeGroup.Campfire),
    t.itemDescriptions[n.ItemType.SandstoneFurnace] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Sandstone, 8, 8, 8)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Advanced,
            reputation: -25
        },
        disassemble: !0,
        durability: 15,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.SandstoneFurnace
        },
        worth: 50
    },
    o(n.ItemType.SandstoneFurnace, n.ItemTypeGroup.Heating, n.ItemTypeGroup.Furnace),
    t.itemDescriptions[n.ItemType.SandstoneWaterStill] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemType.Sandstone, 2, 2, 1), r(n.ItemTypeGroup.Sharpened, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Container, 1, 1, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        disassemble: !0,
        durability: 15,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.SandstoneWaterStill
        },
        worth: 75
    },
    o(n.ItemType.SandstoneWaterStill, n.ItemTypeGroup.WaterStill),
    t.itemDescriptions[n.ItemType.StoneKiln] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemTypeGroup.Rock, 8, 8, 8)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Advanced,
            reputation: -25
        },
        disassemble: !0,
        durability: 25,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.StoneKiln
        },
        worth: 50
    },
    o(n.ItemType.StoneKiln, n.ItemTypeGroup.Heating, n.ItemTypeGroup.Kiln),
    t.itemDescriptions[n.ItemType.WroughtIronAnvil] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.Log, 1, 1, 1), r(n.ItemType.WroughtIron, 12, 12, 12), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            level: n.RecipeLevel.Advanced,
            reputation: -50
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        durability: 50,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.WroughtIronAnvil
        },
        worth: 450
    },
    o(n.ItemType.WroughtIronAnvil, n.ItemTypeGroup.Anvil),
    t.itemDescriptions[n.ItemType.IronAnvil] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.Log, 1, 1, 1), r(n.ItemType.IronIngot, 12, 12, 12), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -50
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        durability: 100,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.IronAnvil
        },
        worth: 750
    },
    o(n.ItemType.IronAnvil, n.ItemTypeGroup.Anvil),
    t.itemDescriptions[n.ItemType.MageRobe] = {
        durability: 10,
        equip: n.EquipType.Back,
        showOverHair: !0,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,2),new n.Vulnerabilities(n.DamageType.Piercing,1)),
        recipe: {
            components: [r(n.ItemType.CottonFabric, 1, 1, 1)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Expert,
            reputation: 25
        },
        disassemble: !0,
        craftable: !1,
        flammable: !0,
        hideHelmet: !0,
        worth: 250
    },
    o(n.ItemType.MageRobe, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.OrbOfInfluence] = {
        weight: 1,
        onBurn: [n.ItemType.PileOfAsh],
        use: [a.ActionType.RubClockwise, a.ActionType.RubCounterclockwise],
        worth: 250
    },
    t.itemDescriptions[n.ItemType.AnimalClaw] = {
        weight: .3,
        durability: 10,
        onBurn: [n.ItemType.PileOfAsh],
        damageType: n.DamageType.Piercing,
        worth: 5
    },
    o(n.ItemType.AnimalClaw, n.ItemTypeGroup.Needle),
    t.itemDescriptions[n.ItemType.AnimalPelt] = {
        weight: 1.5,
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        equip: n.EquipType.Back,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1),new n.Vulnerabilities(n.DamageType.Blunt,1)),
        dismantle: {
            items: [[n.ItemType.LeatherHide, 1], [n.ItemType.AnimalFur, 1]],
            required: n.ItemTypeGroup.Sharpened,
            skill: n.SkillType.Leatherworking
        },
        flammable: !0,
        worth: 10
    },
    o(n.ItemType.AnimalPelt, n.ItemTypeGroup.Equipment, n.ItemTypeGroup.Fabric),
    t.itemDescriptions[n.ItemType.AnimalFur] = {
        weight: .1,
        onBurn: [n.ItemType.PileOfAsh],
        use: [a.ActionType.StokeFire],
        onUse: {
            [a.ActionType.StokeFire]: 2
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.AnimalFur, n.ItemTypeGroup.Tinder),
    t.itemDescriptions[n.ItemType.Scales] = {
        weight: .8,
        onBurn: [n.ItemType.PileOfAsh],
        worth: 10
    },
    o(n.ItemType.Scales, n.ItemTypeGroup.Fabric),
    t.itemDescriptions[n.ItemType.SharkFin] = {
        weight: .4,
        onBurn: [n.ItemType.PileOfAsh],
        decayMax: 4750,
        decaysInto: n.ItemType.RottenMeat,
        worth: 10
    },
    t.itemDescriptions[n.ItemType.RawReptileMeat] = {
        weight: .7,
        use: [a.ActionType.Eat],
        decayMax: 2750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedReptileMeat],
        onUse: {
            [a.ActionType.Eat]: [-2, 2, 6, -2]
        },
        worth: 5
    },
    o(n.ItemType.RawReptileMeat, n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.CookedReptileMeat] = {
        use: [a.ActionType.Eat],
        decayMax: 4750,
        decaysInto: n.ItemType.RottenMeat,
        recipe: {
            components: [r(n.ItemType.RawReptileMeat, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Intermediate,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 12, 7, -1]
        },
        worth: 15
    },
    o(n.ItemType.CookedReptileMeat, n.ItemTypeGroup.Meat, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.Tentacles] = {
        weight: .6,
        use: [a.ActionType.Eat],
        decayMax: 5500,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedTentacles],
        onUse: {
            [a.ActionType.Eat]: [0, 2, 5, -1]
        },
        worth: 10
    },
    o(n.ItemType.Tentacles, n.ItemTypeGroup.Meat, n.ItemTypeGroup.Food),
    t.itemDescriptions[n.ItemType.CookedTentacles] = {
        use: [a.ActionType.Eat],
        decayMax: 6500,
        decaysInto: n.ItemType.RottenMeat,
        recipe: {
            components: [r(n.ItemType.Tentacles, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Intermediate,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 6, 6, -1]
        },
        worth: 20
    },
    o(n.ItemType.CookedTentacles, n.ItemTypeGroup.Meat, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.WormMeat] = {
        weight: .5,
        use: [a.ActionType.Eat],
        decayMax: 4500,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedWormMeat],
        onUse: {
            [a.ActionType.Eat]: [0, 0, 4, 0]
        },
        worth: 5
    },
    o(n.ItemType.WormMeat, n.ItemTypeGroup.RawMeat, n.ItemTypeGroup.Food, n.ItemTypeGroup.Bait),
    t.itemDescriptions[n.ItemType.CookedWormMeat] = {
        use: [a.ActionType.Eat],
        decayMax: 5500,
        decaysInto: n.ItemType.RottenMeat,
        recipe: {
            components: [r(n.ItemType.WormMeat, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Intermediate,
            requiresFire: !0,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 4, 5, -1]
        },
        worth: 10
    },
    o(n.ItemType.CookedWormMeat, n.ItemTypeGroup.Meat, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.StonePickaxe] = {
        durability: 50,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Blunt | n.DamageType.Piercing,
        use: [a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.SharpenedRock, 2, 2, 2)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: -75
        },
        disassemble: !0,
        worth: 25,
        flammable: !0
    },
    o(n.ItemType.StonePickaxe, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.WroughtIronAxe] = {
        durability: 150,
        equip: n.EquipType.Held,
        attack: 5,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 4, 4, 4), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -500
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 150
    },
    o(n.ItemType.WroughtIronAxe, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.IronAxe] = {
        durability: 300,
        equip: n.EquipType.Held,
        attack: 6,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 4, 4, 4), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 250
    },
    o(n.ItemType.IronAxe, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.FertileSoil] = {
        recipe: {
            components: [r(n.ItemType.Soil, 1, 1), r(n.ItemType.Fertilizer, 1, 1)],
            skill: n.SkillType.Gardening,
            level: n.RecipeLevel.Advanced,
            reputation: 50
        },
        use: [a.ActionType.SetDown, a.ActionType.SmotherFire],
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.FertileSoil,
            [a.ActionType.SmotherFire]: n.TerrainType.FertileSoil
        },
        worth: 25
    },
    t.itemDescriptions[n.ItemType.StoneHoe] = {
        durability: 50,
        equip: n.EquipType.Held,
        attack: 1,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Till, a.ActionType.Harvest, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.String, 2, 2, 2), r(n.ItemTypeGroup.SharpenedRock, 1, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1, 1)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Intermediate,
            reputation: 75
        },
        disassemble: !0,
        worth: 25,
        flammable: !0
    },
    o(n.ItemType.StoneHoe, n.ItemTypeGroup.Tool, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.WroughtIronHoe] = {
        durability: 200,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Till, a.ActionType.Harvest, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.String, 2, 2, 2), r(n.ItemType.WroughtIron, 3, 3, 3), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: 50
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 150
    },
    o(n.ItemType.WroughtIronHoe, n.ItemTypeGroup.Tool, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.IronHoe] = {
        durability: 400,
        equip: n.EquipType.Held,
        attack: 4,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Till, a.ActionType.Harvest, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.String, 2, 2, 2), r(n.ItemType.IronIngot, 3, 3, 3), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: 25
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 250
    },
    o(n.ItemType.IronHoe, n.ItemTypeGroup.Tool, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.LavaBeetleHelmet] = {
        durability: 75,
        equip: n.EquipType.Head,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Blunt,3,n.DamageType.Fire,4),new n.Vulnerabilities),
        repairable: !1,
        damageType: n.DamageType.Piercing,
        weight: 1.5,
        worth: 500
    },
    o(n.ItemType.LavaBeetleHelmet, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.SpruceCone] = {
        weight: .2,
        onBurn: [n.ItemType.PileOfAsh],
        skillUse: n.SkillType.Botany,
        dismantle: {
            items: [[n.ItemType.SpruceSeeds, 1]],
            required: n.ItemTypeGroup.Sharpened,
            skill: n.SkillType.Botany
        },
        flammable: !0,
        worth: 5
    },
    t.itemDescriptions[n.ItemType.SpruceSeeds] = {
        weight: .1,
        skillUse: n.SkillType.Botany,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-1, 1, 1, -1],
            [a.ActionType.Plant]: n.DoodadType.SpruceTree
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.SpruceSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.SpruceNeedles] = {
        use: [a.ActionType.StokeFire],
        weight: .1,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.StokeFire]: 2
        },
        worth: 5
    },
    o(n.ItemType.SpruceNeedles, n.ItemTypeGroup.Compost, n.ItemTypeGroup.Tinder),
    t.itemDescriptions[n.ItemType.CypressCone] = {
        weight: .2,
        onBurn: [n.ItemType.PileOfAsh],
        skillUse: n.SkillType.Botany,
        dismantle: {
            items: [[n.ItemType.CypressSeeds, 1]],
            required: n.ItemTypeGroup.Sharpened,
            skill: n.SkillType.Botany
        },
        flammable: !0,
        worth: 5
    },
    t.itemDescriptions[n.ItemType.CypressSeeds] = {
        weight: .1,
        skillUse: n.SkillType.Botany,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-1, 6, 1, -1],
            [a.ActionType.Plant]: n.DoodadType.CypressTree
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.CypressSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.CypressLeaves] = {
        use: [a.ActionType.StokeFire],
        weight: .1,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.StokeFire]: 2
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.CypressLeaves, n.ItemTypeGroup.Compost, n.ItemTypeGroup.Tinder),
    t.itemDescriptions[n.ItemType.Lettuce] = {
        weight: .2,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 9750,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 8, 3, 1]
        },
        worth: 10
    },
    o(n.ItemType.Lettuce, n.ItemTypeGroup.Food, n.ItemTypeGroup.Vegetable),
    t.itemDescriptions[n.ItemType.LettuceSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Lettuce,
            [a.ActionType.Eat]: [1, 4, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.LettuceSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.ChiveSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Chives,
            [a.ActionType.Eat]: [1, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.ChiveSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.Potato] = {
        weight: .3,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 15e3,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.CookedPotato],
        onUse: {
            [a.ActionType.Eat]: [-1, -1, 4, -1]
        },
        worth: 10
    },
    o(n.ItemType.Potato, n.ItemTypeGroup.Food, n.ItemTypeGroup.Vegetable),
    t.itemDescriptions[n.ItemType.PotatoSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.PotatoPlant,
            [a.ActionType.Eat]: [0, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.PotatoSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.Carrot] = {
        weight: .2,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 13750,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 8, 3, -1]
        },
        worth: 10
    },
    o(n.ItemType.Carrot, n.ItemTypeGroup.Food, n.ItemTypeGroup.Vegetable),
    t.itemDescriptions[n.ItemType.CarrotSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Carrots,
            [a.ActionType.Eat]: [1, 3, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.CarrotSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.CornEar] = {
        weight: .4,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 1e4,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.CookedCornCob],
        onUse: {
            [a.ActionType.Eat]: [2, 3, 3, -1]
        },
        dismantle: {
            items: [[n.ItemType.CornSeeds, 1]],
            skill: n.SkillType.Botany
        },
        worth: 10
    },
    o(n.ItemType.CornEar, n.ItemTypeGroup.Food, n.ItemTypeGroup.Vegetable),
    t.itemDescriptions[n.ItemType.CornSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.CornStalks,
            [a.ActionType.Eat]: [0, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.CornSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.Cucumber] = {
        weight: .4,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 9e3,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 10, 3, 3]
        },
        dismantle: {
            items: [[n.ItemType.CucumberSeeds, 1]],
            skill: n.SkillType.Botany
        },
        worth: 5
    },
    o(n.ItemType.Cucumber, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.CucumberSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.CucumberPlant,
            [a.ActionType.Eat]: [0, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.CucumberSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.Tomato] = {
        weight: .2,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 8250,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 12, 3, 2]
        },
        dismantle: {
            items: [[n.ItemType.TomatoSeeds, 1]],
            skill: n.SkillType.Botany
        },
        worth: 5
    },
    o(n.ItemType.Tomato, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.TomatoSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.TomatoPlant,
            [a.ActionType.Eat]: [1, 3, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.TomatoSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.Pumpkin] = {
        weight: 1.3,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 14250,
        decaysInto: n.ItemType.RottingVegetation,
        returnOnUse: [n.ItemType.PumpkinSeeds, !0],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [3, 12, 5, 2]
        },
        dismantle: {
            items: [[n.ItemType.PumpkinSeeds, 1]],
            skill: n.SkillType.Botany,
            required: n.ItemTypeGroup.Sharpened
        },
        worth: 10
    },
    o(n.ItemType.Pumpkin, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.PumpkinSeeds] = {
        weight: .2,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Pumpkin,
            [a.ActionType.Eat]: [0, 2, 2, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.PumpkinSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.PricklyPearFruit] = {
        weight: .3,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 8750,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 6, 2, 2]
        },
        dismantle: {
            items: [[n.ItemType.PricklyPearSeeds, 1]],
            skill: n.SkillType.Botany
        },
        worth: 5
    },
    o(n.ItemType.PricklyPearFruit, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.SugarCaneStalks] = {
        weight: .7,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 13750,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 12, 1, -2]
        },
        worth: 10
    },
    o(n.ItemType.SugarCaneStalks, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.SugarCaneSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.SugarCaneStalks,
            [a.ActionType.Eat]: [0, 1, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.SugarCaneSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.BushelOfWheat] = {
        weight: .4,
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        dismantle: {
            items: [[n.ItemType.Wheat, 2], [n.ItemType.SheafOfHay, 1]],
            skill: n.SkillType.Botany
        },
        flammable: !0,
        worth: 10
    },
    t.itemDescriptions[n.ItemType.Wheat] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Wheat,
            [a.ActionType.Eat]: [0, 2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.Wheat, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.CookedPotato] = {
        use: [a.ActionType.Eat],
        decayMax: 1e4,
        skillUse: n.SkillType.Botany,
        recipe: {
            components: [r(n.ItemType.Potato, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 10, 4, -1]
        },
        worth: 15
    },
    o(n.ItemType.CookedPotato, n.ItemTypeGroup.Food, n.ItemTypeGroup.Vegetable),
    t.itemDescriptions[n.ItemType.CookedCornCob] = {
        use: [a.ActionType.Eat],
        decayMax: 5750,
        skillUse: n.SkillType.Botany,
        recipe: {
            components: [r(n.ItemType.CornEar, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [3, 12, 3, -1]
        },
        worth: 15
    },
    o(n.ItemType.CookedCornCob, n.ItemTypeGroup.Food, n.ItemTypeGroup.Vegetable),
    t.itemDescriptions[n.ItemType.BundleOfSwitchgrass] = {
        weight: .4,
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        dismantle: {
            items: [[n.ItemType.SwitchgrassSeeds, 2], [n.ItemType.SheafOfHay, 1]],
            skill: n.SkillType.Botany
        },
        flammable: !0,
        worth: 10
    },
    t.itemDescriptions[n.ItemType.Cloak] = {
        durability: 30,
        equip: n.EquipType.Back,
        showOverHair: !0,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,2),new n.Vulnerabilities(n.DamageType.Piercing,2)),
        recipe: {
            components: [r(n.ItemType.CottonFabric, 1, 1, 1)],
            skill: n.SkillType.Tailoring,
            level: n.RecipeLevel.Expert,
            reputation: 25
        },
        disassemble: !0,
        craftable: !1,
        flammable: !0,
        hideHelmet: !0,
        worth: 100
    },
    o(n.ItemType.Cloak, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.WoodenMortarAndPestle] = {
        reducedWeight: 3.5,
        recipe: {
            components: [r(n.ItemType.Log, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        durability: 10,
        onBurn: [n.ItemType.Charcoal, n.ItemType.Charcoal, n.ItemType.Charcoal, n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 30
    },
    o(n.ItemType.WoodenMortarAndPestle, n.ItemTypeGroup.Tool, n.ItemTypeGroup.MortarAndPestle),
    t.itemDescriptions[n.ItemType.SandstoneMortarAndPestle] = {
        reducedWeight: 1.5,
        recipe: {
            components: [r(n.ItemType.Sandstone, 3, 2)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        durability: 15,
        worth: 20
    },
    o(n.ItemType.SandstoneMortarAndPestle, n.ItemTypeGroup.Tool, n.ItemTypeGroup.MortarAndPestle),
    t.itemDescriptions[n.ItemType.WroughtIronMortarAndPestle] = {
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.WroughtIron, 2, 2, 2), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: 25
        },
        durability: 100,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 150
    },
    o(n.ItemType.WroughtIronMortarAndPestle, n.ItemTypeGroup.Tool, n.ItemTypeGroup.MortarAndPestle),
    t.itemDescriptions[n.ItemType.IronMortarAndPestle] = {
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 2, 2, 2), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: 25
        },
        durability: 200,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 250
    },
    o(n.ItemType.IronMortarAndPestle, n.ItemTypeGroup.Tool, n.ItemTypeGroup.MortarAndPestle),
    t.itemDescriptions[n.ItemType.RawClayMortarAndPestle] = {
        recipe: {
            components: [r(n.ItemType.RawClay, 1, 1, 1)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        worth: 10
    },
    o(n.ItemType.RawClayMortarAndPestle, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.ClayMortarAndPestle] = {
        recipe: {
            components: [r(n.ItemType.RawClayMortarAndPestle, 1, 1, 1)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.LitKiln,
            reputation: 25
        },
        durability: 20,
        worth: 15
    },
    o(n.ItemType.ClayMortarAndPestle, n.ItemTypeGroup.Tool, n.ItemTypeGroup.MortarAndPestle),
    t.itemDescriptions[n.ItemType.CopperOre] = {
        weight: .6,
        worth: 25
    },
    t.itemDescriptions[n.ItemType.CopperIngot] = {
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.LimestonePowder, 1, 1, 0, !0), r(n.ItemType.CopperOre, 1, 1), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.LitFurnace,
            reputation: -100
        },
        worth: 35
    },
    o(n.ItemType.CopperIngot, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.CopperPickaxe] = {
        durability: 150,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Blunt | n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.CopperIngot, 6, 6, 6), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -250
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        use: [a.ActionType.Gather],
        worth: 200
    },
    o(n.ItemType.CopperPickaxe, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.CopperDoubleAxe] = {
        durability: 150,
        equip: n.EquipType.Held,
        attack: 6,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.CopperIngot, 8, 8, 8), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -750
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 400
    },
    o(n.ItemType.CopperDoubleAxe, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.CopperShovel] = {
        durability: 150,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Dig, a.ActionType.Gather, a.ActionType.GatherTreasure, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.String, 2, 2, 2), r(n.ItemType.CopperIngot, 3, 3, 3), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -175
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 200
    },
    o(n.ItemType.CopperShovel, n.ItemTypeGroup.Tool, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.CopperSpear] = {
        durability: 75,
        equip: n.EquipType.Held,
        attack: 5,
        damageType: n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.CopperIngot, 2, 2, 2), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -500
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        use: [a.ActionType.Gather],
        worth: 200
    },
    o(n.ItemType.CopperSpear, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.CopperHammer] = {
        durability: 45,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Blunt,
        use: [a.ActionType.Repair, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.CopperIngot, 3, 3, 3), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -175
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 200
    },
    o(n.ItemType.CopperHammer, n.ItemTypeGroup.Hammer, n.ItemTypeGroup.Repair, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.CopperLockPick] = {
        durability: 30,
        use: [a.ActionType.LockPick],
        recipe: {
            components: [r(n.ItemType.CopperIngot, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -175
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        damageType: n.DamageType.Piercing,
        worth: 50
    },
    o(n.ItemType.CopperLockPick, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.CopperShield] = {
        durability: 75,
        equip: n.EquipType.Held,
        defense: new n.Defense(3,new n.Resistances,new n.Vulnerabilities(n.DamageType.Blunt,1,n.DamageType.Fire,1)),
        recipe: {
            components: [r(n.ItemType.CopperIngot, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -500
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 600
    },
    o(n.ItemType.CopperShield, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.CopperGauntlets] = {
        durability: 75,
        equip: n.EquipType.Hands,
        defense: new n.Defense(2,new n.Resistances,new n.Vulnerabilities(n.DamageType.Blunt,1,n.DamageType.Fire,1)),
        recipe: {
            components: [r(n.ItemType.CopperIngot, 8, 8, 8), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -500
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 400
    },
    o(n.ItemType.CopperGauntlets, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.CopperGreaves] = {
        durability: 75,
        equip: n.EquipType.Legs,
        defense: new n.Defense(4,new n.Resistances,new n.Vulnerabilities(n.DamageType.Blunt,1,n.DamageType.Fire,1)),
        recipe: {
            components: [r(n.ItemType.CopperIngot, 10, 10, 10), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -500
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 600
    },
    o(n.ItemType.CopperGreaves, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.CopperGorget] = {
        durability: 75,
        equip: n.EquipType.Neck,
        defense: new n.Defense(2,new n.Resistances,new n.Vulnerabilities(n.DamageType.Blunt,1,n.DamageType.Fire,1)),
        recipe: {
            components: [r(n.ItemType.CopperIngot, 6, 6, 6), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -500
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 400
    },
    o(n.ItemType.CopperGorget, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.CopperHelmet] = {
        durability: 75,
        equip: n.EquipType.Head,
        defense: new n.Defense(3,new n.Resistances,new n.Vulnerabilities(n.DamageType.Blunt,1,n.DamageType.Fire,1)),
        recipe: {
            components: [r(n.ItemType.CopperIngot, 8, 8, 8), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -500
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 400
    },
    o(n.ItemType.CopperHelmet, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.CopperBoots] = {
        durability: 75,
        equip: n.EquipType.Feet,
        defense: new n.Defense(3,new n.Resistances,new n.Vulnerabilities(n.DamageType.Blunt,1,n.DamageType.Fire,1)),
        recipe: {
            components: [r(n.ItemType.CopperIngot, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -500
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 600
    },
    o(n.ItemType.CopperBoots, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.CopperBreastPlate] = {
        durability: 75,
        equip: n.EquipType.Chest,
        defense: new n.Defense(4,new n.Resistances,new n.Vulnerabilities(n.DamageType.Blunt,1,n.DamageType.Fire,1)),
        recipe: {
            components: [r(n.ItemType.CopperIngot, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -500
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 600
    },
    o(n.ItemType.CopperBreastPlate, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.CopperSword] = {
        durability: 75,
        equip: n.EquipType.Held,
        attack: 7,
        damageType: n.DamageType.Piercing | n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.CopperIngot, 8, 8, 8), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -500
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 400
    },
    o(n.ItemType.CopperSword, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.CopperTongs] = {
        recipe: {
            components: [r(n.ItemType.CopperIngot, 3, 3, 3), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -50
        },
        repairAndDisassemblyRequiresFire: !0,
        durability: 35,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        use: [a.ActionType.Grasp],
        worth: 200
    },
    o(n.ItemType.CopperTongs, n.ItemTypeGroup.Tongs, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.CopperArrow] = {
        recipe: {
            components: [r(n.ItemType.Feather, 1, 1, 1), r(n.ItemType.CopperArrowhead, 1, 1, 1), r(n.ItemType.ArrowShaft, 1, 1, 1), r(n.ItemTypeGroup.Cordage, 1, 1, 1)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Intermediate,
            reputation: -75
        },
        disassemble: !0,
        attack: 3,
        damageType: n.DamageType.Piercing,
        durability: 35,
        onBurn: [n.ItemType.CopperArrowhead],
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.CopperArrow, n.ItemTypeGroup.Arrow),
    t.itemDescriptions[n.ItemType.CopperBullet] = {
        recipe: {
            components: [r(n.ItemType.CopperIngot, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -50
        },
        repairAndDisassemblyRequiresFire: !0,
        attack: 2,
        damageType: n.DamageType.Blunt,
        durability: 35,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 50
    },
    o(n.ItemType.CopperBullet, n.ItemTypeGroup.Bullet),
    t.itemDescriptions[n.ItemType.CopperArrowhead] = {
        use: [a.ActionType.Carve],
        recipe: {
            components: [r(n.ItemType.CopperIngot, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -50
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        damageType: n.DamageType.Piercing,
        worth: 50
    },
    o(n.ItemType.CopperArrowhead, n.ItemTypeGroup.Sharpened),
    t.itemDescriptions[n.ItemType.CopperChest] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.CopperIngot, 15, 15, 15), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Intermediate,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: 25
        },
        repairAndDisassemblyRequiresFire: !0,
        durability: 35,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        doodadContainer: n.DoodadType.CopperChest,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.CopperChest
        },
        worth: 1e3
    };
    o(n.ItemType.CopperChest, n.ItemTypeGroup.Storage),
    t.itemDescriptions[n.ItemType.CopperAnvil] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Log, 1, 1, 1), r(n.ItemType.CopperIngot, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            level: n.RecipeLevel.Intermediate,
            reputation: -50
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        durability: 35,
        onUse: {
            [a.ActionType.Build]: n.DoodadType.CopperAnvil
        },
        worth: 600
    },
    o(n.ItemType.CopperAnvil, n.ItemTypeGroup.Anvil),
    t.itemDescriptions[n.ItemType.CopperAxe] = {
        durability: 100,
        equip: n.EquipType.Held,
        attack: 4,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.CopperIngot, 4, 4, 4), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: -500
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 200
    },
    o(n.ItemType.CopperAxe, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.CopperHoe] = {
        durability: 150,
        equip: n.EquipType.Held,
        attack: 2,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Till, a.ActionType.Harvest, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.String, 2, 2, 2), r(n.ItemType.CopperIngot, 3, 3, 3), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: 50
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 200
    },
    o(n.ItemType.CopperHoe, n.ItemTypeGroup.Tool, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.CopperMortarAndPestle] = {
        recipe: {
            components: [r(n.ItemType.CopperIngot, 2, 2, 2), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: 25
        },
        repairAndDisassemblyRequiresFire: !0,
        durability: 75,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 200
    },
    o(n.ItemType.CopperMortarAndPestle, n.ItemTypeGroup.Tool, n.ItemTypeGroup.MortarAndPestle),
    t.itemDescriptions[n.ItemType.WaterskinOfGoatMilk] = {
        inheritWeight: n.ItemType.Waterskin,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        durability: 20,
        returnOnUse: [n.ItemType.Waterskin, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        flammable: !0,
        onUse: {
            [a.ActionType.DrinkItem]: [2, 20, 2, 5]
        }
    },
    o(n.ItemType.WaterskinOfGoatMilk, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.Milk),
    t.itemDescriptions[n.ItemType.ClayJugOfGoatMilk] = {
        inheritWeight: n.ItemType.ClayJug,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        durability: 10,
        returnOnUse: [n.ItemType.ClayJug, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [2, 20, 2, 5]
        },
        worth: 75
    },
    o(n.ItemType.ClayJugOfGoatMilk, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.Milk),
    t.itemDescriptions[n.ItemType.GlassBottleOfGoatMilk] = {
        inheritWeight: n.ItemType.GlassBottle,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        durability: 15,
        returnOnUse: [n.ItemType.GlassBottle, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [2, 20, 2, 5]
        },
        worth: 75
    },
    o(n.ItemType.GlassBottleOfGoatMilk, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.Milk),
    t.itemDescriptions[n.ItemType.Obsidian] = {
        durability: 10,
        weight: 1.2,
        use: [a.ActionType.Carve, a.ActionType.Harvest],
        damageType: n.DamageType.Piercing | n.DamageType.Slashing,
        worth: 10
    },
    o(n.ItemType.Obsidian, n.ItemTypeGroup.Sharpened),
    t.itemDescriptions[n.ItemType.OrnateBlueBook] = {
        weight: 1.5,
        use: [a.ActionType.Read],
        burnsLike: [n.ItemType.PaperSheet, n.ItemType.PaperSheet, n.ItemType.PaperSheet, n.ItemType.PaperSheet, n.ItemType.PaperSheet],
        flammable: !0,
        worth: 50,
        dismantle: {
            items: [[n.ItemType.ShreddedPaper, 5]]
        }
    },
    o(n.ItemType.OrnateBlueBook, n.ItemTypeGroup.Book),
    t.itemDescriptions[n.ItemType.Journal] = {
        weight: 1.2,
        use: [a.ActionType.Read],
        burnsLike: [n.ItemType.PaperSheet, n.ItemType.PaperSheet, n.ItemType.PaperSheet, n.ItemType.PaperSheet],
        flammable: !0,
        worth: 50,
        dismantle: {
            items: [[n.ItemType.ShreddedPaper, 3]]
        }
    },
    o(n.ItemType.Journal, n.ItemTypeGroup.Book),
    t.itemDescriptions[n.ItemType.MossCoveredBook] = {
        weight: 1.4,
        use: [a.ActionType.Read],
        burnsLike: [n.ItemType.PaperSheet, n.ItemType.PaperSheet, n.ItemType.PaperSheet],
        flammable: !0,
        worth: 50,
        dismantle: {
            items: [[n.ItemType.ShreddedPaper, 4]]
        }
    },
    o(n.ItemType.MossCoveredBook, n.ItemTypeGroup.Book),
    t.itemDescriptions[n.ItemType.GildedRedBook] = {
        weight: 1.6,
        use: [a.ActionType.Read],
        burnsLike: [n.ItemType.PaperSheet, n.ItemType.PaperSheet, n.ItemType.PaperSheet, n.ItemType.PaperSheet, n.ItemType.PaperSheet],
        flammable: !0,
        worth: 50,
        dismantle: {
            items: [[n.ItemType.ShreddedPaper, 6]]
        }
    },
    o(n.ItemType.GildedRedBook, n.ItemTypeGroup.Book),
    t.itemDescriptions[n.ItemType.ArrowShaft] = {
        reducedWeight: .3,
        recipe: {
            components: [r(n.ItemTypeGroup.Pole, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.ArrowShaft, n.ItemTypeGroup.Other),
    t.itemDescriptions[n.ItemType.SlitherSucker] = {
        durability: 25,
        equip: n.EquipType.Head,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Blunt,4),new n.Vulnerabilities(n.DamageType.Fire,2)),
        repairable: !1,
        weight: .7
    },
    o(n.ItemType.SlitherSucker, n.ItemTypeGroup.Equipment, n.ItemTypeGroup.Untradable),
    t.itemDescriptions[n.ItemType.AberrantSlitherSucker] = {
        durability: 50,
        equip: n.EquipType.Head,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Blunt,8),new n.Vulnerabilities(n.DamageType.Fire,4)),
        repairable: !1,
        weight: 1.4
    },
    o(n.ItemType.AberrantSlitherSucker, n.ItemTypeGroup.Equipment, n.ItemTypeGroup.Untradable),
    t.itemDescriptions[n.ItemType.StrawHat] = {
        durability: 25,
        equip: n.EquipType.Head,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1),new n.Vulnerabilities(n.DamageType.Piercing,1,n.DamageType.Fire,1)),
        recipe: {
            components: [r(n.ItemType.SheafOfHay, 4, 4)],
            skill: n.SkillType.Tinkering,
            level: n.RecipeLevel.Advanced,
            reputation: 25
        },
        worth: 25,
        burnsLike: [n.ItemType.SheafOfHay, n.ItemType.SheafOfHay, n.ItemType.SheafOfHay, n.ItemType.SheafOfHay],
        flammable: !0
    },
    o(n.ItemType.StrawHat, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.BlackplateBreastplate] = {
        durability: 150,
        equip: n.EquipType.Chest,
        defense: new n.Defense(5,new n.Resistances(n.DamageType.Slashing,2,n.DamageType.Piercing,2),new n.Vulnerabilities(n.DamageType.Blunt,2)),
        recipe: {
            components: [r(n.ItemType.IronIngot, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        craftable: !1,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 3e3
    },
    o(n.ItemType.BlackplateBreastplate, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.BlackplateBoots] = {
        durability: 150,
        equip: n.EquipType.Feet,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,2,n.DamageType.Piercing,2),new n.Vulnerabilities(n.DamageType.Blunt,2)),
        recipe: {
            components: [r(n.ItemType.IronIngot, 12, 12, 12), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        craftable: !1,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 3e3
    },
    o(n.ItemType.BlackplateBoots, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.BlackplateHelmet] = {
        durability: 150,
        equip: n.EquipType.Head,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,2,n.DamageType.Piercing,2),new n.Vulnerabilities(n.DamageType.Blunt,2)),
        recipe: {
            components: [r(n.ItemType.IronIngot, 8, 8, 8), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        craftable: !1,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 2500
    },
    o(n.ItemType.BlackplateHelmet, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.BlackplateGorget] = {
        durability: 150,
        equip: n.EquipType.Neck,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,2,n.DamageType.Piercing,2),new n.Vulnerabilities(n.DamageType.Blunt,2)),
        recipe: {
            components: [r(n.ItemType.IronIngot, 6, 6, 6), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        craftable: !1,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 2e3
    },
    o(n.ItemType.BlackplateGorget, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.BlackplateGreaves] = {
        durability: 150,
        equip: n.EquipType.Legs,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,2,n.DamageType.Piercing,2),new n.Vulnerabilities(n.DamageType.Blunt,2)),
        recipe: {
            components: [r(n.ItemType.IronIngot, 10, 10, 10), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        craftable: !1,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 2500
    },
    o(n.ItemType.BlackplateGreaves, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.BlackplateGauntlets] = {
        durability: 150,
        equip: n.EquipType.Hands,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Slashing,2,n.DamageType.Piercing,2),new n.Vulnerabilities(n.DamageType.Blunt,2)),
        recipe: {
            components: [r(n.ItemType.IronIngot, 8, 8, 8), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Expert,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1e3
        },
        craftable: !1,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 2500
    },
    o(n.ItemType.BlackplateGauntlets, n.ItemTypeGroup.Equipment),
    t.itemDescriptions[n.ItemType.DeathKnightAxe] = {
        durability: 350,
        equip: n.EquipType.Held,
        attack: 9,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.TalcumPowder, 1, 1, 0, !0), r(n.ItemType.IronIngot, 12, 12, 12), r(n.ItemTypeGroup.SandCastFlask, 1, 0), r(n.ItemTypeGroup.Pole, 1, 1, 1), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: -1500
        },
        craftable: !1,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 3e3
    },
    o(n.ItemType.DeathKnightAxe, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.Macuahuitl] = {
        durability: 25,
        equip: n.EquipType.Held,
        attack: 8,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.Obsidian, 4, 4, 4), r(n.ItemTypeGroup.Pole, 3, 3, 3)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Expert,
            reputation: -500
        },
        disassemble: !0,
        flammable: !0,
        worth: 150
    },
    o(n.ItemType.Macuahuitl, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.ObsidianArrow] = {
        recipe: {
            components: [r(n.ItemType.Feather, 1, 1, 1), r(n.ItemType.ObsidianArrowhead, 1, 1, 1), r(n.ItemType.ArrowShaft, 1, 1, 1), r(n.ItemTypeGroup.Cordage, 1, 1, 1)],
            skill: n.SkillType.Fletching,
            level: n.RecipeLevel.Advanced,
            reputation: -75
        },
        disassemble: !0,
        attack: 4,
        damageType: n.DamageType.Piercing,
        durability: 15,
        flammable: !0,
        worth: 50
    },
    o(n.ItemType.ObsidianArrow, n.ItemTypeGroup.Arrow),
    t.itemDescriptions[n.ItemType.ObsidianArrowhead] = {
        reducedWeight: 1.5,
        minimumWeight: .5,
        use: [a.ActionType.Carve],
        recipe: {
            components: [r(n.ItemType.Obsidian, 2, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Advanced,
            reputation: -50
        },
        damageType: n.DamageType.Piercing,
        worth: 20
    },
    o(n.ItemType.ObsidianArrowhead, n.ItemTypeGroup.Sharpened),
    t.itemDescriptions[n.ItemType.ObsidianAxe] = {
        durability: 35,
        equip: n.EquipType.Held,
        attack: 5,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Gather, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemType.Obsidian, 2, 2, 2), r(n.ItemTypeGroup.Pole, 1, 1, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Advanced,
            reputation: -500
        },
        disassemble: !0,
        worth: 50,
        flammable: !0
    },
    o(n.ItemType.ObsidianAxe, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Tool),
    t.itemDescriptions[n.ItemType.ObsidianKnife] = {
        reducedWeight: .3,
        durability: 15,
        equip: n.EquipType.Held,
        attack: 3,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Carve, a.ActionType.Harvest, a.ActionType.Gather],
        recipe: {
            components: [r(n.ItemType.String, 1, 1), r(n.ItemType.Obsidian, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: -100
        },
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        worth: 25,
        flammable: !0
    },
    o(n.ItemType.ObsidianKnife, n.ItemTypeGroup.Sharpened, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.ObsidianShovel] = {
        durability: 50,
        equip: n.EquipType.Held,
        attack: 4,
        damageType: n.DamageType.Slashing,
        use: [a.ActionType.Dig, a.ActionType.Gather, a.ActionType.GatherTreasure, a.ActionType.Harvest],
        recipe: {
            components: [r(n.ItemType.String, 2, 2, 2), r(n.ItemType.Obsidian, 1, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Advanced,
            reputation: -175
        },
        disassemble: !0,
        worth: 50,
        flammable: !0
    },
    o(n.ItemType.ObsidianShovel, n.ItemTypeGroup.Tool, n.ItemTypeGroup.Weapon),
    t.itemDescriptions[n.ItemType.ObsidianSpear] = {
        durability: 25,
        equip: n.EquipType.Held,
        attack: 6,
        damageType: n.DamageType.Piercing,
        recipe: {
            components: [r(n.ItemType.String, 1, 1, 1), r(n.ItemType.Obsidian, 1, 1, 1), r(n.ItemTypeGroup.Pole, 1, 1, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Advanced,
            reputation: -500
        },
        disassemble: !0,
        use: [a.ActionType.Gather],
        worth: 50,
        flammable: !0
    },
    o(n.ItemType.ObsidianSpear, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.TumbleweedSeeds] = {
        weight: .1,
        skillUse: n.SkillType.Botany,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.Tumbleweed,
            [a.ActionType.Eat]: [1, 0, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.TumbleweedSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.CoconutHusk] = {
        weight: .2,
        onBurn: [n.ItemType.PileOfAsh],
        use: [a.ActionType.StokeFire],
        onUse: {
            [a.ActionType.StokeFire]: 2
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.CoconutHusk, n.ItemTypeGroup.Tinder, n.ItemTypeGroup.Cordage, n.ItemTypeGroup.Pulp, n.ItemTypeGroup.Compost),
    t.itemDescriptions[n.ItemType.PeeledCoconut] = {
        weight: 1.3,
        decayMax: 7500,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        dismantle: {
            items: [[n.ItemType.CoconutMeat, 1]],
            skill: n.SkillType.Botany,
            required: n.ItemTypeGroup.Sharpened
        },
        skillUse: n.SkillType.Botany,
        use: [a.ActionType.Plant],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.CoconutTree
        },
        flammable: !0,
        worth: 20
    },
    t.itemDescriptions[n.ItemType.CoconutMeat] = {
        weight: 1.2,
        skillUse: n.SkillType.Botany,
        decayMax: 6500,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        use: [a.ActionType.Eat],
        onUse: {
            [a.ActionType.Eat]: [4, 6, 4, 0]
        },
        worth: 10
    },
    t.itemDescriptions[n.ItemType.CoconutContainer] = {
        inheritWeight: n.ItemType.CoconutContainerOfCoconutWater,
        gather: {
            milk: n.ItemType.CoconutContainerOfGoatMilk,
            desalinated: n.ItemType.CoconutContainerOfDesalinatedWater,
            unpurified: n.ItemType.CoconutContainerOfUnpurifiedFreshWater,
            seawater: n.ItemType.CoconutContainerOfSeawater
        },
        use: [a.ActionType.GatherWater, a.ActionType.GatherMilk],
        onBurn: [n.ItemType.PileOfAsh, n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 25
    },
    o(n.ItemType.CoconutContainer, n.ItemTypeGroup.Container),
    t.itemDescriptions[n.ItemType.CoconutContainerOfCoconutWater] = {
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            components: [r(n.ItemType.PeeledCoconut, 1, 1), r(n.ItemType.Cork, 1, 1), r(n.ItemType.String, 1, 1), r(n.ItemTypeGroup.Sharpened, 1, 0)],
            skill: n.SkillType.Botany,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        returnOnUse: [n.ItemType.CoconutContainer, !1],
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [2, 16, 2, 7]
        },
        flammable: !0,
        worth: 50,
        burnsLike: [n.ItemType.CoconutContainer]
    },
    o(n.ItemType.CoconutContainerOfCoconutWater, n.ItemTypeGroup.Liquid),
    t.itemDescriptions[n.ItemType.CoconutContainerOfSeawater] = {
        inheritWeight: n.ItemType.CoconutContainerOfCoconutWater,
        use: [a.ActionType.Pour, a.ActionType.PourOnYourself, a.ActionType.DrinkItem],
        returnOnUse: [n.ItemType.CoconutContainer, !1],
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [0, -15, 1, -2]
        },
        flammable: !0,
        worth: 50,
        burnsLike: [n.ItemType.CoconutContainer]
    },
    o(n.ItemType.CoconutContainerOfSeawater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfSeawater),
    t.itemDescriptions[n.ItemType.CoconutContainerOfDesalinatedWater] = {
        inheritWeight: n.ItemType.CoconutContainerOfCoconutWater,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemType.CoconutContainerOfSeawater,
            components: [r(n.ItemType.Flask, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        returnOnUse: [n.ItemType.CoconutContainer, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [2, 25, 1, 11]
        },
        flammable: !0,
        worth: 75,
        burnsLike: [n.ItemType.CoconutContainer]
    },
    o(n.ItemType.CoconutContainerOfDesalinatedWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.CoconutContainerOfPotableWater, n.ItemTypeGroup.ContainerOfDesalinatedWater),
    t.itemDescriptions[n.ItemType.CoconutContainerOfMedicinalWater] = {
        inheritWeight: n.ItemType.CoconutContainerOfCoconutWater,
        use: [a.ActionType.DrinkCure, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemTypeGroup.CoconutContainerOfPotableWater,
            components: [r(n.ItemTypeGroup.Medicinal, 2, 2)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Intermediate,
            reputation: 25
        },
        returnOnUse: [n.ItemType.CoconutContainer, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkCure]: [3, 16, 1, 9]
        },
        flammable: !0,
        worth: 75,
        burnsLike: [n.ItemType.CoconutContainer]
    },
    o(n.ItemType.CoconutContainerOfMedicinalWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfMedicinalWater),
    t.itemDescriptions[n.ItemType.CoconutContainerOfPurifiedFreshWater] = {
        inheritWeight: n.ItemType.CoconutContainerOfCoconutWater,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemType.CoconutContainerOfUnpurifiedFreshWater,
            components: [],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        returnOnUse: [n.ItemType.CoconutContainer, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [1, 25, 1, 10]
        },
        flammable: !0,
        worth: 75,
        burnsLike: [n.ItemType.CoconutContainer]
    },
    o(n.ItemType.CoconutContainerOfPurifiedFreshWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.CoconutContainerOfPotableWater, n.ItemTypeGroup.ContainerOfPurifiedFreshWater),
    t.itemDescriptions[n.ItemType.CoconutContainerOfUnpurifiedFreshWater] = {
        inheritWeight: n.ItemType.CoconutContainerOfCoconutWater,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        recipe: {
            baseComponent: n.ItemType.CoconutContainer,
            components: [r(n.ItemType.PileOfSnow, 1, 1)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        returnOnUse: [n.ItemType.CoconutContainer, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [-4, 16, 1, 8]
        },
        flammable: !0,
        worth: 50,
        burnsLike: [n.ItemType.CoconutContainer]
    },
    o(n.ItemType.CoconutContainerOfUnpurifiedFreshWater, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.ContainerOfUnpurifiedFreshWater),
    t.itemDescriptions[n.ItemType.CoconutContainerOfGoatMilk] = {
        inheritWeight: n.ItemType.CoconutContainerOfCoconutWater,
        use: [a.ActionType.DrinkItem, a.ActionType.Pour, a.ActionType.PourOnYourself],
        durability: 10,
        returnOnUse: [n.ItemType.CoconutContainer, !1],
        keepDurabilityOnCraft: !0,
        repairable: !1,
        onUse: {
            [a.ActionType.DrinkItem]: [2, 20, 2, 5]
        },
        flammable: !0,
        worth: 75,
        burnsLike: [n.ItemType.CoconutContainer]
    },
    o(n.ItemType.CoconutContainerOfGoatMilk, n.ItemTypeGroup.Liquid, n.ItemTypeGroup.Milk),
    t.itemDescriptions[n.ItemType.OldEducationalScroll] = {
        weight: .2,
        use: [a.ActionType.Learn],
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 75,
        dismantle: {
            items: [[n.ItemType.ShreddedPaper, 1]]
        }
    },
    t.itemDescriptions[n.ItemType.StrippedLeather] = {
        weight: .2,
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.StrippedLeather, n.ItemTypeGroup.Cordage),
    t.itemDescriptions[n.ItemType.ClaySandCastFlask] = {
        recipe: {
            components: [r(n.ItemType.RawClay, 1, 1), r(n.ItemType.GreenSand, 1, 1)],
            skill: n.SkillType.Claythrowing,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        durability: 15,
        worth: 35
    },
    o(n.ItemType.ClaySandCastFlask, n.ItemTypeGroup.SandCastFlask),
    t.itemDescriptions[n.ItemType.SandstoneSandCastFlask] = {
        recipe: {
            components: [r(n.ItemType.Sandstone, 1, 1), r(n.ItemType.GreenSand, 1, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        durability: 25,
        worth: 35
    },
    o(n.ItemType.SandstoneSandCastFlask, n.ItemTypeGroup.SandCastFlask),
    t.itemDescriptions[n.ItemType.StoneSandCastFlask] = {
        recipe: {
            components: [r(n.ItemType.LargeRock, 1, 1), r(n.ItemType.GreenSand, 1, 1)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        durability: 35,
        worth: 35
    },
    o(n.ItemType.StoneSandCastFlask, n.ItemTypeGroup.SandCastFlask),
    t.itemDescriptions[n.ItemType.AnimalGlue] = {
        use: [a.ActionType.Reinforce, a.ActionType.Eat],
        recipe: {
            components: [r(n.ItemType.Offal, 1, 1), r(n.ItemTypeGroup.Bone, 1, 1), r(n.ItemTypeGroup.Liquid, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Advanced,
            requiresFire: !0,
            reputation: -25
        },
        decayMax: 500,
        onBurn: [n.ItemType.None],
        onUse: {
            [a.ActionType.Eat]: [-1, -2, 1, 0]
        },
        worth: 10
    },
    o(n.ItemType.AnimalGlue, n.ItemTypeGroup.Reinforce, n.ItemTypeGroup.Glue),
    t.itemDescriptions[n.ItemType.CopalResin] = {
        recipe: {
            components: [r(n.ItemType.Copal, 1, 1), r(n.ItemTypeGroup.MortarAndPestle, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Intermediate,
            reputation: -25
        },
        onBurn: [n.ItemType.MeltedCopal],
        worth: 25
    },
    o(n.ItemType.CopalResin, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.BoneMeal] = {
        reducedWeight: .3,
        minimumWeight: .2,
        recipe: {
            components: [r(n.ItemTypeGroup.Bone, 1, 1), r(n.ItemTypeGroup.MortarAndPestle, 1, 0)],
            skill: n.SkillType.Chemistry,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        onBurn: [n.ItemType.None],
        worth: 10
    },
    o(n.ItemType.BoneMeal, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.PileOfDesertSand] = {
        weight: 3,
        use: [a.ActionType.SetDown, a.ActionType.SmotherFire],
        onUse: {
            [a.ActionType.SetDown]: n.TerrainType.DesertSand,
            [a.ActionType.SmotherFire]: n.TerrainType.DesertSand
        },
        worth: 5
    },
    o(n.ItemType.PileOfDesertSand, n.ItemTypeGroup.Sand),
    t.itemDescriptions[n.ItemType.JoshuaTreeLeaves] = {
        weight: .3,
        onBurn: [n.ItemType.PileOfAsh],
        use: [a.ActionType.StokeFire],
        onUse: {
            [a.ActionType.StokeFire]: 6
        },
        worth: 5,
        flammable: !0
    },
    o(n.ItemType.JoshuaTreeLeaves, n.ItemTypeGroup.Cordage, n.ItemTypeGroup.Compost, n.ItemTypeGroup.Tinder),
    t.itemDescriptions[n.ItemType.JoshuaTreeFruit] = {
        weight: .4,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 8e3,
        decaysInto: n.ItemType.RottingVegetation,
        returnOnUse: [n.ItemType.JoshuaTreeSeeds, !0],
        onBurn: [n.ItemType.CookedJoshuaTreeFruit],
        onUse: {
            [a.ActionType.Eat]: [1, 3, 1, 1]
        },
        dismantle: {
            items: [[n.ItemType.JoshuaTreeSeeds, 1]],
            skill: n.SkillType.Botany
        },
        worth: 5
    },
    o(n.ItemType.JoshuaTreeFruit, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.JoshuaTreeSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.JoshuaTree,
            [a.ActionType.Eat]: [1, 1, 2, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.JoshuaTreeSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.CookedJoshuaTreeFruit] = {
        use: [a.ActionType.Eat],
        decayMax: 1e4,
        skillUse: n.SkillType.Botany,
        recipe: {
            components: [r(n.ItemType.JoshuaTreeFruit, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Simple,
            requiresFire: !0,
            reputation: 25
        },
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [3, 8, 1, -1]
        },
        worth: 15
    },
    o(n.ItemType.CookedJoshuaTreeFruit, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.JoshuaTreeFlowers] = {
        weight: .1,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 4, 2, -2]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.JoshuaTreeFlowers, n.ItemTypeGroup.Medicinal, n.ItemTypeGroup.Food),
    t.itemDescriptions[n.ItemType.SaguaroCactusFruit] = {
        weight: .2,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        decayMax: 4500,
        decaysInto: n.ItemType.RottingVegetation,
        returnOnUse: [n.ItemType.SaguaroCactusSeeds, !0],
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 8, 1, 1]
        },
        dismantle: {
            items: [[n.ItemType.SaguaroCactusSeeds, 1]],
            skill: n.SkillType.Botany
        },
        worth: 5
    },
    o(n.ItemType.SaguaroCactusFruit, n.ItemTypeGroup.Food, n.ItemTypeGroup.Fruit),
    t.itemDescriptions[n.ItemType.SaguaroCactusSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.SaguaroCactus,
            [a.ActionType.Eat]: [-2, -2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.SaguaroCactusSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.SaguaroCactusChunk] = {
        weight: 2,
        use: [a.ActionType.Eat],
        decayMax: 3500,
        skillUse: n.SkillType.Botany,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-6, -8, 4, -2]
        },
        worth: 5
    },
    t.itemDescriptions[n.ItemType.StoneWell] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemTypeGroup.Rock, 14, 14, 14), r(n.ItemType.Rope, 1, 1, 1), r(n.ItemTypeGroup.Pole, 3, 3, 3)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Expert,
            reputation: -25
        },
        disassemble: !0,
        durability: 15,
        worth: 50,
        doodad: {
            repairItem: n.ItemType.StoneWell,
            particles: {
                r: 130,
                g: 128,
                b: 128
            },
            reduceDurabilityOnGather: !0,
            group: n.DoodadTypeGroup.Well,
            isTall: !0,
            blockMove: !0,
            canBreak: !0
        }
    },
    t.itemDescriptions[n.ItemType.SandstoneWell] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Sandstone, 14, 14, 14), r(n.ItemType.Rope, 1, 1, 1), r(n.ItemTypeGroup.Pole, 3, 3, 3)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Expert,
            reputation: -25
        },
        disassemble: !0,
        durability: 5,
        worth: 50,
        doodad: {
            repairItem: n.ItemType.SandstoneWell,
            particles: {
                r: 199,
                g: 156,
                b: 128
            },
            reduceDurabilityOnGather: !0,
            group: n.DoodadTypeGroup.Well,
            isTall: !0,
            blockMove: !0,
            canBreak: !0
        }
    },
    t.itemDescriptions[n.ItemType.ClayBrickWell] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.ClayBrick, 14, 14, 14), r(n.ItemType.Rope, 1, 1, 1), r(n.ItemTypeGroup.Pole, 3, 3, 3)],
            skill: n.SkillType.Stonecrafting,
            level: n.RecipeLevel.Expert,
            reputation: -25
        },
        disassemble: !0,
        durability: 10,
        worth: 50,
        doodad: {
            repairItem: n.ItemType.ClayBrickWell,
            particles: {
                r: 200,
                g: 205,
                b: 207
            },
            reduceDurabilityOnGather: !0,
            group: n.DoodadTypeGroup.Well,
            isTall: !0,
            blockMove: !0,
            canBreak: !0
        }
    },
    t.itemDescriptions[n.ItemType.AloeVeraLeaves] = {
        weight: .3,
        use: [a.ActionType.Apply, a.ActionType.Eat],
        skillUse: n.SkillType.Anatomy,
        decayMax: 3e3,
        decaysInto: n.ItemType.RottingVegetation,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Apply]: [1, 0, 0, 0],
            [a.ActionType.Eat]: [-4, -8, 1, -1]
        },
        worth: 5
    },
    o(n.ItemType.AloeVeraLeaves, n.ItemTypeGroup.Health, n.ItemTypeGroup.Food, n.ItemTypeGroup.Medicinal),
    t.itemDescriptions[n.ItemType.AloeVeraSeeds] = {
        weight: .1,
        use: [a.ActionType.Plant, a.ActionType.Eat],
        skillUse: n.SkillType.Botany,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Plant]: n.DoodadType.AloeVera,
            [a.ActionType.Eat]: [-1, -2, 1, -1]
        },
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.AloeVeraSeeds, n.ItemTypeGroup.Seed),
    t.itemDescriptions[n.ItemType.DeadScorpion] = {
        weight: .2,
        use: [a.ActionType.Eat],
        decayMax: 5750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedScorpion],
        onUse: {
            [a.ActionType.Eat]: [-1, -4, 2, -1]
        },
        worth: 5
    },
    o(n.ItemType.DeadScorpion, n.ItemTypeGroup.Bait, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.CookedScorpion] = {
        use: [a.ActionType.Eat],
        recipe: {
            components: [r(n.ItemType.DeadScorpion, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Intermediate,
            requiresFire: !0,
            reputation: 25
        },
        decayMax: 6750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [2, 8, 2, 0]
        },
        worth: 10
    },
    o(n.ItemType.CookedScorpion, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.DeadAberrantScorpion] = {
        weight: .4,
        use: [a.ActionType.Eat],
        decayMax: 4750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.CookedAberrantScorpion],
        onUse: {
            [a.ActionType.Eat]: [-2, -8, 4, -1]
        },
        worth: 10
    },
    o(n.ItemType.DeadAberrantScorpion, n.ItemTypeGroup.Bait, n.ItemTypeGroup.RawMeat),
    t.itemDescriptions[n.ItemType.CookedAberrantScorpion] = {
        use: [a.ActionType.Eat],
        recipe: {
            components: [r(n.ItemType.DeadAberrantScorpion, 1, 1), r(n.ItemTypeGroup.CookingEquipment, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Intermediate,
            requiresFire: !0,
            reputation: 25
        },
        decayMax: 5750,
        decaysInto: n.ItemType.RottenMeat,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [4, 16, 4, 0]
        },
        worth: 20
    },
    o(n.ItemType.DeadAberrantScorpion, n.ItemTypeGroup.Food, n.ItemTypeGroup.CookedMeat),
    t.itemDescriptions[n.ItemType.ScorpionStinger] = {
        weight: .1,
        use: [a.ActionType.Eat],
        skillUse: n.SkillType.Anatomy,
        decayMax: 4750,
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [-12, -20, 1, -1]
        },
        worth: 25
    },
    o(n.ItemType.ScorpionStinger, n.ItemTypeGroup.Medicinal),
    t.itemDescriptions[n.ItemType.CopperBakingTray] = {
        durability: 50,
        recipe: {
            components: [r(n.ItemType.CopperIngot, 4, 4, 4), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            reputation: 25
        },
        repairAndDisassemblyRequiresFire: !0,
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 100
    },
    o(n.ItemType.CopperBakingTray, n.ItemTypeGroup.Cookware, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.WroughtIronBakingTray] = {
        durability: 75,
        recipe: {
            components: [r(n.ItemType.WroughtIron, 4, 4, 4), r(n.ItemTypeGroup.Hammer, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: 25
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer],
        worth: 50
    },
    o(n.ItemType.WroughtIronBakingTray, n.ItemTypeGroup.Cookware, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.IronBakingTray] = {
        durability: 100,
        recipe: {
            components: [r(n.ItemType.IronIngot, 4, 4, 4), r(n.ItemTypeGroup.Hammer, 1, 0), r(n.ItemTypeGroup.Tongs, 1, 0)],
            skill: n.SkillType.Blacksmithing,
            level: n.RecipeLevel.Simple,
            requiredDoodad: n.DoodadTypeGroup.Anvil,
            requiresFire: !0,
            reputation: 25
        },
        disassemble: !0,
        requiredForDisassembly: [n.ItemTypeGroup.Hammer, n.ItemTypeGroup.SandCastFlask],
        worth: 150
    },
    o(n.ItemType.IronBakingTray, n.ItemTypeGroup.Cookware, n.ItemTypeGroup.CookingEquipment),
    t.itemDescriptions[n.ItemType.Flour] = {
        recipe: {
            components: [r(n.ItemType.Wheat, 4, 4), r(n.ItemTypeGroup.MortarAndPestle, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Simple,
            reputation: 25
        },
        onBurn: [n.ItemType.None],
        worth: 25
    },
    o(n.ItemType.Flour, n.ItemTypeGroup.Powder),
    t.itemDescriptions[n.ItemType.Dough] = {
        use: [a.ActionType.Eat],
        decayMax: 3750,
        recipe: {
            components: [r(n.ItemType.Flour, 1, 1), r(n.ItemTypeGroup.Liquid, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Intermediate,
            reputation: 50
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [0, -6, 2, -1]
        },
        worth: 50
    },
    t.itemDescriptions[n.ItemType.Hardtack] = {
        reducedWeight: .2,
        use: [a.ActionType.Eat],
        recipe: {
            components: [r(n.ItemType.Dough, 1, 1), r(n.ItemTypeGroup.Cookware, 1, 0)],
            skill: n.SkillType.Cooking,
            level: n.RecipeLevel.Advanced,
            requiredDoodad: n.DoodadTypeGroup.LitFurnace,
            reputation: 75
        },
        onBurn: [n.ItemType.PileOfAsh],
        onUse: {
            [a.ActionType.Eat]: [1, 10, 8, -3]
        },
        worth: 75
    },
    o(n.ItemType.Hardtack, n.ItemTypeGroup.Food),
    t.itemDescriptions[n.ItemType.HitchingPost] = {
        use: [a.ActionType.Build],
        recipe: {
            components: [r(n.ItemType.Log, 3, 3, 3), r(n.ItemType.Rope, 1, 1, 1)],
            skill: n.SkillType.Woodworking,
            level: n.RecipeLevel.Advanced,
            reputation: -25
        },
        disassemble: !0,
        durability: 25,
        worth: 50,
        doodad: {
            repairItem: n.ItemType.HitchingPost,
            particles: {
                r: 132,
                g: 96,
                b: 44
            },
            reduceDurabilityOnGather: !0,
            blockMove: !0,
            group: n.DoodadTypeGroup.Hitch,
            canBreak: !0
        }
    },
    t.itemDescriptions[n.ItemType.ShreddedPaper] = {
        use: [a.ActionType.StokeFire],
        onUse: {
            [a.ActionType.StokeFire]: 2
        },
        weight: .1,
        onBurn: [n.ItemType.PileOfAsh],
        flammable: !0,
        worth: 5
    },
    o(n.ItemType.ShreddedPaper, n.ItemTypeGroup.Pulp, n.ItemTypeGroup.Tinder)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Log", ["require", "exports", "utilities/Objects"], function(e, t, a) {
    var i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.ActionManager = 0] = "ActionManager",
        e[e.Audio = 1] = "Audio",
        e[e.BaseMod = 2] = "BaseMod",
        e[e.BindingManager = 3] = "BindingManager",
        e[e.Chat = 4] = "Chat",
        e[e.CommandManager = 5] = "CommandManager",
        e[e.CorpseManager = 6] = "CorpseManager",
        e[e.CreatureManager = 7] = "CreatureManager",
        e[e.DailyChallenge = 8] = "DailyChallenge",
        e[e.DoodadManager = 9] = "DoodadManager",
        e[e.EnumManager = 10] = "EnumManager",
        e[e.FlowFieldManager = 11] = "FlowFieldManager",
        e[e.Game = 12] = "Game",
        e[e.HookManager = 13] = "HookManager",
        e[e.InterModRegistryManager = 14] = "InterModRegistryManager",
        e[e.ItemManager = 15] = "ItemManager",
        e[e.Languages = 16] = "Languages",
        e[e.MapGen = 17] = "MapGen",
        e[e.Matchmaking = 18] = "Matchmaking",
        e[e.MatchmakingServer = 19] = "MatchmakingServer",
        e[e.Mod = 20] = "Mod",
        e[e.Mods = 21] = "Mods",
        e[e.Multiplayer = 22] = "Multiplayer",
        e[e.NewUi = 23] = "NewUi",
        e[e.NPCManager = 24] = "NPCManager",
        e[e.Packet = 25] = "Packet",
        e[e.Player = 26] = "Player",
        e[e.ResourceLoader = 27] = "ResourceLoader",
        e[e.SaveManager = 28] = "SaveManager",
        e[e.Serializer = 29] = "Serializer",
        e[e.Shaders = 30] = "Shaders",
        e[e.Steamworks = 31] = "Steamworks",
        e[e.TileEventManager = 32] = "TileEventManager",
        e[e.Trello = 33] = "Trello",
        e[e.Ui = 34] = "Ui",
        e[e.Utilities = 35] = "Utilities",
        e[e.WebAssembly = 36] = "WebAssembly",
        e[e.WebRTCConnection = 37] = "WebRTCConnection",
        e[e.WebSocketConnection = 38] = "WebSocketConnection"
    }(i = t.LogSource || (t.LogSource = {}));
    const n = ["color:lightskyblue", "color:plum", "color:lightgreen"];
    function o(e, t=!1) {
        const a = []
          , o = new Date;
        let r;
        r = t ? `${`0${o.getHours()}`.slice(-2)}:${`0${o.getMinutes()}`.slice(-2)}:${`0${o.getSeconds()}`.slice(-2)}.${`000${o.getMilliseconds()}`.slice(-3)}` : o.toISOString();
        const s = [];
        for (const t of e)
            s.push(`[${"number" == typeof t ? i[t] : t}]`);
        if (!t || "boolean" == typeof isEdge && isEdge)
            a.unshift(`[${r}] ${s.join(" ")}`);
        else {
            a.unshift("color:black");
            for (let e = s.length - 1; e >= 0; e--)
                a.unshift(n[e]);
            a.unshift("color:gray"),
            a.unshift(`%c[${r}] %c${s.join(" %c")}%c`)
        }
        return a
    }
    const r = [];
    class s {
        constructor(...e) {
            this.setSources(...e),
            r.push(this)
        }
        setSources(...e) {
            this.sources = e,
            this.refresh()
        }
        refresh() {
            this.info = s.info(...this.sources),
            this.warn = s.warn(...this.sources),
            this.error = s.error(...this.sources),
            this.trace = s.trace(...this.sources),
            this.debug = s.debug(...this.sources)
        }
    }
    !function(e) {
        let t, n;
        function s() {
            return saveDataGlobal && saveDataGlobal.options.developerMode ? saveDataGlobal.options.consoleLogSourceFilter : void 0
        }
        function l(e) {
            const t = s();
            if (!t)
                return !0;
            for (const a of e)
                if ("number" == typeof a) {
                    if (t.disabledSources.includes(i[a]))
                        return !1
                } else if (!new RegExp(t.miscSourceFilter).test(a))
                    return !1;
            return !0
        }
        function u(i, r) {
            const s = i.format(e=>{
                const t = [e.level];
                Array.isArray(e.message) ? t.push(...e.message) : t.push(e.message);
                const i = e[Symbol.for("splat")];
                i && t.push(...i);
                for (let e = 0; e < t.length; e++) {
                    const i = t[e];
                    if (i instanceof Error)
                        t[e] = `[Error Object] ${i.name} - ${i.message}. Stack: ${i.stack}`;
                    else if ("object" == typeof i)
                        try {
                            t[e] = a.default.stringify(i, 4)
                        } catch (a) {
                            t[e] = "[Circular]"
                        }
                }
                return e[Symbol.for("message")] = t.join(" "),
                e
            }
            );
            t = i.createLogger({
                format: s(),
                transports: [new i.transports.File({
                    filename: r,
                    maxsize: 5e6,
                    maxFiles: 5
                })]
            }),
            e.info = ((...e)=>(...a)=>{
                l(e) && console.info(...o(e, !0), ...a),
                t.info(o(e), ...a),
                n && n(...o(e), "[INFO]", ...a)
            }
            ),
            e.warn = ((...e)=>(...a)=>{
                l(e) && console.warn(...o(e, !0), ...a),
                t.warn(o(e), ...a),
                n && n(...o(e), "[WARN]", ...a)
            }
            ),
            e.error = ((...e)=>(...a)=>{
                l(e) && console.error(...o(e, !0), ...a),
                t.error(o(e), ...a),
                n && n(...o(e), "[ERROR]", ...a)
            }
            ),
            e.debug = ((...e)=>(...a)=>{
                l(e) && console.debug(...o(e, !0), ...a),
                t.debug(o(e), ...a),
                n && n(...o(e), "[DEBUG]", ...a)
            }
            ),
            d()
        }
        function d() {
            for (const e of r)
                e.refresh()
        }
        function p(t) {
            n = t,
            e.info = ((...e)=>(...t)=>{
                l(e) && console.info(...o(e, !0), ...t),
                n && n(...o(e), "[INFO]", ...t)
            }
            ),
            e.warn = ((...e)=>(...t)=>{
                l(e) && console.warn(...o(e, !0), ...t),
                n && n(...o(e), "[WARN]", ...t)
            }
            ),
            e.error = ((...e)=>(...t)=>{
                l(e) && console.error(...o(e, !0), ...t),
                n && n(...o(e), "[ERROR]", ...t)
            }
            ),
            e.debug = ((...e)=>(...t)=>{
                l(e) && console.debug(...o(e, !0), ...t),
                n && n(...o(e), "[DEBUG]", ...t)
            }
            );
            for (const e of r)
                e.refresh()
        }
        function c(...e) {
            return l(e) ? console.info.bind(null, ...o(e, !0)) : ()=>{}
        }
        function m(...e) {
            return l(e) ? console.warn.bind(null, ...o(e, !0)) : ()=>{}
        }
        function h(...e) {
            return l(e) ? console.error.bind(null, ...o(e, !0)) : ()=>{}
        }
        function y(...e) {
            return l(e) ? console.trace.bind(null, ...o(e, !0)) : ()=>{}
        }
        function g(...e) {
            return l(e) ? console.debug.bind(null, ...o(e, !0)) : ()=>{}
        }
        e.setWinston = u,
        e.refresh = d,
        e.setCallback = p,
        e.info = c,
        e.warn = m,
        e.error = h,
        e.trace = y,
        e.debug = g
    }(s || (s = {}));
    class l extends s {
        refresh() {
            this.info = this.warn = this.error = this.trace = this.debug = ((...e)=>{}
            )
        }
    }
    __decorate([Override], l.prototype, "refresh", null),
    t.NullLog = l,
    t.nullLog = new l,
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/InterModRegistryManager", ["require", "exports", "utilities/Log"], function(e, t, a) {
    var i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        const t = {};
        function i(e, a) {
            const i = t[e] || {}
              , n = i[a] || {};
            return n.registrations || []
        }
        function n(e, i, n) {
            const o = t[e] = t[e] || {}
              , r = o[i] = o[i] || {};
            r.registry = n,
            new a.default(a.LogSource.InterModRegistryManager,e).info(`Registered inter-mod registry "${i}".`)
        }
        function o(e, i) {
            const n = t[e] = t[e];
            if (!n)
                return;
            const o = n[i] = n[i];
            o && (delete o.registry,
            new a.default(a.LogSource.InterModRegistryManager,e).info(`Deregistered inter-mod registry "${i}".`),
            o.registrations && o.registrations.length || (delete n[i],
            Object.keys(n).length || delete t[e]))
        }
        function r(e, i, n) {
            const o = t[e] = t[e] || {}
              , r = o[i] = o[i] || {};
            (r.registrations = r.registrations || []).push(n),
            new a.default(a.LogSource.InterModRegistryManager,n.modName).info(`Registered into inter-mod registry "${i}" of "${e}".`)
        }
        function s(e, i, n) {
            const o = t[e] = t[e];
            if (!o)
                return;
            const r = o[i] = o[i];
            if (!r)
                return;
            const s = r.registrations;
            if (!s)
                return;
            const l = s.indexOf(n);
            -1 !== l && (new a.default(a.LogSource.InterModRegistryManager,n.modName).info(`Deregistered from inter-mod registry "${i}" of "${e}".`),
            s.length > 1 ? s.splice(l, 1) : (delete r.registrations,
            r.registry || (delete o[i],
            Object.keys(o).length || delete t[e])))
        }
        e.getRegistrations = i,
        e.registerRegistry = n,
        e.deregisterRegistry = o,
        e.register = r,
        e.deregister = s
    }(i || (i = {})),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/InterModRegistry", ["require", "exports", "mod/InterModRegistryManager"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i {
        constructor(e, t) {
            this.modName = e,
            this.name = t
        }
        getRegistrations() {
            return a.default.getRegistrations(this.modName, this.name)
        }
    }
    t.default = i;
    class n {
        constructor(e, t) {
            this.modName = e,
            this.data = t
        }
    }
    t.InterModRegistration = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/dictionary/InterruptChoice", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Cancel = 0] = "Cancel",
        e[e.ContinueAnyway = 1] = "ContinueAnyway",
        e[e.LocalFile = 2] = "LocalFile",
        e[e.No = 3] = "No",
        e[e.NoWarn = 4] = "NoWarn",
        e[e.Ok = 5] = "Ok",
        e[e.OpenSaveFolderAndQuit = 6] = "OpenSaveFolderAndQuit",
        e[e.Quit = 7] = "Quit",
        e[e.Rejoin = 8] = "Rejoin",
        e[e.Rename = 9] = "Rename",
        e[e.Retry = 10] = "Retry",
        e[e.SteamWorkshop = 11] = "SteamWorkshop",
        e[e.Yes = 12] = "Yes"
    }(a || (a = {})),
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/Language", ["require", "exports", "language/TranslationsProvider"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        constructor(e, t=!1) {
            super(e),
            this.alternateFontStyle = t
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/LanguageExtension", ["require", "exports", "language/TranslationsProvider"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        constructor(e) {
            super(e)
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 */
define("game/Registrar", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor() {
            this.registrations = {},
            this.registrationSubTypeToMainType = {}
        }
        get(e, t=!1) {
            if (t) {
                const t = this.registrationSubTypeToMainType[e];
                if (void 0 !== t)
                    return this.registrations[t] || this.baseItem
            }
            return this.registrations[e] || this.baseItem
        }
        isBase(e) {
            return void 0 !== this.baseItem && e instanceof this.baseItem
        }
        usesBase(e) {
            return void 0 !== this.baseItem && this.get(e) === this.baseItem
        }
        registerBase(e) {
            this.baseItem = e
        }
        register(e, t, a) {
            if (void 0 === t) {
                const e = Object.keys(this.registrations);
                t = e.length
            }
            this.registrations[t] = e,
            void 0 !== a && (this.registrationSubTypeToMainType[a] = t),
            e.setRegistrarId(t)
        }
        unregister(e) {
            const t = e.getRegistrarId();
            return !(void 0 === t || !this.registrations[t]) && (delete this.registrations[t],
            !0)
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/matchmaking/IMatchmaking", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.UpdateDirectory = -2] = "UpdateDirectory",
        e[e.IpAddress = -1] = "IpAddress",
        e[e.JoinChannel = 0] = "JoinChannel",
        e[e.IceCandidate = 1] = "IceCandidate",
        e[e.SessionDescription = 2] = "SessionDescription",
        e[e.HostIpAddress = 3] = "HostIpAddress",
        e[e.Connected = 4] = "Connected",
        e[e.UnableToJoinGame = 5] = "UnableToJoinGame"
    }(a = t.MatchmakingMessageDataType || (t.MatchmakingMessageDataType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Random", ["require", "exports", "utilities/Log", "utilities/Objects"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        constructor(e) {
            this.generator = e
        }
        float(e, t) {
            return void 0 === t && (t = void 0 !== e ? e : 1,
            e = 0),
            e + this.generator.get() * (t - e)
        }
        int(e) {
            return Math.floor(this.generator.get() * e)
        }
        intInRange(e, t) {
            return Math.floor(this.generator.get() * (t - e + 1)) + Math.ceil(e)
        }
        bool() {
            return this.generator.get() > .5
        }
        percent(e=0, t=100, a=!0) {
            return a ? Math.ceil(this.generator.get() * t) - e : this.generator.get() * t - e
        }
        chance(e) {
            return this.generator.get() < e
        }
        choice(...e) {
            return e[this.int(e.length)]
        }
        shuffle(e) {
            for (let t = e.length - 1; t > 0; t--) {
                const a = Math.floor(this.generator.get() * (t + 1))
                  , i = e[t];
                e[t] = e[a],
                e[a] = i
            }
            return e
        }
        getElement(e) {
            return e[this.int(e.length)]
        }
        weightedChoice(e) {
            const t = e.reduce((e,[t])=>e + t, 0)
              , a = this.float(t);
            let i = 0
              , n = 0;
            for (; n < e.length && !((i += e[n][0]) >= a); n++)
                ;
            return e[n][1]
        }
    }
    function o(e) {
        if ("string" != typeof e)
            return e;
        let t = parseInt(e, 10);
        if (isNaN(t)) {
            t = 13;
            const a = e.toLowerCase();
            for (let e = 0; e < a.length; e++)
                t = 37 * t + a.charCodeAt(e)
        }
        return t
    }
    __decorate([i.Bound], n.prototype, "weightedChoice", null),
    t.Random = n,
    t.convertStringToSeed = o;
    class r {
        constructor() {
            this.debug = !1,
            this.pushedSeeds = [],
            this.generateSeed()
        }
        tickSeed(e) {
            return (9301 * e + 49297) % 233280
        }
        getSeed() {
            return this.seed
        }
        setSeed(e) {
            this.seed = e
        }
        generateSeed() {
            this.seed = (new Date).getTime()
        }
        setDebug(e) {
            this.debug = e
        }
        pushSeed(e) {
            this.pushedSeeds.push({
                seed: this.seed,
                history: this.history
            }),
            void 0 !== e && (this.seed = e,
            void 0 !== this.history && this.startHistory())
        }
        popSeed() {
            const e = this.seed;
            let t;
            return this.pushedSeeds.length > 0 ? (t = this.pushedSeeds.pop(),
            this.seed = t.seed,
            this.history = t.history) : a.default.warn(a.LogSource.Utilities)("Trying to pop an invalid seed"),
            e
        }
        get() {
            if (void 0 !== this.history) {
                let e = (new Error).stack;
                if (void 0 !== e) {
                    const t = (e = e.substring(7)).indexOf("at Multiplayer.");
                    -1 !== t && (e = e.substring(0, t));
                    const a = (e = (e = (e = (e = (e = e.replace(/\\n/g, "")).replace(/\n/g, "")).replace(/_=(\d+):/g, "")).replace(/file:\/\/\/.*?\/out\/js/g, "")).replace(/http:\/\/.*?\/out\/js/g, "")).indexOf("at");
                    if (-1 !== a) {
                        const t = e.indexOf("at", a + 2);
                        if (-1 !== t) {
                            const a = e.indexOf("at", t + 2);
                            if (-1 !== a) {
                                const t = e.indexOf("at", a + 2);
                                -1 !== t && (e = e.substring(t + 2))
                            }
                        }
                    }
                    const i = e.indexOf(".processAndSend");
                    if (-1 !== i) {
                        const t = e.substring(0, i).lastIndexOf("at");
                        -1 !== t && (e = e.substring(0, t))
                    }
                    e = e.trim();
                    let n = !1;
                    if (this.history.length > 0) {
                        const t = this.history[this.history.length - 1];
                        t.stack === e && (t.seeds.push(this.seed),
                        n = !0)
                    }
                    n || this.history.push({
                        stack: e,
                        seeds: [this.seed]
                    })
                }
            }
            return this.debug && console.trace("nextFloat", this.seed),
            this.seed = (9301 * this.seed + 49297) % 233280,
            this.seed / 233280
        }
        startHistory() {
            this.history = []
        }
        stopHistory() {
            if (void 0 === this.history)
                return [];
            const e = this.history;
            return this.history = void 0,
            e
        }
    }
    t.SeededGenerator = r;
    const s = new n(new r);
    t.generalRandom = new n({
        get: ()=>Math.random()
    }),
    window.generalRandom = t.generalRandom,
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/IPacket", ["require", "exports"], function(e, t) {
    var a, i;
    function n(e) {
        return r(e, !1)
    }
    function o(e) {
        return r(e, !0)
    }
    function r(e, t) {
        return function(a, i) {
            const n = a.constructor;
            n._networkedProperties || (n._networkedProperties = []),
            n._networkedProperties.push({
                key: i,
                type: e,
                optional: t
            })
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.reservedBytes = 5,
    function(e) {
        e[e.Client = 0] = "Client",
        e[e.Server = 1] = "Server",
        e[e.Shared = 2] = "Shared"
    }(a = t.PacketType || (t.PacketType = {})),
    function(e) {
        e[e.Bool = 0] = "Bool",
        e[e.Int8 = 1] = "Int8",
        e[e.Uint8 = 2] = "Uint8",
        e[e.Uint16 = 3] = "Uint16",
        e[e.Float64 = 4] = "Float64",
        e[e.Uint32NumberArray = 5] = "Uint32NumberArray",
        e[e.String = 6] = "String",
        e[e.Container = 7] = "Container",
        e[e.Generic = 8] = "Generic",
        e[e.Item = 9] = "Item",
        e[e.MovementIntent = 10] = "MovementIntent",
        e[e.Vector2Array = 11] = "Vector2Array"
    }(i = t.NetworkPropertyType || (t.NetworkPropertyType = {})),
    t.NetworkProperty = n,
    t.OptionalNetworkProperty = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/networking/IConnection", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("utilities/Async", ["require", "exports"], function(e, t) {
    async function a(e) {
        return new Promise(t=>{
            setTimeout(t, e)
        }
        )
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.sleep = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/util/ElementManipulator", ["require", "exports", "utilities/Async"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i {
        constructor(e) {
            this.element = e
        }
        add(...e) {
            return this.element.element.classList.add(...e),
            this.element
        }
        remove(...e) {
            return this.element.element.classList.remove(...e),
            this.element
        }
        toggle(e, ...t) {
            "string" == typeof e && (t.unshift(e),
            e = void 0);
            for (const a of t)
                this.element.element.classList.toggle(a, e);
            return this.element
        }
        has(...e) {
            for (const t of e)
                if (!this.element.element.classList.contains(t))
                    return !1;
            return !0
        }
        after(e) {
            return {
                add: (...t)=>("number" == typeof e && (e = a.sleep(e)),
                e.then(()=>{
                    this.element.element.classList.add(...t)
                }
                ),
                this.element),
                remove: (...t)=>("number" == typeof e && (e = a.sleep(e)),
                e.then(()=>{
                    this.element.element.classList.remove(...t)
                }
                ),
                this.element)
            }
        }
        until(e) {
            return {
                add: (...t)=>(this.element.element.classList.add(...t),
                "number" == typeof e && (e = a.sleep(e)),
                e.then(()=>{
                    this.element.element.classList.remove(...t)
                }
                ),
                this.element),
                remove: (...t)=>(this.element.element.classList.remove(...t),
                "number" == typeof e && (e = a.sleep(e)),
                e.then(()=>{
                    this.element.element.classList.add(...t)
                }
                ),
                this.element)
            }
        }
    }
    t.ClassListManipulator = i;
    class n {
        constructor(e) {
            this.element = e
        }
        set(e, t) {
            if ("string" != typeof e)
                for (const [t,a] of e)
                    null !== a && this.set(t, a);
            else
                this.element.element.setAttribute(e, t);
            return this.element
        }
        get(...e) {
            return 1 === e.length ? this.element.element.getAttribute(e[0]) : this.getAttributeIterator(...e)
        }
        remove(...e) {
            for (const t of e)
                this.element.element.removeAttribute(t);
            return this.element
        }
        has(...e) {
            for (const t of e)
                if (!this.element.element.hasAttribute(t))
                    return !1;
            return !0
        }
        *getAttributeIterator(...e) {
            for (const t of e)
                yield[t, this.element.element.getAttribute(t)]
        }
    }
    t.AttributeManipulator = n;
    class o {
        constructor(e) {
            this.element = e
        }
        set(e, t) {
            if ("string" != typeof e)
                for (const [t,a] of e)
                    void 0 !== a && this.set(t, a);
            else
                this.element.element.dataset[e] = t;
            return this.element
        }
        get(...e) {
            return 1 === e.length ? this.element.element.dataset[e[0]] : this.getDataIterator(...e)
        }
        remove(...e) {
            for (const t of e)
                delete this.element.element.dataset[t];
            return this.element
        }
        has(...e) {
            for (const t of e)
                if (!this.element.element.hasAttribute(`data-${t}`))
                    return !1;
            return !0
        }
        *getDataIterator(...e) {
            for (const t of e)
                yield[t, this.element.element.dataset[t]]
        }
    }
    t.DataManipulator = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Emitter", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        get subscribers() {
            return Object.defineProperty(this, "subscribers", {
                value: {},
                writable: !0
            }),
            this.subscribers
        }
        set subscribers(e) {}
        on(e, t) {
            Array.isArray(e) || (e = [e]);
            for (const a of e) {
                a in this.subscribers || (this.subscribers[a] = []);
                const e = this.subscribers[a];
                e.includes(t) || e.push(t)
            }
            return this
        }
        once(e, t) {
            Array.isArray(e) || (e = [e]);
            const a = async(i,...n)=>{
                for (const t of e) {
                    const e = this.subscribers[t];
                    if (1 === e.length)
                        delete this.subscribers[t];
                    else {
                        const t = e.indexOf(a);
                        -1 !== t && e.splice(t, 1)
                    }
                }
                await t(i,...n)
            }
            ;
            for (const t of e)
                t in this.subscribers || (this.subscribers[t] = []),
                this.subscribers[t].push(a);
            return this
        }
        async emitAsync(e, ...t) {
            let a = [];
            return this.subscribers[e] && (a = await Promise.all(this.subscribers[e].slice().map(e=>e(this,...t)))),
            a
        }
        emit(e, ...t) {
            let a = [];
            return this.subscribers[e] && (a = this.subscribers[e].slice().map(e=>e(this, ...t))),
            a
        }
        cancel(e, t) {
            Array.isArray(e) || (e = [e]);
            for (const a of e)
                if (t) {
                    const e = this.subscribers[a];
                    if (!e)
                        continue;
                    const i = e.indexOf(t);
                    i >= 0 && e.splice(i, 1)
                } else
                    delete this.subscribers[a];
            return this
        }
        cancelAll() {
            return this.subscribers = {},
            this
        }
        async waitUntil(e) {
            return new Promise(t=>{
                this.once(e, (e,...a)=>()=>{
                    t([e, ...a])
                }
                )
            }
            )
        }
        until(e) {
            return {
                bind: (t,a,i)=>(t.on(a, i),
                this.once(e, ()=>t.cancel(a, i)),
                this)
            }
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/Iterables", ["require", "exports"], function(e, t) {
    function a(e) {
        return e && "object" == typeof e && Symbol.iterator in e
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.isIterable = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/string/Interpolator", ["require", "exports", "utilities/iterable/Iterables", "utilities/Objects"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        get segments() {
            return [...this._segments]
        }
        constructor(...e) {
            this._segments = e.map(e=>Object.assign({}, e)),
            this.interpolate = this.interpolate.bind(this)
        }
        interpolate(e, ...t) {
            let i = {
                content: ""
            };
            const n = [i];
            for (let o = 0; o < e.length; o++) {
                const r = this.handleChar(e, o);
                if (!r.length) {
                    i.content += e[o];
                    continue
                }
                let s = 0;
                1 === r.length && (o += s = (r[0].startChar || "{").length - 1);
                let l = 0
                  , u = 0
                  , d = o + 1;
                for (; d < e.length; d++) {
                    if ("{" === e[d])
                        u++;
                    else if ("}" === e[d])
                        u--;
                    else
                        for (const {endChar: t} of r)
                            if ((t || "}")[0] === e[d] && e.slice(d).startsWith(t || "}")) {
                                l = (t || "}").length - 1,
                                u--;
                                break
                            }
                    if (u < 0)
                        break
                }
                if (u >= 0) {
                    i.content += e.slice(o - s, o + 1);
                    continue
                }
                const p = e.slice(o + 1, d);
                let c = !1;
                for (const {regex: e, handle: s} of r) {
                    const r = p.match(e);
                    if (!r)
                        continue;
                    c = !0;
                    let u = s(r, p, this, ...t);
                    "string" == typeof u && (u = {
                        content: u
                    }),
                    (u = (u = a.isIterable(u) ? [...u] : [u]).filter(e=>e.content.length > 0)).length > 0 && (i = {
                        content: ""
                    },
                    n.push(...u, i)),
                    o = d + l;
                    break
                }
                c || (i.content += e[o])
            }
            return n[0].content || n.shift(),
            i.content || n.pop(),
            n
        }
        interpolateString(e, ...t) {
            return this.interpolate(e, ...t).map(({content: e})=>e).join("")
        }
        handleChar(e, t) {
            const a = [];
            for (const i of this._segments) {
                const n = i.startChar || "{";
                e[t] === n[0] && (1 === n.length || e.slice(t).startsWith(n)) && a.push(i)
            }
            return a
        }
        static combineLikeSections(e, t=[]) {
            if (!(e.length < 2))
                e: for (let a = 1; a < e.length; a++) {
                    const i = e[a]
                      , n = e[a - 1];
                    for (const e in n)
                        if (!("content" === e || t.includes(e) || e in i))
                            continue e;
                    for (const e in i)
                        if (!("content" === e || t.includes(e) || e in n && i[e] === n[e]))
                            continue e;
                    n.content += i.content,
                    e.splice(a, 1),
                    a--
                }
        }
    }
    function o(e, ...a) {
        return t.basicInterpolator.interpolate(e, ...a)
    }
    function r(e, ...a) {
        return t.basicInterpolator.interpolate(e, ...a).map(e=>e.content).join("")
    }
    !function(e) {
        function t(e, ...t) {
            const a = e.split(".");
            return isNaN(+a[0]) && a.unshift("0"),
            i.default.followDirections(t, a)
        }
        function a(e, t) {
            let a = 0;
            for (let i = 0; i < t.length; i++)
                switch (t[i]) {
                case "{":
                    a++;
                    break;
                case "}":
                    --a < 0 && (a = 0);
                    break;
                case "\\":
                    i++;
                    break;
                case e[0]:
                    if (0 === a)
                        return i
                }
            return -1
        }
        e.getArgument = t,
        e.getIndexOfTopLevel = a
    }(n || (n = {})),
    t.default = n,
    t.argumentSegment = {
        regex: /^[a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)*$/,
        handle: (e,t,i,...o)=>{
            const r = n.getArgument(t, ...o);
            return void 0 === r ? "" : a.isIterable(r) ? r : `${r}`
        }
    },
    t.conditionalSegment = {
        regex: /^([a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)*)\?/,
        handle: ([,e],t,a,...i)=>{
            let o = n.getIndexOfTopLevel(":", t);
            o = -1 === o ? 1 / 0 : o;
            const r = n.getArgument(e, ...i)
              , s = (Array.isArray(r) ? r.length : r) ? t.slice(e.length + 1, o).replace(/\\:/g, ":") : t.slice(o + 1);
            return a.interpolate(s, ...i)
        }
    },
    t.escapedSegment = {
        regex: /^\{.*\}$/,
        handle: e=>e[0]
    },
    t.basicInterpolator = new n(t.escapedSegment,t.argumentSegment,t.conditionalSegment),
    t.interpolateSectioned = o,
    t.interpolate = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/IComponent", ["require", "exports"], function(e, t) {
    var a, i, n, o, r;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        function t(e) {
            return {
                after: e
            }
        }
        function a(e) {
            return {
                before: e
            }
        }
        e.Append = "append",
        e.Prepend = "prepend",
        e.after = t,
        e.before = a
    }(a = t.AppendStrategy || (t.AppendStrategy = {})),
    function(e) {
        e.SVG = "http://www.w3.org/2000/svg"
    }(i = t.Namespace || (t.Namespace = {})),
    function(e) {
        e[e.Primary = 0] = "Primary",
        e[e.Secondary = 1] = "Secondary",
        e[e.Tertiary = 2] = "Tertiary",
        e[e.Quaternary = 3] = "Quaternary"
    }(n = t.SelectableLayer || (t.SelectableLayer = {})),
    function(e) {
        e[e.AboveLeft = 0] = "AboveLeft",
        e[e.AboveRight = 1] = "AboveRight",
        e[e.TopLeft = 2] = "TopLeft",
        e[e.TopRight = 3] = "TopRight",
        e[e.CenterLeft = 4] = "CenterLeft",
        e[e.CenterRight = 5] = "CenterRight",
        e[e.BottomLeft = 6] = "BottomLeft",
        e[e.BottomRight = 7] = "BottomRight",
        e[e.BeneathLeft = 8] = "BeneathLeft",
        e[e.BeneathRight = 9] = "BeneathRight",
        e[e.Mouse = 10] = "Mouse"
    }(o = t.TooltipLocation || (t.TooltipLocation = {})),
    function(e) {
        e[e.Stat = 0] = "Stat",
        e[e.MenuBarButton = 1] = "MenuBarButton",
        e[e.Selector = 2] = "Selector"
    }(r = t.HighlightType || (t.HighlightType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/fieldofview/IByteGrid", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/fieldofview/ByteGrid", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor(e, t=e) {
            this.width = e,
            this.height = t,
            this.width = Math.floor(e),
            this.height = Math.floor(t),
            this.size = this.width * this.height,
            this.data = new Uint8Array(this.size)
        }
        get(e, t) {
            return this.data[e + t * this.width]
        }
        set(e, t, a) {
            this.data[e + t * this.width] = a
        }
        rawSet(e, t) {
            this.data[e] = t
        }
        clear() {
            this.data.fill(0)
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/IExploreMap", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/ExploreMap", ["require", "exports", "renderer/fieldofview/ByteGrid"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        encode() {
            this.encodedData = [];
            let e = 0
              , t = 0;
            for (let a = 0; a < this.data.length; a++)
                this.data[a] !== t ? (this.encodedData.push(e),
                e = 1,
                t = 0 === t ? 255 : 0) : e++;
            return this.encodedData.push(e),
            this.encodedData
        }
        decode(e) {
            void 0 !== e && (this.encodedData = e);
            let t = 0
              , a = 0;
            for (let e = 0; e < this.encodedData.length; e++) {
                for (let i = 0; i < this.encodedData[e]; i++)
                    this.data[t] = a,
                    t++;
                a = 0 === a ? 255 : 0
            }
            delete this.encodedData
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/clientStore/clientData/ExploredMap", ["require", "exports", "renderer/ExploreMap", "save/ISerializer"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        preSerializeObject() {
            if (this.exploredMap) {
                this.exploredMapEncodedData = [];
                for (let e = 0; e < this.exploredMap.length; e++) {
                    const t = this.exploredMap[e];
                    t && (this.exploredMapEncodedData[e] = t.encode())
                }
            }
        }
        getExploreMap(e) {
            let t = this.exploredMap;
            t || (t = this.exploredMap = []);
            let i = t[e];
            if (!i) {
                const n = renderer && renderer.layers ? renderer.layers[e] : void 0;
                i = t[e] = new a.default(n ? n.width : game.mapSize,n ? n.height : game.mapSize)
            }
            return i
        }
        restoreExploredMap() {
            if (this.exploredMapEncodedData) {
                this.exploredMap = [];
                for (let e = 0; e < this.exploredMapEncodedData.length; e++) {
                    const t = this.exploredMapEncodedData[e];
                    if (t) {
                        const i = world.layers[e];
                        if (i) {
                            const n = new a.default(i.width,i.height);
                            n.decode(t),
                            this.exploredMap[e] = n
                        }
                    }
                }
                delete this.exploredMapEncodedData
            }
        }
    }
    __decorate([i.SaveProperty()], n.prototype, "exploredMapEncodedData", void 0),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/ServerPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/Packet"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.Packet {
        getType() {
            return a.PacketType.Server
        }
    }
    __decorate([Override], n.prototype, "getType", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/PlayerTargetedServerPacket", ["require", "exports", "multiplayer/packets/ServerPacket"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        preProcess() {
            void 0 !== this.pid && void 0 === this.player && (this.player = players[this.pid])
        }
    }
    __decorate([Override], i.prototype, "preProcess", null),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/server/NewUiDataUpdatePacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedServerPacket", "save/clientStore/IClientStore"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o extends i.default {
        static create(e, t, a, i) {
            const n = new o;
            return n.player = e,
            n.hostId = t,
            n.key = a,
            n.value = i,
            n
        }
        process() {
            this.player.clientStore.get(n.ClientDataType.NewUi).set(this.hostId, this.key, this.value)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Generic)], o.prototype, "hostId", void 0),
    __decorate([a.NetworkProperty(a.NetworkPropertyType.String)], o.prototype, "key", void 0),
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Generic)], o.prototype, "value", void 0),
    __decorate([Override], o.prototype, "process", null),
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/clientStore/clientData/NewUiData", ["require", "exports", "multiplayer/packets/server/NewUiDataUpdatePacket", "save/ISerializer"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        constructor() {
            this.data = new Map
        }
        get(e, t, a) {
            this.data.has(e) || this.data.set(e, {});
            const i = this.data.get(e);
            return t in i || this.set(e, t, a),
            i[t]
        }
        set(e, t, a) {
            this.data.has(e) || this.data.set(e, {});
            const i = this.data.get(e);
            i[t] = a,
            this.update(e, t)
        }
        has(e, t) {
            const a = this.data.get(e);
            return a && t in a
        }
        update(e, t) {
            if (!this.data.has(e))
                return;
            const i = this.data.get(e);
            t in i && multiplayer.isClient() && multiplayer.sendPacket(a.default.create(localPlayer, e, t, i[t]))
        }
    }
    __decorate([i.SaveProperty()], n.prototype, "data", void 0),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/clientStore/IClientStore", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.ExploredMap = 0] = "ExploredMap",
        e[e.NewUi = 1] = "NewUi"
    }(a = t.ClientDataType || (t.ClientDataType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("save/ISaveManager", ["require", "exports", "save/ISerializer"], function(e, t, a) {
    var i, n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.SaveTime = 0] = "SaveTime",
        e[e.Name = 1] = "Name",
        e[e.TurnCount = 2] = "TurnCount",
        e[e.CreatedTime = 3] = "CreatedTime"
    }(i = t.SaveSort || (t.SaveSort = {})),
    function(e) {
        e[e.More = 1] = "More",
        e[e.Less = -1] = "Less"
    }(n = t.SortDirection || (t.SortDirection = {})),
    t.SLOT_CHALLENGE = -1,
    t.SLOT_GLOBAL = 26,
    t.SLOT_MULTIPLAYER = 27,
    t.SLOT_COUNT_MAX = 20,
    t.propertiesToSerialize = [{
        key: "game",
        property: ["game"]
    }, {
        key: "player",
        property: ["localPlayer"]
    }, {
        key: "absentPlayers",
        property: ["absentPlayers"]
    }, {
        key: "ui",
        property: ["ui"]
    }, {
        key: "world",
        property: ["world"],
        skipCompression: !0
    }, {
        key: "gameSlotName",
        property: ["saveData", "gameSlotName"]
    }, {
        key: "gameState",
        property: ["saveData", "gameState"]
    }, {
        key: "gameBaseSeed",
        property: ["saveData", "gameBaseSeed"]
    }, {
        key: "gameCreationTime",
        property: ["saveData", "gameCreationTime"]
    }, {
        key: "saveManagerOriginalVersion",
        property: ["saveData", "saveManagerOriginalVersion"]
    }, {
        key: "gameThumbnail",
        property: ["saveData", "gameThumbnail"]
    }, {
        key: "saveTime",
        property: ["saveData", "saveManagerSaveTime"]
    }, {
        key: "saveManagerTicks",
        property: ["saveData", "saveManagerTicks"]
    }, {
        key: "saveManagerScore",
        property: ["saveData", "saveManagerScore"]
    }, {
        key: "saveManagerDifficulty",
        property: ["saveData", "saveManagerDifficulty"]
    }, {
        key: "saveManagerDeathBy",
        property: ["saveData", "saveManagerDeathBy"]
    }, {
        key: "modsSaveData",
        property: ["saveData", "modManagerSaveData"]
    }, {
        key: "modsUnloadable",
        property: ["saveData", "modManagerUnloadable"]
    }, {
        key: "allocatedEnums",
        property: ["saveData", "utilitiesEnumsAllocated"]
    }, {
        key: "newui",
        property: ["saveData", "newui"]
    }, {
        key: "clientStore",
        property: ["saveData", "clientStore"]
    }, {
        key: "multiplayerState",
        property: ["saveData", "multiplayerState"]
    }],
    t.propertiesToSerializeGlobal = [{
        key: "lastPlayedVersion",
        property: ["saveDataGlobal", "gameLastPlayedVersion"]
    }, {
        key: "gamesPlayed",
        property: ["saveDataGlobal", "gamePlayedCount"]
    }, {
        key: "crafted",
        property: ["saveDataGlobal", "gameCrafted"]
    }, {
        key: "highscores",
        property: ["saveDataGlobal", "gameHighscores"]
    }, {
        key: "options",
        property: ["saveDataGlobal", "options"]
    }, {
        key: "milestoneData",
        property: ["saveDataGlobal", "playerMilestoneData"]
    }, {
        key: "modState",
        property: ["saveDataGlobal", "modManagerModState"]
    }, {
        key: "modsSaveDataGlobal",
        property: ["saveDataGlobal", "modManagerSaveData"]
    }, {
        key: "languagesSaveData",
        property: ["saveDataGlobal", "languageManagerSaveData"]
    }, {
        key: "savedDialogInfo",
        property: ["saveDataGlobal", "savedDialogInfo"]
    }, {
        key: "multiplayerBannedPlayers",
        property: ["saveDataGlobal", "multiplayerBannedPlayers"]
    }, {
        key: "multiplayerPreviousGames",
        property: ["saveDataGlobal", "multiplayerPreviousGames"]
    }, {
        key: "characters",
        property: ["saveDataGlobal", "characters"]
    }, {
        key: "allocatedEnums",
        property: ["saveDataGlobal", "utilitiesEnumsAllocated"]
    }, {
        key: "newui",
        property: ["saveDataGlobal", "newui"]
    }, {
        key: "lastServerJoined",
        property: ["saveDataGlobal", "lastServerJoined"]
    }];
    let o = class e {
        constructor() {
            this.data = {},
            this.isCompressed = !1
        }
    }
    ;
    o = __decorate([a.SaveAllProperties()], o),
    t.SaveObject = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("steamworks/ISteamworks", ["require", "exports"], function(e, t) {
    var a, i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Private = 0] = "Private",
        e[e.FriendsOnly = 1] = "FriendsOnly",
        e[e.Public = 2] = "Public",
        e[e.Invisible = 3] = "Invisible"
    }(a = t.LobbyType || (t.LobbyType = {})),
    function(e) {
        e[e.OverlayShown = 0] = "OverlayShown",
        e[e.OverlayHidden = 1] = "OverlayHidden"
    }(i = t.SteamworksEvent || (t.SteamworksEvent = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/IMultiplayer", ["require", "exports", "Enums", "steamworks/ISteamworks"], function(e, t, a, i) {
    var n, o, r, s;
    function l() {
        return {
            lobbyType: i.LobbyType.FriendsOnly,
            pvp: !1,
            turnMode: a.TurnMode.Simulated,
            maxPlayers: 32,
            tickSpeed: a.TickSpeed.Default,
            syncChecks: t.networkingOptions.syncChecks
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Connect = 0] = "Connect",
        e[e.Disconnect = 1] = "Disconnect",
        e[e.JoinLobby = 2] = "JoinLobby",
        e[e.LeaveLobby = 3] = "LeaveLobby"
    }(n = t.MultiplayerEvent || (t.MultiplayerEvent = {})),
    function(e) {
        e[e.ActionAttack = 0] = "ActionAttack",
        e[e.ActionMove = 1] = "ActionMove",
        e[e.BaseEntityManager = 2] = "BaseEntityManager",
        e[e.CanASeeB = 3] = "CanASeeB",
        e[e.Container = 4] = "Container",
        e[e.Creature = 5] = "Creature",
        e[e.CreatureIsInFlowField = 6] = "CreatureIsInFlowField",
        e[e.CreatureMoveDirection = 7] = "CreatureMoveDirection",
        e[e.CreatureNearestPlayer = 8] = "CreatureNearestPlayer",
        e[e.Dismantle = 9] = "Dismantle",
        e[e.FlowFieldHashCode = 10] = "FlowFieldHashCode",
        e[e.FlowFieldValue = 11] = "FlowFieldValue",
        e[e.HandToUse = 12] = "HandToUse",
        e[e.HealthChange = 13] = "HealthChange",
        e[e.InventoryCount = 14] = "InventoryCount",
        e[e.IsTileEmpty = 15] = "IsTileEmpty",
        e[e.Item = 16] = "Item",
        e[e.ItemCraft = 17] = "ItemCraft",
        e[e.ItemDamage = 18] = "ItemDamage",
        e[e.ItemOrder = 19] = "ItemOrder",
        e[e.LastCreationIds = 20] = "LastCreationIds",
        e[e.PenaltyFieldHashCode = 21] = "PenaltyFieldHashCode",
        e[e.PlaceOnTile = 22] = "PlaceOnTile",
        e[e.PlayerPositions = 23] = "PlayerPositions",
        e[e.Players = 24] = "Players",
        e[e.Random = 25] = "Random",
        e[e.Seed = 26] = "Seed",
        e[e.StaminaChanges = 27] = "StaminaChanges",
        e[e.Stats = 28] = "Stats",
        e[e.Temp = 29] = "Temp",
        e[e.Tick = 30] = "Tick",
        e[e.Ticks = 31] = "Ticks",
        e[e.Weight = 32] = "Weight"
    }(o = t.MultiplayerSyncCheck || (t.MultiplayerSyncCheck = {})),
    t.maxPlayers = 32,
    t.defaultServerPort = 38740,
    t.keepAliveInterval = 4e3,
    t.keepAliveTimeout = 15e3,
    t.steamLobbyPrefix = "steam:",
    t.networkingOptions = {
        matchmakingServer: "mm.waywardgame.com",
        matchmakingServerPort: 38740,
        syncChecks: [o.Seed, o.Ticks],
        enablePacketNumberChecks: !1,
        checkSeedHistory: !1,
        chunkSize: 16384,
        logPackets: !1,
        stopWebRtc: !1,
        fakeRoundTripTime: 0,
        recentPacketTracking: 30
    },
    t.getDefaultMultiplayerOptions = l,
    function(e) {
        e[e.Serverside = 1] = "Serverside",
        e[e.Clientside = 2] = "Clientside",
        e[e.All = 3] = "All"
    }(r = t.PacketAcceptType || (t.PacketAcceptType = {})),
    function(e) {
        e[e.ConnectionTimeout = 0] = "ConnectionTimeout",
        e[e.Desync = 1] = "Desync",
        e[e.KeepAliveTimeout = 2] = "KeepAliveTimeout",
        e[e.Kick = 3] = "Kick",
        e[e.Left = 4] = "Left",
        e[e.LostConnection = 5] = "LostConnection",
        e[e.ServerShutdown = 6] = "ServerShutdown",
        e[e.UnableToJoinGame = 7] = "UnableToJoinGame",
        e[e.UnableToLoadMods = 8] = "UnableToLoadMods"
    }(s = t.DisconnectReason || (t.DisconnectReason = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/BasePacket", ["require", "exports", "entity/IEntity", "item/IItem", "player/IPlayer"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o {
        static getRegistrarId() {
            return this.registrarId
        }
        static setRegistrarId(e) {
            this.registrarId = e
        }
        constructor(e) {
            e && (this.connection = e)
        }
        getRegistrarId() {
            return this.constructor.registrarId
        }
        readInt8() {
            const e = this.dataView.getInt8(this.byteOffset);
            return this.byteOffset += 1,
            e
        }
        writeInt8(e) {
            this.ensureSize(1),
            this.dataView.setInt8(this.byteOffset, e),
            this.byteOffset += 1
        }
        readUint8() {
            const e = this.dataView.getUint8(this.byteOffset);
            return this.byteOffset += 1,
            e
        }
        writeUint8(e) {
            this.ensureSize(1),
            this.dataView.setUint8(this.byteOffset, e),
            this.byteOffset += 1
        }
        readUint16() {
            const e = this.dataView.getUint16(this.byteOffset);
            return this.byteOffset += 2,
            e
        }
        writeUint16(e) {
            this.ensureSize(2),
            this.dataView.setUint16(this.byteOffset, e),
            this.byteOffset += 2
        }
        readUint32() {
            const e = this.dataView.getUint32(this.byteOffset);
            return this.byteOffset += 4,
            e
        }
        writeUint32(e) {
            this.ensureSize(4),
            this.dataView.setUint32(this.byteOffset, e),
            this.byteOffset += 4
        }
        readFloat64() {
            const e = this.dataView.getFloat64(this.byteOffset);
            return this.byteOffset += 8,
            e
        }
        writeFloat64(e) {
            this.ensureSize(8),
            this.dataView.setFloat64(this.byteOffset, e),
            this.byteOffset += 8
        }
        readBool() {
            return 1 === this.readUint8()
        }
        writeBool(e) {
            this.writeUint8(e ? 1 : 0)
        }
        readUint8Array() {
            const e = this.readUint32()
              , t = new Uint8Array(this.dataView.buffer.slice(this.byteOffset, this.byteOffset + e));
            return this.byteOffset += e,
            t
        }
        writeUint8Array(e) {
            const t = e.byteLength;
            this.writeUint32(t),
            this.ensureSize(t),
            this.byteArray.set(e, this.byteOffset),
            this.byteOffset += t
        }
        readUint32NumberArray() {
            const e = [];
            e.length = this.readUint32();
            const t = this.readUint32();
            for (let a = 0; a < t; a++) {
                const t = this.readUint32();
                e[t] = this.readUint32()
            }
            return e
        }
        writeUint32NumberArray(e) {
            this.writeUint32(e.length);
            const t = Object.keys(e).map(e=>parseInt(e, 10));
            this.writeUint32(t.length);
            for (let a = 0; a < t.length; a++) {
                const i = t[a];
                this.writeUint32(i),
                this.writeUint32(e[i])
            }
        }
        readString() {
            const e = this.readUint32();
            let t = "";
            for (let a = 0; a < e; a++)
                t += String.fromCharCode(this.readUint16());
            return t
        }
        writeString(e) {
            this.writeUint32(e.length);
            for (let t = 0; t < e.length; t++)
                this.writeUint16(e.charCodeAt(t))
        }
        readStringArray() {
            const e = [];
            e.length = this.readUint32();
            const t = this.readUint32();
            for (let a = 0; a < t; a++) {
                const t = this.readUint32();
                e[t] = this.readString()
            }
            return e
        }
        writeStringArray(e) {
            this.writeUint32(e.length);
            const t = Object.keys(e).map(e=>parseInt(e, 10));
            this.writeUint32(t.length);
            for (let a = 0; a < t.length; a++) {
                const i = t[a];
                this.writeUint32(i),
                this.writeString(e[i])
            }
        }
        readVector2() {
            const e = this.readUint16()
              , t = this.readUint16();
            return {
                x: e,
                y: t
            }
        }
        writeVector2(e) {
            this.writeUint16(e.x),
            this.writeUint16(e.y)
        }
        readVector3() {
            const e = this.readUint16()
              , t = this.readUint16()
              , a = this.readUint16();
            return {
                x: e,
                y: t,
                z: a
            }
        }
        writeVector3(e) {
            this.writeUint16(e.x),
            this.writeUint16(e.y),
            this.writeUint16(e.z)
        }
        readContainer() {
            const e = {
                type: this.readUint8()
            };
            switch (e.type) {
            case i.ContainerReferenceType.PlayerInventory:
                e.pid = this.readUint8();
                break;
            case i.ContainerReferenceType.Doodad:
            case i.ContainerReferenceType.Tile:
                e.x = this.readUint16(),
                e.y = this.readUint16(),
                e.z = this.readUint16();
                break;
            case i.ContainerReferenceType.Item:
            case i.ContainerReferenceType.NPCInventory:
                e.id = this.readUint32()
            }
            return itemManager.derefenceContainerReference(e)
        }
        writeContainer(e) {
            const t = itemManager.getContainerReference(e);
            switch (this.writeUint8(t.type),
            t.type) {
            case i.ContainerReferenceType.PlayerInventory:
                this.writeUint8(t.pid);
                break;
            case i.ContainerReferenceType.Doodad:
            case i.ContainerReferenceType.Tile:
                this.writeUint16(t.x),
                this.writeUint16(t.y),
                this.writeUint16(t.z);
                break;
            case i.ContainerReferenceType.Item:
            case i.ContainerReferenceType.NPCInventory:
                this.writeUint32(t.id)
            }
        }
        readCreature() {
            const e = this.readUint32();
            return game.creatures[e]
        }
        writeCreature(e) {
            this.writeUint32(e.id)
        }
        readPlayer() {
            const e = this.readUint8();
            return players[e]
        }
        writePlayer(e) {
            this.writeUint8(e.id)
        }
        readDoodad() {
            const e = this.readUint32();
            return game.doodads[e]
        }
        writeDoodad(e) {
            this.writeUint32(e.id)
        }
        readNPC() {
            const e = this.readUint32();
            return game.npcs[e]
        }
        writeNPC(e) {
            this.writeUint32(e.id)
        }
        readCorpse() {
            const e = this.readUint32();
            return game.corpses[e]
        }
        writeCorpse(e) {
            this.writeUint32(e.id)
        }
        readEntity() {
            const e = this.readUint8()
              , t = this.readUint32();
            switch (e) {
            case a.EntityType.Player:
                return players[t];
            case a.EntityType.Creature:
                return game.creatures[t];
            case a.EntityType.NPC:
                return game.npcs[t]
            }
        }
        writeHuman(e) {
            this.writeUint8(e.entityType),
            this.writeUint32(e.id)
        }
        readHuman() {
            const e = this.readUint8()
              , t = this.readUint32();
            switch (e) {
            case a.EntityType.Player:
                return players[t];
            case a.EntityType.NPC:
                return game.npcs[t]
            }
        }
        writeEntity(e) {
            this.writeUint8(e.entityType),
            this.writeUint32(e.id)
        }
        readItem() {
            const e = this.readUint32();
            return game.items[e]
        }
        writeItem(e) {
            this.writeUint32(e.id)
        }
        readMovementIntent() {
            const e = this.readUint8();
            let t = this.readUint8();
            return t = 1 == (1 & t) ? t >> 1 : void 0,
            {
                intent: n.movementIntents[e],
                turnDelay: t
            }
        }
        writeMovementIntent(e) {
            this.writeUint8(n.movementIntents.indexOf(e.intent)),
            void 0 !== e.turnDelay ? this.writeUint8(1 | (127 & e.turnDelay) << 1) : this.writeUint8(0)
        }
        readItems() {
            const e = []
              , t = this.readUint32();
            for (let a = 0; a < t; a++) {
                const t = this.readUint32();
                e[a] = game.items[t]
            }
            return e
        }
        writeItems(e) {
            this.writeUint32(e.length);
            for (let t = 0; t < e.length; t++)
                this.writeUint32(e[t].id)
        }
        readTileEvent() {
            const e = this.readUint32();
            return game.tileEvents[e]
        }
        writeTileEvent(e) {
            this.writeUint32(e.id)
        }
        readObject() {
            const e = this.readUint8Array()
              , t = {}
              , a = saveManager.getSerializer();
            return a.loadFromUint8Array(t, "a", e),
            t.a
        }
        writeObject(e) {
            const t = saveManager.getSerializer()
              , a = t.saveToUint8Array({
                a: e
            }, "a");
            if (!a)
                throw new Error("Failed to serialize object");
            this.writeUint8Array(a)
        }
        readVector2Array() {
            const e = []
              , t = this.readUint32();
            for (let a = 0; a < t; a++)
                e[a] = this.readVector2();
            return e
        }
        writeVector2Array(e) {
            this.writeUint32(e.length);
            for (let t = 0; t < e.length; t++)
                this.writeVector2(e[t])
        }
        ensureSize(e) {
            if (this.byteOffset + e >= this.bufferSize) {
                do {
                    this.bufferSize *= 2
                } while (this.byteOffset + e >= this.bufferSize);const t = new Uint8Array(this.bufferSize);
                t.set(this.byteArray),
                this.byteArray = t,
                this.dataView = new DataView(t.buffer)
            }
        }
    }
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/IndexedPacket", ["require", "exports", "multiplayer/packets/BasePacket", "multiplayer/packets/IPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        resetIndexes(e) {
            this._index = 0;
            const t = this.getIndexSize();
            for (let a = 0; a < t; a++)
                e ? this.writeUint8(0) : (void 0 === this._indexFlags && (this._indexFlags = []),
                this._indexFlags.push(this.readUint8()))
        }
        readIndexedInt8() {
            return this.readIndex() ? this.readInt8() : void 0
        }
        writeIndexedInt8(e) {
            this.writeIndex(e) || this.writeInt8(e)
        }
        readIndexedUint8() {
            return this.readIndex() ? this.readUint8() : void 0
        }
        writeIndexedUint8(e) {
            this.writeIndex(e) || this.writeUint8(e)
        }
        readIndexedUint16() {
            return this.readIndex() ? this.readUint16() : void 0
        }
        writeIndexedUint16(e) {
            this.writeIndex(e) || this.writeUint16(e)
        }
        readIndexedUint32() {
            return this.readIndex() ? this.readUint32() : void 0
        }
        writeIndexedUint32(e) {
            this.writeIndex(e) || this.writeUint32(e)
        }
        readIndexedFloat64() {
            return this.readIndex() ? this.readFloat64() : void 0
        }
        writeIndexedFloat64(e) {
            this.writeIndex(e) || this.writeFloat64(e)
        }
        readIndexedBool() {
            return this.readIndex() ? this.readBool() : void 0
        }
        writeIndexedBool(e) {
            this.writeIndex(e) || this.writeBool(e)
        }
        readIndexedUint8Array() {
            return this.readIndex() ? this.readUint8Array() : void 0
        }
        writeIndexedUint8Array(e) {
            this.writeIndex(e) || this.writeUint8Array(e)
        }
        readIndexedUint32NumberArray() {
            return this.readIndex() ? this.readUint32NumberArray() : void 0
        }
        writeIndexedUint32NumberArray(e) {
            this.writeIndex(e) || this.writeUint32NumberArray(e)
        }
        readIndexedString() {
            return this.readIndex() ? this.readString() : void 0
        }
        writeIndexedString(e) {
            this.writeIndex(e) || this.writeString(e)
        }
        readIndexedStringArray() {
            return this.readIndex() ? this.readStringArray() : void 0
        }
        writeIndexedStringArray(e) {
            this.writeIndex(e) || this.writeStringArray(e)
        }
        readIndexedVector2() {
            return this.readIndex() ? this.readVector2() : void 0
        }
        writeIndexedVector2(e) {
            this.writeIndex(e) || this.writeVector2(e)
        }
        readIndexedVector3() {
            return this.readIndex() ? this.readVector3() : void 0
        }
        writeIndexedVector3(e) {
            this.writeIndex(e) || this.writeVector3(e)
        }
        readIndexedContainer() {
            return this.readIndex() ? this.readContainer() : void 0
        }
        writeIndexedContainer(e) {
            this.writeIndex(e) || this.writeContainer(e)
        }
        readIndexedCreature() {
            return this.readIndex() ? this.readCreature() : void 0
        }
        writeIndexedCreature(e) {
            this.writeIndex(e) || this.writeCreature(e)
        }
        readIndexedPlayer() {
            return this.readIndex() ? this.readPlayer() : void 0
        }
        writeIndexedPlayer(e) {
            this.writeIndex(e) || this.writePlayer(e)
        }
        readIndexedDoodad() {
            return this.readIndex() ? this.readDoodad() : void 0
        }
        writeIndexedDoodad(e) {
            this.writeIndex(e) || this.writeDoodad(e)
        }
        readIndexedNPC() {
            return this.readIndex() ? this.readNPC() : void 0
        }
        writeIndexedNPC(e) {
            this.writeIndex(e) || this.writeNPC(e)
        }
        readIndexedCorpse() {
            return this.readIndex() ? this.readCorpse() : void 0
        }
        writeIndexedCorpse(e) {
            this.writeIndex(e) || this.writeCorpse(e)
        }
        readIndexedEntity() {
            return this.readIndex() ? this.readEntity() : void 0
        }
        writeIndexedEntity(e) {
            this.writeIndex(e) || this.writeEntity(e)
        }
        readIndexedHuman() {
            return this.readIndex() ? this.readHuman() : void 0
        }
        writeIndexedHuman(e) {
            this.writeIndex(e) || this.writeHuman(e)
        }
        readIndexedItem() {
            return this.readIndex() ? this.readItem() : void 0
        }
        writeIndexedItem(e) {
            this.writeIndex(e) || this.writeItem(e)
        }
        readIndexedMovementIntent() {
            return this.readIndex() ? this.readMovementIntent() : void 0
        }
        writeIndexedMovementIntent(e) {
            this.writeIndex(e) || this.writeMovementIntent(e)
        }
        readIndexedItems() {
            return this.readIndex() ? this.readItems() : void 0
        }
        writeIndexedItems(e) {
            this.writeIndex(e) || this.writeItems(e)
        }
        readIndexedObject() {
            return this.readIndex() ? this.readObject() : void 0
        }
        writeIndexedObject(e) {
            this.writeIndex(e) || this.writeObject(e)
        }
        readIndexedVector2Array() {
            return this.readIndex() ? this.readVector2Array() : void 0
        }
        writeIndexedVector2Array(e) {
            this.writeIndex(e) || this.writeVector2Array(e)
        }
        writeIndex(e) {
            if (void 0 === e)
                return this._index++,
                !0;
            const t = i.reservedBytes + Math.floor(this._index / 8);
            return this.dataView.setUint8(t, this.dataView.getUint8(t) | 1 << this._index % 8),
            this._index++,
            !1
        }
        readIndex() {
            const e = 0 != (this._indexFlags[Math.floor(this._index / 8)] & 1 << this._index % 8);
            return this._index++,
            e
        }
    }
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/Packet", ["require", "exports", "Enums", "multiplayer/packets/IndexedPacket", "multiplayer/packets/IPacket"], function(e, t, a, i, n) {
    var o;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.None = 0] = "None",
        e[e.PacketNumber = 1] = "PacketNumber",
        e[e.AfterRandomHistory = 2] = "AfterRandomHistory",
        e[e.BeforeSyncChecks = 4] = "BeforeSyncChecks",
        e[e.AfterSyncChecks = 8] = "AfterSyncChecks"
    }(o || (o = {}));
    class r extends i.default {
        constructor() {
            super(...arguments),
            this.synchronizationCheckData = {}
        }
        getDebugInfo() {
            return this.constructor.name
        }
        getAllowedStates() {
            return a.ConnectionState.All
        }
        isSyncCheckEnabled() {
            return !0
        }
        isAllowedWhenPaused() {
            return !1
        }
        getSynchronizationCheckData() {
            return this.synchronizationCheckData
        }
        getArrayBuffer(e) {
            return void 0 !== this._arrayBuffer && void 0 === e || (this.bufferSize = this.getInitialBufferSize(),
            this.byteArray = new Uint8Array(this.bufferSize),
            this.dataView = new DataView(this.byteArray.buffer),
            this.byteOffset = n.reservedBytes,
            this.resetIndexes(!0),
            this.isSyncCheckEnabled() && this.writeSynchronizationCheck(),
            this.preWriteData(),
            this.writeData(),
            this.dataView.setUint32(0, this.byteOffset),
            this.dataView.setUint8(4, this.getRegistrarId()),
            this._arrayBuffer = this.dataView.buffer.slice(0, this.byteOffset)),
            this._arrayBuffer
        }
        processData(e) {
            this.dataView = e,
            this.byteOffset = n.reservedBytes,
            this.resetIndexes(!1),
            this.isSyncCheckEnabled() && this.readSynchronizationCheck(),
            this.preReadData(),
            this.readData()
        }
        send(e) {
            multiplayer.sendPacket(this, e)
        }
        sendTo(e, t) {
            multiplayer.sendPacketTo(e, this, t)
        }
        processAndSend(e) {
            const t = this.isSyncCheckEnabled();
            t && multiplayer.addBeforeSyncChecks(this),
            this.preProcess();
            const a = this.process();
            return t && multiplayer.addAfterSyncChecks(this),
            this.send(e),
            a
        }
        getInitialBufferSize() {
            return 8192
        }
        getIndexSize() {
            const e = this.constructor._networkedProperties;
            return e && e.some(e=>e.optional) ? 1 : 0
        }
        preWriteData() {}
        writeData() {
            const e = this.constructor._networkedProperties;
            if (!e)
                return;
            const t = this;
            for (const a of e) {
                const e = t[a.key]
                  , i = a.optional;
                switch (a.type) {
                case n.NetworkPropertyType.Bool:
                    i ? this.writeIndexedBool(e) : this.writeBool(e);
                    break;
                case n.NetworkPropertyType.Int8:
                    i ? this.writeIndexedInt8(e) : this.writeInt8(e);
                    break;
                case n.NetworkPropertyType.Uint8:
                    i ? this.writeIndexedUint8(e) : this.writeUint8(e);
                    break;
                case n.NetworkPropertyType.Uint16:
                    i ? this.writeIndexedUint16(e) : this.writeUint16(e);
                    break;
                case n.NetworkPropertyType.Float64:
                    i ? this.writeIndexedFloat64(e) : this.writeFloat64(e);
                    break;
                case n.NetworkPropertyType.Uint32NumberArray:
                    i ? this.writeIndexedUint32NumberArray(e) : this.writeUint32NumberArray(e);
                    break;
                case n.NetworkPropertyType.String:
                    i ? this.writeIndexedString(e) : this.writeString(e);
                    break;
                case n.NetworkPropertyType.Container:
                    i ? this.writeIndexedContainer(e) : this.writeContainer(e);
                    break;
                case n.NetworkPropertyType.Generic:
                    i ? this.writeIndexedObject(e) : this.writeObject(e);
                    break;
                case n.NetworkPropertyType.Item:
                    i ? this.writeIndexedItem(e) : this.writeItem(e);
                    break;
                case n.NetworkPropertyType.MovementIntent:
                    i ? this.writeIndexedMovementIntent(e) : this.writeMovementIntent(e);
                    break;
                case n.NetworkPropertyType.Vector2Array:
                    i ? this.writeIndexedVector2Array(e) : this.writeVector2Array(e)
                }
            }
        }
        preReadData() {}
        readData() {
            const e = this.constructor._networkedProperties;
            if (!e)
                return;
            const t = this;
            for (const a of e) {
                let e;
                const i = a.optional;
                switch (a.type) {
                case n.NetworkPropertyType.Bool:
                    e = i ? this.readIndexedBool() : this.readBool();
                    break;
                case n.NetworkPropertyType.Int8:
                    e = i ? this.readIndexedInt8() : this.readInt8();
                    break;
                case n.NetworkPropertyType.Uint8:
                    e = i ? this.readIndexedUint8() : this.readUint8();
                    break;
                case n.NetworkPropertyType.Uint16:
                    e = i ? this.readIndexedUint16() : this.readUint16();
                    break;
                case n.NetworkPropertyType.Float64:
                    e = i ? this.readIndexedFloat64() : this.readFloat64();
                    break;
                case n.NetworkPropertyType.Uint32NumberArray:
                    e = i ? this.readIndexedUint32NumberArray() : this.readUint32NumberArray();
                    break;
                case n.NetworkPropertyType.String:
                    e = i ? this.readIndexedString() : this.readString();
                    break;
                case n.NetworkPropertyType.Container:
                    e = i ? this.readIndexedContainer() : this.readContainer();
                    break;
                case n.NetworkPropertyType.Generic:
                    e = i ? this.readIndexedObject() : this.readObject();
                    break;
                case n.NetworkPropertyType.Item:
                    e = i ? this.readIndexedItem() : this.readItem();
                    break;
                case n.NetworkPropertyType.MovementIntent:
                    e = i ? this.readIndexedMovementIntent() : this.readMovementIntent();
                    break;
                case n.NetworkPropertyType.Vector2Array:
                    e = i ? this.readIndexedVector2Array() : this.readVector2Array()
                }
                t[a.key] = e
            }
        }
        preProcess() {}
        readSynchronizationCheck() {
            this.synchronizationCheckData = {};
            const e = this.readUint8();
            (e & o.PacketNumber) === o.PacketNumber && (this.synchronizationCheckData.packetNumber = this.readUint32()),
            (e & o.AfterRandomHistory) === o.AfterRandomHistory && (this.synchronizationCheckData.afterRandomHistory = this.readObject()),
            (e & o.BeforeSyncChecks) === o.BeforeSyncChecks && (this.synchronizationCheckData.beforeSyncChecks = this.readObject()),
            (e & o.AfterSyncChecks) === o.AfterSyncChecks && (this.synchronizationCheckData.afterSyncChecks = this.readObject())
        }
        writeSynchronizationCheck() {
            let e = 0;
            void 0 !== this.synchronizationCheckData.packetNumber && (e |= o.PacketNumber),
            void 0 !== this.synchronizationCheckData.afterRandomHistory && (e |= o.AfterRandomHistory),
            void 0 !== this.synchronizationCheckData.beforeSyncChecks && (e |= o.BeforeSyncChecks),
            void 0 !== this.synchronizationCheckData.afterSyncChecks && (e |= o.AfterSyncChecks),
            this.writeUint8(e),
            void 0 !== this.synchronizationCheckData.packetNumber && this.writeUint32(this.synchronizationCheckData.packetNumber),
            void 0 !== this.synchronizationCheckData.afterRandomHistory && this.writeObject(this.synchronizationCheckData.afterRandomHistory),
            void 0 !== this.synchronizationCheckData.beforeSyncChecks && this.writeObject(this.synchronizationCheckData.beforeSyncChecks),
            void 0 !== this.synchronizationCheckData.afterSyncChecks && this.writeObject(this.synchronizationCheckData.afterSyncChecks)
        }
    }
    __decorate([Override], r.prototype, "getIndexSize", null),
    t.Packet = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/ClientPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/Packet"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.Packet {
        getType() {
            return a.PacketType.Client
        }
    }
    __decorate([Override], n.prototype, "getType", null),
    t.default = n
}),
/*!
* Copyright Unlok, Vaughn Royko 2011-2018
* http://www.unlok.ca
*
* Credits & Thanks:
* http://www.unlok.ca/credits-thanks/
*
* Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
* https://waywardgame.github.io/
*/
define("player/IMessageManager", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.All = 0] = "All",
        e[e.Action = 1] = "Action",
        e[e.Allies = 2] = "Allies",
        e[e.Chat = 3] = "Chat",
        e[e.Combat = 4] = "Combat",
        e[e.Command = 5] = "Command",
        e[e.Creature = 6] = "Creature",
        e[e.Equipment = 7] = "Equipment",
        e[e.Game = 8] = "Game",
        e[e.Item = 9] = "Item",
        e[e.Meta = 10] = "Meta",
        e[e.Milestone = 11] = "Milestone",
        e[e.Multiplayer = 12] = "Multiplayer",
        e[e.Resource = 13] = "Resource",
        e[e.Skill = 14] = "Skill",
        e[e.Wellbeing = 15] = "Wellbeing",
        e[e.Stat = 16] = "Stat"
    }(a = t.Source || (t.Source = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/client/AddPlayerPacket", ["require", "exports", "language/dictionary/Message", "language/Translation", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket", "player/IMessageManager", "player/MessageManager", "utilities/Log"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class u extends n.default {
        process() {
            const e = game.addPlayer(this.playerOptions);
            return e.isConnecting = !0,
            e.wasAbsentPlayer || e.setup(this.playerOptions.completedMilestones),
            l.default.info(l.LogSource.Chat)(i.default.message(a.default.MultiplayerPlayerConnected).getString(e.getName())),
            s.default.toAll((t,i)=>i !== e && t.source(r.Source.Multiplayer).send(a.default.MultiplayerPlayerConnected, e.getName())),
            multiplayer.updateGlobalServerDirectory(),
            e.id
        }
    }
    __decorate([o.NetworkProperty(o.NetworkPropertyType.Generic)], u.prototype, "playerOptions", void 0),
    __decorate([Override], u.prototype, "process", null),
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/client/PausePacket", ["require", "exports", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        process() {
            game.setPaused(this.paused, this.showChatMessage),
            this.paused || multiplayer.clearSyncPacketsWaiting()
        }
    }
    __decorate([i.NetworkProperty(i.NetworkPropertyType.Bool)], n.prototype, "paused", void 0),
    __decorate([i.NetworkProperty(i.NetworkPropertyType.Bool)], n.prototype, "showChatMessage", void 0),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/**
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/IHookManager", ["require", "exports"], function(e, t) {
    var a, i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.CanClientMove = "canClientMove",
        e.CanConsumeItem = "canConsumeItem",
        e.CanCreatureAttack = "canCreatureAttack",
        e.CanCreatureMove = "canCreatureMove",
        e.CanCreatureSpawn = "canCreatureSpawn",
        e.CanDoodadSpawn = "canDoodadSpawn",
        e.CanDropItem = "canDropItem",
        e.CanNPCAttack = "canNPCAttack",
        e.CanNPCMove = "canNPCMove",
        e.CanNPCSpawn = "canNPCSpawn",
        e.CanPickupDoodad = "canPickupDoodad",
        e.CanPlayerAttack = "canPlayerAttack",
        e.CanSeeCreature = "canSeeCreature",
        e.CanSeeNPC = "canSeeNPC",
        e.GetAmbientColor = "getAmbientColor",
        e.GetAmbientColorCave = "getAmbientColorCave",
        e.GetAmbientColorDay = "getAmbientColorDay",
        e.GetAmbientColorNight = "getAmbientColorNight",
        e.GetFogColor = "getFogColor",
        e.GetAmbientLightLevel = "getAmbientLightLevel",
        e.GetCreatureSpriteBatchLayer = "getCreatureSpriteBatchLayer",
        e.GetMaxSpritesForLayer = "getMaxSpritesForLayer",
        e.GetPlayerFieldOfViewRadius = "getPlayerFieldOfViewRadius",
        e.GetPlayerMaxHealth = "getPlayerMaxHealth",
        e.GetPlayerMaxWeight = "getPlayerMaxWeight",
        e.GetPlayerMovementIntent = "getPlayerMovementIntent",
        e.GetPlayerSpriteBatchLayer = "getPlayerSpriteBatchLayer",
        e.GetPlayerWeightMovementPenalty = "getPlayerWeightMovementPenalty",
        e.GetPlayerWeightStatus = "getPlayerWeightStatus",
        e.GetCameraPosition = "getCameraPosition",
        e.GetTileLightLevel = "getTileLightLevel",
        e.GetTilePenalty = "getTilePenalty",
        e.GetZoomLevel = "getZoomLevel",
        e.IsHumanSwimming = "isHumanSwimming",
        e.IsTileBlocked = "isTileBlocked",
        e.OnBindLoop = "onBindLoop",
        e.OnBuild = "onBuild",
        e.OnContainerItemAdd = "onContainerItemAdd",
        e.OnContainerItemRemove = "onContainerItemRemove",
        e.OnContainerItemUpdate = "onContainerItemUpdate",
        e.OnCraft = "onCraft",
        e.OnCreateWorld = "onCreateWorld",
        e.OnCreatureDamage = "onCreatureDamage",
        e.OnCreatureDeath = "onCreatureDeath",
        e.OnCreatureSpawn = "onCreatureSpawn",
        e.OnDigTreasure = "onDigTreasure",
        e.OnDisplayMessage = "onDisplayMessage",
        e.OnDoodadSpawn = "onDoodadSpawn",
        e.OnGameEnd = "onGameEnd",
        e.OnGameScreenVisible = "onGameScreenVisible",
        e.OnGameStart = "onGameStart",
        e.OnGameTickEnd = "onGameTickEnd",
        e.OnGameTickStart = "onGameTickStart",
        e.OnGetTranslation = "onGetTranslation",
        e.OnEntityKill = "onEntityKill",
        e.OnHumanSkillChange = "onHumanSkillChange",
        e.OnInventoryItemAdd = "onInventoryItemAdd",
        e.OnInventoryItemRemove = "onInventoryItemRemove",
        e.OnInventoryItemUpdate = "onInventoryItemUpdate",
        e.OnItemDamage = "onItemDamage",
        e.OnItemEquip = "onItemEquip",
        e.OnItemQuickslot = "onItemQuickslot",
        e.OnLanguageChange = "onLanguageChange",
        e.OnMove = "onMove",
        e.OnMoveComplete = "onMoveComplete",
        e.OnMoveDirectionUpdate = "onMoveDirectionUpdate",
        e.OnNoInputReceived = "onNoInputReceived",
        e.OnNPCDamage = "onNPCDamage",
        e.OnNPCDeath = "onNPCDeath",
        e.OnNPCSpawn = "onNPCSpawn",
        e.OnOpenBook = "onOpenBook",
        e.OnPickupDoodad = "onPickupDoodad",
        e.OnPlayerDamage = "onPlayerDamage",
        e.OnPlayerDeath = "onPlayerDeath",
        e.OnPlayerJoin = "onPlayerJoin",
        e.OnPlayerLeave = "onPlayerLeave",
        e.OnPlayerTickEnd = "onPlayerTickEnd",
        e.OnPlayerTickStart = "onPlayerTickStart",
        e.OnPlayerWalkToTilePath = "onPlayerWalkToTilePath",
        e.OnQueueSoundEffect = "onQueueSoundEffect",
        e.OnReadMap = "onReadMap",
        e.OnRenderOverlay = "onRenderOverlay",
        e.OnSailToCivilization = "onSailToCivilization",
        e.OnSpawnCreatureFromGroup = "onSpawnCreatureFromGroup",
        e.OnTileUpdate = "onTileUpdate",
        e.OnTurnEnd = "onTurnEnd",
        e.OnTurnStart = "onTurnStart",
        e.OnUpdateWeight = "onUpdateWeight",
        e.OnWriteNote = "onWriteNote",
        e.OnWrittenNote = "onWrittenNote",
        e.PostExecuteAction = "postExecuteAction",
        e.PostFieldOfView = "postFieldOfView",
        e.PostGenerateWorld = "postGenerateWorld",
        e.PostRender = "postRender",
        e.PostRenderPostProcess = "postRenderPostProcess",
        e.PostRenderWorld = "postRenderWorld",
        e.PostSaveGame = "postSaveGame",
        e.PreExecuteAction = "preExecuteAction",
        e.PreExecuteCommand = "preExecuteCommand",
        e.PreLoadWorldDifferences = "preLoadWorldDifferences",
        e.PreRender = "preRender",
        e.PreRenderPostProcess = "preRenderPostProcess",
        e.PreRenderWorld = "preRenderWorld",
        e.PreSaveGame = "preSaveGame",
        e.ProcessInput = "processInput",
        e.ShouldDisplayMessage = "shouldDisplayMessage",
        e.ShouldRender = "shouldRender",
        e.ShouldStopWalkToTileMovement = "shouldStopWalkToTileMovement",
        e.OnCreatureTamed = "onCreatureTamed"
    }(a = t.Hook || (t.Hook = {})),
    t.globalHooks = [a.OnQueueSoundEffect, a.OnGetTranslation],
    function(e) {
        e[e.Lowest = -2e3] = "Lowest",
        e[e.Low = -1e3] = "Low",
        e[e.Normal = 0] = "Normal",
        e[e.High = 1e3] = "High",
        e[e.Highest = 2e3] = "Highest"
    }(i = t.HookPriority || (t.HookPriority = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/PlayerTargetedClientPacket", ["require", "exports", "multiplayer/packets/ClientPacket"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        preProcess() {
            void 0 !== this.pid && void 0 === this.player && (this.player = players[this.pid])
        }
        preWriteData() {
            this.writeUint8(this.pid)
        }
        preReadData() {
            this.pid = this.readUint8()
        }
    }
    __decorate([Override], i.prototype, "preProcess", null),
    __decorate([Override], i.prototype, "preWriteData", null),
    __decorate([Override], i.prototype, "preReadData", null),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/client/ReadyPlayerPacket", ["require", "exports", "Enums", "language/dictionary/Message", "language/Translation", "mod/IHookManager", "multiplayer/packets/PlayerTargetedClientPacket", "player/IMessageManager", "player/MessageManager", "steamworks/ISteamworks", "utilities/Log"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class p extends r.default {
        process() {
            if (steamworks.multiplayerLog("ReadyPlayerPacket", this.pid),
            this.player.isLocalPlayer()) {
                if (steamworks.multiplayerLog("Setting connection state to Ready", this.connection.pid),
                this.connection.setState(a.ConnectionState.Ready),
                newui.hideLoadingInterrupt(),
                steamworks.isGreenworksEnabled()) {
                    const e = multiplayer.getConnectedMatchmakingInfo();
                    void 0 !== e && e.isDedicatedServer && !steamworks.isInLobby() && (steamworks.multiplayerLog("Creating lobby"),
                    steamworks.createLobby(u.LobbyType.Public))
                }
                const e = players.filter(e=>!e.isServer()).length - 1;
                this.player.messages.source(s.Source.Multiplayer).type(l.MessageType.Good).send(i.default.JoinedAServer, e),
                commandManager.execute(this.player, a.Command.Ping)
            } else
                d.default.info(d.LogSource.Chat)(n.default.message(i.default.MultiplayerPlayerJoined).getString(this.player.getName())),
                l.default.toAll((e,t)=>t !== this.player && e.source(s.Source.Multiplayer).send(i.default.MultiplayerPlayerJoined, this.player.getName()));
            this.player.isConnecting = !1,
            modManager.getHook(o.Hook.OnPlayerJoin).call(this.player)
        }
    }
    __decorate([Override], p.prototype, "process", null),
    t.default = p
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/client/SynchronizeFlowFieldsPacket", ["require", "exports", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        process() {
            steamworks.multiplayerLog(game.time.ticks, "SynchronizeFlowFields", this.pids),
            game.synchronizeFlowFields(this.pids.map(e=>players[e]))
        }
    }
    __decorate([i.NetworkProperty(i.NetworkPropertyType.Uint32NumberArray)], n.prototype, "pids", void 0),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/server/ReadyPacket", ["require", "exports", "Enums", "multiplayer/packets/client/PausePacket", "multiplayer/packets/client/ReadyPlayerPacket", "multiplayer/packets/client/SynchronizeFlowFieldsPacket", "multiplayer/packets/ServerPacket"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class s extends r.default {
        getAllowedStates() {
            return a.ConnectionState.CatchingUp
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            steamworks.multiplayerLog("ReadyPacket", this.connection.pid),
            this.connection.setState(a.ConnectionState.Ready);
            const e = new o.default;
            e.pids = multiplayer.getClients().filter(e=>e.getState() === a.ConnectionState.Ready).map(e=>e.pid).concat(localPlayer.id),
            e.processAndSend();
            const t = new n.default(this.connection);
            if (t.pid = this.connection.pid,
            t.processAndSend(),
            game.paused) {
                const e = new i.default;
                e.paused = !0,
                e.showChatMessage = !0,
                e.sendTo(this.connection)
            }
        }
    }
    __decorate([Override], s.prototype, "getAllowedStates", null),
    __decorate([Override], s.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], s.prototype, "process", null),
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/client/CaughtUpPacket", ["require", "exports", "multiplayer/packets/ClientPacket", "multiplayer/packets/server/ReadyPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        process() {
            steamworks.multiplayerLog("CaughtUpPacket");
            const e = new i.default;
            e.send()
        }
    }
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/client/ClearSyncPacketWaitingPacket", ["require", "exports", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            multiplayer.clearSyncPacketsWaiting(this.waitId)
        }
    }
    __decorate([i.NetworkProperty(i.NetworkPropertyType.String)], n.prototype, "waitId", void 0),
    __decorate([Override], n.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/client/DisconnectPacket", ["require", "exports", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            multiplayer.disconnectAndResetGameState(this.reason, this.description)
        }
    }
    __decorate([i.NetworkProperty(i.NetworkPropertyType.Uint8)], n.prototype, "reason", void 0),
    __decorate([i.OptionalNetworkProperty(i.NetworkPropertyType.Uint8)], n.prototype, "description", void 0),
    __decorate([Override], n.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/server/ConfirmInterruptSelectionPacket", ["require", "exports", "action/ActionExecutor", "action/IAction", "language/dictionary/UiTranslation", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedServerPacket"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class s extends r.default {
        process() {
            switch (this.title) {
            case n.default.GameInterruptDangerousStep:
            case n.default.GameInterruptConfirmationActionOnFire:
                this.selection && void 0 !== this.player.nextMoveDirection && setTimeout(()=>{
                    a.default.get(i.ActionType.Move).execute(this.player, this.player.nextMoveDirection),
                    this.player.nextMoveDirection = void 0
                }
                , 0)
            }
        }
    }
    __decorate([o.NetworkProperty(o.NetworkPropertyType.Uint16)], s.prototype, "title", void 0),
    __decorate([o.NetworkProperty(o.NetworkPropertyType.Bool)], s.prototype, "selection", void 0),
    __decorate([Override], s.prototype, "process", null),
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/client/DisplayInterruptPacket", ["require", "exports", "language/Translation", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket", "multiplayer/packets/server/ConfirmInterruptSelectionPacket"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends i.default {
        async process() {
            localPlayer && localPlayer.resetMovementStates();
            const e = this.args.map(e=>a.default.deserialize(e))
              , t = await newui.interrupt(()=>a.default .ui(this.title).get(...e)).withDescription(()=>a.default .ui(this.description).get(...e)).withConfirmation()
              , i = new o.default;
            i.title = this.title,
            i.selection = t,
            i.send()
        }
    }
    __decorate([n.NetworkProperty(n.NetworkPropertyType.Uint16)], r.prototype, "title", void 0),
    __decorate([n.NetworkProperty(n.NetworkPropertyType.Uint16)], r.prototype, "description", void 0),
    __decorate([n.NetworkProperty(n.NetworkPropertyType.Generic)], r.prototype, "args", void 0),
    __decorate([Override], r.prototype, "process", null),
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/client/HideLoadingScreenPacket", ["require", "exports", "multiplayer/packets/ClientPacket"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        process() {
            const e = localPlayer.restData;
            void 0 !== e ? localPlayer.showRestInterrupt(e.type) : newui.hideLoadingInterrupt()
        }
    }
    __decorate([Override], i.prototype, "process", null),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/client/PongPacket", ["require", "exports", "language/dictionary/Message", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket", "player/IMessageManager"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends i.default {
        process() {
            localPlayer.messages.source(o.Source.Command).send(a.default.ChatPingCommand, (performance.now() - this.sendTime).toFixed(0))
        }
    }
    __decorate([n.NetworkProperty(n.NetworkPropertyType.Float64)], r.prototype, "sendTime", void 0),
    __decorate([Override], r.prototype, "process", null),
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/client/RemovePlayerPacket", ["require", "exports", "language/dictionary/Message", "language/Translation", "mod/IHookManager", "multiplayer/IMultiplayer", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedClientPacket", "player/IMessageManager", "player/MessageManager", "utilities/Log"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class p extends s.default {
        process() {
            steamworks.multiplayerLog("RemovePlayerPacket", this.pid, o.DisconnectReason[this.reason]),
            d.default.info(d.LogSource.Chat)(i.default.message(a.default.MultiplayerPlayerDisconnected).getString(this.player.getName())),
            u.default.toAll((e,t)=>t !== this.player && e.source(l.Source.Multiplayer).send(a.default.MultiplayerPlayerDisconnected, this.player.getName())),
            modManager.getHook(n.Hook.OnPlayerLeave).call(this.player),
            game.removePlayer(this.pid),
            multiplayer.updateGlobalServerDirectory()
        }
    }
    __decorate([r.NetworkProperty(r.NetworkPropertyType.Uint8)], p.prototype, "reason", void 0),
    __decorate([Override], p.prototype, "process", null),
    t.default = p
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/client/SetPlayerZPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedClientPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        process() {
            this.player.setZ(this.z)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Uint8)], n.prototype, "z", void 0),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/client/ShowLoadingScreenPacket", ["require", "exports", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        process() {
            newui.showLoadingInterrupt(this.title, this.description)
        }
    }
    __decorate([i.NetworkProperty(i.NetworkPropertyType.Uint16)], n.prototype, "title", void 0),
    __decorate([i.OptionalNetworkProperty(i.NetworkPropertyType.Uint16)], n.prototype, "description", void 0),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/server/LogsPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedServerPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            steamworks.multiplayerLog(`Received logs from ${this.player.id}`),
            steamworks.multiplayerLog(this.logs),
            this.containsServerGameState || steamworks.multiplayerLog(`Server game state: ${saveManager.getGameStateAsJson()}`)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.String)], n.prototype, "logs", void 0),
    __decorate([a.OptionalNetworkProperty(a.NetworkPropertyType.Bool)], n.prototype, "containsServerGameState", void 0),
    __decorate([Override], n.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/client/SynchronizeGameStatePacket", ["require", "exports", "multiplayer/IMultiplayer", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket", "multiplayer/packets/server/LogsPacket", "utilities/Async"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class s extends i.default {
        isSyncCheckEnabled() {
            return !1
        }
        process() {
            const e = saveManager.getGameStateAsJson();
            if (this.serverGameState === e)
                steamworks.multiplayerLog("SynchronizeGameStatePacket - Completed sync");
            else {
                steamworks.multiplayerLogError("SynchronizeGameStatePacket - Game state is different"),
                steamworks.multiplayerLogError(`Server game state: ${this.serverGameState}`),
                steamworks.multiplayerLogError(`Client game state: ${e}`);
                const t = new o.default;
                t.logs = steamworks.getMultiplayerLogs(),
                t.containsServerGameState = !0,
                t.send(),
                r.sleep(5e3).then(()=>{
                    multiplayer.disconnectAndResetGameState(a.DisconnectReason.Desync)
                }
                )
            }
        }
        getInitialBufferSize() {
            return 512e3
        }
    }
    __decorate([n.NetworkProperty(n.NetworkPropertyType.String)], s.prototype, "serverGameState", void 0),
    __decorate([Override], s.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], s.prototype, "process", null),
    __decorate([Override], s.prototype, "getInitialBufferSize", null),
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/client/TickPacket", ["require", "exports", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        getDebugInfo() {
            return "Tick"
        }
        process() {
            for (let e = 0; e < this.isMoving.length; e++) {
                const t = players[e];
                t.isMoving = this.isMoving[e],
                t.noInputReceived = this.noInputReceived[e],
                t.movementComplete = this.movementComplete[e]
            }
            game.tickRealtime()
        }
        getInitialBufferSize() {
            return 16384
        }
    }
    __decorate([i.NetworkProperty(i.NetworkPropertyType.Generic)], n.prototype, "isMoving", void 0),
    __decorate([i.NetworkProperty(i.NetworkPropertyType.Generic)], n.prototype, "noInputReceived", void 0),
    __decorate([i.NetworkProperty(i.NetworkPropertyType.Generic)], n.prototype, "movementComplete", void 0),
    __decorate([Override], n.prototype, "getDebugInfo", null),
    __decorate([Override], n.prototype, "process", null),
    __decorate([Override], n.prototype, "getInitialBufferSize", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/client/WorldPacket", ["require", "exports", "Enums", "multiplayer/packets/ClientPacket", "multiplayer/packets/IPacket", "save/ISaveManager"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends i.default {
        getAllowedStates() {
            return a.ConnectionState.Connected
        }
        async process() {
            steamworks.multiplayerLog("WorldPacket", this.data.multiplayerOptions),
            multiplayer.setOptions(this.data.multiplayerOptions);
            const e = await saveManager.importSave(o.SLOT_MULTIPLAYER,this.data.saveObject);
            e ? game.play({
                slot: o.SLOT_MULTIPLAYER,
                multiplayerWorld: this.data,
                difficulty: this.data.difficulty,
                difficultyOptions: this.data.difficultyOptions
            }) : steamworks.multiplayerLogError("Failed to import multiplayer save")
        }
        getInitialBufferSize() {
            return 524288
        }
    }
    __decorate([n.NetworkProperty(n.NetworkPropertyType.Generic)], r.prototype, "data", void 0),
    __decorate([Override], r.prototype, "getAllowedStates", null),
    __decorate([Override], r.prototype, "process", null),
    __decorate([Override], r.prototype, "getInitialBufferSize", null),
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/server/AddMessageHistoryPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedServerPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            this.player.messages.addToHistory(this.messageHistoryItem)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Generic)], n.prototype, "messageHistoryItem", void 0),
    __decorate([Override], n.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/server/ConnectedPacket", ["require", "exports", "Enums", "multiplayer/packets/client/CaughtUpPacket", "multiplayer/packets/ServerPacket"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o extends n.default {
        getAllowedStates() {
            return a.ConnectionState.QueuingPackets
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            steamworks.multiplayerLog("ConnectedPacket", this.connection.playerIdentifier),
            this.connection.setState(a.ConnectionState.CatchingUp);
            const e = new i.default;
            e.sendTo(this.connection)
        }
    }
    __decorate([Override], o.prototype, "getAllowedStates", null),
    __decorate([Override], o.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], o.prototype, "process", null),
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("tile/Terrains", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.terrainDescriptions = {},
    t.default = t.terrainDescriptions,
    t.terrainDescriptions[a.TerrainType.DeepSeawater] = {
        particles: {
            r: 26,
            g: 157,
            b: 216
        },
        deepWater: !0,
        water: !0,
        terrainType: a.TerrainType.DeepSeawater,
        noResting: !0,
        tileOnConsume: a.TerrainType.BeachSand
    },
    t.terrainDescriptions[a.TerrainType.Seawater] = {
        particles: {
            r: 36,
            g: 170,
            b: 231
        },
        water: !0,
        terrainType: a.TerrainType.Seawater,
        noResting: !0,
        tileOnConsume: a.TerrainType.BeachSand
    },
    t.terrainDescriptions[a.TerrainType.ShallowSeawater] = {
        shallowWater: !0,
        passable: !0,
        particles: {
            r: 55,
            g: 192,
            b: 255
        },
        terrainType: a.TerrainType.ShallowSeawater,
        reduceRest: !0,
        tileOnConsume: a.TerrainType.BeachSand
    },
    t.terrainDescriptions[a.TerrainType.Ash] = {
        passable: !0,
        particles: {
            r: 105,
            g: 105,
            b: 105
        },
        terrainType: a.TerrainType.Ash,
        regathered: !0
    },
    t.terrainDescriptions[a.TerrainType.CobblestoneFlooring] = {
        passable: !0,
        particles: {
            r: 174,
            g: 178,
            b: 176
        },
        durability: 15,
        terrainType: a.TerrainType.CobblestoneFlooring
    },
    t.terrainDescriptions[a.TerrainType.Dirt] = {
        passable: !0,
        particles: {
            r: 111,
            g: 76,
            b: 31
        },
        regathered: !0,
        terrainType: a.TerrainType.Dirt,
        tillable: !0,
        hasMound: !0,
        wet: !0
    },
    t.terrainDescriptions[a.TerrainType.CaveEntrance] = {
        passable: !0,
        particles: {
            r: 111,
            g: 76,
            b: 31
        },
        terrainType: a.TerrainType.Dirt,
        doodad: a.DoodadType.CaveEntrance,
        noResting: !0
    },
    t.terrainDescriptions[a.TerrainType.Grass] = {
        passable: !0,
        particles: {
            r: 85,
            g: 143,
            b: 44
        },
        flammable: !0,
        regathered: !0,
        terrainType: a.TerrainType.Grass
    },
    t.terrainDescriptions[a.TerrainType.Gravel] = {
        passable: !0,
        particles: {
            r: 154,
            g: 117,
            b: 57
        },
        regathered: !0,
        terrainType: a.TerrainType.Gravel,
        tillable: !0,
        hasMound: !0
    },
    t.terrainDescriptions[a.TerrainType.Rocks] = {
        particles: {
            r: 105,
            g: 103,
            b: 103
        },
        gatherSkillUse: a.SkillType.Mining,
        gather: !0,
        noLos: !0,
        sound: a.SfxType.RockHit,
        leftOver: a.TerrainType.Dirt,
        noGfxSwitch: !0,
        terrainType: a.TerrainType.Rocks,
        isMountain: !0
    },
    t.terrainDescriptions[a.TerrainType.BeachSand] = {
        passable: !0,
        particles: {
            r: 225,
            g: 219,
            b: 150
        },
        regathered: !0,
        terrainType: a.TerrainType.BeachSand,
        tillable: !0,
        hasMound: !0
    },
    t.terrainDescriptions[a.TerrainType.Sandstone] = {
        particles: {
            r: 173,
            g: 122,
            b: 78
        },
        gatherSkillUse: a.SkillType.Mining,
        gather: !0,
        noLos: !0,
        sound: a.SfxType.SandstoneHit,
        leftOver: a.TerrainType.Gravel,
        noGfxSwitch: !0,
        terrainType: a.TerrainType.Sandstone,
        isMountain: !0
    },
    t.terrainDescriptions[a.TerrainType.Snow] = {
        passable: !0,
        particles: {
            r: 201,
            g: 224,
            b: 228
        },
        terrainType: a.TerrainType.Snow,
        reduceRest: !0
    },
    t.terrainDescriptions[a.TerrainType.Swamp] = {
        passable: !0,
        particles: {
            r: 3,
            g: 67,
            b: 3
        },
        terrainType: a.TerrainType.Swamp,
        tillable: !0,
        hasMound: !0,
        reduceRest: !0,
        wet: !0
    },
    t.terrainDescriptions[a.TerrainType.Clay] = {
        passable: !0,
        particles: {
            r: 135,
            g: 142,
            b: 147
        },
        terrainType: a.TerrainType.Clay,
        wet: !0
    },
    t.terrainDescriptions[a.TerrainType.SandstoneFlooring] = {
        passable: !0,
        particles: {
            r: 173,
            g: 122,
            b: 78
        },
        durability: 15,
        terrainType: a.TerrainType.SandstoneFlooring
    },
    t.terrainDescriptions[a.TerrainType.WoodenFlooring] = {
        passable: !0,
        particles: {
            r: 108,
            g: 71,
            b: 25
        },
        flammable: !0,
        durability: 15,
        terrainType: a.TerrainType.WoodenFlooring
    },
    t.terrainDescriptions[a.TerrainType.DeepFreshWater] = {
        particles: {
            r: 27,
            g: 138,
            b: 169
        },
        deepWater: !0,
        water: !0,
        freshWater: !0,
        terrainType: a.TerrainType.DeepFreshWater,
        noResting: !0,
        tileOnConsume: a.TerrainType.Dirt
    },
    t.terrainDescriptions[a.TerrainType.ShallowFreshWater] = {
        passable: !0,
        shallowWater: !0,
        particles: {
            r: 50,
            g: 169,
            b: 201
        },
        freshWater: !0,
        terrainType: a.TerrainType.ShallowFreshWater,
        reduceRest: !0,
        tileOnConsume: a.TerrainType.Dirt
    },
    t.terrainDescriptions[a.TerrainType.FreshWater] = {
        particles: {
            r: 35,
            g: 150,
            b: 181
        },
        water: !0,
        freshWater: !0,
        terrainType: a.TerrainType.FreshWater,
        noResting: !0,
        tileOnConsume: a.TerrainType.Dirt
    },
    t.terrainDescriptions[a.TerrainType.RocksWithIron] = {
        particles: {
            r: 62,
            g: 67,
            b: 84
        },
        gatherSkillUse: a.SkillType.Mining,
        gather: !0,
        noLos: !0,
        sound: a.SfxType.RockHit,
        baseTerrain: a.TerrainType.Rocks,
        leftOver: a.TerrainType.Dirt,
        noGfxSwitch: !0,
        terrainType: a.TerrainType.RocksWithIron,
        isMountain: !0,
        isOre: !0
    },
    t.terrainDescriptions[a.TerrainType.SandstoneWithIron] = {
        particles: {
            r: 62,
            g: 67,
            b: 84
        },
        gatherSkillUse: a.SkillType.Mining,
        gather: !0,
        noLos: !0,
        sound: a.SfxType.SandstoneHit,
        baseTerrain: a.TerrainType.Sandstone,
        leftOver: a.TerrainType.Gravel,
        noGfxSwitch: !0,
        terrainType: a.TerrainType.SandstoneWithIron,
        isMountain: !0,
        isOre: !0
    },
    t.terrainDescriptions[a.TerrainType.RocksWithTalc] = {
        particles: {
            r: 157,
            g: 170,
            b: 170
        },
        gatherSkillUse: a.SkillType.Mining,
        gather: !0,
        noLos: !0,
        sound: a.SfxType.RockHit,
        baseTerrain: a.TerrainType.Rocks,
        leftOver: a.TerrainType.Dirt,
        noGfxSwitch: !0,
        terrainType: a.TerrainType.RocksWithTalc,
        isMountain: !0,
        isOre: !0
    },
    t.terrainDescriptions[a.TerrainType.RocksWithLimestone] = {
        particles: {
            r: 183,
            g: 177,
            b: 167
        },
        gatherSkillUse: a.SkillType.Mining,
        gather: !0,
        noLos: !0,
        sound: a.SfxType.RockHit,
        baseTerrain: a.TerrainType.Rocks,
        leftOver: a.TerrainType.Dirt,
        noGfxSwitch: !0,
        terrainType: a.TerrainType.RocksWithLimestone,
        isMountain: !0,
        isOre: !0
    },
    t.terrainDescriptions[a.TerrainType.RocksWithCoal] = {
        particles: {
            r: 43,
            g: 43,
            b: 43
        },
        gatherSkillUse: a.SkillType.Mining,
        gather: !0,
        noLos: !0,
        sound: a.SfxType.RockHit,
        baseTerrain: a.TerrainType.Rocks,
        leftOver: a.TerrainType.Dirt,
        noGfxSwitch: !0,
        terrainType: a.TerrainType.RocksWithCoal,
        isMountain: !0,
        isOre: !0
    },
    t.terrainDescriptions[a.TerrainType.SandstoneWithNiter] = {
        particles: {
            r: 145,
            g: 150,
            b: 149
        },
        gatherSkillUse: a.SkillType.Mining,
        gather: !0,
        noLos: !0,
        sound: a.SfxType.SandstoneHit,
        baseTerrain: a.TerrainType.Sandstone,
        leftOver: a.TerrainType.Gravel,
        noGfxSwitch: !0,
        terrainType: a.TerrainType.SandstoneWithNiter,
        isMountain: !0,
        isOre: !0
    },
    t.terrainDescriptions[a.TerrainType.ClayBrickFlooring] = {
        passable: !0,
        particles: {
            r: 171,
            g: 176,
            b: 179
        },
        durability: 15,
        terrainType: a.TerrainType.ClayBrickFlooring
    },
    t.terrainDescriptions[a.TerrainType.RedCarpet] = {
        passable: !0,
        particles: {
            r: 115,
            g: 36,
            b: 27
        },
        durability: 15,
        terrainType: a.TerrainType.RedCarpet
    },
    t.terrainDescriptions[a.TerrainType.Lava] = {
        passable: !0,
        particles: {
            r: 255,
            g: 137,
            b: 0
        },
        terrainType: a.TerrainType.Lava,
        animated: !0,
        flammable: !0,
        noResting: !0
    },
    t.terrainDescriptions[a.TerrainType.FertileSoil] = {
        passable: !0,
        particles: {
            r: 80,
            g: 48,
            b: 16
        },
        regathered: !0,
        terrainType: a.TerrainType.FertileSoil,
        tillable: !0,
        hasMound: !0,
        wet: !0
    },
    t.terrainDescriptions[a.TerrainType.RocksWithCopper] = {
        particles: {
            r: 170,
            g: 69,
            b: 9
        },
        gatherSkillUse: a.SkillType.Mining,
        gather: !0,
        noLos: !0,
        sound: a.SfxType.RockHit,
        baseTerrain: a.TerrainType.Rocks,
        leftOver: a.TerrainType.Dirt,
        noGfxSwitch: !0,
        terrainType: a.TerrainType.RocksWithCopper,
        isMountain: !0,
        isOre: !0
    },
    t.terrainDescriptions[a.TerrainType.SandstoneWithCopper] = {
        particles: {
            r: 170,
            g: 69,
            b: 9
        },
        gatherSkillUse: a.SkillType.Mining,
        gather: !0,
        noLos: !0,
        sound: a.SfxType.RockHit,
        baseTerrain: a.TerrainType.Sandstone,
        leftOver: a.TerrainType.Gravel,
        noGfxSwitch: !0,
        terrainType: a.TerrainType.SandstoneWithCopper,
        isMountain: !0,
        isOre: !0
    },
    t.terrainDescriptions[a.TerrainType.CoolingLava] = {
        passable: !0,
        particles: {
            r: 188,
            g: 21,
            b: 21
        },
        terrainType: a.TerrainType.CoolingLava,
        animated: !0,
        flammable: !0,
        reduceRest: !0
    },
    t.terrainDescriptions[a.TerrainType.Obsidian] = {
        passable: !0,
        particles: {
            r: 59,
            g: 48,
            b: 82
        },
        terrainType: a.TerrainType.Obsidian
    },
    t.terrainDescriptions[a.TerrainType.DesertSand] = {
        passable: !0,
        particles: {
            r: 213,
            g: 186,
            b: 136
        },
        regathered: !0,
        terrainType: a.TerrainType.DesertSand,
        tillable: !0,
        hasMound: !0
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Queue", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor(e) {
            if (this.queue = new Array,
            this.offset = 0,
            e)
                for (const t of e)
                    this.enqueue(t)
        }
        getLength() {
            return this.queue.length - this.offset
        }
        isEmpty() {
            return 0 === this.queue.length
        }
        enqueue(e) {
            this.queue.push(e)
        }
        dequeue() {
            if (0 === this.queue.length)
                return;
            const e = this.queue[this.offset];
            return this.offset++,
            2 * this.offset >= this.queue.length && (this.queue = this.queue.slice(this.offset),
            this.offset = 0),
            e
        }
        isInQueue(e, t) {
            for (let a = this.offset; a < this.queue.length; a++)
                if (t) {
                    if (t(this.queue[a], e))
                        return !0
                } else if (this.queue[a] === e)
                    return !0;
            return !1
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/TileHelpers", ["require", "exports", "Enums", "tile/Terrains", "utilities/Queue", "utilities/Random"], function(require, exports, Enums_12, Terrains_1, Queue_1, Random_1) {
    var TileHelpers;
    Object.defineProperty(exports, "__esModule", {
        value: !0
    }),
    function(TileHelpers) {
        function getGfx(e) {
            return getGfxRaw(e.data)
        }
        function getGfxRaw(e) {
            return e & TileHelpers.maskGfx
        }
        function setGfx(e, t) {
            e.data = setGfxRaw(e.data, t)
        }
        function setGfxRaw(e, t) {
            return e & ~TileHelpers.maskGfx | t & TileHelpers.maskGfx
        }
        function getType(e) {
            return getTypeRaw(e.data)
        }
        function getTypeRaw(e) {
            return (e & TileHelpers.maskType) >> 5
        }
        function setType(e, t) {
            e.data = setTypeRaw(e.data, t)
        }
        function setTypeRaw(e, t) {
            return e & ~TileHelpers.maskType | (t & TileHelpers.maskType >> 5) << 5
        }
        function isTilled(e) {
            return isTilledRaw(e.data)
        }
        function isTilledRaw(e) {
            return (e & TileHelpers.maskTilled) >> 12 == 1
        }
        function setTilled(e, t) {
            e.data = setTilledRaw(e.data, t ? 1 : 0)
        }
        function setTilledRaw(e, t) {
            return e & ~TileHelpers.maskTilled | (t & TileHelpers.maskTilled >> 12) << 12
        }
        function getTileVariation(e, t) {
            const a = 43758.5453 * Math.sin(12.9898 * e + 78.233 * t);
            return a - Math.floor(a)
        }
        let Overlay;
        function findMatchingTile(e, t, a, i) {
            const n = new Queue_1.default([{
                x: e.x,
                y: e.y,
                z: e.z
            }])
              , o = [];
            let r = 0;
            const s = e=>`${e.x},${e.y}`;
            for (; !n.isEmpty(); ) {
                const e = n.dequeue()
                  , l = game.getTileFromPoint(e);
                if (l) {
                    if (!t || t(e, l))
                        return e;
                    for (let t = 0; t < 4; t++) {
                        const a = {
                            x: e.x,
                            y: e.y,
                            z: e.z
                        };
                        switch (t) {
                        case 0:
                            a.x++;
                            break;
                        case 1:
                            a.x--;
                            break;
                        case 2:
                            a.y++;
                            break;
                        case 3:
                            a.y--
                        }
                        const r = s(a);
                        o.indexOf(r) > -1 || (o.push(r),
                        (void 0 === i || i(a, game.getTileFromPoint(a))) && n.enqueue(a))
                    }
                    if (void 0 !== a && a < ++r)
                        break
                }
            }
        }
        function isOpenTile(e, t) {
            if (void 0 !== t.creature || void 0 !== t.npc || void 0 !== t.doodad)
                return !1;
            const a = getType(t)
              , i = Terrains_1.default[a];
            return !(i && !i.passable && !i.water) && !game.isPlayerAtPosition(e.x, e.y, e.z, !1, !0)
        }
        function isSuitableSpawnPointTile(e, t) {
            if (void 0 !== t.creature || void 0 !== t.npc || void 0 !== t.doodad || void 0 !== t.events)
                return !1;
            const a = getType(t);
            if (a === Enums_12.TerrainType.ShallowSeawater || a === Enums_12.TerrainType.BeachSand)
                return !1;
            const i = Terrains_1.default[a];
            return !(!i || !i.passable || i.water) && !game.isPlayerAtPosition(e.x, e.y, e.z, !1, !0)
        }
        function getSuitableSpawnPoint() {
            for (; ; ) {
                const e = Math.floor(400 * Random_1.default.float() + 50)
                  , t = Math.floor(400 * Random_1.default.float() + 50);
                if (isSuitableSpawnPointTile({
                    x: e,
                    y: t,
                    z: Enums_12.WorldZ.Overworld
                }, game.getTile(e, t, Enums_12.WorldZ.Overworld)) && (!game.playing || fieldOfView.disabled || game.getPlayersThatSeePosition(e, t, Enums_12.WorldZ.Overworld).length <= 0))
                    return {
                        x: e,
                        y: t,
                        z: Enums_12.WorldZ.Overworld
                    }
            }
        }
        function getTilesAround(e, t=!1) {
            const a = [game.getTile(e.x + 1, e.y, e.z), game.getTile(e.x - 1, e.y, e.z), game.getTile(e.x, e.y + 1, e.z), game.getTile(e.x, e.y - 1, e.z)];
            return t && a.push(game.getTileFromPoint(e)),
            a
        }
        function *tilesAround(e, t=!1) {
            yield game.getTile(e.x + 1, e.y, e.z),
            yield game.getTile(e.x - 1, e.y, e.z),
            yield game.getTile(e.x, e.y + 1, e.z),
            yield game.getTile(e.x, e.y - 1, e.z),
            t && (yield game.getTileFromPoint(e))
        }
        eval(""),
        TileHelpers.maskGfx = 31,
        TileHelpers.maskType = 4064,
        TileHelpers.maskTilled = 4096,
        TileHelpers.getGfx = getGfx,
        TileHelpers.getGfxRaw = getGfxRaw,
        TileHelpers.setGfx = setGfx,
        TileHelpers.setGfxRaw = setGfxRaw,
        TileHelpers.getType = getType,
        TileHelpers.getTypeRaw = getTypeRaw,
        TileHelpers.setType = setType,
        TileHelpers.setTypeRaw = setTypeRaw,
        TileHelpers.isTilled = isTilled,
        TileHelpers.isTilledRaw = isTilledRaw,
        TileHelpers.setTilled = setTilled,
        TileHelpers.setTilledRaw = setTilledRaw,
        TileHelpers.getTileVariation = getTileVariation,
        function(e) {
            function t(e, t, i) {
                if (e.overlays) {
                    if (i && a(e, i))
                        return !1;
                    e.overlays.push(t)
                } else
                    e.overlays = [t];
                return !0
            }
            function a(e, t) {
                return void 0 !== e.overlays && e.overlays.some(t)
            }
            function i(e, t) {
                if (void 0 !== e.overlays) {
                    if ("function" == typeof t) {
                        let a = !1;
                        for (const n of e.overlays.filter(t))
                            a = i(e, n) || a;
                        return a
                    }
                    const a = e.overlays.indexOf(t);
                    if (-1 !== a)
                        return e.overlays.splice(a, 1),
                        0 === e.overlays.length && delete e.overlays,
                        !0
                }
                return !1
            }
            e.add = t,
            e.has = a,
            e.remove = i
        }(Overlay = TileHelpers.Overlay || (TileHelpers.Overlay = {})),
        TileHelpers.findMatchingTile = findMatchingTile,
        TileHelpers.isOpenTile = isOpenTile,
        TileHelpers.isSuitableSpawnPointTile = isSuitableSpawnPointTile,
        TileHelpers.getSuitableSpawnPoint = getSuitableSpawnPoint,
        TileHelpers.getTilesAround = getTilesAround,
        TileHelpers.tilesAround = tilesAround
    }(TileHelpers || (TileHelpers = {})),
    exports.default = TileHelpers
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/server/ConnectPacket", ["require", "exports", "Enums", "language/dictionary/UiTranslation", "multiplayer/packets/client/AddPlayerPacket", "multiplayer/packets/client/HideLoadingScreenPacket", "multiplayer/packets/client/ShowLoadingScreenPacket", "multiplayer/packets/client/SynchronizeFlowFieldsPacket", "multiplayer/packets/client/WorldPacket", "multiplayer/packets/IPacket", "multiplayer/packets/ServerPacket", "player/MessageManager", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class h extends d.default {
        getAllowedStates() {
            return a.ConnectionState.Connected
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            this.playerOptions.character.name = game.getValidPlayerName(this.playerOptions.character.name);
            const e = !game.paused;
            e && game.setPaused(!0),
            multiplayer.pausePacketProcessing(!0);
            const t = new r.default;
            t.title = i.default.GameInterruptLoadingMultiplayerPlayerConnecting,
            t.processAndSend(this.connection),
            setTimeout(async()=>{
                const t = multiplayer.getOptions();
                let i;
                c.default.generator.pushSeed(),
                t.pvp ? i = m.default.getSuitableSpawnPoint() : void 0 === (i = m.default.findMatchingTile(localPlayer, m.default.isSuitableSpawnPointTile)) && (i = {
                    x: localPlayer.x,
                    y: localPlayer.y,
                    z: localPlayer.z
                }),
                c.default.generator.popSeed();
                const r = new n.default;
                r.playerOptions = {
                    identifier: this.connection.playerIdentifier,
                    position: i,
                    options: this.playerOptions.options,
                    character: this.playerOptions.character,
                    completedMilestones: this.playerOptions.completedMilestones
                };
                const u = r.processAndSend(this.connection);
                this.connection.pid = u;
                const d = multiplayer.getClients().filter(e=>e.getState() === a.ConnectionState.Ready).map(e=>players[e.pid]).concat(localPlayer).map(e=>e.id)
                  , h = new s.default;
                h.pids = d,
                h.processAndSend(this.connection),
                steamworks.multiplayerLog(`Saving game in multiplayer slot with pid ${u}. seed - ${c.default.generator.getSeed()} - ${this.connection.pid} - ${this.connection.playerIdentifier}`),
                this.connection.setState(a.ConnectionState.QueuingPackets);
                const y = []
                  , g = [...players, ...absentPlayers];
                for (let e = 0; e < g.length; e++) {
                    const t = g[e];
                    t.id !== u && (y[e] = {
                        messages: t.messages
                    },
                    t.messages = p.default.get(void 0))
                }
                const f = saveData.clientStore
                  , T = saveManager.getClientStore(players[u]);
                saveData.clientStore = new Map,
                saveData.clientStore.set(players[u].identifier, T);
                const S = await game.saveGame(a.SaveType.Multiplayer);
                saveData.clientStore = f;
                for (let e = 0; e < g.length; e++) {
                    const t = g[e]
                      , a = y[e];
                    a && (t.messages = a.messages)
                }
                if (void 0 === S || void 0 === S.saveObject)
                    steamworks.multiplayerLogError("Failed to save game");
                else {
                    steamworks.multiplayerLog(`Saved game in multiplayer slot - player count ${players.length}. seed - ${game.seeds.saved} - ${this.connection.pid} - ${this.connection.playerIdentifier}`);
                    const e = modManager.getLoadedMods()
                      , a = new l.default;
                    a.data = {
                        pid: u,
                        playerCount: players.length,
                        mods: e.filter(e=>!modManager.isMultiplayerClientSide(e.index)).map(e=>({
                            name: e.config.name,
                            version: e.config.version,
                            publishedFileId: e.config.publishedFileId
                        })),
                        multiplayerOptions: t,
                        difficulty: game.getDifficulty(),
                        difficultyOptions: game.getDifficultyOptions(),
                        saveObject: S.saveObject,
                        initialFlowFieldPids: d,
                        crafted: game.crafted
                    },
                    a.sendTo(this.connection, !0),
                    this.connection.addConnectionTimeout()
                }
                const I = new o.default;
                I.processAndSend(this.connection),
                e && game.setPaused(!1),
                multiplayer.pausePacketProcessing(!1)
            }
            , 50)
        }
    }
    __decorate([u.NetworkProperty(u.NetworkPropertyType.Generic)], h.prototype, "playerOptions", void 0),
    __decorate([Override], h.prototype, "getAllowedStates", null),
    __decorate([Override], h.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], h.prototype, "process", null),
    t.default = h
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/server/DesyncPacket", ["require", "exports", "multiplayer/IMultiplayer", "multiplayer/packets/client/DisconnectPacket", "multiplayer/packets/IPacket", "multiplayer/packets/ServerPacket"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends o.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            steamworks.multiplayerLog("DesyncPacket", this.connection.pid, this.logs);
            const e = new i.default;
            e.reason = a.DisconnectReason.Desync,
            e.sendTo(this.connection)
        }
    }
    __decorate([n.NetworkProperty(n.NetworkPropertyType.String)], r.prototype, "logs", void 0),
    __decorate([Override], r.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], r.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], r.prototype, "process", null),
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/server/KeepAlivePacket", ["require", "exports", "multiplayer/packets/ServerPacket"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            this.connection.addKeepAliveTimeout()
        }
    }
    __decorate([Override], i.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], i.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], i.prototype, "process", null),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/server/PingPacket", ["require", "exports", "multiplayer/packets/client/PongPacket", "multiplayer/packets/IPacket", "multiplayer/packets/ServerPacket"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o extends n.default {
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            const e = new a.default;
            e.sendTime = this.sendTime,
            e.sendTo(this.connection)
        }
    }
    __decorate([i.NetworkProperty(i.NetworkPropertyType.Float64)], o.prototype, "sendTime", void 0),
    __decorate([Override], o.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], o.prototype, "process", null),
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/IScreen", ["require", "exports"], function(e, t) {
    var a, i, n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Game = 1] = "Game",
        e[e.Interrupt = 2] = "Interrupt",
        e[e.MainMenu = 3] = "MainMenu",
        e[e.Splash = 4] = "Splash"
    }(a = t.ScreenId || (t.ScreenId = {})),
    function(e) {
        e.ShowMenu = "ShowMenu",
        e.HideMenu = "HideMenu",
        e.GoBackMenu = "GoBackMenu",
        e.CanShowTooltip = "AttemptShowTooltip"
    }(i = t.ScreenEvent || (t.ScreenEvent = {})),
    function(e) {
        e[e.Default = 0] = "Default",
        e[e.Win = 1] = "Win",
        e[e.Death = 2] = "Death"
    }(n = t.Background || (t.Background = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/component/IMenu", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.BACK = -1] = "BACK",
        e[e.NONE = 0] = "NONE",
        e[e.CharacterSelection = 1] = "CharacterSelection",
        e[e.GameEnd = 2] = "GameEnd",
        e[e.Help = 3] = "Help",
        e[e.Highscores = 4] = "Highscores",
        e[e.Interrupt = 5] = "Interrupt",
        e[e.JoinServer = 6] = "JoinServer",
        e[e.LoadGame = 7] = "LoadGame",
        e[e.Main = 8] = "Main",
        e[e.Mods = 9] = "Mods",
        e[e.Multiplayer = 10] = "Multiplayer",
        e[e.NewGame = 11] = "NewGame",
        e[e.Options = 12] = "Options",
        e[e.Pause = 13] = "Pause"
    }(a = t.MenuId || (t.MenuId = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("creature/Creatures", ["require", "exports", "creature/ICreature", "entity/IEntity", "Enums"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.spawnableTiles = Array(),
    t.creatureDescriptions = {},
    t.default = t.creatureDescriptions,
    t.spawnableTiles[a.SpawnableTiles.None] = [],
    t.spawnableTiles[a.SpawnableTiles.Default] = [n.TerrainType.Ash, n.TerrainType.Dirt, n.TerrainType.Grass, n.TerrainType.Gravel, n.TerrainType.BeachSand, n.TerrainType.DesertSand, n.TerrainType.Snow, n.TerrainType.Swamp, n.TerrainType.Clay],
    t.spawnableTiles[a.SpawnableTiles.DefaultWithLava] = [n.TerrainType.Ash, n.TerrainType.Dirt, n.TerrainType.Grass, n.TerrainType.Gravel, n.TerrainType.BeachSand, n.TerrainType.DesertSand, n.TerrainType.Snow, n.TerrainType.Swamp, n.TerrainType.Clay, n.TerrainType.Lava, n.TerrainType.CoolingLava, n.TerrainType.Obsidian],
    t.spawnableTiles[a.SpawnableTiles.DefaultWithWater] = [n.TerrainType.Ash, n.TerrainType.Dirt, n.TerrainType.Grass, n.TerrainType.Gravel, n.TerrainType.BeachSand, n.TerrainType.DesertSand, n.TerrainType.Snow, n.TerrainType.Swamp, n.TerrainType.Clay, n.TerrainType.ShallowSeawater, n.TerrainType.ShallowFreshWater],
    t.spawnableTiles[a.SpawnableTiles.DeepSeawater] = [n.TerrainType.Seawater, n.TerrainType.DeepSeawater],
    t.spawnableTiles[a.SpawnableTiles.Water] = [n.TerrainType.Seawater, n.TerrainType.FreshWater, n.TerrainType.DeepSeawater, n.TerrainType.DeepFreshWater, n.TerrainType.ShallowSeawater, n.TerrainType.ShallowFreshWater],
    t.spawnableTiles[a.SpawnableTiles.Flying] = [n.TerrainType.Ash, n.TerrainType.Dirt, n.TerrainType.Grass, n.TerrainType.Gravel, n.TerrainType.BeachSand, n.TerrainType.DesertSand, n.TerrainType.ShallowSeawater, n.TerrainType.Snow, n.TerrainType.Swamp, n.TerrainType.Clay, n.TerrainType.ShallowFreshWater, n.TerrainType.Lava],
    t.spawnableTiles[a.SpawnableTiles.Ghost] = [n.TerrainType.Ash, n.TerrainType.Dirt, n.TerrainType.Grass, n.TerrainType.Gravel, n.TerrainType.BeachSand, n.TerrainType.DesertSand, n.TerrainType.ShallowSeawater, n.TerrainType.Snow, n.TerrainType.Swamp, n.TerrainType.Clay, n.TerrainType.ShallowFreshWater, n.TerrainType.Rocks, n.TerrainType.Sandstone, n.TerrainType.Lava],
    t.spawnableTiles[a.SpawnableTiles.Desert] = [n.TerrainType.DesertSand],
    t.spawnableTiles[a.SpawnableTiles.Lava] = [n.TerrainType.Lava, n.TerrainType.CoolingLava, n.TerrainType.Obsidian],
    t.spawnableTiles[a.SpawnableTiles.Wet] = [n.TerrainType.ShallowFreshWater, n.TerrainType.FreshWater, n.TerrainType.DeepFreshWater, n.TerrainType.Dirt, n.TerrainType.FertileSoil, n.TerrainType.Clay],
    t.spawnableTiles[a.SpawnableTiles.Ground] = [n.TerrainType.Grass, n.TerrainType.Gravel, n.TerrainType.Dirt, n.TerrainType.BeachSand, n.TerrainType.DesertSand, n.TerrainType.Snow, n.TerrainType.Swamp, n.TerrainType.Clay, n.TerrainType.Ash, n.TerrainType.CobblestoneFlooring, n.TerrainType.WoodenFlooring, n.TerrainType.ClayBrickFlooring, n.TerrainType.CaveEntrance, n.TerrainType.RedCarpet, n.TerrainType.FertileSoil, n.TerrainType.CoolingLava, n.TerrainType.Obsidian, n.TerrainType.ShallowSeawater, n.TerrainType.ShallowFreshWater],
    t.spawnableTiles[a.SpawnableTiles.All] = [n.TerrainType.DeepSeawater, n.TerrainType.Seawater, n.TerrainType.ShallowSeawater, n.TerrainType.DeepFreshWater, n.TerrainType.FreshWater, n.TerrainType.ShallowFreshWater, n.TerrainType.Grass, n.TerrainType.Gravel, n.TerrainType.Dirt, n.TerrainType.BeachSand, n.TerrainType.Snow, n.TerrainType.Swamp, n.TerrainType.Clay, n.TerrainType.Ash, n.TerrainType.Rocks, n.TerrainType.RocksWithIron, n.TerrainType.RocksWithTalc, n.TerrainType.RocksWithCoal, n.TerrainType.RocksWithLimestone, n.TerrainType.CobblestoneFlooring, n.TerrainType.Sandstone, n.TerrainType.SandstoneFlooring, n.TerrainType.SandstoneWithIron, n.TerrainType.SandstoneWithNiter, n.TerrainType.WoodenFlooring, n.TerrainType.ClayBrickFlooring, n.TerrainType.CaveEntrance, n.TerrainType.RedCarpet, n.TerrainType.Lava, n.TerrainType.FertileSoil, n.TerrainType.RocksWithCopper, n.TerrainType.SandstoneWithCopper, n.TerrainType.CoolingLava, n.TerrainType.Obsidian, n.TerrainType.DesertSand],
    t.spawnableTiles[a.SpawnableTiles.Seawater] = [n.TerrainType.ShallowSeawater, n.TerrainType.Seawater, n.TerrainType.DeepSeawater],
    t.spawnableTiles[a.SpawnableTiles.FreshWater] = [n.TerrainType.ShallowFreshWater, n.TerrainType.FreshWater, n.TerrainType.DeepFreshWater],
    t.creatureDescriptions[n.CreatureType.Slime] = {
        minhp: 4,
        maxhp: 8,
        minatk: 1,
        maxatk: 4,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Blunt,3),new n.Vulnerabilities),
        damageType: n.DamageType.Blunt,
        ai: i.AiType.Neutral,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        blood: {
            r: 150,
            g: 255,
            b: 70
        },
        aberrantBlood: {
            r: 220,
            g: 0,
            b: 15
        },
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -1e3,
        makeNoise: !0,
        jumpOver: !0,
        reputation: -200,
        tamingDifficulty: 50,
        spawnGroup: [a.SpawnGroup.Guardians],
        acceptedItems: [n.ItemType.SlimeGelatin],
        spawnOnBenignity: !0,
        canTrample: !0,
        skipMovementChance: 5
    },
    t.creatureDescriptions[n.CreatureType.JellyCube] = {
        minhp: 12,
        maxhp: 13,
        minatk: 3,
        maxatk: 7,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Blunt,8),new n.Vulnerabilities),
        damageType: n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        blood: {
            r: 150,
            g: 255,
            b: 70
        },
        aberrantBlood: {
            r: 220,
            g: 0,
            b: 15
        },
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -8e3,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 150,
        tamingDifficulty: 100,
        spawnGroup: [a.SpawnGroup.Guardians],
        acceptedItems: [n.ItemType.SlimeGelatin],
        canTrample: !0
    },
    t.creatureDescriptions[n.CreatureType.GiantSpider] = {
        minhp: 4,
        maxhp: 8,
        minatk: 1,
        maxatk: 4,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Slashing,1),new n.Vulnerabilities(n.DamageType.Blunt,1)),
        damageType: n.DamageType.Piercing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        canCauseStatus: [n.StatusType.Poisoned],
        loot: [{
            item: n.ItemType.SpiderSilk
        }],
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: 0,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 150,
        tamingDifficulty: 50,
        spawnGroup: [a.SpawnGroup.Guardians, a.SpawnGroup.Night, a.SpawnGroup.EasyNight, a.SpawnGroup.Cave],
        acceptedItems: [n.ItemTypeGroup.Bait],
        skipMovementChance: 20,
        blood: {
            r: 162,
            g: 155,
            b: 37
        }
    },
    t.creatureDescriptions[n.CreatureType.Bear] = {
        minhp: 13,
        maxhp: 16,
        minatk: 10,
        maxatk: 15,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Piercing,4,n.DamageType.Blunt,2),new n.Vulnerabilities),
        damageType: n.DamageType.Slashing | n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater | n.MoveType.Water | n.MoveType.BreakDoodads,
        waterAnimations: !0,
        canCauseStatus: [n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.DefaultWithWater,
        spawnReputation: -18e3,
        makeNoise: !0,
        reputation: 250,
        tamingDifficulty: 200,
        spawnGroup: [a.SpawnGroup.Guardians],
        acceptedItems: [n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat, n.ItemTypeGroup.CookedMeat],
        canTrample: !0,
        skipMovementChance: 1
    },
    t.creatureDescriptions[n.CreatureType.Rabbit] = {
        minhp: 2,
        maxhp: 3,
        minatk: 1,
        maxatk: 2,
        defense: new n.Defense(0,new n.Resistances,new n.Vulnerabilities),
        damageType: n.DamageType.Slashing,
        ai: i.AiType.Scared,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: 0,
        makeNoise: !0,
        jumpOver: !0,
        reputation: -300,
        spawnOnBenignity: !0,
        tamingDifficulty: 25,
        acceptedItems: [n.ItemTypeGroup.Seed, n.ItemType.SheafOfHay, n.ItemType.Raspberries, n.ItemType.Beggarticks, n.ItemType.Carrot, n.ItemType.Apple, n.ItemType.Pineapple, n.ItemType.Lettuce]
    },
    t.creatureDescriptions[n.CreatureType.Snake] = {
        minhp: 3,
        maxhp: 4,
        minatk: 4,
        maxatk: 10,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Piercing,2),new n.Vulnerabilities(n.DamageType.Fire,1)),
        damageType: n.DamageType.Piercing,
        canCauseStatus: [n.StatusType.Poisoned],
        ai: i.AiType.Neutral,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: 0,
        jumpOver: !0,
        reputation: -200,
        tamingDifficulty: 50,
        acceptedItems: [n.ItemTypeGroup.RawMeat, n.ItemTypeGroup.Bait],
        noStumble: !0,
        skipMovementChance: 5
    },
    t.creatureDescriptions[n.CreatureType.GiantRat] = {
        minhp: 3,
        maxhp: 4,
        minatk: 2,
        maxatk: 5,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Blunt,1),new n.Vulnerabilities(n.DamageType.Fire,1)),
        damageType: n.DamageType.Slashing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        canCauseStatus: [n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: 0,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 150,
        tamingDifficulty: 75,
        spawnGroup: [a.SpawnGroup.Guardians, a.SpawnGroup.Night, a.SpawnGroup.EasyNight, a.SpawnGroup.Cave],
        acceptedItems: [n.ItemTypeGroup.Food, n.ItemTypeGroup.Seed],
        canTrample: !0,
        skipMovementChance: 10
    },
    t.creatureDescriptions[n.CreatureType.Rat] = {
        minhp: 2,
        maxhp: 3,
        minatk: 1,
        maxatk: 2,
        defense: new n.Defense(0,new n.Resistances,new n.Vulnerabilities),
        damageType: n.DamageType.Slashing,
        ai: i.AiType.Scared,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: 0,
        makeNoise: !0,
        jumpOver: !0,
        reputation: -200,
        spawnOnBenignity: !0,
        tamingDifficulty: 25,
        spawnGroup: [a.SpawnGroup.Cave],
        acceptedItems: [n.ItemTypeGroup.Seed],
        skipMovementChance: 2
    },
    t.creatureDescriptions[n.CreatureType.VampireBat] = {
        minhp: 3,
        maxhp: 6,
        minatk: 2,
        maxatk: 6,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Piercing,3),new n.Vulnerabilities(n.DamageType.Fire,3)),
        damageType: n.DamageType.Piercing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Flying,
        canCauseStatus: [n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.Flying,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 250,
        tamingDifficulty: 50,
        spawnGroup: [a.SpawnGroup.Night, a.SpawnGroup.Cave],
        acceptedItems: [n.ItemTypeGroup.RawMeat, n.ItemTypeGroup.Fruit],
        noStumble: !0,
        skipMovementChance: 10
    },
    t.creatureDescriptions[n.CreatureType.GreyWolf] = {
        minhp: 10,
        maxhp: 14,
        minatk: 7,
        maxatk: 9,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Blunt,2),new n.Vulnerabilities),
        damageType: n.DamageType.Slashing | n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        canCauseStatus: [n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -1e4,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 250,
        tamingDifficulty: 150,
        spawnGroup: [a.SpawnGroup.Guardians],
        acceptedItems: [n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat, n.ItemTypeGroup.CookedMeat, n.ItemTypeGroup.Bone],
        canTrample: !0
    },
    t.creatureDescriptions[n.CreatureType.Imp] = {
        minhp: 14,
        maxhp: 18,
        minatk: 15,
        maxatk: 19,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Fire,99),new n.Vulnerabilities),
        damageType: n.DamageType.Slashing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Flying | n.MoveType.Fire,
        loot: [{
            item: n.ItemType.FlyAmanita
        }, {
            item: n.ItemType.FlyAmanita,
            chance: 50
        }, {
            item: n.ItemType.OrbOfInfluence,
            chance: 15
        }],
        lootGroup: n.LootGroupType.High,
        canCauseStatus: [n.StatusType.Bleeding, n.StatusType.Burned],
        spawnTiles: a.SpawnableTiles.DefaultWithLava,
        spawnReputation: -24e3,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 250,
        tamingDifficulty: 300,
        spawnGroup: [a.SpawnGroup.Guardians, a.SpawnGroup.Cave, a.SpawnGroup.StrongGuardians],
        acceptedItems: [n.ItemType.FlyAmanita],
        noStumble: !0,
        skipMovementChance: 2
    },
    t.creatureDescriptions[n.CreatureType.Bogling] = {
        minhp: 15,
        maxhp: 17,
        minatk: 8,
        maxatk: 11,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Blunt,3,n.DamageType.Fire,5),new n.Vulnerabilities),
        damageType: n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        loot: [{
            item: n.ItemType.Peat
        }, {
            item: n.ItemType.VineWhip,
            chance: 5
        }, {
            item: n.ItemType.MossCoveredBook,
            chance: 10
        }],
        blood: {
            r: 70,
            g: 90,
            b: 20
        },
        aberrantBlood: {
            r: 170,
            g: 50,
            b: 45
        },
        canCauseStatus: [n.StatusType.Poisoned],
        lootGroup: n.LootGroupType.Low,
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -16e3,
        makeNoise: !0,
        reputation: 150,
        tamingDifficulty: 300,
        acceptedItems: [n.ItemType.Peat],
        helpPlants: !0,
        skipMovementChance: 5
    },
    t.creatureDescriptions[n.CreatureType.LivingRock] = {
        minhp: 20,
        maxhp: 28,
        minatk: 4,
        maxatk: 6,
        defense: new n.Defense(5,new n.Resistances(n.DamageType.Piercing,3,n.DamageType.Slashing,3,n.DamageType.Fire,99),new n.Vulnerabilities(n.DamageType.Blunt,2)),
        damageType: n.DamageType.Blunt,
        ai: i.AiType.Neutral,
        moveType: n.MoveType.None,
        loot: [{
            item: n.ItemType.LargeRock
        }, {
            item: n.ItemType.SharpRock
        }],
        blood: {
            r: 110,
            g: 110,
            b: 110
        },
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -2e4,
        jumpOver: !0,
        reputation: -200,
        spawnGroup: [a.SpawnGroup.Cave],
        acceptedItems: [n.ItemType.LargeRock],
        noStumble: !0
    },
    t.creatureDescriptions[n.CreatureType.Shark] = {
        minhp: 9,
        maxhp: 11,
        minatk: 6,
        maxatk: 12,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Blunt,2,n.DamageType.Fire,99),new n.Vulnerabilities),
        damageType: n.DamageType.Slashing | n.DamageType.Piercing,
        ai: i.AiType.Hostile | i.AiType.Fearless,
        moveType: n.MoveType.Water,
        canCauseStatus: [n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.DeepSeawater,
        reputation: 150,
        tamingDifficulty: 300,
        spawnGroup: [a.SpawnGroup.Seawater],
        acceptedItems: [n.ItemTypeGroup.Meat, n.ItemTypeGroup.RawMeat],
        noStumble: !0,
        skipMovementChance: 2
    },
    t.creatureDescriptions[n.CreatureType.Zombie] = {
        minhp: 8,
        maxhp: 14,
        minatk: 6,
        maxatk: 13,
        defense: new n.Defense(5,new n.Resistances(n.DamageType.Piercing,1,n.DamageType.Blunt,1),new n.Vulnerabilities(n.DamageType.Fire,5,n.DamageType.Slashing,1)),
        damageType: n.DamageType.Slashing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater | n.MoveType.BreakDoodads,
        loot: [{
            item: n.ItemType.Bone
        }, {
            item: n.ItemType.TatteredPants,
            chance: 5
        }, {
            item: n.ItemType.TatteredShirt,
            chance: 5
        }, {
            item: n.ItemType.Journal,
            chance: 5
        }],
        lootGroup: n.LootGroupType.Low,
        canCauseStatus: [n.StatusType.Poisoned, n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -16e3,
        makeNoise: !0,
        respawn: !0,
        reputation: 250,
        tamingDifficulty: 500,
        spawnGroup: [a.SpawnGroup.Night, a.SpawnGroup.Cave],
        acceptedItems: [n.ItemTypeGroup.RawMeat],
        canTrample: !0,
        skipMovementChance: 40
    },
    t.creatureDescriptions[n.CreatureType.Skeleton] = {
        minhp: 11,
        maxhp: 16,
        minatk: 8,
        maxatk: 12,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Piercing,3,n.DamageType.Slashing,3),new n.Vulnerabilities(n.DamageType.Fire,2,n.DamageType.Blunt,2)),
        damageType: n.DamageType.Blunt | n.DamageType.Piercing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        loot: [{
            item: n.ItemType.Bone
        }, {
            item: n.ItemType.Bone,
            chance: 25
        }, {
            item: n.ItemType.GoldenRing,
            chance: 2
        }],
        lootGroup: n.LootGroupType.Low,
        blood: {
            r: 200,
            g: 200,
            b: 200
        },
        canCauseStatus: [n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.Default,
        makeNoise: !0,
        respawn: !0,
        reputation: 250,
        spawnGroup: [a.SpawnGroup.Guardians, a.SpawnGroup.Cave, a.SpawnGroup.StrongGuardians],
        canTrample: !0,
        skipMovementChance: 20
    },
    t.creatureDescriptions[n.CreatureType.PirateGhost] = {
        minhp: 18,
        maxhp: 24,
        minatk: 16,
        maxatk: 19,
        defense: new n.Defense(8,new n.Resistances,new n.Vulnerabilities(n.DamageType.Fire,4)),
        damageType: n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Flying | n.MoveType.Mountain,
        lootGroup: n.LootGroupType.VeryHigh,
        blood: {
            r: 250,
            g: 250,
            b: 250
        },
        spawnTiles: a.SpawnableTiles.Ghost,
        spawnReputation: -4e4,
        jumpOver: !0,
        reputation: 350,
        tamingDifficulty: 500,
        spawnGroup: [a.SpawnGroup.Cave, a.SpawnGroup.StrongGuardians],
        acceptedItems: [n.ItemType.Ectoplasm],
        noStumble: !0,
        skipMovementChance: 1,
        disableHitching: !0
    },
    t.creatureDescriptions[n.CreatureType.TimeSkitter] = {
        minhp: 10,
        maxhp: 12,
        minatk: 17,
        maxatk: 21,
        defense: new n.Defense(8,new n.Resistances,new n.Vulnerabilities(n.DamageType.Blunt,2)),
        damageType: n.DamageType.Slashing | n.DamageType.Piercing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        lootGroup: n.LootGroupType.High,
        canCauseStatus: [n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -36e3,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 250,
        acceptedItems: [n.ItemType.Sundial],
        noStumble: !0,
        canTrample: !0,
        skipMovementChance: 1
    },
    t.creatureDescriptions[n.CreatureType.Chicken] = {
        minhp: 2,
        maxhp: 3,
        minatk: 1,
        maxatk: 3,
        defense: new n.Defense(0,new n.Resistances,new n.Vulnerabilities),
        damageType: n.DamageType.Slashing,
        ai: i.AiType.Scared,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        loot: [{
            item: n.ItemType.Feather
        }, {
            item: n.ItemType.Feather,
            chance: 75
        }],
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: 4e3,
        makeNoise: !0,
        jumpOver: !0,
        reputation: -300,
        tamingDifficulty: 25,
        acceptedItems: [n.ItemTypeGroup.Seed, n.ItemTypeGroup.Bait],
        skipMovementChance: 1
    },
    t.creatureDescriptions[n.CreatureType.TrapdoorSpider] = {
        minhp: 2,
        maxhp: 5,
        minatk: 2,
        maxatk: 3,
        defense: new n.Defense(0,new n.Resistances(n.DamageType.Piercing,2),new n.Vulnerabilities(n.DamageType.Blunt,1)),
        damageType: n.DamageType.Piercing,
        ai: i.AiType.Hidden,
        moveType: n.MoveType.Land,
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -2e3,
        jumpOver: !0,
        reputation: 150,
        tamingDifficulty: 50,
        acceptedItems: [n.ItemTypeGroup.Bait],
        blood: {
            r: 162,
            g: 155,
            b: 37
        }
    },
    t.creatureDescriptions[n.CreatureType.FireElemental] = {
        minhp: 15,
        maxhp: 19,
        minatk: 14,
        maxatk: 21,
        defense: new n.Defense(5,new n.Resistances(n.DamageType.Fire,100),new n.Vulnerabilities),
        damageType: n.DamageType.Fire | n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Flying | n.MoveType.Fire,
        lootGroup: n.LootGroupType.FireElemental,
        loot: [{
            item: n.ItemType.PileOfAsh
        }],
        blood: {
            r: 205,
            g: 105,
            b: 25
        },
        canCauseStatus: [n.StatusType.Burned],
        spawnTiles: a.SpawnableTiles.DefaultWithLava,
        spawnReputation: -3e4,
        makeNoise: !0,
        reputation: 250,
        tamingDifficulty: 300,
        spawnGroup: [a.SpawnGroup.Guardians, a.SpawnGroup.StrongGuardians],
        acceptedItems: [n.ItemType.LitPoleTorch, n.ItemType.LitBarkTorch, n.ItemType.LitAnimalFatTorch],
        lightSource: !0,
        noStumble: !0,
        providesFire: !0,
        canTrample: !0,
        skipMovementChance: 5,
        disableHitching: !0
    },
    t.creatureDescriptions[n.CreatureType.Cod] = {
        minhp: 2,
        maxhp: 3,
        minatk: 0,
        maxatk: 1,
        defense: new n.Defense(0,new n.Resistances(n.DamageType.Fire,99,n.DamageType.Blunt,2,n.DamageType.Slashing,2),new n.Vulnerabilities),
        damageType: n.DamageType.Blunt,
        ai: i.AiType.Neutral,
        moveType: n.MoveType.Water | n.MoveType.ShallowWater,
        loot: [{
            item: n.ItemType.RawCod
        }],
        spawnTiles: a.SpawnableTiles.Seawater,
        jumpOver: !0,
        noCorpse: !0,
        fishable: !0,
        reputation: 0,
        spawnOnBenignity: !0,
        tamingDifficulty: 100,
        spawnGroup: [a.SpawnGroup.Seawater],
        acceptedItems: [n.ItemTypeGroup.Bait],
        noStumble: !0,
        skipMovementChance: 2
    },
    t.creatureDescriptions[n.CreatureType.Hobgoblin] = {
        minhp: 15,
        maxhp: 16,
        minatk: 9,
        maxatk: 16,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Blunt,2),new n.Vulnerabilities),
        damageType: n.DamageType.Slashing | n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater | n.MoveType.BreakDoodads,
        loot: [{
            item: n.ItemType.TatteredPants,
            chance: 5
        }, {
            item: n.ItemType.OrbOfInfluence,
            chance: 15
        }, {
            item: n.ItemType.GoldenSword,
            chance: 2
        }, {
            item: n.ItemType.OrnateBlueBook,
            chance: 5
        }],
        lootGroup: n.LootGroupType.Low,
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -22e3,
        makeNoise: !0,
        reputation: 150,
        tamingDifficulty: 500,
        spawnGroup: [a.SpawnGroup.Guardians],
        acceptedItems: [n.ItemTypeGroup.Equipment, n.ItemTypeGroup.Weapon, n.ItemTypeGroup.Trap],
        canTrample: !0,
        skipMovementChance: 2
    },
    t.creatureDescriptions[n.CreatureType.LivingMushroom] = {
        minhp: 7,
        maxhp: 12,
        minatk: 6,
        maxatk: 10,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Fire,4),new n.Vulnerabilities(n.DamageType.Slashing,2)),
        damageType: n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        loot: [{
            item: n.ItemType.ButtonMushrooms
        }],
        aberrantLoot: [{
            item: n.ItemType.FlyAmanita
        }],
        blood: {
            r: 175,
            g: 155,
            b: 135
        },
        aberrantBlood: {
            r: 150,
            g: 45,
            b: 25
        },
        spawnTiles: a.SpawnableTiles.Default,
        makeNoise: !0,
        reputation: 150,
        tamingDifficulty: 150,
        acceptedItems: [n.ItemType.RottenMeat, n.ItemType.RottingVegetation],
        canTrample: !0,
        skipMovementChance: 1
    },
    t.creatureDescriptions[n.CreatureType.Kraken] = {
        minhp: 65,
        maxhp: 75,
        minatk: 24,
        maxatk: 26,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,4),new n.Vulnerabilities(n.DamageType.Fire,2)),
        damageType: n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater | n.MoveType.Water | n.MoveType.BreakDoodads,
        lootGroup: n.LootGroupType.SeaTreasure,
        loot: [{
            item: n.ItemType.OrnateWoodenChest,
            chance: 3
        }],
        blood: {
            r: 80,
            g: 150,
            b: 175
        },
        aberrantBlood: {
            r: 220,
            g: 30,
            b: 90
        },
        spawnTiles: a.SpawnableTiles.Water,
        spawnReputation: -42e3,
        makeNoise: !0,
        reputation: 350,
        tamingDifficulty: 1e3,
        spawnGroup: [a.SpawnGroup.CaveWater, a.SpawnGroup.Seawater, a.SpawnGroup.StrongGuardians],
        acceptedItems: [n.ItemTypeGroup.Treasure],
        noStumble: !0,
        skipMovementChance: 3
    },
    t.creatureDescriptions[n.CreatureType.Blindfish] = {
        minhp: 2,
        maxhp: 3,
        minatk: 1,
        maxatk: 3,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Fire,99,n.DamageType.Blunt,3,n.DamageType.Slashing,3),new n.Vulnerabilities),
        damageType: n.DamageType.Blunt,
        ai: i.AiType.Neutral,
        moveType: n.MoveType.Water | n.MoveType.ShallowWater,
        loot: [{
            item: n.ItemType.RawBlindfish
        }],
        spawnTiles: a.SpawnableTiles.FreshWater,
        jumpOver: !0,
        noCorpse: !0,
        fishable: !0,
        reputation: 0,
        spawnOnBenignity: !0,
        tamingDifficulty: 125,
        spawnGroup: [a.SpawnGroup.CaveWater],
        acceptedItems: [n.ItemTypeGroup.Bait],
        noStumble: !0,
        skipMovementChance: 25
    },
    t.creatureDescriptions[n.CreatureType.Harpy] = {
        minhp: 14,
        maxhp: 17,
        minatk: 9,
        maxatk: 16,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Slashing,4),new n.Vulnerabilities(n.DamageType.Fire,2)),
        damageType: n.DamageType.Slashing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Flying,
        canCauseStatus: [n.StatusType.Bleeding],
        loot: [{
            item: n.ItemType.Feather
        }, {
            item: n.ItemType.Feather,
            chance: 75
        }],
        lootGroup: n.LootGroupType.Low,
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -32e3,
        makeNoise: !0,
        reputation: 150,
        tamingDifficulty: 300,
        spawnGroup: [a.SpawnGroup.Guardians, a.SpawnGroup.Cave, a.SpawnGroup.StrongGuardians],
        noStumble: !0,
        skipMovementChance: 2
    },
    t.creatureDescriptions[n.CreatureType.AcidSpitterDemon] = {
        minhp: 23,
        maxhp: 29,
        minatk: 26,
        maxatk: 28,
        defense: new n.Defense(9,new n.Resistances(n.DamageType.Slashing,3,n.DamageType.Blunt,3,n.DamageType.Fire,10,n.DamageType.Piercing,2),new n.Vulnerabilities),
        damageType: n.DamageType.Slashing | n.DamageType.Piercing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        canCauseStatus: [n.StatusType.Bleeding],
        lootGroup: n.LootGroupType.VeryHigh,
        loot: [{
            item: n.ItemType.GoldenChalice,
            chance: 10
        }, {
            item: n.ItemType.GoldenKey,
            chance: 10
        }],
        blood: {
            r: 20,
            g: 180,
            b: 20
        },
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -52e3,
        makeNoise: !0,
        reputation: 350,
        canTrample: !0,
        skipMovementChance: 1
    },
    t.creatureDescriptions[n.CreatureType.SkeletalMage] = {
        minhp: 34,
        maxhp: 36,
        minatk: 18,
        maxatk: 23,
        defense: new n.Defense(7,new n.Resistances(n.DamageType.Slashing,4,n.DamageType.Fire,4,n.DamageType.Piercing,4),new n.Vulnerabilities(n.DamageType.Blunt,2)),
        damageType: n.DamageType.Slashing | n.DamageType.Piercing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        canCauseStatus: [n.StatusType.Bleeding],
        lootGroup: n.LootGroupType.VeryHigh,
        loot: [{
            item: n.ItemType.SkeletalMageWand
        }, {
            item: n.ItemType.GoldenChalice,
            chance: 5
        }, {
            item: n.ItemType.GildedRedBook,
            chance: 5
        }],
        blood: {
            r: 200,
            g: 200,
            b: 200
        },
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -44e3,
        makeNoise: !0,
        reputation: 350,
        spawnGroup: [a.SpawnGroup.StrongGuardians],
        canTrample: !0,
        skipMovementChance: 10
    },
    t.creatureDescriptions[n.CreatureType.ClawWorm] = {
        minhp: 8,
        maxhp: 11,
        minatk: 2,
        maxatk: 3,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Piercing,1),new n.Vulnerabilities(n.DamageType.Fire,2)),
        damageType: n.DamageType.Piercing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        spawnTiles: a.SpawnableTiles.Default,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 150,
        tamingDifficulty: 25,
        acceptedItems: [n.ItemTypeGroup.Fruit, n.ItemTypeGroup.Vegetable],
        noStumble: !0,
        helpPlants: !0,
        skipMovementChance: 10
    },
    t.creatureDescriptions[n.CreatureType.Drake] = {
        minhp: 110,
        maxhp: 130,
        minatk: 28,
        maxatk: 34,
        defense: new n.Defense(10,new n.Resistances(n.DamageType.Slashing,3,n.DamageType.Blunt,3,n.DamageType.Fire,100),new n.Vulnerabilities(n.DamageType.Piercing,2)),
        damageType: n.DamageType.Slashing | n.DamageType.Piercing | n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.Fire | n.MoveType.BreakDoodads,
        canCauseStatus: [n.StatusType.Bleeding, n.StatusType.Burned],
        lootGroup: n.LootGroupType.VeryHigh,
        spawnTiles: a.SpawnableTiles.DefaultWithLava,
        loot: [{
            item: n.ItemType.GoldenKey
        }],
        spawnReputation: -62e3,
        makeNoise: !0,
        reputation: 450,
        tamingDifficulty: 1500,
        acceptedItems: [n.ItemTypeGroup.Treasure],
        canTrample: !0,
        skipMovementChance: 2
    },
    t.creatureDescriptions[n.CreatureType.Sandcat] = {
        minhp: 9,
        maxhp: 13,
        minatk: 5,
        maxatk: 8,
        defense: new n.Defense(3,new n.Resistances(n.DamageType.Blunt,2),new n.Vulnerabilities),
        damageType: n.DamageType.Slashing | n.DamageType.Piercing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        canCauseStatus: [n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.Desert,
        spawnReputation: -8e3,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 250,
        tamingDifficulty: 50,
        acceptedItems: [n.ItemTypeGroup.RawMeat, n.ItemTypeGroup.Meat],
        canTrample: !0,
        skipMovementChance: 4
    },
    t.creatureDescriptions[n.CreatureType.LavaBeetle] = {
        minhp: 18,
        maxhp: 22,
        minatk: 14,
        maxatk: 17,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Fire,100,n.DamageType.Blunt,6,n.DamageType.Slashing,3),new n.Vulnerabilities(n.DamageType.Piercing,2)),
        damageType: n.DamageType.Blunt | n.DamageType.Piercing,
        ai: i.AiType.Hostile,
        blood: {
            r: 230,
            g: 90,
            b: 25
        },
        moveType: n.MoveType.Land | n.MoveType.Fire | n.MoveType.BreakDoodads,
        lootGroup: n.LootGroupType.High,
        loot: [{
            item: n.ItemType.Obsidian
        }],
        canCauseStatus: [n.StatusType.Burned],
        spawnTiles: a.SpawnableTiles.Lava,
        spawnReputation: -26e3,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 250,
        tamingDifficulty: 200,
        acceptedItems: [n.ItemType.MeltedCopal],
        lightSource: !0,
        spawnGroup: [a.SpawnGroup.StrongGuardians],
        providesFire: !0,
        canTrample: !0
    },
    t.creatureDescriptions[n.CreatureType.Goat] = {
        minhp: 8,
        maxhp: 13,
        minatk: 2,
        maxatk: 5,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Blunt,2),new n.Vulnerabilities),
        damageType: n.DamageType.Piercing | n.DamageType.Blunt,
        ai: i.AiType.Neutral,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        canCauseStatus: [n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: 0,
        makeNoise: !0,
        jumpOver: !0,
        reputation: -200,
        tamingDifficulty: 50,
        acceptedItems: [n.ItemTypeGroup.Vegetable, n.ItemTypeGroup.Seed, n.ItemType.SheafOfHay, n.ItemType.LeatherBoots, n.ItemType.TreeBark, n.ItemType.PlantRoots, n.ItemType.PoisonIvyLeaves, n.ItemType.Leaves, n.ItemType.PalmLeaf, n.ItemTypeGroup.Fruit],
        spawnOnBenignity: !0,
        canTrample: !0,
        skipMovementChance: 1
    },
    t.creatureDescriptions[n.CreatureType.SlitherSucker] = {
        minhp: 20,
        maxhp: 24,
        minatk: 6,
        maxatk: 11,
        defense: new n.Defense(5,new n.Resistances(n.DamageType.Blunt,4),new n.Vulnerabilities(n.DamageType.Fire,2)),
        damageType: n.DamageType.Piercing,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land,
        canCauseStatus: [n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.Default,
        spawnReputation: -2e4,
        makeNoise: !0,
        reputation: 250,
        spawnGroup: [a.SpawnGroup.Guardians],
        blood: {
            r: 255,
            g: 234,
            b: 0
        },
        noStumble: !0,
        canTrample: !0,
        skipMovementChance: 2
    },
    t.creatureDescriptions[n.CreatureType.Mudskipper] = {
        minhp: 8,
        maxhp: 10,
        minatk: 1,
        maxatk: 2,
        defense: new n.Defense(4,new n.Resistances(n.DamageType.Piercing,2),new n.Vulnerabilities),
        damageType: n.DamageType.Blunt,
        ai: i.AiType.Scared,
        moveType: n.MoveType.WetLand | n.MoveType.Water | n.MoveType.ShallowWater,
        spawnTiles: a.SpawnableTiles.Wet,
        makeNoise: !0,
        jumpOver: !0,
        reputation: -50,
        tamingDifficulty: 20,
        acceptedItems: [n.ItemTypeGroup.Bait, n.ItemType.RawCod, n.ItemType.RawBlindfish, n.ItemType.RawFishSteak],
        noStumble: !0,
        spawnReputation: 8e3,
        waterAnimations: !0,
        particlesOnMove: !0,
        spawnGroup: [a.SpawnGroup.FreshWater],
        canTrample: !0,
        skipMovementChance: 4
    },
    t.creatureDescriptions[n.CreatureType.Scorpion] = {
        minhp: 6,
        maxhp: 12,
        minatk: 1,
        maxatk: 4,
        defense: new n.Defense(2,new n.Resistances(n.DamageType.Slashing,1,n.DamageType.Piercing,1),new n.Vulnerabilities(n.DamageType.Blunt,2)),
        damageType: n.DamageType.Piercing | n.DamageType.Slashing | n.DamageType.Blunt,
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        canCauseStatus: [n.StatusType.Poisoned, n.StatusType.Bleeding],
        spawnTiles: a.SpawnableTiles.Desert,
        spawnReputation: -3e3,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 200,
        tamingDifficulty: 100,
        acceptedItems: [n.ItemTypeGroup.Bait],
        blood: {
            r: 162,
            g: 155,
            b: 37
        },
        skipMovementChance: 2
    },
    t.creatureDescriptions[n.CreatureType.Rattlesnake] = {
        minhp: 6,
        maxhp: 8,
        minatk: 7,
        maxatk: 9,
        defense: new n.Defense(6,new n.Resistances(n.DamageType.Piercing,1),new n.Vulnerabilities(n.DamageType.Fire,2)),
        damageType: n.DamageType.Piercing,
        canCauseStatus: [n.StatusType.Poisoned],
        ai: i.AiType.Hostile,
        moveType: n.MoveType.Land,
        spawnTiles: a.SpawnableTiles.Desert,
        spawnReputation: -5e3,
        makeNoise: !0,
        jumpOver: !0,
        reputation: 200,
        tamingDifficulty: 100,
        acceptedItems: [n.ItemTypeGroup.RawMeat, n.ItemTypeGroup.Bait],
        noStumble: !0,
        skipMovementChance: 10
    },
    t.creatureDescriptions[n.CreatureType.AntelopeJackrabbit] = {
        minhp: 5,
        maxhp: 7,
        minatk: 1,
        maxatk: 2,
        defense: new n.Defense(1,new n.Resistances(n.DamageType.Blunt,1),new n.Vulnerabilities),
        damageType: n.DamageType.Slashing,
        ai: i.AiType.Scared,
        moveType: n.MoveType.Land | n.MoveType.ShallowWater,
        spawnTiles: a.SpawnableTiles.Desert,
        spawnReputation: 0,
        makeNoise: !0,
        jumpOver: !0,
        reputation: -300,
        spawnOnBenignity: !0,
        tamingDifficulty: 50,
        acceptedItems: [n.ItemTypeGroup.Seed, n.ItemType.SheafOfHay, n.ItemType.Raspberries, n.ItemType.Beggarticks, n.ItemType.Carrot, n.ItemType.Apple, n.ItemType.Pineapple, n.ItemType.Lettuce, n.ItemType.SaguaroCactusChunk, n.ItemType.Nopal],
        speed: 2
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/PriorityQueue", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.LowestToHighest = 0] = "LowestToHighest",
        e[e.HighestToLowest = 1] = "HighestToLowest"
    }(a = t.PriorityQueueType || (t.PriorityQueueType = {}));
    class i {
        constructor(e) {
            this.type = e,
            this.length = 0
        }
        getLength() {
            return this.length
        }
        isEmpty() {
            return void 0 === this.head
        }
        push(e, t) {
            if (this.length++,
            void 0 === this.head)
                this.head = {
                    data: e,
                    priority: t,
                    next: void 0
                };
            else {
                let i, n = this.head;
                for (; void 0 !== n; ) {
                    if (this.type === a.HighestToLowest ? t > n.priority : t < n.priority)
                        return void (void 0 !== i ? i.next = {
                            data: e,
                            priority: t,
                            next: n
                        } : this.head = {
                            data: e,
                            priority: t,
                            next: n
                        });
                    i = n,
                    n = n.next
                }
                i.next = {
                    data: e,
                    priority: t,
                    next: void 0
                }
            }
        }
        pop() {
            const e = this.head;
            if (void 0 !== e)
                return this.head = e.next,
                this.length--,
                e.data
        }
        *entries() {
            let e = this.head;
            for (; void 0 !== e; )
                yield e.data,
                e = e.next
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("creature/Pathing", ["require", "exports", "Enums", "mod/IHookManager", "tile/ITileEvent", "tile/Terrains", "utilities/PriorityQueue", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s) {
    function l(e, t, a, i, n, o=300) {
        if (d(e, t))
            return [];
        const s = new r.default(r.PriorityQueueType.LowestToHighest);
        s.push(e, 0);
        const l = {}
          , u = {}
          , c = {}
          , m = {}
          , h = {}
          , y = e=>`${e.x},${e.y}`
          , g = y(e);
        let f;
        for (m[g] = p(e, t),
        c[g] = 0; !s.isEmpty() && o > 0 && (o--,
        void 0 !== (f = s.pop())); ) {
            if (d(f, t)) {
                const e = [];
                for (; void 0 !== f; )
                    e.unshift(f),
                    f = h[y(f)];
                return e
            }
            const e = y(f);
            u[e] = !0;
            const o = c[e];
            for (let e = 0; e < 4; e++) {
                const r = {
                    x: f.x,
                    y: f.y
                };
                switch (e) {
                case 0:
                    r.x = game.getWrappedCoord(r.x + 1);
                    break;
                case 1:
                    r.x = game.getWrappedCoord(r.x - 1);
                    break;
                case 2:
                    r.y = game.getWrappedCoord(r.y + 1);
                    break;
                case 3:
                    r.y = game.getWrappedCoord(r.y - 1)
                }
                const d = y(r);
                if (u[d])
                    continue;
                const g = game.getTile(r.x, r.y, a);
                if (i(g, r))
                    continue;
                let T = o + 1;
                if (n && (T += n(g, r)),
                !l[d] || T < c[d]) {
                    l[d] = !0,
                    h[d] = f;
                    const e = m[d] = T + p(r, t);
                    c[d] = T,
                    s.push(r, e)
                }
            }
        }
    }
    function u(e, t, r, l) {
        const u = s.default.getType(t);
        if (u === a.TerrainType.CaveEntrance || u === a.TerrainType.Lava || tileEventManager.get(t, n.TileEventType.Fire))
            return !0;
        if (fieldOfView && !fieldOfView.disabled && l) {
            const t = world.layers[e.z];
            if (t) {
                const e = t.exploredMap;
                if (e && 255 !== e.get(r.x, r.y))
                    return !0
            }
        }
        const d = o.default[u];
        if (d && !d.passable && !d.water)
            return !0;
        if (void 0 !== t.creature || void 0 !== t.npc)
            return !0;
        if (void 0 !== t.doodad && t.doodad.type !== a.DoodadType.WoodenDoor && t.doodad.type !== a.DoodadType.WoodenDoorOpen && t.doodad.type !== a.DoodadType.WoodenGate && t.doodad.type !== a.DoodadType.WoodenGateOpen && (t.doodad.blocksMove() || t.doodad.isDangerous(e)))
            return !0;
        const p = game.getPlayersAtPosition(r.x, r.y, e.z, !1, !0);
        if (p.length > 0)
            for (const t of p)
                if (t !== e)
                    return !0;
        return !!modManager.getHook(i.Hook.IsTileBlocked).call(t)
    }
    function d(e, t) {
        return e.x === t.x && e.y === t.y
    }
    function p(e, t) {
        const a = e.x;
        let i = t.x;
        const n = t.y;
        let o = t.y;
        return a - i > 255 ? i += game.mapSize : i - a > 255 && (i -= game.mapSize),
        n - o > 255 ? o += game.mapSize : o - n > 255 && (o -= game.mapSize),
        Math.abs(i - a) + Math.abs(o - n)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.findPath = l,
    t.isWalkToTileBlocked = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("doodad/Doodads", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.doodadDescriptions = {},
    t.default = t.doodadDescriptions,
    t.doodadGroups = {};
    for (let e = a.DoodadTypeGroup.Invalid + 1; e < a.DoodadTypeGroup.Last; e++)
        t.doodadGroups[e] = {
            name: ""
        };
    t.doodadDescriptions[a.DoodadType.ButtonMushrooms] = {
        spreadMax: 3,
        gather: {
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.ButtonMushrooms,
                chance: 15
            }, {
                type: a.ItemType.ButtonMushrooms
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.ButtonMushrooms
            }, {
                type: a.ItemType.ButtonMushrooms
            }]
        },
        skillUse: a.SkillType.Mycology,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass, a.TerrainType.WoodenFlooring],
        canTrampleWhenMature: !0,
        canGrowInCaves: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 243,
            g: 219,
            b: 202
        },
        canGrow: !0,
        decayMax: 750,
        isFungi: !0
    },
    t.doodadDescriptions[a.DoodadType.FlyAmanita] = {
        spreadMax: 3,
        gather: {
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.FlyAmanita
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.FlyAmanita
            }]
        },
        skillUse: a.SkillType.Mycology,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass, a.TerrainType.WoodenFlooring],
        canTrampleWhenMature: !0,
        canGrowInCaves: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 202,
            g: 16,
            b: 16
        },
        canGrow: !0,
        decayMax: 750,
        isFungi: !0
    },
    t.doodadDescriptions[a.DoodadType.Beggarticks] = {
        spreadMax: 4,
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Beggarticks
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Beggarticks
            }, {
                type: a.ItemType.Beggarticks
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.BeggartickSeeds
            }, {
                type: a.ItemType.Beggarticks
            }, {
                type: a.ItemType.Beggarticks,
                chance: 15
            }, {
                type: a.ItemType.Beggarticks
            }]
        },
        skillUse: a.SkillType.Botany,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        canTrampleWhenMature: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 245,
            g: 210,
            b: 17
        },
        growthParticles: {
            [a.GrowingStage.Seedling]: {
                r: 187,
                g: 213,
                b: 81
            }
        },
        canGrow: !0,
        decayMax: 1300
    },
    t.doodadDescriptions[a.DoodadType.Grass] = {
        spreadMax: 20,
        skillUse: a.SkillType.Botany,
        gather: {
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.GrassSeeds
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.GrassSeeds
            }]
        },
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil],
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 85,
            g: 143,
            b: 44
        },
        canGrow: !0,
        decayMax: 750
    },
    t.doodadDescriptions[a.DoodadType.MilkThistles] = {
        spreadMax: 4,
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.MilkThistleFlowers
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.MilkThistleSeeds
            }, {
                type: a.ItemType.MilkThistleFlowers,
                chance: 5
            }, {
                type: a.ItemType.MilkThistleFlowers
            }]
        },
        skillUse: a.SkillType.Botany,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        canTrampleWhenMature: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 121,
            g: 166,
            b: 109
        },
        canGrow: !0,
        decayMax: 1300
    },
    t.doodadDescriptions[a.DoodadType.Clematis] = {
        spreadMax: 5,
        gather: {
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.ClematisVine
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.ClematisVine,
                chance: 15
            }, {
                type: a.ItemType.ClematisVine
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.ClematisSeeds
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        skillUse: a.SkillType.Botany,
        allowedTiles: [a.TerrainType.Swamp, a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 86,
            g: 135,
            b: 8
        },
        canGrow: !0,
        decayMax: 1300
    },
    t.doodadDescriptions[a.DoodadType.Badderlocks] = {
        allowedTiles: [a.TerrainType.Seawater],
        graphicVariation: !0,
        particles: {
            r: 0,
            g: 52,
            b: 39
        },
        pickUp: [a.ItemType.Badderlocks],
        skillUse: a.SkillType.Botany,
        spreadMax: 3
    },
    t.doodadDescriptions[a.DoodadType.Tumbleweed] = {
        spreadMax: 5,
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.TumbleweedSeeds
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.TumbleweedSeeds
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.Twigs,
                chance: 10
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        skillUse: a.SkillType.Botany,
        allowedTiles: [a.TerrainType.BeachSand, a.TerrainType.DesertSand, a.TerrainType.Gravel, a.TerrainType.Dirt, a.TerrainType.FertileSoil],
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 89,
            g: 121,
            b: 60
        },
        canGrow: !0,
        decayMax: 1300
    },
    t.doodadDescriptions[a.DoodadType.PricklyPears] = {
        gather: {
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.CactusSpines
            }, {
                type: a.ItemType.Nopal
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.CactusSpines
            }, {
                type: a.ItemType.Nopal,
                chance: 10
            }, {
                type: a.ItemType.Nopal
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.PricklyPearFruit
            }, {
                type: a.ItemType.PricklyPearFruit
            }]
        },
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        damage: 1,
        spreadMax: 1,
        allowedTiles: [a.TerrainType.BeachSand, a.TerrainType.DesertSand, a.TerrainType.Gravel, a.TerrainType.Dirt, a.TerrainType.FertileSoil],
        graphicVariation: !0,
        particles: {
            r: 136,
            g: 193,
            b: 54
        },
        canGrow: !0,
        decayMax: 1500,
        gatherCanHurtHands: !0
    },
    t.doodadDescriptions[a.DoodadType.RaspberryBush] = {
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.Raspberries,
                chance: 5
            }, {
                type: a.ItemType.Raspberries
            }]
        },
        skillUse: a.SkillType.Botany,
        spreadMax: 1,
        allowedTiles: [a.TerrainType.Swamp, a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 111,
            g: 169,
            b: 52
        },
        canGrow: !0,
        decayMax: 1700
    },
    t.doodadDescriptions[a.DoodadType.PileOfRocks] = {
        graphicVariation: !0,
        particles: {
            r: 109,
            g: 109,
            b: 109
        },
        pickUp: [a.ItemType.LargeRock, a.ItemType.Stones],
        gatherCanHurtHands: !0
    },
    t.doodadDescriptions[a.DoodadType.StoneCampfire] = {
        pickUp: [a.ItemType.StoneCampfire],
        lit: a.DoodadType.LitStoneCampfire,
        repairItem: a.ItemType.StoneCampfire,
        particles: {
            r: 104,
            g: 100,
            b: 100
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitStoneCampfire] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 3,
        revert: a.DoodadType.StoneCampfire,
        isAnimated: !0,
        repairItem: a.ItemType.StoneCampfire,
        particles: {
            r: 104,
            g: 100,
            b: 100
        },
        group: a.DoodadTypeGroup.LitCampfire
    },
    t.doodadDescriptions[a.DoodadType.StoneFurnace] = {
        pickUp: [a.ItemType.StoneFurnace],
        blockMove: !0,
        canBreak: !0,
        lit: a.DoodadType.LitStoneFurnace,
        repairItem: a.ItemType.StoneFurnace,
        particles: {
            r: 104,
            g: 100,
            b: 100
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitStoneFurnace] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 1,
        blockMove: !0,
        canBreak: !0,
        revert: a.DoodadType.StoneFurnace,
        isAnimated: !0,
        repairItem: a.ItemType.StoneFurnace,
        particles: {
            r: 104,
            g: 100,
            b: 100
        },
        group: a.DoodadTypeGroup.LitFurnace
    },
    t.doodadDescriptions[a.DoodadType.SandstoneKiln] = {
        pickUp: [a.ItemType.SandstoneKiln],
        blockMove: !0,
        canBreak: !0,
        lit: a.DoodadType.LitSandstoneKiln,
        repairItem: a.ItemType.SandstoneKiln,
        particles: {
            r: 199,
            g: 156,
            b: 128
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitSandstoneKiln] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 1,
        blockMove: !0,
        canBreak: !0,
        revert: a.DoodadType.SandstoneKiln,
        isAnimated: !0,
        repairItem: a.ItemType.SandstoneKiln,
        particles: {
            r: 199,
            g: 156,
            b: 128
        },
        group: a.DoodadTypeGroup.LitKiln
    },
    t.doodadDescriptions[a.DoodadType.StoneAnvil] = {
        pickUp: [a.ItemType.StoneAnvil],
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.StoneAnvil,
        particles: {
            r: 104,
            g: 100,
            b: 100
        },
        group: a.DoodadTypeGroup.Anvil,
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.WoodenChest] = {
        pickUp: [a.ItemType.WoodenChest],
        weightCapacity: 75,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.WoodenChest,
        isFlammable: !0,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        burnsLike: [a.ItemType.WoodenChest]
    },
    t.doodadDescriptions[a.DoodadType.LockedWoodenChest] = {
        pickUp: [a.ItemType.WoodenChest],
        blockDig: !0,
        blockMove: !0,
        canBreak: !0,
        isLocked: !0,
        isFlammable: !0,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        burnsLike: [a.ItemType.WoodenChest]
    },
    t.doodadDescriptions[a.DoodadType.Switchgrass] = {
        spreadMax: 20,
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.BundleOfSwitchgrass
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.BundleOfSwitchgrass,
                chance: 5
            }, {
                type: a.ItemType.BundleOfSwitchgrass
            }]
        },
        skillUse: a.SkillType.Botany,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.Gravel, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 158,
            g: 218,
            b: 65
        },
        canGrow: !0,
        decayMax: 1200
    },
    t.doodadDescriptions[a.DoodadType.Pineapple] = {
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.Pineapple
            }]
        },
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        spreadMax: 1,
        allowedTiles: [a.TerrainType.BeachSand, a.TerrainType.DesertSand, a.TerrainType.Gravel, a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        graphicVariation: !0,
        particles: {
            r: 139,
            g: 182,
            b: 75
        },
        canGrow: !0,
        decayMax: 3700
    },
    t.doodadDescriptions[a.DoodadType.Chives] = {
        gather: {
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Chives
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Chives,
                chance: 5
            }, {
                type: a.ItemType.Chives
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.ChiveSeeds
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        skillUse: a.SkillType.Botany,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        spreadMax: 2,
        canTrampleWhenMature: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 99,
            g: 166,
            b: 3
        },
        canGrow: !0,
        decayMax: 1500
    },
    t.doodadDescriptions[a.DoodadType.PoleTorchStand] = {
        pickUp: [a.ItemType.WoodenPole],
        lit: a.DoodadType.LitPoleTorchStand,
        repairItem: a.ItemType.WoodenPole,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        isUnlitTorch: !0
    },
    t.doodadDescriptions[a.DoodadType.LitPoleTorchStand] = {
        pickUp: [a.ItemType.LitPoleTorch],
        decayMax: 250,
        providesFire: !0,
        providesLight: 2,
        revert: a.DoodadType.PoleTorchStand,
        isAnimated: !0,
        repairItem: a.ItemType.LitPoleTorch,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        isLitTorch: !0
    },
    t.doodadDescriptions[a.DoodadType.Cotton] = {
        spreadMax: 3,
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.CottonSeeds
            }, {
                type: a.ItemType.Cotton
            }, {
                type: a.ItemType.Cotton,
                chance: 5
            }, {
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        skillUse: a.SkillType.Botany,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        canTrampleWhenMature: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 136,
            g: 172,
            b: 39
        },
        growthParticles: {
            [a.GrowingStage.Ripening]: {
                r: 255,
                g: 255,
                b: 255
            }
        },
        canGrow: !0,
        decayMax: 1500
    },
    t.doodadDescriptions[a.DoodadType.SetDeadfall] = {
        skillUse: a.SkillType.Trapping,
        pickUp: [a.ItemType.Deadfall],
        isTrap: !0,
        isFlammable: !0,
        repairItem: a.ItemType.Deadfall,
        particles: {
            r: 105,
            g: 103,
            b: 103
        },
        reduceDurabilityOnGather: !0,
        trapDamage: 6,
        burnsLike: [a.ItemType.Deadfall]
    },
    t.doodadDescriptions[a.DoodadType.SetSnare] = {
        skillUse: a.SkillType.Trapping,
        pickUp: [a.ItemType.Snare],
        isTrap: !0,
        isFlammable: !0,
        repairItem: a.ItemType.Snare,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        trapDamage: 5,
        burnsLike: [a.ItemType.Snare]
    },
    t.doodadDescriptions[a.DoodadType.SetHobgoblinSnare] = {
        pickUp: [a.ItemType.Snare],
        isTrap: !0,
        isFlammable: !0,
        repairItem: a.ItemType.Snare,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        trapDamage: 6,
        burnsLike: [a.ItemType.Snare]
    },
    t.doodadDescriptions[a.DoodadType.SolarStill] = {
        pickUp: [a.ItemType.SolarStill],
        decayMax: -1,
        isWaterSource: !0,
        particles: {
            r: 206,
            g: 208,
            b: 210
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.StoneWaterStill] = {
        pickUp: [a.ItemType.StoneWaterStill],
        decayMax: -1,
        lit: a.DoodadType.LitStoneWaterStill,
        isWaterSource: !0,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.StoneWaterStill,
        particles: {
            r: 130,
            g: 128,
            b: 128
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitStoneWaterStill] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 2,
        revert: a.DoodadType.StoneWaterStill,
        isAnimated: !0,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.StoneWaterStill,
        canStoke: !1,
        particles: {
            r: 130,
            g: 128,
            b: 128
        },
        group: a.DoodadTypeGroup.LitWaterStill,
        waterStill: !0
    },
    t.doodadDescriptions[a.DoodadType.CreatureIdol] = {
        pickUp: [a.ItemType.CreatureIdol],
        blockMove: !0,
        canBreak: !0,
        isFlammable: !0,
        particles: {
            r: 202,
            g: 91,
            b: 91
        },
        reduceDurabilityOnGather: !0,
        burnsLike: [a.ItemType.CreatureIdol]
    },
    t.doodadDescriptions[a.DoodadType.WoodenDoor] = {
        pickUp: [a.ItemType.WoodenDoor],
        blockMove: !0,
        canBreak: !0,
        isFlammable: !0,
        blockJump: !0,
        repairItem: a.ItemType.WoodenDoor,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        disableDrop: !0,
        isClosedDoor: !0,
        isDoor: !0,
        burnsLike: [a.ItemType.WoodenDoor]
    },
    t.doodadDescriptions[a.DoodadType.WoodenFence] = {
        pickUp: [a.ItemType.WoodenFence],
        blockMove: !0,
        canBreak: !0,
        isFlammable: !0,
        repairItem: a.ItemType.WoodenFence,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        isFence: !0,
        burnsLike: [a.ItemType.WoodenFence]
    },
    t.doodadDescriptions[a.DoodadType.WoodenWall] = {
        pickUp: [a.ItemType.WoodenWall],
        blockMove: !0,
        canBreak: !0,
        blockJump: !0,
        isFlammable: !0,
        repairItem: a.ItemType.WoodenWall,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        disableDrop: !0,
        isWall: !0,
        burnsLike: [a.ItemType.WoodenWall]
    },
    t.doodadDescriptions[a.DoodadType.StoneWall] = {
        pickUp: [a.ItemType.StoneWall],
        blockMove: !0,
        canBreak: !0,
        blockJump: !0,
        repairItem: a.ItemType.StoneWall,
        particles: {
            r: 130,
            g: 128,
            b: 128
        },
        reduceDurabilityOnGather: !0,
        disableDrop: !0,
        isWall: !0
    },
    t.doodadDescriptions[a.DoodadType.SandstoneWall] = {
        pickUp: [a.ItemType.SandstoneWall],
        blockMove: !0,
        canBreak: !0,
        blockJump: !0,
        repairItem: a.ItemType.SandstoneWall,
        particles: {
            r: 199,
            g: 156,
            b: 128
        },
        reduceDurabilityOnGather: !0,
        disableDrop: !0,
        isWall: !0
    },
    t.doodadDescriptions[a.DoodadType.ClayBrickWall] = {
        pickUp: [a.ItemType.ClayBrickWall],
        blockMove: !0,
        canBreak: !0,
        blockJump: !0,
        repairItem: a.ItemType.ClayBrickWall,
        particles: {
            r: 200,
            g: 205,
            b: 207
        },
        reduceDurabilityOnGather: !0,
        disableDrop: !0,
        isWall: !0
    },
    t.doodadDescriptions[a.DoodadType.Acid] = {
        blockDig: !0,
        decayMax: 400,
        damage: 14,
        isAnimated: !0,
        causesStatus: [a.StatusType.Burned],
        particles: {
            r: 148,
            g: 255,
            b: 59
        }
    },
    t.doodadDescriptions[a.DoodadType.CaveEntrance] = {
        particles: {
            r: 111,
            g: 76,
            b: 31
        }
    },
    t.doodadDescriptions[a.DoodadType.SetExplosiveTrap] = {
        skillUse: a.SkillType.Trapping,
        pickUp: [a.ItemType.ExplosiveTrap],
        isTrap: !0,
        particles: {
            r: 85,
            g: 168,
            b: 41
        },
        reduceDurabilityOnGather: !0,
        trapDamage: 8,
        disableDrop: !0
    },
    t.doodadDescriptions[a.DoodadType.WoodenDoorOpen] = {
        pickUp: [a.ItemType.WoodenDoor],
        isFlammable: !0,
        repairItem: a.ItemType.WoodenDoor,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        isDoor: !0,
        burnsLike: [a.ItemType.WoodenDoor]
    },
    t.doodadDescriptions[a.DoodadType.WoodenGate] = {
        pickUp: [a.ItemType.WoodenGate],
        blockMove: !0,
        canBreak: !0,
        isFlammable: !0,
        repairItem: a.ItemType.WoodenGate,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        disableDrop: !0,
        isGate: !0,
        burnsLike: [a.ItemType.WoodenGate]
    },
    t.doodadDescriptions[a.DoodadType.WoodenGateOpen] = {
        pickUp: [a.ItemType.WoodenGate],
        isFlammable: !0,
        repairItem: a.ItemType.WoodenGate,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        isGate: !0,
        burnsLike: [a.ItemType.WoodenGate]
    },
    t.doodadDescriptions[a.DoodadType.PoisonIvy] = {
        spreadMax: 3,
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.PoisonIvyLeaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.PoisonIvyLeaves,
                chance: 5
            }, {
                type: a.ItemType.PoisonIvyLeaves
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.PoisonIvySeeds
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        skillUse: a.SkillType.Botany,
        allowedTiles: [a.TerrainType.Swamp, a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        canTrampleWhenMature: !0,
        isFlammable: !0,
        graphicVariation: !0,
        causesStatus: [a.StatusType.Poisoned],
        particles: {
            r: 70,
            g: 149,
            b: 5
        },
        canGrow: !0,
        decayMax: 1300
    },
    t.doodadDescriptions[a.DoodadType.WroughtIronChest] = {
        pickUp: [a.ItemType.WroughtIronChest],
        weightCapacity: 100,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.WroughtIronChest,
        particles: {
            r: 88,
            g: 95,
            b: 114
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.IronChest] = {
        pickUp: [a.ItemType.IronChest],
        weightCapacity: 125,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.IronChest,
        particles: {
            r: 220,
            g: 223,
            b: 231
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.OrnateWoodenChest] = {
        pickUp: [a.ItemType.OrnateWoodenChest],
        weightCapacity: 100,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.OrnateWoodenChest,
        isFlammable: !0,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        burnsLike: [a.ItemType.WoodenChest]
    },
    t.doodadDescriptions[a.DoodadType.SkeletalRemains] = {
        particles: {
            r: 255,
            g: 255,
            b: 253
        },
        graphicVariation: !0
    },
    t.doodadDescriptions[a.DoodadType.ClayKiln] = {
        pickUp: [a.ItemType.ClayKiln],
        blockMove: !0,
        canBreak: !0,
        lit: a.DoodadType.LitClayKiln,
        repairItem: a.ItemType.ClayKiln,
        particles: {
            r: 200,
            g: 205,
            b: 207
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitClayKiln] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 1,
        blockMove: !0,
        canBreak: !0,
        revert: a.DoodadType.ClayKiln,
        isAnimated: !0,
        repairItem: a.ItemType.ClayKiln,
        particles: {
            r: 200,
            g: 205,
            b: 207
        },
        group: a.DoodadTypeGroup.LitKiln
    },
    t.doodadDescriptions[a.DoodadType.ClayCampfire] = {
        pickUp: [a.ItemType.ClayCampfire],
        lit: a.DoodadType.LitClayCampfire,
        repairItem: a.ItemType.ClayCampfire,
        particles: {
            r: 200,
            g: 205,
            b: 207
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitClayCampfire] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 3,
        revert: a.DoodadType.ClayCampfire,
        isAnimated: !0,
        repairItem: a.ItemType.ClayCampfire,
        particles: {
            r: 200,
            g: 205,
            b: 207
        },
        group: a.DoodadTypeGroup.LitCampfire
    },
    t.doodadDescriptions[a.DoodadType.ClayFurnace] = {
        pickUp: [a.ItemType.ClayFurnace],
        blockMove: !0,
        canBreak: !0,
        lit: a.DoodadType.LitClayFurnace,
        repairItem: a.ItemType.ClayFurnace,
        particles: {
            r: 200,
            g: 205,
            b: 207
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitClayFurnace] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 1,
        blockMove: !0,
        canBreak: !0,
        revert: a.DoodadType.ClayFurnace,
        isAnimated: !0,
        repairItem: a.ItemType.ClayFurnace,
        particles: {
            r: 200,
            g: 205,
            b: 207
        },
        group: a.DoodadTypeGroup.LitFurnace
    },
    t.doodadDescriptions[a.DoodadType.ClayWaterStill] = {
        pickUp: [a.ItemType.ClayWaterStill],
        decayMax: -1,
        lit: a.DoodadType.LitClayWaterStill,
        isWaterSource: !0,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.ClayWaterStill,
        particles: {
            r: 200,
            g: 205,
            b: 207
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitClayWaterStill] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 2,
        revert: a.DoodadType.ClayWaterStill,
        isAnimated: !0,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.ClayWaterStill,
        canStoke: !1,
        particles: {
            r: 200,
            g: 205,
            b: 207
        },
        group: a.DoodadTypeGroup.LitWaterStill,
        waterStill: !0
    },
    t.doodadDescriptions[a.DoodadType.SandstoneCampfire] = {
        pickUp: [a.ItemType.SandstoneCampfire],
        lit: a.DoodadType.LitSandstoneCampfire,
        repairItem: a.ItemType.SandstoneCampfire,
        particles: {
            r: 199,
            g: 156,
            b: 128
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitSandstoneCampfire] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 3,
        revert: a.DoodadType.SandstoneCampfire,
        isAnimated: !0,
        repairItem: a.ItemType.SandstoneCampfire,
        particles: {
            r: 199,
            g: 156,
            b: 128
        },
        group: a.DoodadTypeGroup.LitCampfire
    },
    t.doodadDescriptions[a.DoodadType.SandstoneFurnace] = {
        pickUp: [a.ItemType.SandstoneFurnace],
        blockMove: !0,
        canBreak: !0,
        lit: a.DoodadType.LitSandstoneFurnace,
        repairItem: a.ItemType.SandstoneFurnace,
        particles: {
            r: 199,
            g: 156,
            b: 128
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitSandstoneFurnace] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 1,
        blockMove: !0,
        canBreak: !0,
        revert: a.DoodadType.SandstoneFurnace,
        isAnimated: !0,
        repairItem: a.ItemType.SandstoneFurnace,
        particles: {
            r: 199,
            g: 156,
            b: 128
        },
        group: a.DoodadTypeGroup.LitFurnace
    },
    t.doodadDescriptions[a.DoodadType.SandstoneWaterStill] = {
        pickUp: [a.ItemType.SandstoneWaterStill],
        decayMax: -1,
        lit: a.DoodadType.LitSandstoneWaterStill,
        isWaterSource: !0,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.SandstoneWaterStill,
        particles: {
            r: 199,
            g: 156,
            b: 128
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitSandstoneWaterStill] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 2,
        revert: a.DoodadType.SandstoneWaterStill,
        isAnimated: !0,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.SandstoneWaterStill,
        canStoke: !1,
        particles: {
            r: 199,
            g: 156,
            b: 128
        },
        group: a.DoodadTypeGroup.LitWaterStill,
        waterStill: !0
    },
    t.doodadDescriptions[a.DoodadType.StoneKiln] = {
        pickUp: [a.ItemType.StoneKiln],
        blockMove: !0,
        canBreak: !0,
        lit: a.DoodadType.LitStoneKiln,
        repairItem: a.ItemType.StoneKiln,
        particles: {
            r: 130,
            g: 128,
            b: 128
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.LitStoneKiln] = {
        decayMax: 320,
        blockDig: !0,
        providesFire: !0,
        providesLight: 1,
        blockMove: !0,
        canBreak: !0,
        revert: a.DoodadType.StoneKiln,
        isAnimated: !0,
        repairItem: a.ItemType.StoneKiln,
        particles: {
            r: 130,
            g: 128,
            b: 128
        },
        group: a.DoodadTypeGroup.LitKiln
    },
    t.doodadDescriptions[a.DoodadType.WroughtIronAnvil] = {
        pickUp: [a.ItemType.WroughtIronAnvil],
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.WroughtIronAnvil,
        particles: {
            r: 88,
            g: 95,
            b: 114
        },
        group: a.DoodadTypeGroup.Anvil,
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.IronAnvil] = {
        pickUp: [a.ItemType.IronAnvil],
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.IronAnvil,
        particles: {
            r: 220,
            g: 223,
            b: 231
        },
        group: a.DoodadTypeGroup.Anvil,
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.MapleTree] = {
        blockLos: !0,
        blockMove: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 124,
            g: 193,
            b: 41
        },
        growthParticles: {
            [a.GrowingStage.Dead]: {
                r: 85,
                g: 50,
                b: 36
            }
        },
        reduceDurabilityOnGather: !0,
        skillUse: a.SkillType.Botany,
        gatherSkillUse: a.SkillType.Lumberjacking,
        isTall: !0,
        gather: {
            [a.GrowingStage.Seedling]: [{
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.Branch,
                chance: 10
            }, {
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.TreeBark,
                chance: 5
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Dead]: [{
                type: a.ItemType.Log
            }, {
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.Log
            }, {
                type: a.ItemType.Log,
                chance: 10
            }, {
                type: a.ItemType.Log
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.MapleSeeds
            }, {
                type: a.ItemType.MapleSeeds
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        canGrow: !0,
        spawnOnTerrain: [a.TerrainType.Dirt, a.TerrainType.Grass],
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.Grass, a.TerrainType.FertileSoil],
        decayMax: 3900,
        spreadMax: 2,
        growthCycle: !0,
        isTree: !0,
        gatherCanHurtHands: !0
    },
    t.doodadDescriptions[a.DoodadType.AppleTree] = {
        blockLos: !0,
        blockMove: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 106,
            g: 154,
            b: 5
        },
        growthParticles: {
            [a.GrowingStage.Dead]: {
                r: 136,
                g: 90,
                b: 81
            }
        },
        reduceDurabilityOnGather: !0,
        skillUse: a.SkillType.Botany,
        gatherSkillUse: a.SkillType.Lumberjacking,
        isTall: !0,
        gather: {
            [a.GrowingStage.Seedling]: [{
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.Apple
            }, {
                type: a.ItemType.Apple
            }, {
                type: a.ItemType.Apple
            }, {
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.Branch,
                chance: 5
            }, {
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Dead]: [{
                type: a.ItemType.Log
            }, {
                type: a.ItemType.Branch
            }, {
                type: a.ItemType.Log,
                chance: 50
            }, {
                type: a.ItemType.Log,
                chance: 10
            }, {
                type: a.ItemType.Log
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.Apple
            }, {
                type: a.ItemType.Apple
            }, {
                type: a.ItemType.Apple
            }]
        },
        canGrow: !0,
        spawnOnTerrain: [a.TerrainType.Dirt, a.TerrainType.Grass],
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.Grass, a.TerrainType.FertileSoil],
        decayMax: 3700,
        spreadMax: 2,
        isTree: !0,
        gatherCanHurtHands: !0
    },
    t.doodadDescriptions[a.DoodadType.SpruceTree] = {
        blockLos: !0,
        blockMove: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 86,
            g: 120,
            b: 20
        },
        growthParticles: {
            [a.GrowingStage.Dead]: {
                r: 81,
                g: 32,
                b: 13
            }
        },
        reduceDurabilityOnGather: !0,
        skillUse: a.SkillType.Botany,
        gatherSkillUse: a.SkillType.Lumberjacking,
        isTall: !0,
        gather: {
            [a.GrowingStage.Seedling]: [{
                type: a.ItemType.SpruceNeedles
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.SpruceNeedles
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.SpruceNeedles
            }, {
                type: a.ItemType.SpruceNeedles
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.SpruceNeedles
            }, {
                type: a.ItemType.SpruceNeedles
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.TreeBark,
                chance: 5
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Dead]: [{
                type: a.ItemType.Log
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.Log
            }, {
                type: a.ItemType.Log,
                chance: 10
            }, {
                type: a.ItemType.Log
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.SpruceCone
            }, {
                type: a.ItemType.SpruceCone
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        canGrow: !0,
        spawnOnTerrain: [a.TerrainType.Dirt],
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.Grass, a.TerrainType.FertileSoil],
        decayMax: 3700,
        spreadMax: 1,
        growthCycle: !0,
        isTree: !0,
        gatherCanHurtHands: !0
    },
    t.doodadDescriptions[a.DoodadType.CoconutTree] = {
        blockLos: !0,
        blockMove: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 157,
            g: 179,
            b: 0
        },
        growthParticles: {
            [a.GrowingStage.Dead]: {
                r: 212,
                g: 201,
                b: 148
            }
        },
        reduceDurabilityOnGather: !0,
        skillUse: a.SkillType.Botany,
        gatherSkillUse: a.SkillType.Lumberjacking,
        isTall: !0,
        gather: {
            [a.GrowingStage.Seedling]: [{
                type: a.ItemType.PalmLeaf
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PalmLeaf
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.PalmLeaf
            }, {
                type: a.ItemType.PalmLeaf
            }, {
                type: a.ItemType.TreeBark
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.PalmLeaf
            }, {
                type: a.ItemType.PalmLeaf
            }, {
                type: a.ItemType.TreeBark
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Dead]: [{
                type: a.ItemType.Log
            }, {
                type: a.ItemType.Log,
                chance: 10
            }, {
                type: a.ItemType.Log
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.Coconut
            }, {
                type: a.ItemType.Coconut,
                chance: 5
            }, {
                type: a.ItemType.Coconut
            }]
        },
        canGrow: !0,
        spawnOnTerrain: [a.TerrainType.DesertSand, a.TerrainType.Gravel],
        allowedTiles: [a.TerrainType.BeachSand, a.TerrainType.DesertSand, a.TerrainType.Gravel, a.TerrainType.FertileSoil],
        decayMax: 3900,
        spreadMax: 1,
        isTree: !0,
        gatherCanHurtHands: !0
    },
    t.doodadDescriptions[a.DoodadType.CypressTree] = {
        blockLos: !0,
        blockMove: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 135,
            g: 171,
            b: 7
        },
        growthParticles: {
            [a.GrowingStage.Dead]: {
                r: 196,
                g: 178,
                b: 138
            }
        },
        reduceDurabilityOnGather: !0,
        skillUse: a.SkillType.Botany,
        gatherSkillUse: a.SkillType.Lumberjacking,
        isTall: !0,
        gather: {
            [a.GrowingStage.Seedling]: [{
                type: a.ItemType.CypressLeaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.CypressLeaves
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.CypressLeaves
            }, {
                type: a.ItemType.CypressLeaves
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.CypressLeaves
            }, {
                type: a.ItemType.CypressLeaves
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Dead]: [{
                type: a.ItemType.Log
            }, {
                type: a.ItemType.Twigs
            }, {
                type: a.ItemType.Log
            }, {
                type: a.ItemType.Log,
                chance: 10
            }, {
                type: a.ItemType.Log
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.CypressCone
            }, {
                type: a.ItemType.CypressCone
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        canGrow: !0,
        spawnOnTerrain: [a.TerrainType.Swamp, a.TerrainType.ShallowFreshWater, a.TerrainType.Dirt, a.TerrainType.Grass],
        allowedTiles: [a.TerrainType.Swamp, a.TerrainType.Dirt, a.TerrainType.Grass, a.TerrainType.FertileSoil],
        decayMax: 3900,
        spreadMax: 1,
        growthCycle: !0,
        isTree: !0,
        gatherCanHurtHands: !0
    },
    t.doodadDescriptions[a.DoodadType.Lettuce] = {
        gather: {
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Lettuce
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Lettuce
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.LettuceSeeds
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        spreadMax: 3,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        graphicVariation: !0,
        particles: {
            r: 136,
            g: 216,
            b: 9
        },
        canGrow: !0,
        decayMax: 1300
    },
    t.doodadDescriptions[a.DoodadType.PotatoPlant] = {
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.Leaves
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Potato
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Potato
            }, {
                type: a.ItemType.Potato,
                chance: 5
            }, {
                type: a.ItemType.Potato
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.PotatoSeeds
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        spreadMax: 3,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        graphicVariation: !0,
        particles: {
            r: 100,
            g: 189,
            b: 27
        },
        canGrow: !0,
        decayMax: 1500
    },
    t.doodadDescriptions[a.DoodadType.Carrots] = {
        gather: {
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Carrot
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Carrot
            }, {
                type: a.ItemType.Carrot,
                chance: 5
            }, {
                type: a.ItemType.Carrot
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.CarrotSeeds
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        spreadMax: 3,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        graphicVariation: !0,
        particles: {
            r: 161,
            g: 221,
            b: 0
        },
        canGrow: !0,
        decayMax: 1500
    },
    t.doodadDescriptions[a.DoodadType.CornStalks] = {
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.CornEar
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.CornEar
            }, {
                type: a.ItemType.CornEar
            }]
        },
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        spreadMax: 1,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        graphicVariation: !0,
        particles: {
            r: 148,
            g: 203,
            b: 2
        },
        canGrow: !0,
        decayMax: 1500
    },
    t.doodadDescriptions[a.DoodadType.CucumberPlant] = {
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.Cucumber
            }, {
                type: a.ItemType.Cucumber
            }]
        },
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        spreadMax: 1,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        graphicVariation: !0,
        particles: {
            r: 95,
            g: 174,
            b: 31
        },
        canGrow: !0,
        canTrampleWhenMature: !0,
        decayMax: 1500
    },
    t.doodadDescriptions[a.DoodadType.TomatoPlant] = {
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.Tomato
            }, {
                type: a.ItemType.Tomato
            }]
        },
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        spreadMax: 1,
        allowedTiles: [a.TerrainType.Swamp, a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        graphicVariation: !0,
        particles: {
            r: 114,
            g: 186,
            b: 0
        },
        canGrow: !0,
        canTrampleWhenMature: !0,
        decayMax: 1500
    },
    t.doodadDescriptions[a.DoodadType.Pumpkin] = {
        gather: {
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Leaves
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.Pumpkin
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.Pumpkin
            }]
        },
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        spreadMax: 1,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        graphicVariation: !0,
        particles: {
            r: 162,
            g: 198,
            b: 21
        },
        canGrow: !0,
        decayMax: 1700
    },
    t.doodadDescriptions[a.DoodadType.SugarCaneStalks] = {
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.SugarCaneStalks
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.Leaves
            }, {
                type: a.ItemType.SugarCaneStalks,
                chance: 5
            }, {
                type: a.ItemType.SugarCaneStalks
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.SugarCaneSeeds
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        spreadMax: 3,
        allowedTiles: [a.TerrainType.BeachSand, a.TerrainType.DesertSand, a.TerrainType.Gravel, a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        graphicVariation: !0,
        particles: {
            r: 103,
            g: 185,
            b: 15
        },
        canGrow: !0,
        decayMax: 1700,
        gatherCanHurtHands: !0
    },
    t.doodadDescriptions[a.DoodadType.Wheat] = {
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.BushelOfWheat,
                chance: 5
            }, {
                type: a.ItemType.BushelOfWheat
            }]
        },
        skillUse: a.SkillType.Botany,
        isFlammable: !0,
        spreadMax: 6,
        allowedTiles: [a.TerrainType.Dirt, a.TerrainType.FertileSoil, a.TerrainType.Grass],
        graphicVariation: !0,
        particles: {
            r: 161,
            g: 207,
            b: 25
        },
        growthParticles: {
            [a.GrowingStage.Ripening]: {
                r: 230,
                g: 176,
                b: 29
            }
        },
        canGrow: !0,
        decayMax: 1300
    },
    t.doodadDescriptions[a.DoodadType.CopperChest] = {
        pickUp: [a.ItemType.CopperChest],
        weightCapacity: 100,
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.CopperChest,
        particles: {
            r: 225,
            g: 152,
            b: 116
        },
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.CopperAnvil] = {
        pickUp: [a.ItemType.CopperAnvil],
        blockMove: !0,
        canBreak: !0,
        repairItem: a.ItemType.CopperAnvil,
        particles: {
            r: 88,
            g: 95,
            b: 114
        },
        group: a.DoodadTypeGroup.Anvil,
        reduceDurabilityOnGather: !0
    },
    t.doodadDescriptions[a.DoodadType.BarkTorchStand] = {
        pickUp: [a.ItemType.BarkTorch],
        lit: a.DoodadType.LitBarkTorchStand,
        repairItem: a.ItemType.BarkTorch,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        isUnlitTorch: !0
    },
    t.doodadDescriptions[a.DoodadType.LitBarkTorchStand] = {
        pickUp: [a.ItemType.LitBarkTorch],
        decayMax: 2e3,
        providesFire: !0,
        providesLight: 3,
        revert: a.DoodadType.BarkTorchStand,
        isAnimated: !0,
        repairItem: a.ItemType.BarkTorch,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        isLitTorch: !0
    },
    t.doodadDescriptions[a.DoodadType.AnimalFatTorchStand] = {
        pickUp: [a.ItemType.AnimalFatTorch],
        lit: a.DoodadType.LitAnimalFatTorchStand,
        repairItem: a.ItemType.AnimalFatTorch,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        isUnlitTorch: !0
    },
    t.doodadDescriptions[a.DoodadType.LitAnimalFatTorchStand] = {
        pickUp: [a.ItemType.LitAnimalFatTorch],
        decayMax: 3500,
        providesFire: !0,
        providesLight: 4,
        revert: a.DoodadType.AnimalFatTorchStand,
        isAnimated: !0,
        repairItem: a.ItemType.AnimalFatTorch,
        particles: {
            r: 132,
            g: 96,
            b: 44
        },
        reduceDurabilityOnGather: !0,
        isLitTorch: !0
    },
    t.doodadDescriptions[a.DoodadType.Item] = {},
    t.doodadDescriptions[a.DoodadType.JoshuaTree] = {
        blockLos: !0,
        blockMove: !0,
        isFlammable: !0,
        graphicVariation: !0,
        particles: {
            r: 85,
            g: 116,
            b: 23
        },
        growthParticles: {
            [a.GrowingStage.Dead]: {
                r: 131,
                g: 102,
                b: 88
            }
        },
        reduceDurabilityOnGather: !0,
        skillUse: a.SkillType.Botany,
        gatherSkillUse: a.SkillType.Lumberjacking,
        isTall: !0,
        gather: {
            [a.GrowingStage.Seedling]: [{
                type: a.ItemType.JoshuaTreeLeaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.JoshuaTreeLeaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.JoshuaTreeLeaves
            }, {
                type: a.ItemType.JoshuaTreeLeaves
            }, {
                type: a.ItemType.TreeBark
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.JoshuaTreeLeaves
            }, {
                type: a.ItemType.JoshuaTreeLeaves
            }, {
                type: a.ItemType.TreeBark
            }, {
                type: a.ItemType.TreeBark
            }],
            [a.GrowingStage.Dead]: [{
                type: a.ItemType.Log,
                chance: 10
            }, {
                type: a.ItemType.Log
            }]
        },
        harvest: {
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.JoshuaTreeFlowers,
                chance: 50
            }, {
                type: a.ItemType.JoshuaTreeFlowers
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.JoshuaTreeFlowers
            }, {
                type: a.ItemType.JoshuaTreeFlowers
            }, {
                type: a.ItemType.JoshuaTreeFruit
            }, {
                type: a.ItemType.JoshuaTreeFruit,
                chance: 5
            }, {
                type: a.ItemType.JoshuaTreeFruit
            }]
        },
        canGrow: !0,
        spawnOnTerrain: [a.TerrainType.DesertSand, a.TerrainType.Gravel],
        allowedTiles: [a.TerrainType.BeachSand, a.TerrainType.DesertSand, a.TerrainType.Gravel, a.TerrainType.FertileSoil],
        decayMax: 3900,
        spreadMax: 2,
        isTree: !0,
        gatherCanHurtHands: !0
    },
    t.doodadDescriptions[a.DoodadType.SaguaroCactus] = {
        blockLos: !0,
        blockMove: !0,
        graphicVariation: !0,
        particles: {
            r: 114,
            g: 121,
            b: 40
        },
        reduceDurabilityOnGather: !0,
        skillUse: a.SkillType.Botany,
        isTall: !0,
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.CactusSpines
            }, {
                type: a.ItemType.SaguaroCactusChunk
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.CactusSpines
            }, {
                type: a.ItemType.CactusSpines
            }, {
                type: a.ItemType.SaguaroCactusChunk,
                chance: 75
            }, {
                type: a.ItemType.SaguaroCactusChunk
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.CactusSpines
            }, {
                type: a.ItemType.CactusSpines,
                chance: 50
            }, {
                type: a.ItemType.CactusSpines
            }, {
                type: a.ItemType.SaguaroCactusChunk
            }, {
                type: a.ItemType.SaguaroCactusChunk
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.CactusSpines
            }, {
                type: a.ItemType.CactusSpines
            }, {
                type: a.ItemType.CactusSpines
            }, {
                type: a.ItemType.SaguaroCactusChunk
            }, {
                type: a.ItemType.SaguaroCactusChunk
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.SaguaroCactusFruit,
                chance: 75
            }, {
                type: a.ItemType.SaguaroCactusFruit
            }, {
                type: a.ItemType.SaguaroCactusFruit
            }]
        },
        canGrow: !0,
        spawnOnTerrain: [a.TerrainType.DesertSand, a.TerrainType.Gravel],
        allowedTiles: [a.TerrainType.BeachSand, a.TerrainType.DesertSand, a.TerrainType.Gravel, a.TerrainType.FertileSoil],
        decayMax: 2800,
        spreadMax: 1,
        gatherCanHurtHands: !0
    },
    t.doodadDescriptions[a.DoodadType.AloeVera] = {
        graphicVariation: !0,
        particles: {
            r: 87,
            g: 171,
            b: 66
        },
        reduceDurabilityOnGather: !0,
        skillUse: a.SkillType.Botany,
        isTall: !0,
        gather: {
            [a.GrowingStage.Vegetative]: [{
                type: a.ItemType.AloeVeraLeaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Budding]: [{
                type: a.ItemType.AloeVeraLeaves
            }, {
                type: a.ItemType.AloeVeraLeaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Flowering]: [{
                type: a.ItemType.AloeVeraLeaves
            }, {
                type: a.ItemType.AloeVeraLeaves,
                chance: 25
            }, {
                type: a.ItemType.AloeVeraLeaves
            }, {
                type: a.ItemType.PlantRoots
            }],
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.AloeVeraLeaves
            }, {
                type: a.ItemType.AloeVeraLeaves
            }, {
                type: a.ItemType.AloeVeraLeaves
            }, {
                type: a.ItemType.PlantRoots
            }]
        },
        harvest: {
            [a.GrowingStage.Ripening]: [{
                type: a.ItemType.AloeVeraSeeds
            }]
        },
        group: a.DoodadTypeGroup.GatheredPlant,
        canGrow: !0,
        spawnOnTerrain: [a.TerrainType.DesertSand, a.TerrainType.Gravel],
        allowedTiles: [a.TerrainType.BeachSand, a.TerrainType.DesertSand, a.TerrainType.Gravel, a.TerrainType.FertileSoil],
        decayMax: 2e3,
        spreadMax: 1,
        gatherCanHurtHands: !0
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("flowfield/IFlowField", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("flowfield/IFlowFieldDebugRenderer", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("flowfield/IFlowFieldManager", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.blockedPenalty = 11
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("item/LootGroups", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.lootGroup = Array(),
    t.default = t.lootGroup,
    t.lootGroup[a.LootGroupType.Low] = [a.ItemType.StoneAxe, a.ItemType.StonePickaxe, a.ItemType.WoodenSpear, a.ItemType.WoodenSword, a.ItemType.BarkTunic, a.ItemType.BarkLeggings, a.ItemType.BarkShield, a.ItemType.Skullcap, a.ItemType.AnimalPelt, a.ItemType.AnimalFur, a.ItemType.String, a.ItemType.StoneShovel, a.ItemType.MessageInABottle, a.ItemType.OldInstructionalScroll, a.ItemType.TatteredMap, a.ItemType.Tourniquet, a.ItemType.WovenFabric, a.ItemType.SmallBag, a.ItemType.Bow, a.ItemType.Copal, a.ItemType.Fossil, a.ItemType.StoneHammer, a.ItemType.LockPick, a.ItemType.Waterskin, a.ItemType.WoodenArrow, a.ItemType.StoneBullet, a.ItemType.CordedSling, a.ItemType.OrbOfInfluence, a.ItemType.Cloak, a.ItemType.Obsidian, a.ItemType.Journal, a.ItemType.OldEducationalScroll, a.ItemType.CopperIngot],
    t.lootGroup[a.LootGroupType.High] = [a.ItemType.GoldCoins, a.ItemType.Rope, a.ItemType.Spyglass, a.ItemType.LeatherBelt, a.ItemType.LeatherCap, a.ItemType.LeatherBoots, a.ItemType.LeatherGorget, a.ItemType.LeatherPants, a.ItemType.LeatherTunic, a.ItemType.LeatherGloves, a.ItemType.LeatherSling, a.ItemType.LongBow, a.ItemType.StoneSpear, a.ItemType.TatteredMap, a.ItemType.OldInstructionalScroll, a.ItemType.BarkTorch, a.ItemType.CottonFabric, a.ItemType.Backpack, a.ItemType.Suture, a.ItemType.Bandage, a.ItemType.TannedLeather, a.ItemType.StoneArrow, a.ItemType.GlassBottle, a.ItemType.Waterskin, a.ItemType.ClayJug, a.ItemType.OrbOfInfluence, a.ItemType.OrnateBlueBook, a.ItemType.OldEducationalScroll, a.ItemType.CopperIngot],
    t.lootGroup[a.LootGroupType.VeryHigh] = [a.ItemType.GoldenChalice, a.ItemType.CopperPickaxe, a.ItemType.CopperDoubleAxe, a.ItemType.CopperShovel, a.ItemType.CopperSpear, a.ItemType.CopperHammer, a.ItemType.CopperLockPick, a.ItemType.CopperShield, a.ItemType.CopperGauntlets, a.ItemType.CopperGreaves, a.ItemType.CopperGorget, a.ItemType.CopperHelmet, a.ItemType.CopperBoots, a.ItemType.CopperBreastPlate, a.ItemType.CopperSword, a.ItemType.CopperTongs, a.ItemType.CopperArrow, a.ItemType.CopperBullet, a.ItemType.CopperArrowhead, a.ItemType.CopperAxe, a.ItemType.CopperHoe, a.ItemType.CopperMortarAndPestle, a.ItemType.CompositeBow, a.ItemType.TatteredMap, a.ItemType.AnimalFatTorch, a.ItemType.PeatBandage, a.ItemType.OrbOfInfluence, a.ItemType.GildedRedBook, a.ItemType.OldEducationalScroll],
    t.lootGroup[a.LootGroupType.CaveChest] = [a.ItemType.GoldenRing, a.ItemType.AnimalFatTorch, a.ItemType.OldInstructionalScroll, a.ItemType.TatteredMap, a.ItemType.IronOre, a.ItemType.CopperIngot, a.ItemType.Limestone, a.ItemType.Niter, a.ItemType.Talc, a.ItemType.WroughtIronPickaxe, a.ItemType.WroughtIronShovel, a.ItemType.WroughtIronHammer, a.ItemType.WroughtIronLockPick, a.ItemType.WroughtIronTongs, a.ItemType.WroughtIronBullet, a.ItemType.WroughtIronArrow, a.ItemType.WroughtIronHoe, a.ItemType.WroughtIronAxe, a.ItemType.WroughtIronMortarAndPestle, a.ItemType.LeatherBelt, a.ItemType.LeatherCap, a.ItemType.LeatherBoots, a.ItemType.LeatherGorget, a.ItemType.LeatherPants, a.ItemType.LeatherTunic, a.ItemType.LeatherGloves, a.ItemType.RollOfRedCarpet, a.ItemType.OrnateCape, a.ItemType.OrbOfInfluence, a.ItemType.OrnateBlueBook, a.ItemType.OldEducationalScroll],
    t.lootGroup[a.LootGroupType.Treasure] = [a.ItemType.GoldenRing, a.ItemType.GoldenChalice, a.ItemType.GoldCoins, a.ItemType.GoldenSword, a.ItemType.WroughtIron, a.ItemType.AnimalFatTorch, a.ItemType.TatteredMap, a.ItemType.WroughtIron, a.ItemType.IronOre, a.ItemType.Limestone, a.ItemType.Niter, a.ItemType.Talc, a.ItemType.IronIngot, a.ItemType.WroughtIronBoots, a.ItemType.WroughtIronHelmet, a.ItemType.WroughtIronGorget, a.ItemType.WroughtIronGauntlets, a.ItemType.WroughtIronGreaves, a.ItemType.WroughtIronShield, a.ItemType.WroughtIronPickaxe, a.ItemType.WroughtIronDoubleAxe, a.ItemType.WroughtIronShovel, a.ItemType.WroughtIronSpear, a.ItemType.WroughtIronHammer, a.ItemType.WroughtIronLockPick, a.ItemType.WroughtIronTongs, a.ItemType.WroughtIronBreastPlate, a.ItemType.WroughtIronSword, a.ItemType.WroughtIronBullet, a.ItemType.WroughtIronArrow, a.ItemType.WroughtIronHoe, a.ItemType.WroughtIronAxe, a.ItemType.WroughtIronMortarAndPestle, a.ItemType.FlintlockPistol, a.ItemType.RollOfRedCarpet, a.ItemType.OrbOfInfluence, a.ItemType.Cloak, a.ItemType.GildedRedBook, a.ItemType.OldEducationalScroll],
    t.lootGroup[a.LootGroupType.SeaTreasure] = [a.ItemType.MessageInABottle, a.ItemType.Badderlocks, a.ItemType.LeatherBoots, a.ItemType.FishingNet, a.ItemType.FishingRod, a.ItemType.GoldCoins, a.ItemType.TatteredMap, a.ItemType.GoldenSword, a.ItemType.OrbOfInfluence],
    t.lootGroup[a.LootGroupType.FireElemental] = [a.ItemType.Coal, a.ItemType.MeltedCopal, a.ItemType.PileOfAsh, a.ItemType.WroughtIron, a.ItemType.Charcoal, a.ItemType.Obsidian]
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/dictionary/Misc", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Unknown = 0] = "Unknown",
        e[e.UnknownCreature = 1] = "UnknownCreature",
        e[e.UnknownDoodad = 2] = "UnknownDoodad",
        e[e.UnknownItem = 3] = "UnknownItem",
        e[e.UnknownTileEvent = 4] = "UnknownTileEvent",
        e[e.ReformatSingularNoun = 5] = "ReformatSingularNoun",
        e[e.ItemQuality = 6] = "ItemQuality",
        e[e.Thing = 7] = "Thing",
        e[e.Message = 8] = "Message",
        e[e.CorpseOf = 9] = "CorpseOf",
        e[e.AAndB = 10] = "AAndB",
        e[e.AOrB = 11] = "AOrB",
        e[e.ListItemSeparator = 12] = "ListItemSeparator",
        e[e.AListAndB = 13] = "AListAndB",
        e[e.AListOrB = 14] = "AListOrB",
        e[e.CountThing = 15] = "CountThing",
        e[e.Renamed = 16] = "Renamed",
        e[e.HumanName = 17] = "HumanName",
        e[e.ItemQualityColor = 18] = "ItemQualityColor",
        e[e.Aberrant = 19] = "Aberrant",
        e[e.ItemLegendary = 20] = "ItemLegendary"
    }(a = t.MiscTranslation || (t.MiscTranslation = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/Messages", ["require", "exports", "Enums", "language/dictionary/Message", "language/Translation", "utilities/enum/Enums"], function(e, t, a, i, n, o) {
    function r(e, i) {
        return o.default.values(a.DamageType).filter(t=>e.some(e=>(e & t) === t)).map(e=>n.default.message(t.damageTypeToMessage[e]).addReformatter(i && i(e))).collect(n.default.formatList)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.equipTypeToMessage = Array(),
    t.equipTypeToMessage[a.EquipType.Held] = i.default.Held,
    t.equipTypeToMessage[a.EquipType.Legs] = i.default.Legs,
    t.equipTypeToMessage[a.EquipType.Chest] = i.default.Chest,
    t.equipTypeToMessage[a.EquipType.Head] = i.default.Head,
    t.equipTypeToMessage[a.EquipType.Belt] = i.default.Belt,
    t.equipTypeToMessage[a.EquipType.Feet] = i.default.Feet,
    t.equipTypeToMessage[a.EquipType.Neck] = i.default.Neck,
    t.equipTypeToMessage[a.EquipType.Hands] = i.default.Hands,
    t.equipTypeToMessage[a.EquipType.Back] = i.default.Back,
    t.equipTypeToMessage[a.EquipType.LeftHand] = i.default.LeftHandEquip,
    t.equipTypeToMessage[a.EquipType.RightHand] = i.default.RightHandEquip,
    t.damageTypeToMessage = Array(),
    t.damageTypeToMessage[a.DamageType.Blunt] = i.default.Blunt,
    t.damageTypeToMessage[a.DamageType.Slashing] = i.default.Slashing,
    t.damageTypeToMessage[a.DamageType.Piercing] = i.default.Piercing,
    t.damageTypeToMessage[a.DamageType.Fire] = i.default.Fire,
    t.damageTypeToMessage[a.DamageType.True] = i.default.True,
    t.fullDamageType = r,
    t.recipeLevelToMessage = Array(),
    t.recipeLevelToMessage[a.RecipeLevel.Simple] = i.default.Simple,
    t.recipeLevelToMessage[a.RecipeLevel.Intermediate] = i.default.Intermediate,
    t.recipeLevelToMessage[a.RecipeLevel.Advanced] = i.default.Advanced,
    t.recipeLevelToMessage[a.RecipeLevel.Expert] = i.default.Expert
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("player/IMilestone", ["require", "exports"], function(e, t) {
    var a, i, n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Abnormalizer = 0] = "Abnormalizer",
        e[e.Chef = 1] = "Chef",
        e[e.Exterminator = 2] = "Exterminator",
        e[e.Crafter = 3] = "Crafter",
        e[e.Gardener = 4] = "Gardener",
        e[e.Gatherer = 5] = "Gatherer",
        e[e.Hunter = 6] = "Hunter",
        e[e.Locksmith = 7] = "Locksmith",
        e[e.ReaperOfSouls = 8] = "ReaperOfSouls",
        e[e.Survivor = 9] = "Survivor",
        e[e.Thrower = 10] = "Thrower",
        e[e.Trapper = 11] = "Trapper",
        e[e.TreasureHunter = 12] = "TreasureHunter",
        e[e.Collector = 13] = "Collector",
        e[e.Explorer = 14] = "Explorer",
        e[e.Grandmaster = 15] = "Grandmaster",
        e[e.Prepared = 16] = "Prepared",
        e[e.Doctor = 17] = "Doctor",
        e[e.Artificer = 18] = "Artificer",
        e[e.Seafarer = 19] = "Seafarer",
        e[e.Navigator = 20] = "Navigator",
        e[e.DragonSlayer = 21] = "DragonSlayer",
        e[e.Treasurer = 22] = "Treasurer",
        e[e.Pulchritudinous = 23] = "Pulchritudinous",
        e[e.Friendly = 24] = "Friendly",
        e[e.Malevolent = 25] = "Malevolent",
        e[e.Benevolent = 26] = "Benevolent",
        e[e.Boundless = 27] = "Boundless",
        e[e.Talented = 28] = "Talented",
        e[e.Weathered = 29] = "Weathered",
        e[e.Seasoned = 30] = "Seasoned",
        e[e.Pacifier = 31] = "Pacifier",
        e[e.Merchant = 32] = "Merchant",
        e[e.Notekeeper = 33] = "Notekeeper",
        e[e.Operator = 34] = "Operator",
        e[e.Huntsman = 35] = "Huntsman"
    }(a = t.MilestoneType || (t.MilestoneType = {})),
    function(e) {
        e[e.Visible = 0] = "Visible",
        e[e.Invisible = 1] = "Invisible",
        e[e.Hidden = 2] = "Hidden"
    }(i = t.MilestoneVisibility || (t.MilestoneVisibility = {})),
    function(e) {
        e[e.Counter = 0] = "Counter",
        e[e.Check = 1] = "Check"
    }(n = t.MilestoneDataType || (t.MilestoneDataType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/particle/IParticle", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Fire = 0] = "Fire",
        e[e.Water = 1] = "Water",
        e[e.Blood = 2] = "Blood",
        e[e.Milk = 3] = "Milk"
    }(a = t.ParticleType || (t.ParticleType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/particle/Particles", ["require", "exports", "renderer/particle/IParticle"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.particles = Array(),
    t.default = t.particles,
    t.particles[a.ParticleType.Fire] = {
        r: 210,
        g: 125,
        b: 20
    },
    t.particles[a.ParticleType.Water] = {
        r: 12,
        g: 128,
        b: 247
    },
    t.particles[a.ParticleType.Blood] = {
        r: 255,
        g: 0,
        b: 0
    },
    t.particles[a.ParticleType.Milk] = {
        r: 255,
        g: 255,
        b: 255
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/ISpriteInfo", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/PriorityList", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor(...e) {
            this.map = {},
            e && this.add(...e)
        }
        add(...e) {
            for (const [t,a] of e) {
                const e = this.map[t] = this.map[t] || [];
                e.push(a)
            }
            return this.priorities = Object.keys(this.map).map(e=>+e).sort((e,t)=>t - e),
            this
        }
        *values() {
            for (const e of this.priorities)
                for (const t of this.map[e])
                    yield t
        }
        *reverse() {
            for (let e = this.priorities.length - 1; e >= 0; e--)
                for (const t of this.map[this.priorities[e]])
                    yield t
        }
    }
    t.PriorityList = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/StatusEffectRenderer", ["require", "exports", "utilities/enum/Enums", "utilities/PriorityList"], function(e, t, a, i) {
    var n, o;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Body = 1] = "Body",
        e[e.Hair = 2] = "Hair",
        e[e.Clothes = 4] = "Clothes"
    }(n = t.StatusEffectRenderLayer || (t.StatusEffectRenderLayer = {})),
    function(e) {
        e[e.Lowest = -1e3] = "Lowest",
        e[e.Low = -100] = "Low",
        e[e.Normal = 0] = "Normal",
        e[e.High = 100] = "High",
        e[e.Highest = 1e3] = "Highest"
    }(o = t.RenderPriority || (t.RenderPriority = {}));
    class r {
        constructor(e=o.Normal) {
            this.layers = new Map,
            this.tints = [],
            this.priority = e
        }
        getTints() {
            return this.tints
        }
        addTint(...e) {
            return this.tints.push(...e),
            this
        }
        hasLayer() {
            return this.layers.size > 0
        }
        addLayer(e, t, o=0) {
            for (const r of a.default.values(n))
                if (e & r) {
                    const e = this.layers.get(r) || new i.PriorityList;
                    this.layers.set(r, e),
                    e.add([o, t])
                }
            return this
        }
        render(e, t) {
            const a = this.layers.get(e);
            if (a)
                for (const e of a.reverse())
                    this.renderLayer(e, t)
        }
        renderLayer(e, t) {
            "function" == typeof e ? e(t) : t(e)
        }
    }
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("utilities/Color", ["require", "exports", "utilities/math/Math2"], function(e, t, a) {
    function i(e) {
        return "number" != typeof e || isNaN(e) ? 255 : a.default.clamp255(e)
    }
    function n(e, t, a) {
        if ("object" == typeof e)
            return {
                r: i(e.r),
                g: i(e.g),
                b: i(e.b)
            };
        if ("string" == typeof e)
            switch (e.startsWith("#") && (e = e.slice(1)),
            e.length) {
            case 2:
                e = parseInt(e, 16);
                break;
            case 3:
                a = parseInt(e[2] + e[2], 16),
                t = parseInt(e[1] + e[1], 16),
                e = parseInt(e[0] + e[0], 16);
                break;
            case 6:
                a = parseInt(e[4] + e[5], 16),
                t = parseInt(e[2] + e[3], 16),
                e = parseInt(e[0] + e[1], 16)
            }
        return e = i(e),
        void 0 === t ? {
            r: e,
            g: e,
            b: e
        } : {
            r: e,
            g: t = i(t),
            b: a = i(a)
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        function t(...t) {
            if (3 === t.length && "number" == typeof t[2]) {
                const [a,i,n] = t;
                return n >= 1 ? e(i) : n <= 0 ? e(a) : {
                    r: Math.round((1 - n) * a.r + n * i.r),
                    g: Math.round((1 - n) * a.g + n * i.g),
                    b: Math.round((1 - n) * a.b + n * i.b)
                }
            }
            {
                if (1 === t.length)
                    return e(t[0]);
                const a = {
                    r: 0,
                    g: 0,
                    b: 0
                };
                for (const e of t)
                    a.r += e.r,
                    a.g += e.g,
                    a.b += e.b;
                return {
                    r: Math.round(a.r / t.length),
                    g: Math.round(a.g / t.length),
                    b: Math.round(a.b / t.length)
                }
            }
        }
        function a(e) {
            return `rgb(${e.r}, ${e.g}, ${e.b})`
        }
        function i(e) {
            return e ? `${e.r / 255} 0 0 0 0 0 ${e.g / 255} 0 0 0 0 0 ${e.b / 255} 0 0 0 0 0 1 0` : ""
        }
        function n(e, t) {
            return e.r === t.r && e.g === t.g && e.b === t.b
        }
        e.blend = t,
        e.getCSS = a,
        e.getSVGColorMatrix = i,
        e.equals = n
    }(n || (n = {})),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("entity/StatusEffects", ["require", "exports", "entity/IStats", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "renderer/StatusEffectRenderer", "utilities/Color", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const c = {};
    c[i.StatusType.Bleeding] = {
        shouldPass: (e,t)=>p.default.chance(1 / 8 * t),
        onPassed(e) {
            r.default.get(e).source(o.Source.Wellbeing).send(n.default.BleedingHasStopped)
        },
        onTick(e, t) {
            const i = e.getStat(a.Stat.Hunger)
              , u = e.getStat(a.Stat.Thirst)
              , d = e.getStat(a.Stat.Stamina)
              , c = e.getMaxHealth()
              , m = Math.floor(p.default.intInRange(c / 25, c / 10) * t);
            e.damage(-1 * m, n.default.DeathByBleeding),
            r.default.get(e).source(o.Source.Wellbeing).type(r.MessageType.Bad).send(n.default.BleedingToDeathLostHealth, m),
            game.particle.create(e.x, e.y, e.z, l.default[s.ParticleType.Blood]),
            0 === p.default.int(3) && corpseManager.createBlood(e.x, e.y, e.z),
            i.changeTimer++,
            u.changeTimer++,
            d.changeTimer--
        },
        renderer: (new u.default).addLayer(u.StatusEffectRenderLayer.Body, 0)
    },
    c[i.StatusType.Poisoned] = {
        shouldPass: (e,t)=>p.default.chance(1 / 8 * t),
        onPassed(e) {
            r.default.get(e).source(o.Source.Wellbeing).send(n.default.PoisonWorkedItsCourse)
        },
        onTick(e, t) {
            const i = e.getStat(a.Stat.Thirst)
              , s = e.getStat(a.Stat.Stamina)
              , l = e.getMaxHealth()
              , u = Math.floor(p.default.intInRange(l / 25, l / 10) * t);
            e.damage(-1 * u, n.default.DeathByPoison, 0, !1),
            r.default.get(e).type(r.MessageType.Bad).source(o.Source.Wellbeing).send(n.default.PoisonedLostHealth, u),
            i.changeTimer += 2,
            s.changeTimer -= 2
        },
        renderer: (new u.default).addTint(d.default(116, 133, 0))
    },
    c[i.StatusType.Burned] = {
        shouldPass: (e,t)=>p.default.chance(.1 * t),
        onPassed(e) {
            r.default.get(e).source(o.Source.Wellbeing).send(n.default.NoLongerFeelPainOfBeingBurned)
        },
        onTick(e, t) {
            const a = e.getMaxHealth()
              , i = Math.floor(p.default.intInRange(a / 55, a / 45) * t);
            e.damage(-1 * i, n.default.DeathByBurning, 0, !1),
            r.default.get(e).source(o.Source.Wellbeing).type(r.MessageType.Bad).send(n.default.FeltBurningPainLostHealth, i)
        },
        renderer: (new u.default).addTint(d.default(200, 55, 0))
    },
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("item/ItemRecipeRequirementChecker", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor(e, t, a, i) {
            this.player = e,
            this.recipe = t,
            this.trackItems = a,
            this.cacheItems = i,
            this.itemsToProcess = [],
            a && (this.itemComponentsRequired = [],
            this.itemComponentsConsumed = [],
            this.itemComponentsCanBurn = !1),
            this.numComponentsNeeded = 0,
            this.components = [],
            t && this.setRecipe(t)
        }
        amountNeededForComponent(e) {
            return this.components[e].requiredAmount
        }
        requirementsMet() {
            return 0 === this.numComponentsNeeded
        }
        setAdjacentContainers(e) {
            this.adjacentContainers = e
        }
        isDiscovered() {
            if (void 0 !== this.baseComponent && !this.itemBaseComponent || !this.recipe)
                return !1;
            for (let e = 0; e < this.recipe.components.length; e++) {
                const t = this.recipe.components[e]
                  , a = this.components[e];
                if (t.requiredAmount > 0 && t.requiredAmount === a.requiredAmount)
                    return !1
            }
            return !0
        }
        process(e=!0) {
            if (!this.cacheItems || 0 === this.itemsToProcess.length) {
                if (this.processContainer(this.player.inventory, e))
                    return !0;
                if (this.processAdjacent(e))
                    return !0
            }
            if (this.cacheItems && this.itemsToProcess.length > 0)
                for (const e of this.itemsToProcess)
                    if (this.processItem(e))
                        return !0;
            return !1
        }
        setRecipe(e) {
            this.components = [],
            this.numComponentsNeeded = 0,
            this.itemBaseComponent = void 0;
            for (let t = 0; t < e.components.length; t++) {
                const a = e.components[t];
                this.numComponentsNeeded += a.requiredAmount,
                this.components.push({
                    type: a.type,
                    requiredAmount: a.requiredAmount,
                    consumedAmount: a.consumedAmount,
                    disassembleAmount: a.disassembleAmount,
                    ignoreWeight: a.ignoreWeight
                })
            }
            e.baseComponent ? (this.baseComponent = e.baseComponent,
            this.numComponentsNeeded++) : this.baseComponent = void 0
        }
        processAdjacent(e=!0) {
            const t = this.adjacentContainers || itemManager.getAdjacentContainers(this.player);
            for (const a of t)
                if (this.processContainer(a, e))
                    return !0;
            return !1
        }
        processContainer(e, t=!0) {
            const a = itemManager.getOrderedContainerItems(e, t ? this.player.getProtectedItemsOptions() : void 0);
            for (const e of a) {
                if (this.cacheItems)
                    this.itemsToProcess.push(e);
                else if (this.processItem(e))
                    return !0;
                const a = e;
                if (a.containedItems && a.containedItems.length > 0 && this.processContainer(a, t))
                    return !0
            }
            return !1
        }
        processItem(e) {
            if (void 0 !== this.baseComponent && !this.itemBaseComponent && (itemManager.isGroup(this.baseComponent) && itemManager.isInGroup(e.type, this.baseComponent) || e.type === this.baseComponent))
                return this.itemBaseComponent = e,
                this.numComponentsNeeded--,
                0 === this.numComponentsNeeded;
            for (let t = 0; t < this.components.length; t++) {
                const a = this.components[t]
                  , i = a.requiredAmount
                  , n = a.type;
                if (i > 0 && (itemManager.isGroup(n) && itemManager.isInGroup(e.type, n) || e.type === n))
                    return a.requiredAmount--,
                    this.numComponentsNeeded--,
                    this.trackItems && (a.consumedAmount > 0 ? (a.consumedAmount--,
                    this.itemComponentsConsumed.push(e)) : this.itemComponentsRequired.push(e),
                    !this.itemComponentsCanBurn && e.canBurnPlayer() && (this.itemComponentsCanBurn = !0)),
                    0 === this.numComponentsNeeded
            }
            return !1
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/server/UpdateQuickSlotInfoPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedServerPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            this.quickSlotInfo ? this.player.updateQuickSlotInfo(this.quickSlot, this.quickSlotInfo.itemType, this.quickSlotInfo.action) : this.player.updateQuickSlotInfo(this.quickSlot)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Uint8)], n.prototype, "quickSlot", void 0),
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Generic)], n.prototype, "quickSlotInfo", void 0),
    __decorate([Override], n.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/SharedPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/Packet"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.Packet {
        getType() {
            return a.PacketType.Shared
        }
    }
    __decorate([Override], n.prototype, "getType", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/PlayerTargetedSharedPacket", ["require", "exports", "multiplayer/packets/SharedPacket"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        preProcess() {
            void 0 !== this.pid && void 0 === this.player && (this.player = players[this.pid])
        }
        preWriteData() {
            this.writeUint8(this.pid)
        }
        preReadData() {
            this.pid = this.readUint8()
        }
    }
    __decorate([Override], i.prototype, "preProcess", null),
    __decorate([Override], i.prototype, "preWriteData", null),
    __decorate([Override], i.prototype, "preReadData", null),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/shared/UpdateMovementIntentPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedSharedPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            this.player.updateMovementIntent(this.intent)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.MovementIntent)], n.prototype, "intent", void 0),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/shared/UpdateWalkPathPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedSharedPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            this.player.walkAlongPath(this.path)
        }
    }
    __decorate([a.OptionalNetworkProperty(a.NetworkPropertyType.Vector2Array)], n.prototype, "path", void 0),
    __decorate([Override], n.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/dictionary/GameEndMessage", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Win = 0] = "Win",
        e[e.Dead = 1] = "Dead"
    }(a = t.GameEndMessage || (t.GameEndMessage = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/IInput", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/INewUi", ["require", "exports", "utilities/iterable/Collectors", "utilities/Objects"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const n = Symbol("data");
    var o, r, s;
    function l(e) {
        return (t,a)=>{
            u(t, a, e)
        }
    }
    function u(e, t, a=o.Local) {
        n in e || (e[n] = {}),
        e.constructor.name in e[n] || (e[n][e.constructor.name] = {}),
        e[n][e.constructor.name][t] = a
    }
    function d(e) {
        const t = new Map
          , o = e[n];
        if (o) {
            let n = e;
            for (; o[n.constructor.name] && i.default.entries(o[n.constructor.name]).collect(a.default.setTo(t)),
            n = n.__proto__; )
                ;
        }
        return t
    }
    !function(e) {
        e[e.Local = 0] = "Local",
        e[e.Global = 1] = "Global",
        e[e.Both = 2] = "Both"
    }(o = t.SaveLocation || (t.SaveLocation = {})),
    t.Save = l,
    t.savedProperties = d,
    function(e) {
        e[e.Resize = 0] = "Resize",
        e[e.Interrupt = 1] = "Interrupt",
        e[e.InterruptClose = 2] = "InterruptClose",
        e.LoadedFromSave = "LoadedFromSave"
    }(r = t.UiApiEvent || (t.UiApiEvent = {})),
    function(e) {
        e[e.Up = -1] = "Up",
        e[e.Down = 1] = "Down",
        e[e.Left = -2] = "Left",
        e[e.Right = 2] = "Right"
    }(s = t.SelectDirection || (t.SelectDirection = {})),
    t.DIALOG_OPACITY_MIN = 0,
    t.DIALOG_OPACITY_DEFAULT = 80,
    t.NEWUI_HOOK_PRIORITY = -99999999999
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/Component", ["require", "exports", "Enums", "mod/IHookHost", "newui/BindingManager", "newui/component/IComponent", "newui/util/ElementManipulator", "utilities/Emitter", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class d extends s.default {
        constructor(e, t, a) {
            super(),
            this.api = e,
            this.debounces = new Map,
            this.classes = new r.ClassListManipulator(this),
            this.attributes = new r.AttributeManipulator(this),
            this.data = new r.DataManipulator(this),
            this.setElement(t, a)
        }
        static get(e) {
            if ("string" == typeof e) {
                const t = e;
                if (!(e = document.querySelector(t)))
                    throw new Error(`No components matched the selector '${t}'`)
            }
            return d.map.get(e) || new d(newui).setElement(e)
        }
        static all(e) {
            return document.querySelectorAll(e).values().map(e=>d.get(e))
        }
        static findDescendants(e, t, a=!1) {
            e = e instanceof d ? e.element : e;
            const i = Array.prototype.slice.apply(e.querySelectorAll(t));
            return a && i.unshift(e),
            i
        }
        static getSelectableLayer(e) {
            const t = (e = e instanceof d ? e.element : e).dataset.selectableLayer;
            return !e.classList.contains("selectable") && (void 0 === t ? o.SelectableLayer.Secondary : +t)
        }
        static append(e, t, a="append") {
            if ("string" == typeof e && !(e = document.querySelector(e)))
                throw new Error("Appending element from selector failed; selector did not match");
            if ("string" == typeof t && !(t = document.querySelector(t)))
                throw new Error("Appending element to selector failed; selector did not match");
            if (e instanceof d) {
                const t = e.getParent();
                t && (e.emit("RemoveForAppend"),
                t.emit("RemoveChild"))
            }
            e instanceof d && e.emit("Append", t),
            t instanceof d && t.emit("AddChild", e),
            t instanceof d && (t = t.element);
            const i = e instanceof d ? e.element : e
              , n = t;
            if ("prepend" === a)
                n.insertBefore(i, n.firstChild);
            else if ("append" === a)
                n.appendChild(i);
            else {
                const e = "after"in a ? a.after : a.before
                  , t = e.element;
                n.insertBefore(i, "after"in a ? t.nextSibling : t)
            }
        }
        static remove(e) {
            if (e instanceof d) {
                if (e.emit("WillRemove").some(e=>!1 === e))
                    return;
                const t = e.getParent();
                for (t && t.emit("RemoveChild"); e._element.lastElementChild; ) {
                    const t = d.map.get(e._element.lastElementChild);
                    t ? t.remove() : e._element.lastElementChild.remove()
                }
                e.emit("Remove"),
                e = e.element
            } else if ("string" == typeof e && !(e = document.querySelector(e)))
                return void l.default.warn(l.LogSource.NewUi)("Removing element by selector failed; selector did not match");
            e.remove()
        }
        get element() {
            return this._element
        }
        get dataset() {
            return this._element.dataset
        }
        get childCount() {
            return this._element.children.length
        }
        get scrollHeight() {
            return this._element.scrollHeight
        }
        get style() {
            return this._element.style
        }
        get selectable() {
            return d.getSelectableLayer(this)
        }
        get listen() {
            return this.addEventListener || (this.addEventListener = ((...e)=>(this.element.addEventListener(...e),
            this))),
            this.addEventListener
        }
        setElement(e="div", t) {
            const a = this._element;
            if (this._element = e && "string" != typeof e ? e : t ? document.createElementNS(t.toString(), e) : document.createElement(e),
            d.map.set(this._element, this),
            a)
                for (this._element.classList.add(...a.classList),
                a.id && (this._element.id = a.id),
                a.parentElement && a.replaceWith(this._element); a.firstChild; )
                    this._element.appendChild(a.firstChild);
            return "input" === e && (this.element.addEventListener("change", (...e)=>{
                this.emit("InputChange", ...e)
            }
            ),
            this.element.addEventListener("click", e=>{
                e.stopPropagation()
            }
            )),
            this._data = new Proxy(this.element.dataset,{
                get: (e,t)=>{
                    const a = e[t];
                    return a && a.length > 0 ? JSON.parse(a) : void 0
                }
                ,
                set: (e,t,a)=>(e[t] = JSON.stringify(a),
                !0)
            }),
            this
        }
        setId(e) {
            return this.element.id = e,
            this
        }
        jsonData() {
            return this._data
        }
        setSelectable(e) {
            return this.classes.toggle(!1 !== e, "selectable"),
            "number" == typeof e ? (this.dataset.selectableLayer = `${e}`,
            this.attributes.set("tabindex", "0")) : (delete this.dataset.selectableLayer,
            this.attributes.remove("tabindex")),
            this
        }
        onBindLoop(e, t) {
            if (t.wasPressed(a.Bindable.MenuContextMenu) && !e && t.isMouseWithin(this)) {
                const i = this.api.getVisibleScreen();
                if (i) {
                    const e = this.contextMenuGenerator();
                    e && e.setPosition(t.mouseX, t.mouseY).schedule(i.setContextMenu)
                }
                e = a.Bindable.MenuContextMenu
            }
            return e
        }
        isVisible() {
            return null !== this.element.offsetParent && !this.classes.has("hidden")
        }
        show() {
            return this.classes.has("hidden") && (this.emit("Show"),
            this.classes.remove("hidden")),
            this
        }
        hide() {
            return this.classes.has("hidden") || (this.classes.add("hidden"),
            this.emit("Hide")),
            this
        }
        toggle(e=!this.classes.has("hidden") ) {
            return e ? this.show() : this.hide()
        }
        getParent() {
            return this._element.parentElement && d.get(this._element.parentElement)
        }
        appendTo(e, t) {
            return d.append(this, e, t),
            this
        }
        append(...e) {
            for (const t of e.values().flatMap())
                t && d.append(t, this);
            return this
        }
        remove() {
            return d.remove(this),
            this
        }
        contains(e) {
            "string" == typeof e ? e = document.querySelector(e) : e instanceof d && (e = e.element);
            for (let t = e; t; t = t.parentElement)
                if (this.element === t)
                    return !0;
            return !1
        }
        dump(e) {
            for (; this.element.lastElementChild; ) {
                const t = d.map.get(this.element.lastElementChild);
                t ? e && e(t) || t.remove() : this.element.lastElementChild.remove()
            }
            return this
        }
        dumpFast() {
            for (; this.element.lastChild; )
                this.element.removeChild(this.element.lastChild);
            return this
        }
        setContents(e, t=!1) {
            return this.element.innerHTML = e,
            t && (this.element.innerHTML = this.element.textContent),
            this
        }
        store() {
            return this.api.storeElements(this),
            this
        }
        findDescendants(e) {
            return this.element.querySelectorAll(e)
        }
        setTooltip(e) {
            return !this.tooltipInitializer && e && (this.element.addEventListener("mouseenter", this.onMouseEnterForTooltip),
            this.element.addEventListener("mouseleave", this.onMouseLeaveForTooltip)),
            e || this.removeTooltip(),
            this.tooltipInitializer = e,
            this
        }
        removeTooltip() {
            this.tooltipInitializer = void 0,
            this.element.removeEventListener("mouseenter", this.onMouseEnterForTooltip),
            this.element.removeEventListener("mouseleave", this.onMouseLeaveForTooltip)
        }
        setContextMenu(e) {
            this.contextMenuGenerator = e,
            e ? hookManager.register(this, "NewUi:Component:ForContextMenu").until("Remove") : hookManager.deregister(this)
        }
        setHighlight(e) {
            return this.highlight = e,
            this.element.addEventListener("mouseenter", this.onMouseEnterForHighlights),
            this.element.addEventListener("mouseleave", this.onMouseLeaveForHighlights),
            this
        }
        removeHighlight() {
            this.highlight = void 0,
            this.element.removeEventListener("mouseenter", this.onMouseEnterForHighlights),
            this.element.removeEventListener("mouseleave", this.onMouseLeaveForHighlights)
        }
        setStyle(e, t) {
            return this.style.setProperty(e, `${t}`),
            this
        }
        getBox() {
            return this.element.getBoundingClientRect()
        }
        getOffset() {
            return {
                top: this.element.offsetTop,
                left: this.element.offsetLeft
            }
        }
        getNthChild(e=0) {
            return d.get(this._element.children[e])
        }
        *getChildren() {
            for (const e of this._element.children)
                yield d.get(e)
        }
        scrollTo(e, t=1e3) {
            if (this.scrollingChild === e)
                return;
            this.scrollingChild = e;
            const a = parseInt(this.getStyle("padding-top"), 10)
              , i = this.element.scrollTop
              , n = e.element.offsetTop - a
              , o = n - i;
            if (Math.abs(o) < 20 || t < 50)
                return this.element.scrollTop = n,
                void (this.scrollingChild = void 0);
            const r = e=>e < .5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1
              , s = Date.now()
              , l = ()=>{
                if (this.scrollingChild !== e)
                    return;
                const a = Date.now()
                  , u = a - s
                  , d = r(u / t);
                this.element.scrollTop = i + o * d,
                u < t ? requestAnimationFrame(l) : (this.element.scrollTop = n,
                this.scrollingChild = void 0)
            }
            ;
            requestAnimationFrame(l)
        }
        getStyle(e) {
            return getComputedStyle(this.element).getPropertyValue(e)
        }
        schedule(e, t, a, ...i) {
            if ("number" != typeof e && (void 0 !== a && i.unshift(a),
            void 0 !== t && i.unshift(t),
            a = e,
            t = !1,
            e = 0),
            "function" == typeof t && (void 0 !== a && i.unshift(a),
            a = t,
            t = !1),
            !a)
                return this;
            if (e + (t || 0) > 0) {
                const n = setTimeout(()=>a.call(this, this, ...i), e)
                  , o = Object.assign({
                    id: -1,
                    duration: e,
                    lastCall: Date.now()
                }, this.debounces.get(a) || {});
                clearTimeout(o.id),
                t && this.debounces.set(a, {
                    id: n,
                    duration: o.lastCall + o.duration > Date.now() ? t : Math.min(t, o.duration),
                    lastCall: Date.now()
                })
            } else
                a.call(this, this, ...i);
            return this
        }
        repaint() {
            const e = this.style.visibility;
            this.style.visibility = "hidden",
            this.element.offsetWidth,
            this.style.visibility = e
        }
        forceShowTooltip() {
            n.bindingManager.isMouseWithin(this, !0) && this.onMouseEnterForTooltip(void 0, !0)
        }
        onMouseEnterForTooltip(e, t=!1) {
            const a = this.api.tooltips.show(this, t);
            a && this.tooltipInitializer && (a.dump(),
            this.tooltipInitializer(a))
        }
        onMouseLeaveForTooltip() {
            this.api.tooltips.hide(this)
        }
        onMouseEnterForHighlights() {
            this.highlight && this.api.highlights.start(this, this.highlight)
        }
        onMouseLeaveForHighlights() {
            this.api.highlights.end(this)
        }
    }
    d.map = new Map,
    __decorate([i.HookMethod], d.prototype, "onBindLoop", null),
    __decorate([u.Bound], d.prototype, "hide", null),
    __decorate([u.Bound], d.prototype, "remove", null),
    __decorate([u.Bound], d.prototype, "onMouseEnterForTooltip", null),
    __decorate([u.Bound], d.prototype, "onMouseLeaveForTooltip", null),
    __decorate([u.Bound], d.prototype, "onMouseEnterForHighlights", null),
    __decorate([u.Bound], d.prototype, "onMouseLeaveForHighlights", null),
    t.default = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/segment/ColorSegment", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const a = {
        regex: /^#(--.*?|[0-9a-fA-F]{3}|[0-9a-fA-F]{6}):/,
        handle: ([e,t],a,i,...n)=>{
            const o = i.interpolate(a.slice(e.length), ...n);
            t = t.startsWith("--") ? `var(${i.interpolateString(t, ...n)})` : `#${t}`;
            for (const e of o)
                e.color || (e.color = t);
            return o
        }
    };
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/segment/TextDecorationSegments", ["require", "exports", "utilities/enum/Enums", "utilities/iterable/Generators"], function(e, t, a, i) {
    var n;
    function o(e) {
        return a.default.values(n).map(t=>i.tuple(t, t & (e.decoration || 0))).filter(([,e])=>e)
    }
    function r(e) {
        return t=>{
            const a = t;
            return a.decoration = (a.decoration || 0) | e,
            a
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Underline = 1] = "Underline",
        e[e.Bold = 2] = "Bold",
        e[e.Italicized = 4] = "Italicized"
    }(n = t.TextDecoration || (t.TextDecoration = {})),
    t.italicizedSegment = {
        startChar: "//",
        endChar: "//",
        regex: /^.*$/,
        handle: (e,t,a,...i)=>a.interpolate(t, ...i).map(r(n.Italicized))
    },
    t.boldSegment = {
        startChar: "**",
        endChar: "**",
        regex: /^.*$/,
        handle: (e,t,a,...i)=>a.interpolate(t, ...i).map(r(n.Bold))
    },
    t.underlineSegment = {
        startChar: "__",
        endChar: "__",
        regex: /^.*$/,
        handle: (e,t,a,...i)=>a.interpolate(t, ...i).map(r(n.Underline))
    },
    t.getDecorations = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/segment/LinkSegment", ["require", "exports", "utilities/Objects"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        regex: /^link\((?:(https?:\/\/.*?)|Menu\.([a-zA-Z0-9]+(?:\.[a-zA-Z0-9]+)?))\):/,
        handle: ([e,t,i],n,o,...r)=>{
            const s = o.interpolate(n.slice(e.length), ...r)
              , l = t || i.split(".");
            return s.map(a.default.addProperty("link", l))
        }
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/segment/HeadingSegment", ["require", "exports", "utilities/Objects"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        regex: /^heading:/,
        handle: ([e],t,i,...n)=>{
            const o = i.interpolate(t.slice(e.length), ...n);
            return o.map(a.default.addProperty("fontSize", "heading"))
        }
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/ContextMenu", ["require", "exports", "newui/component/Button", "newui/component/Component", "utilities/Async", "utilities/math/Math2", "utilities/Objects"], function(e, t, a, i, n, o, r) {
    var s;
    function l(e) {
        return void 0 !== e
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Chosen = "Chosen",
        e.BecomeActive = "ShowSubmenu"
    }(s = t.ContextMenuEvent || (t.ContextMenuEvent = {}));
    class u extends i.default {
        constructor(e, ...t) {
            super(e),
            this.options = new Map,
            this.classes.add("context-menu", "hidden"),
            this.attributes.set("intercept", "all"),
            this.descriptions = t.filter(l)
        }
        addAllDescribedOptions() {
            return this.descriptions.values().map(e=>e[0]).flatMap().collect(this.addOptions),
            this
        }
        addOptions(...e) {
            for (const t of e.values().flatMap()) {
                const e = this.getDescription(t)
                  , a = new d(this.api,e).appendTo(this).on(s.Chosen, e=>{
                    this.emit(s.Chosen, e)
                }
                ).on(s.BecomeActive, ()=>{
                    this.activeOption && this.activeOption !== a && this.activeOption.onUnselected(),
                    this.activeOption = a
                }
                );
                this.options.set(t, a)
            }
            return this
        }
        disableOptions(...e) {
            for (const t of e.values().flatMap()) {
                const e = this.options.get(t);
                e && e.setDisabled(!0)
            }
            return this
        }
        removeOptions(...e) {
            for (const t of e.values().flatMap()) {
                const e = this.options.get(t);
                e && (e.remove(),
                this.options.delete(t))
            }
            return this
        }
        setPosition(e, t, a=!1) {
            return n.sleep(10).then(()=>{
                const {width: i, height: r} = this.getBox()
                  , s = 20 * newui.scale.getCurrent()
                  , l = o.default.clamp(s, window.innerWidth - i - s, a ? e - i : e)
                  , u = l / window.innerWidth * 100;
                this.style.setProperty("--context-menu-left", `${u}%`);
                const d = o.default.clamp(s, window.innerHeight - r - s, t) / window.innerHeight * 100;
                this.style.setProperty("--context-menu-top", `${d}%`),
                this.show(),
                n.sleep(100).then(()=>{
                    this.classes.add("interactable")
                }
                )
            }
            ),
            this
        }
        async hideAndRemove() {
            await this.options.values().map(async e=>e.hideAndRemove()).collect(Promise.all),
            this.classes.add("hidden"),
            await n.sleep(this.element.matches(".context-menu-option > *")?100:300),
            super.remove()
        }
        getDescription(e) {
            for (const t of this.descriptions)
                if (t[0] === e)
                    return t[1]
        }
    }
    __decorate([r.Bound], u.prototype, "addOptions", null),
    t.default = u;
    class d extends a.default {
        constructor(e, t) {
            super(e),
            this.classes.add("context-menu-option", "menu-text-not-heading"),
            this.setText(t.translation),
            this.schedule(t.create),
            this.element.addEventListener("mouseenter", this.onSelected),
            "submenu"in t ? (this.submenuDescription = t.submenu,
            this.classes.add("context-menu-option-submenu", "has-icon-before", "icon-no-scale")) : this.element.addEventListener("click", ()=>{
                this.classes.has("disabled") || (t.onActivate(),
                this.emit(s.Chosen))
            }
            )
        }
        hideSubmenu() {
            this.submenu && (this.classes.remove("active"),
            this.submenu.remove(),
            this.submenu = void 0)
        }
        async hideAndRemove() {
            this.submenu && await this.submenu.hideAndRemove()
        }
        onSelected() {
            this.isActive || (this.isActive = !0,
            this.submenuDescription && this.showSubmenu(this.submenuDescription),
            this.emit(s.BecomeActive))
        }
        onUnselected() {
            this.isActive = !1,
            this.hideSubmenu()
        }
        showSubmenu(e) {
            if (this.submenu)
                return;
            const t = this.getBox();
            this.classes.add("active");
            const a = window.innerWidth - t.right < 420 * this.api.scale.getCurrent() || this.element.matches(".context-menu-positioned-right :scope");
            this.classes.toggle(a, "context-menu-positioned-right"),
            this.submenu = e(this.api).classes.add("context-menu-submenu").setPosition(a ? t.left : t.left + t.width, t.top, a).appendTo(this).on(s.Chosen, (e,t)=>{
                this.emit(s.Chosen, t)
            }
            )
        }
    }
    __decorate([r.Bound], d.prototype, "onSelected", null),
    t.ContextMenuOption = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/Screen", ["require", "exports", "Enums", "mod/IHookHost", "newui/component/Component", "newui/component/ContextMenu", "newui/screen/IScreen", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class u extends n.default {
        constructor(e, t) {
            super(e),
            this.isOverlayScreen = !1,
            this.classes.add("screen", "hidden"),
            this.attributes.set("tabindex", "0"),
            this.dataset.screenId = r.ScreenId[t],
            this.log = new s.default(s.LogSource.NewUi,`${this.dataset.screenId}Screen`),
            this.on("Show", this.onShow),
            this.element.addEventListener("click", this.onClick)
        }
        get background() {
            return r.Background[this.dataset.backgroundImage]
        }
        set background(e) {
            this.dataset.backgroundImage = r.Background[e]
        }
        setContextMenu(e) {
            if (e && "setPosition"in e)
                return this.contextMenu && this.contextMenu.hideAndRemove(),
                this.contextMenu = e.appendTo(this).on(o.ContextMenuEvent.Chosen, ()=>{
                    this.hideContextMenu(e)
                }
                ),
                void document.addEventListener("click", this.onDocumentClick);
            super.setContextMenu(e)
        }
        hideContextMenu(e) {
            return !(!this.contextMenu || e && e !== this.contextMenu) && (this.contextMenu.hideAndRemove(),
            this.contextMenu = void 0,
            document.removeEventListener("click", this.onDocumentClick),
            !0)
        }
        onBindLoop(e, t) {
            return t.isAnythingDown() && !t.isDown(a.Bindable.MenuContextMenu) && this.api.isScreenVisible(r.ScreenId[this.dataset.screenId]) && this.hideContextMenu() && (e = a.Bindable.MenuCancel),
            e
        }
        onShow() {
            hookManager.register(this, `NewUi:Screen:${this.dataset.screenId}`).until("Hide")
        }
        onClick() {
            this.element.focus()
        }
        onDocumentClick() {
            this.hideContextMenu()
        }
    }
    __decorate([l.Bound, Override], u.prototype, "setContextMenu", null),
    __decorate([Override, i.HookMethod], u.prototype, "onBindLoop", null),
    __decorate([l.Bound], u.prototype, "onShow", null),
    __decorate([l.Bound], u.prototype, "onClick", null),
    __decorate([l.Bound], u.prototype, "onDocumentClick", null),
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/Refreshable", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/Input", ["require", "exports", "newui/component/Component", "newui/component/IComponent", "newui/component/Text", "utilities/Async", "utilities/Objects"], function(e, t, a, i, n, o, r) {
    var s;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Change = "Change",
        e.Done = "Done",
        e.Enter = "Enter",
        e.Escape = "Escape",
        e.Focus = "Focus",
        e.Blur = "Blur"
    }(s = t.InputEvent || (t.InputEvent = {}));
    const l = ["Backquote", "Backslash", "Backspace", "BracketLeft", "BracketRight", "CapsLock", "Comma", "Delete", "Equal", "Minus", "Period", "Quote", "Semicolon", "Slash", "Space"];
    class u extends a.default {
        constructor(e) {
            super(e, "input"),
            this.keydownEnter = !1,
            this.keydownEscape = !1,
            this.canBeEmpty = !1,
            this.shouldBlurWhenEnterPressed = !0,
            this.shouldBlurWhenEnterPressedAndEmpty = !0,
            this.hasChanged = !1,
            this.classes.add("input", "input-usefixer"),
            this.attributes.set("type", "text"),
            this.setSelectable(i.SelectableLayer.Primary),
            this.listen("change", this.change),
            this.listen("click", this.change),
            this.listen("keyup", this.keyup),
            this.listen("input", this.change),
            this.listen("paste", this.change),
            this.listen("keydown", this.keydown),
            this.listen("mousedown", e=>{
                e.stopPropagation()
            }
            ),
            this.listen("focus", this.focus),
            this.listen("blur", this.blur)
        }
        get text() {
            return this.element.value
        }
        set text(e) {
            this.element.value = e,
            this.change(e)
        }
        get changed() {
            return this.hasChanged
        }
        setMaxLength(e) {
            return e ? this.attributes.set("maxlength", `${e}`) : this.attributes.remove("maxlength"),
            this
        }
        setCanBeEmpty(e=!0) {
            return this.canBeEmpty = e,
            this
        }
        setDefault(e) {
            return this.default = e,
            this
        }
        setClearTo(e) {
            return this.clearTo = e,
            this
        }
        setPlaceholder(e) {
            return this.placeholder = e,
            this.refresh(),
            this
        }
        setShouldBlurWhenEnterPressedAndEmpty(e=!0) {
            return this.shouldBlurWhenEnterPressedAndEmpty = e,
            this
        }
        setShouldBlurWhenEnterPressed(e=!0) {
            return this.shouldBlurWhenEnterPressed = e,
            this
        }
        refresh() {
            return this.attributes.set("placeholder", n.default.toString(this.placeholder)),
            this
        }
        clear(e=!1) {
            const t = this.element;
            return t.value = e || void 0 === this.clearTo ? this.default ? this.default() : "" : this.clearTo(),
            this.hasChanged = !1,
            this
        }
        focus() {
            this.element !== document.activeElement && this.element.focus();
            const e = this.api.getVisibleScreen();
            e && e.hideContextMenu(),
            this.emit(s.Focus)
        }
        blur(e) {
            this.element === document.activeElement && this.element.blur(),
            "" !== this.text || this.canBeEmpty || this.clear(),
            this.emit(s.Done, this.text),
            this.keydownEnter && (this.emit(s.Enter),
            this.keydownEnter = !1),
            this.keydownEscape && (this.emit(s.Escape),
            this.keydownEscape = !1),
            this.emit(s.Blur)
        }
        keydown(e) {
            const t = e;
            "Enter" === t.code ? this.keydownEnter = !0 : "Escape" === t.code ? this.keydownEscape = !0 : (t.code.startsWith("Key") || t.code.startsWith("Digit") || t.code.startsWith("Numpad") || l.includes(t.code)) && t.stopPropagation()
        }
        keyup(e) {
            const t = e;
            (t.code.startsWith("Key") || t.code.startsWith("Digit") || t.code.startsWith("Numpad") || l.includes(t.code)) && t.stopPropagation(),
            this.change(e, !1)
        }
        change(e, t=!0) {
            if ("string" != typeof e) {
                e instanceof KeyboardEvent && ("Enter" === e.code && this.keydownEnter ? this.shouldBlurWhenEnterPressed && ("" !== this.text || this.shouldBlurWhenEnterPressedAndEmpty) ? this.blur() : this.shouldBlurWhenEnterPressed || this.emit(s.Enter) : "Escape" === e.code && this.keydownEscape && this.blur());
                const a = document.getElementsByClassName("input-usefixer");
                for (const e of a)
                    e.classList.add("input-fixer");
                o.sleep(1).then(()=>{
                    for (const e of a)
                        e.classList.remove("input-fixer")
                }
                ),
                t && e.stopPropagation()
            }
            this.emit(s.Change, "string" == typeof e ? e : this.text),
            this.hasChanged = !0
        }
    }
    __decorate([r.Bound], u.prototype, "focus", null),
    __decorate([r.Bound], u.prototype, "blur", null),
    __decorate([r.Bound], u.prototype, "keydown", null),
    __decorate([r.Bound], u.prototype, "keyup", null),
    __decorate([r.Bound], u.prototype, "change", null),
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/InputButton", ["require", "exports", "newui/component/Button", "newui/component/IComponent", "newui/component/Input", "utilities/Async", "utilities/Objects"], function(e, t, a, i, n, o, r) {
    var s;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Change = "Change",
        e.Done = "Done"
    }(s = t.InputButtonEvent || (t.InputButtonEvent = {}));
    class l extends a.default {
        constructor(e, t) {
            super(e),
            this.classes.add("input-button"),
            this.inputElement = new n.default(this.api).setSelectable(i.SelectableLayer.Secondary).classes.add("hidden").schedule(t).appendTo(this),
            this.inputElement.on(n.InputEvent.Change, this.onInputChange),
            this.inputElement.on(n.InputEvent.Done, this.onInputDone),
            this.editMode = !1
        }
        get editMode() {
            return this._editMode
        }
        set editMode(e) {
            if (this._editMode = e,
            this.classes.toggle(e, "editing"),
            e) {
                if (this.inputElement.isVisible())
                    return;
                this.inputElement.show(),
                o.sleep(100).then(()=>{
                    const e = this.api.getVisibleScreen().visibleMenu;
                    e && e.selection.select(this.inputElement.element),
                    this.inputElement.focus()
                }
                )
            } else {
                if (!this.inputElement.isVisible())
                    return;
                this.inputElement.hide();
                const e = this.api.getVisibleScreen().visibleMenu;
                e && e.selection.selectNext(!1),
                this.inputElement.blur(),
                this.inputElement.clear()
            }
        }
        onInputChange(e, t) {
            this.classes.toggle(t.length > 0, "has-input"),
            this.emit(s.Change, t)
        }
        onInputDone(e, t) {
            this.editMode = !1,
            this.emit(s.Done, t)
        }
    }
    __decorate([r.Bound], l.prototype, "onInputChange", null),
    __decorate([r.Bound], l.prototype, "onInputDone", null),
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/Dropdown", ["require", "exports", "Enums", "mod/IHookHost", "mod/IHookManager", "newui/component/Button", "newui/component/Component", "newui/component/IComponent", "newui/component/InputButton", "newui/screen/screens/menu/component/MenuScreen", "utilities/Async", "utilities/iterable/Collectors", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    var m;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Selection = "Selection"
    }(m = t.DropdownEvent || (t.DropdownEvent = {}));
    class h extends r.default {
        constructor(e) {
            super(e),
            this.options = new Map,
            this.isFirstSelection = !0,
            this.hovered = -1,
            this.classes.add("menu-dropdown", "has-icon-after", "icon-no-scale"),
            this.inputButton = new l.default(this.api,e=>e.setSelectable(s.SelectableLayer.Quaternary)).appendTo(this).on(o.ButtonEvent.Activate, ()=>{
                this.open || this.showDropdown()
            }
            ).on(l.InputButtonEvent.Change, (e,t)=>{
                this.filter(t)
            }
            ),
            this.inputButton.playSound = !1,
            this.optionsWrapper = new r.default(this.api).classes.add("menu-dropdown-content", "nonselectable").appendTo(this.optionsWrapperWrapper = new r.default(this.api).classes.add("menu-dropdown-content-wrapper").appendTo(document.body)),
            this.on("Remove", this.optionsWrapperWrapper.remove)
        }
        get selection() {
            return this._selection
        }
        onBindLoop(e, t) {
            const i = this.api.getVisibleScreen();
            if (!i)
                return e;
            let n;
            if (i instanceof u.default)
                n = i.visibleMenu;
            else {
                if ((t.wasPressed(a.Bindable.MenuDown) || t.wasPressed(a.Bindable.MenuNext)) && !e) {
                    const t = this.options.get(this.visibleOptions[this.hovered]);
                    t && t.classes.remove("active"),
                    -1 === this.hovered || this.hovered === this.visibleOptions.length - 1 ? this.hovered = 0 : this.hovered++,
                    this.options.get(this.visibleOptions[this.hovered]).classes.add("active"),
                    e = a.Bindable.MenuDown
                }
                if ((t.wasPressed(a.Bindable.MenuUp) || t.wasPressed(a.Bindable.MenuPrevious)) && !e) {
                    const t = this.options.get(this.visibleOptions[this.hovered]);
                    t && t.classes.remove("active"),
                    -1 === this.hovered || 0 === this.hovered ? this.hovered = this.visibleOptions.length - 1 : this.hovered--,
                    this.options.get(this.visibleOptions[this.hovered]).classes.add("active"),
                    e = a.Bindable.MenuUp
                }
                if (t.wasPressed(a.Bindable.MenuEnter) && !e) {
                    const t = this.options.get(this.visibleOptions[this.hovered]);
                    t && (t.classes.remove("active"),
                    this.select(this.visibleOptions[this.hovered])),
                    this.hideDropdown(),
                    e = a.Bindable.MenuEnter
                }
                if (t.wasPressed(a.Bindable.MenuCancel) && !e) {
                    const t = this.options.get(this.visibleOptions[this.hovered]);
                    t && t.classes.remove("active"),
                    this.hideDropdown(),
                    e = a.Bindable.MenuCancel
                }
            }
            return t.wasPressed("Mouse0") ? t.isMouseWithin(this.optionsWrapper.element) || this.hideDropdown() : !t.wasPressed(a.Bindable.MenuCancel) && (!n || n.selection.getSelection() && this.contains(n.selection.getSelection())) || this.hideDropdown(),
            (t.isDown("MouseUp") || t.isDown("MouseDown")) && (t.isMouseWithin(this.optionsWrapperWrapper) || this.hideDropdown()),
            e
        }
        showDropdown() {
            this.filter(),
            this.optionsWrapperWrapper.classes.add("open"),
            this.classes.add("open"),
            this.optionsWrapper.classes.remove("nonselectable"),
            this.inputButton.editMode = !0;
            const e = this.inputButton.getBox();
            this.updateWrapperPosition(e),
            this.optionsWrapperWrapper.style.setProperty("--block-height", this.getStyle("--block-height")),
            this.optionsWrapperWrapper.style.setProperty("--text-size", this.inputButton.getStyle("--text-size")),
            this.optionsWrapperWrapper.style.setProperty("--button-text-margin-top", this.inputButton.getStyle("--button-text-margin-top")),
            d.sleep(150).then(()=>{
                this.open = !0
            }
            ),
            hookManager.register(this, "Dropdown"),
            newui.playActivateSound()
        }
        hideDropdown() {
            if (!this.open)
                return;
            const e = this.contains(document.activeElement);
            if (this.open = !1,
            this.optionsWrapperWrapper.classes.remove("open"),
            this.classes.remove("open"),
            this.optionsWrapper.classes.add("nonselectable"),
            this.inputButton.editMode = !1,
            hookManager.deregister(this, "Dropdown"),
            e) {
                const e = this.api.getVisibleScreen().visibleMenu;
                e && e.selection.select(this.inputButton.element)
            }
        }
        select(e) {
            if (void 0 !== e && this._selection !== e) {
                this._selection = e;
                const t = this.options.get(e);
                t && (this.inputButton.setText(t.getText()),
                this.emit(m.Selection, e, this.isFirstSelection),
                this.isFirstSelection = !1)
            }
        }
        selectDefault() {
            this.select(this.defaultOption)
        }
        setRefreshMethod(e) {
            return this.refreshMethod = e,
            this.refresh(),
            this
        }
        refresh() {
            this.optionsWrapper.dump(),
            this.options.clear();
            const {defaultOption: e, options: t} = this.refreshMethod();
            this.defaultOption = e;
            for (const [e,a] of t)
                this.options.set(e, new o.default(this.api).classes.add("menu-dropdown-option", "menu-option").setSelectable(s.SelectableLayer.Quaternary).on(o.ButtonEvent.Activate, ()=>{
                    this.select(e),
                    this.hideDropdown()
                }
                ).schedule(a).appendTo(this.optionsWrapper));
            return this.selectDefault(),
            this
        }
        updateWrapperPosition(e=this.inputButton.getBox() ) {
            this.optionsWrapperWrapper.style.setProperty("--x", `${e.left}px`),
            this.optionsWrapperWrapper.style.setProperty("--w", `${e.width}px`);
            const t = e.bottom > window.innerHeight / 2 + e.height / 2;
            this.optionsWrapperWrapper.classes.toggle(t, "flip"),
            this.optionsWrapperWrapper.style.setProperty("--y", `${(t ? window.innerHeight - e.bottom : e.top) + e.height}px`)
        }
        filter(e="") {
            e = e.toLowerCase();
            for (const t of this.options.values())
                if ("" === e)
                    t.classes.remove("hidden");
                else {
                    const a = t.getTextAsString();
                    t.classes.toggle(!a || !a.toLowerCase().includes(e), "hidden")
                }
            this.visibleOptions = this.options.entries().filter(([,e])=>e.isVisible()).map(([e])=>e).collect(p.default.toArray)
        }
    }
    __decorate([Override, i.HookMethod(n.HookPriority.High)], h.prototype, "onBindLoop", null),
    __decorate([c.Bound], h.prototype, "hideDropdown", null),
    t.default = h
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/BlockRow", ["require", "exports", "newui/component/Component"], function(e, t, a) {
    var i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Auto = "auto",
        e.Fill = "1fr"
    }(i = t.ColumnType || (t.ColumnType = {}));
    class n extends a.default {
        constructor(e, t) {
            super(e, t),
            this.classes.add("menu-block-row");
            const a = this.jsonData();
            a.childCount = 0,
            this.element.style.setProperty("--column-count", `${a.childCount}`),
            this.on("AddChild", ()=>{
                a.childCount++,
                this.element.style.setProperty("--column-count", `${a.childCount}`)
            }
            ),
            this.on("RemoveChild", ()=>{
                a.childCount--,
                this.element.style.setProperty("--column-count", `${a.childCount}`)
            }
            )
        }
        setColumns(...e) {
            return this.element.style.gridTemplateColumns = e.join(" "),
            this
        }
    }
    t.BlockRow = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/LabelledRow", ["require", "exports", "newui/component/BlockRow", "newui/component/Text"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.BlockRow {
        constructor(e) {
            super(e),
            this.classes.add("menu-label-row"),
            this.label = new i.Heading(this.api).classes.add("label").appendTo(this)
        }
        setLabel(e) {
            return this.label.schedule(e),
            this
        }
        dump() {
            return super.dump(e=>e !== this.label)
        }
    }
    __decorate([Override], n.prototype, "dump", null),
    t.LabelledRow = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/Dialogs", ["require", "exports"], function(e, t) {
    var a, i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Messages = 0] = "Messages",
        e[e.Notes = 1] = "Notes",
        e[e.MessagesEditFilters = 2] = "MessagesEditFilters",
        e[e.QuickSettings = 3] = "QuickSettings",
        e[e.Milestones = 4] = "Milestones",
        e[e.Skills = 5] = "Skills",
        e[e.Book = 6] = "Book",
        e[e.Map = 7] = "Map",
        e[e.Quests = 8] = "Quests"
    }(a = t.DialogId || (t.DialogId = {})),
    function(e) {
        e[e.Top = 0] = "Top",
        e[e.Right = 1] = "Right",
        e[e.Bottom = 2] = "Bottom",
        e[e.Left = 3] = "Left"
    }(i = t.Edge || (t.Edge = {}));
    const n = {
        [a.Messages]: {
            minSize: {
                x: 20,
                y: 20
            },
            size: {
                x: 35,
                y: 30
            },
            maxSize: {
                x: 40,
                y: 70
            },
            edges: [[i.Left, 1], [i.Bottom, 98]]
        },
        [a.Notes]: {
            minSize: {
                x: 20,
                y: 30
            },
            size: {
                x: 20,
                y: 35
            },
            maxSize: {
                x: 40,
                y: 60
            },
            edges: [[i.Left, 1], [i.Bottom, 68]]
        },
        [a.QuickSettings]: {
            minSize: {
                x: 15,
                y: 25
            },
            size: {
                x: 15,
                y: 35
            },
            maxSize: {
                x: 25,
                y: 50
            },
            edges: [[i.Left, 21], [i.Bottom, 68]]
        },
        [a.Milestones]: {
            minSize: {
                x: 14,
                y: 20
            },
            size: {
                x: 14,
                y: 30
            },
            maxSize: {
                x: 20,
                y: 70
            },
            edges: [[i.Left, 36], [i.Bottom, 98]]
        },
        [a.Skills]: {
            minSize: {
                x: 14,
                y: 20
            },
            size: {
                x: 14,
                y: 30
            },
            maxSize: {
                x: 20,
                y: 70
            },
            edges: [[i.Left, 50], [i.Bottom, 98]]
        },
        [a.MessagesEditFilters]: {
            minSize: {
                x: 10,
                y: 15
            },
            size: {
                x: 10,
                y: 30
            },
            maxSize: {
                x: 25,
                y: 50
            },
            edges: [[i.Left, 45], [i.Bottom, 35]]
        },
        [a.Book]: {
            minSize: {
                x: 20,
                y: 30
            },
            size: {
                x: 28,
                y: 35
            },
            maxSize: {
                x: 40,
                y: 60
            },
            edges: [[i.Left, 36], [i.Bottom, 68]],
            saveOpen: !1
        },
        [a.Quests]: {
            minSize: {
                x: 18,
                y: 30
            },
            size: {
                x: 20,
                y: 40
            },
            maxSize: {
                x: 25,
                y: 80
            },
            edges: [[i.Left, 40], [i.Bottom, 70]]
        },
        [a.Map]: {
            minSize: {
                x: 16,
                y: 0
            },
            size: {
                x: 20,
                y: 0
            },
            maxSize: {
                x: 30,
                y: 100
            },
            edges: [[i.Left, 40], [i.Bottom, 68]],
            square: !0,
            saveOpen: !1
        }
    };
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/component/StaticComponent", ["require", "exports", "newui/component/Component"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        constructor(e) {
            super(e),
            this.classes.add("game-static")
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/component/QuadrantComponent", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/ContextMenu", "newui/screen/screens/game/component/StaticComponent", "utilities/enum/Enums", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u) {
    var d, p, c;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.None = 0] = "None",
        e[e.TopLeft = 1] = "TopLeft",
        e[e.Top = 2] = "Top",
        e[e.TopRight = 3] = "TopRight",
        e[e.BottomRight = 4] = "BottomRight",
        e[e.Bottom = 5] = "Bottom",
        e[e.BottomLeft = 6] = "BottomLeft"
    }(d = t.Quadrant || (t.Quadrant = {})),
    function(e) {
        e.ChangeQuadrant = "ChangeQuadrant",
        e.GetQuadrantElementList = "GetQuadrantElementList"
    }(p = t.QuadrantComponentEvent || (t.QuadrantComponentEvent = {}));
    class m extends r.default {
        constructor(e) {
            super("uiApi"in e ? e.uiApi : e),
            "uiApi"in e && (this.gsapi = e),
            this.classes.add("game-quadrant"),
            this.setContextMenu(this.getContextMenu)
        }
        get preferredQuadrant() {
            return d.None
        }
        setQuadrant(e, t=!0) {
            const a = d[this.dataset.quadrant];
            a !== e && (this.dataset.quadrant = d[e],
            t && this.emit(p.ChangeQuadrant, e, a))
        }
        getContextMenuDescription() {
            return [[c.MoveTo, {
                translation: ()=>n.default.ui(i.default.GameQuadrantElementContextMenuMoveTo).get(this.getName()),
                submenu: e=>s.default.values(d).map(e=>l.tuple(e, {
                    translation: new n.default(a.Dictionary.UiQuadrant,e),
                    onActivate: ()=>{
                        this.setQuadrant(e)
                    }
                })).collect(t=>new o.default(e,...t)).addAllDescribedOptions().removeOptions(d.None).disableOptions(d[this.dataset.quadrant], d.TopRight)
            }], [c.SwitchWith, {
                translation: n.default.ui(i.default.GameQuadrantElementContextMenuSwitchWith),
                submenu: e=>this.emit(p.GetQuadrantElementList)[0].map(e=>l.tuple(e.getID(), {
                    translation: ()=>e.getName(),
                    onActivate: ()=>{
                        const t = d[e.dataset.quadrant];
                        this.setQuadrant(t)
                    }
                })).collect(t=>new o.default(e,...t)).addAllDescribedOptions().disableOptions(this.getID(), 2)
            }]]
        }
        getContextMenu() {
            const e = this.getContextMenuDescription();
            if (e.length)
                return new o.default(this.api,...e).addAllDescribedOptions()
        }
    }
    __decorate([u.Bound], m.prototype, "getContextMenu", null),
    t.default = m,
    function(e) {
        e[e.SwitchWith = 0] = "SwitchWith",
        e[e.MoveTo = 1] = "MoveTo"
    }(c || (c = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/IRequirement", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.SailToCivilization = 0] = "SailToCivilization",
        e[e.CollectItem = 1] = "CollectItem",
        e[e.KillCreature = 2] = "KillCreature",
        e[e.KillCreatures = 3] = "KillCreatures",
        e[e.LearnSkill = 4] = "LearnSkill",
        e[e.LearnSkills = 5] = "LearnSkills",
        e[e.LearnAnySkill = 6] = "LearnAnySkill",
        e[e.Equip = 7] = "Equip",
        e[e.Craft = 8] = "Craft",
        e[e.Dismantle = 9] = "Dismantle",
        e[e.Build = 10] = "Build",
        e[e.TameCreature = 11] = "TameCreature",
        e[e.TameCreatures = 12] = "TameCreatures"
    }(a = t.RequirementType || (t.RequirementType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/quest/IQuest", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Challenge = 0] = "Challenge"
    }(a = t.QuestType || (t.QuestType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/Requirement", ["require", "exports", "language/Dictionaries", "language/Translation", "utilities/Emitter"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o extends n.default {
        constructor(e) {
            super(),
            this.defaultData = e,
            this.triggers = new Map,
            this.hostTriggers = new Map
        }
        setTrigger(e, t) {
            return this.triggers.set(e, t),
            this
        }
        getTriggers() {
            return this.triggers.entries()
        }
        setHostTrigger(e, t) {
            return this.hostTriggers.set(e, t),
            this
        }
        getHostTriggers() {
            return this.hostTriggers.entries()
        }
        setInitializeTrigger(e) {
            return this.initializeTrigger = e,
            this
        }
        getInitializeTrigger() {
            return this.initializeTrigger
        }
        setRelations(e) {
            return this.relationsHandler = Array.isArray(e) ? ()=>e : e,
            this
        }
        getRelations(e) {
            return this.relationsHandler ? this.relationsHandler(e) : []
        }
        setTranslation(e) {
            return this.translation = e,
            this
        }
        getTranslation(e) {
            const t = this.translation;
            return t ? "function" == typeof t ? t(e) : t : new i.default(a.Dictionary.QuestRequirement,e.requirement.type)
        }
        setCompletionAmountGetter(e) {
            return this.completionAmountGetter = e,
            this
        }
        getCompletionAmount(e) {
            return this.completionAmountGetter ? this.completionAmountGetter(e) : e.requirement.completed ? 1 : 0
        }
        validateOptions(...e) {
            return 0 === e.length
        }
    }
    t.Requirement = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/helpers/IsItemMatch", ["require", "exports"], function(e, t) {
    function a(e, t) {
        for (const a of t)
            if (itemManager.isGroup(a)) {
                if (itemManager.isInGroup(e, a))
                    return !0
            } else if (e === a)
                return !0;
        return !1
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/BuildRequirement", ["require", "exports", "Enums", "language/Dictionaries", "language/Translation", "mod/IHookManager", "newui/component/IComponent", "player/quest/requirement/helpers/IsItemMatch", "player/quest/requirement/Requirement", "utilities/iterable/Generators"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new l.Requirement({}).setTrigger(o.Hook.OnBuild, (e,t,a,i,n)=>{
        if (t !== e.host)
            return !1;
        const [o] = e.requirement.options;
        return !!s.default(a.type, o)
    }
    ).setRelations(e=>{
        const [t] = e.requirement.options;
        return [...t.map(e=>u.tuple(r.HighlightType.Selector, itemManager.isGroup(e)?`#inventory li.group-${a.ItemTypeGroup[e]}`:`#inventory li[data-item-type="${e}"]`))]
    }
    ).setTranslation(e=>{
        const [t] = e.requirement.options
          , a = t.map(e=>itemManager.isGroup(e) ? itemManager.getItemTypeGroupName(e) : n.default.nameOf(i.Dictionary.Item, e)).collect(n.default.formatList, 2);
        return new n.default(i.Dictionary.QuestRequirement,e.requirement.type).addArgs(a)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/CollectItemRequirement", ["require", "exports", "language/Dictionaries", "language/Translation", "mod/IHookManager", "player/quest/requirement/helpers/IsItemMatch", "player/quest/requirement/IRequirement", "player/quest/requirement/Requirement"], function(e, t, a, i, n, o, r, s) {
    function l(e, t) {
        return e.inventory.containedItems.filter(e=>o.default(e.type, t)).length
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new s.Requirement({}).setTrigger(n.Hook.OnInventoryItemAdd, (e,t,a)=>{
        const [i,n] = e.requirement.options;
        return !(t !== e.host || !o.default(a.type, i)) && (e.updated = !0,
        l(t, i) >= n)
    }
    ).setTrigger(n.Hook.OnInventoryItemRemove, (e,t,a)=>{
        const [i] = e.requirement.options;
        return !(t !== e.host || !o.default(a.type, i)) && (e.updated = !0,
        !1)
    }
    ).setTrigger(n.Hook.OnInventoryItemUpdate, (e,t,a)=>{
        const [i,n] = e.requirement.options;
        return !(t !== e.host || !o.default(a.type, i)) && (e.updated = !0,
        l(t, i) >= n)
    }
    ).setInitializeTrigger(e=>{
        const [t,a] = e.requirement.options;
        return l(e.host, t) >= a
    }
    ).setTranslation(e=>{
        const [t,n] = e.requirement.options
          , o = t.map(e=>itemManager.isGroup(e) ? itemManager.getItemTypeGroupName(e) : i.default.nameOf(a.Dictionary.Item, e, n)).collect(i.default.formatList, 2);
        return new i.default(a.Dictionary.QuestRequirement,r.RequirementType.CollectItem).addArgs(o, e.requirement.completed ? n : l(e.host, t), n)
    }
    ).setCompletionAmountGetter(e=>{
        const [t,a] = e.requirement.options;
        return e.requirement.completed ? 1 : l(e.host, t) / a
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/menubar/MenuBarButtonDescriptions", ["require", "exports", "Enums", "game/Difficulty", "language/dictionary/UiTranslation", "newui/BindingManager", "newui/screen/screens/game/Dialogs", "newui/screen/screens/menu/component/IMenu"], function(e, t, a, i, n, o, r, s) {
    var l, u;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Menu = 0] = "Menu",
        e[e.Save = 1] = "Save",
        e[e.Help = 2] = "Help",
        e[e.QuickSettings = 3] = "QuickSettings",
        e[e.Milestones = 4] = "Milestones",
        e[e.Notes = 5] = "Notes",
        e[e.Quests = 6] = "Quests",
        e[e.Messages = 7] = "Messages",
        e[e.Actions = 8] = "Actions",
        e[e.Inventory = 9] = "Inventory",
        e[e.Crafting = 10] = "Crafting",
        e[e.Equipment = 11] = "Equipment",
        e[e.Skills = 12] = "Skills"
    }(l = t.MenuBarButtonType || (t.MenuBarButtonType = {})),
    function(e) {
        e[e.Meta = 0] = "Meta",
        e[e.World = 1] = "World"
    }(u = t.MenuBarButtonGroup || (t.MenuBarButtonGroup = {}));
    const d = {
        [l.Menu]: {
            group: u.Meta,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.GamePause,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipMenu)),
            onActivate() {
                newui.interrupt().withMenu(s.MenuId.Pause)
            }
        },
        [l.Save]: {
            group: u.Meta,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.GameSave,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipSave)),
            async onActivate() {
                game.getDifficulty() !== i.Difficulty.Challenge && await newui.interrupt(n.default .GameInterruptLoadingSaving).withDescription(n.default .GameInterruptLoadingSavingDescription).withLoading(game.saveGame(a.SaveType.InGame))
            },
            onCreate(e) {
                e.toggle(game.getDifficulty() !== i.Difficulty.Challenge)
            }
        },
        [l.Help]: {
            group: u.Meta,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.DialogHelp,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipHelp)),
            onActivate() {
                newui.interrupt().withMenu(s.MenuId.Help)
            }
        },
        [l.QuickSettings]: {
            group: u.Meta,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.DialogOptions,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipQuickSettings)),
            onActivate(e) {
                e.toggleDialog(r.DialogId.QuickSettings)
            }
        },
        [l.Milestones]: {
            group: u.Meta,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.DialogMilestones,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipMilestones)),
            onActivate(e) {
                e.toggleDialog(r.DialogId.Milestones)
            }
        },
        [l.Notes]: {
            group: u.World,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.DialogNotes,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipNotes)),
            onActivate(e) {
                e.toggleDialog(r.DialogId.Notes)
            }
        },
        [l.Quests]: {
            group: u.World,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.DialogQuests,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipQuests)),
            onActivate(e) {
                localPlayer.quests.getQuests().length && e.toggleDialog(r.DialogId.Quests)
            },
            onCreate(e) {
                localPlayer.quests.getQuests().length || (e.setDisabled(),
                localPlayer.quests.once(1, ()=>e.setDisabled(!1)))
            }
        },
        [l.Messages]: {
            group: u.World,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.DialogMessages,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipMessages)),
            onActivate(e) {
                e.toggleDialog(r.DialogId.Messages)
            }
        },
        [l.Actions]: {
            group: u.World,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.GameActions,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipActions)),
            onActivate() {
                const e = o.bindingManager.isPressed(a.Bindable.GameActions);
                if (e && !o.bindingManager.isMouseWithin(document.getElementById("game"), !0))
                    return !1;
                const t = ui.screenInGame;
                return t.toggleActionsMenu(!e),
                !0
            }
        },
        [l.Inventory]: {
            group: u.World,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.DialogInventory,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipInventory)),
            onActivate() {
                const e = ui.screenInGame;
                e.toggleDialog(e.elementDialogInventory)
            }
        },
        [l.Crafting]: {
            group: u.World,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.DialogCrafting,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipCrafting)),
            onActivate() {
                const e = ui.screenInGame;
                e.toggleCraftingTab("crafting", !0)
            }
        },
        [l.Equipment]: {
            group: u.World,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.DialogEquipment,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipEquipment)),
            onActivate() {
                const e = o.bindingManager.getMouse();
                if (document.elementFromPoint(e.x, e.y).classList.contains("item"))
                    return;
                const t = ui.screenInGame;
                t.toggleDialog(t.elementDialogEquipment)
            }
        },
        [l.Skills]: {
            group: u.World,
            imageWidth: 12,
            imageHeight: 12,
            bindable: a.Bindable.DialogSkills,
            tooltip: e=>e.addText(e=>e.setText(n.default.GameMenuBarButtonTooltipSkills)),
            onActivate(e) {
                e.toggleDialog(r.DialogId.Skills)
            }
        }
    };
    t.default = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/CraftRequirement", ["require", "exports", "language/Dictionaries", "language/Translation", "mod/IHookManager", "newui/component/IComponent", "newui/screen/screens/game/static/menubar/MenuBarButtonDescriptions", "player/quest/requirement/helpers/IsItemMatch", "player/quest/requirement/Requirement"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new l.Requirement({
        crafted: 0
    }).setTrigger(n.Hook.OnCraft, (e,t,a)=>{
        if (t !== e.host)
            return !1;
        const [i,n] = e.requirement.options;
        return !!s.default(a.type, i) && (e.requirement.data.crafted++,
        e.updated = !0,
        e.requirement.data.crafted >= n)
    }
    ).setRelations(e=>{
        const [t] = e.requirement.options;
        return [[o.HighlightType.MenuBarButton, r.MenuBarButtonType.Crafting], [o.HighlightType.Selector, `#container-crafting li[data-item-type="${t}"]`]]
    }
    ).setTranslation(e=>{
        const [t,n] = e.requirement.options
          , o = t.map(e=>itemManager.isGroup(e) ? itemManager.getItemTypeGroupName(e) : i.default.nameOf(a.Dictionary.Item, e, n)).collect(i.default.formatList, 2);
        return new i.default(a.Dictionary.QuestRequirement,e.requirement.type).addArgs(o, e.requirement.completed ? n : e.requirement.data.crafted, n)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Dismantle", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "item/Items", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>{
        const a = r.itemDescriptions[t.type];
        if (!a)
            return !1;
        const i = a.dismantle;
        if (!i)
            return !1;
        const n = i.required;
        if (!n)
            return !0;
        const o = itemManager.getItemForHuman(e.executor, n);
        return o ? (e.addItems(o),
        !0) : (p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.DismantlingRequires, t.getName(), u.default.nameOf(s.Dictionary.ItemGroup, n)),
        !1)
    }
    ).setHandler((e,t)=>{
        if (void 0 === t.minDur || void 0 === t.maxDur)
            return;
        e.setDelay(25);
        const a = e.executor.getTile()
          , i = c.default[m.default.getType(a)];
        if (i && i.water)
            return void p.default.get(e.executor).source(d.Source.Action).send(l.default.CannotInWater, u.default.message(l.default.Dismantle));
        const n = r.itemDescriptions[t.type];
        if (!n)
            return;
        const s = n.dismantle;
        if (!s)
            return;
        const h = t.minDur / t.maxDur;
        let y, g, f = 0;
        p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.YouDismantled, t.getName());
        const T = s.items
          , S = [];
        let I = o.SkillType.Tinkering;
        n.dismantle && n.dismantle.skill ? I = n.dismantle.skill : n.recipe && void 0 !== n.recipe.skill && (I = n.recipe.skill);
        const v = e.executor.getSkill(I);
        for (const a of T)
            for (let i = 0; i < a[1]; i++) {
                const i = itemManager.getQualityBasedOnSkill(t.quality, v);
                if (void 0 !== (g = itemManager.createFake(a[0], i)).minDur) {
                    if ((y = Math.floor(g.minDur * h)) <= 0) {
                        if (f++,
                        T.length !== f)
                            continue;
                        y = 0
                    }
                    void 0 !== (g = itemManager.create(a[0], t.containedWithin, i)).minDur && (y = Math.floor(g.minDur * h),
                    g.minDur = y,
                    ui.updateItem(g),
                    p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.YouSeparate, g.getName()),
                    S.push(g))
                }
            }
        itemManager.reduceDismantleWeight(S, t.weight),
        f >= 1 && p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.MaterialsDestroyed, u.default.message(l.default.Dismantling)),
        itemManager.remove(t),
        e.setItemsUsed(),
        n.dismantle && n.dismantle.reputation ? e.setReputationChange(n.dismantle.reputation) : n.recipe && n.recipe.reputation && e.setReputationChange(-1 * n.recipe.reputation),
        e.addSkillGains(I, .1),
        e.setStaminaReduction(I),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect(o.SfxType.Craft)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/DismantleRequirement", ["require", "exports", "action/IAction", "language/Dictionaries", "language/Translation", "mod/IHookManager", "newui/component/IComponent", "newui/screen/screens/game/static/menubar/MenuBarButtonDescriptions", "player/quest/requirement/helpers/IsItemMatch", "player/quest/requirement/Requirement", "utilities/iterable/Generators"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new u.Requirement({
        dismantled: 0
    }).setTrigger(o.Hook.PostExecuteAction, (e,t,i,n)=>{
        if (t.executor !== e.host || i.type !== a.ActionType.Dismantle)
            return !1;
        const [o,r] = e.requirement.options
          , [s] = n;
        return !!l.default(s.type, o) && (!itemManager.exists(s) && (e.requirement.data.dismantled++,
        e.updated = !0,
        e.requirement.data.dismantled >= r))
    }
    ).setRelations(e=>{
        const [t] = e.requirement.options;
        return [[r.HighlightType.MenuBarButton, s.MenuBarButtonType.Crafting], ...t.map(e=>d.tuple(r.HighlightType.Selector, `#container-dismantle li[data-item-type="${e}"]`))]
    }
    ).setTranslation(e=>{
        const [t,a] = e.requirement.options
          , o = t.map(e=>itemManager.isGroup(e) ? itemManager.getItemTypeGroupName(e) : n.default.nameOf(i.Dictionary.Item, e, a)).collect(n.default.formatList, 2);
        return new n.default(i.Dictionary.QuestRequirement,e.requirement.type).addArgs(o, e.requirement.completed ? a : e.requirement.data.dismantled, a)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/EquipRequirement", ["require", "exports", "Enums", "language/Dictionaries", "language/Translation", "mod/IHookManager", "newui/component/IComponent", "player/quest/requirement/Requirement", "utilities/iterable/Generators"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new s.Requirement({}).setTrigger(o.Hook.OnItemEquip, (e,t,a,i)=>{
        if (t !== e.host)
            return !1;
        const [n,o] = e.requirement.options;
        return n.includes(i) && o.some(e=>itemManager.isInGroup(a.type, e))
    }
    ).setInitializeTrigger(e=>{
        const [t,a] = e.requirement.options;
        for (const i of t) {
            const t = e.host.getEquippedItem(i);
            if (t && a.some(e=>itemManager.isInGroup(t.type, e)))
                return !0
        }
        return !1
    }
    ).setRelations(e=>{
        const [t,i] = e.requirement.options
          , n = [...t.map(e=>`#equipment ul[data-equip-slot="${a.EquipType[e]}"]`), ...i.map(e=>`#inventory li.group-${a.ItemTypeGroup[e]}`)];
        return n.map(e=>l.tuple(r.HighlightType.Selector, e))
    }
    ).setTranslation(e=>{
        const [t,a] = e.requirement.options
          , o = t.map(e=>new n.default(i.Dictionary.EquipSlot,e)).collect(n.default.formatList, 2)
          , r = a.map(e=>itemManager.getItemTypeGroupName(e)).collect(n.default.formatList, 2);
        return new n.default(i.Dictionary.QuestRequirement,e.requirement.type).addArgs(r, o)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/TilePosition", ["require", "exports"], function(e, t) {
    function a(e, t, a) {
        return e + 512 * t + 512 * a * 512
    }
    function i(e) {
        return [e % 512, Math.floor(e / 512) % 512, Math.floor(e / 512 / 512)]
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.getTileId = a,
    t.getTilePosition = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("doodad/doodads/Doodad", ["require", "exports", "creature/ICreature", "doodad/Doodads", "entity/Entity", "entity/IEntity", "Enums", "game/IGame", "game/inspection/IInspection", "item/Items", "item/LootGroups", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Misc", "language/dictionary/Note", "language/Translation", "mod/IHookManager", "multiplayer/IMultiplayer", "player/IMessageManager", "player/MessageManager", "player/note/NoteManager", "save/ISerializer", "tile/ITileEvent", "tile/Terrains", "utilities/math/Math2", "utilities/math/Vector3", "utilities/Random", "utilities/TileHelpers", "utilities/TilePosition"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class P {
        constructor(e, t=0, a=0, i=0, n={}) {
            if (void 0 === e)
                return;
            this.type = e,
            this.x = t,
            this.y = a,
            this.z = i,
            Object.assign(this, n);
            const o = this.description();
            if (!o)
                return;
            const s = this;
            if (void 0 !== o.weightCapacity && (s.containedItems = [],
            delete s.containedWithin,
            s.weightCapacity = o.weightCapacity),
            void 0 !== this.quality && this.quality !== r.ItemQuality.Random || (this.quality = game.getRandomQuality()),
            void 0 === this.decay && o.decayMax && (-1 === o.decayMax ? this.decay = o.decayMax : this.decay = o.decayMax + C.default.int(Math.floor(o.decayMax / 15))),
            void 0 === this.maxDur) {
                const t = this.getPickupTypes();
                if (t)
                    if (e === r.DoodadType.LockedWoodenChest)
                        this.maxDur = 25;
                    else {
                        const e = u.default[t[0]];
                        e && e.durability ? this.maxDur = e.durability : this.maxDur = this.getDefaultDurability()
                    }
                else
                    o.canGrow && (this.maxDur = this.getDefaultDurability());
                o.isTree || (this.maxDur = game.getMaxDurability(this.quality, this.maxDur ? this.maxDur : this.getDefaultDurability()))
            }
            if (void 0 === this.minDur && (this.minDur = this.maxDur),
            void 0 === this.weight) {
                const e = this.getPickupTypes();
                if (e && 1 === e.length) {
                    const t = u.default[e[0]];
                    t && t.weight ? this.weight = t.weight : this.weight = itemManager.getWeight(e[0])
                }
            }
            void 0 === this.gfx && o.canGrow && this.setGrowingStage(r.GrowingStage.Seedling)
        }
        static getGrowingStageTranslation(e, t) {
            if (void 0 === e || void 0 === t)
                return;
            const a = t.isFungi ? p.Dictionary.GrowthFungus : p.Dictionary.Growth;
            return new y.default(a,e)
        }
        static getRegistrarId() {
            return this.registrarId
        }
        static setRegistrarId(e) {
            this.registrarId = e
        }
        getRegistrarId() {
            return this.type
        }
        getName(e, t) {
            const a = this.getNameTranslation(e, t);
            if (this.quality && a.addReformatter(new y.default(p.Dictionary.Misc,m.MiscTranslation.ItemQuality).addArgs(r.ItemQuality[this.quality].toLowerCase()), !0),
            this.legendary && this.quality === r.ItemQuality.Legendary) {
                const {type: e, skill: t, stat: i} = this.legendary
                  , n = void 0 !== t ? new y.default(p.Dictionary.Skill,t) : void 0 !== i ? new y.default(p.Dictionary.Stat,i) : void 0;
                a.addReformatter(new y.default(p.Dictionary.Misc,m.MiscTranslation.ItemLegendary).addArgs(new y.default(p.Dictionary.LegendaryType,e).addArgs(n)))
            }
            return this.quality && a.addReformatter(new y.default(p.Dictionary.Misc,m.MiscTranslation.ItemQualityColor).addArgs(r.ItemQuality[this.quality].toLowerCase())),
            a
        }
        description() {
            return this._description || (this._description = i.default[this.type]),
            this._description
        }
        inspect({context: e, inspectFire: t}, a) {
            a.border = this.quality ? `var(--item-quality-${r.ItemQuality[this.quality].toLowerCase()})` : void 0,
            a.add({
                title: !0,
                name: !0,
                text: this.getName()
            }),
            this.quality && this.renamed && a.add(new y.default(p.Dictionary.Misc,m.MiscTranslation.ItemQualityColor).addArgs(r.ItemQuality[this.quality].toLowerCase(), new y.default(p.Dictionary.ItemQuality,this.quality).inContext(3))),
            a.add(this.getDescriptionTranslation().setFailWith(""));
            const i = P.getGrowingStageTranslation(this.getGrowingStage(), this.description());
            i && a.add(y.default.message(this.getGrowingStage() === r.GrowingStage.Dead ? c.default.PlantIsDead : c.default.PlantIsInStage).inContext(4).addArgs(y.default.message(c.default.ThePlant), i));
            const n = this.description();
            n && n.weightCapacity && itemManager.isContainer(this) && a.addExtra(y.default.message(e === l.InspectionContext.Tooltip ? c.default.WeightCapacity : c.default.ItsWeightCapacity).addArgs(b.default.roundNumber(itemManager.computeContainerWeight(this), 1), this.weightCapacity)),
            itemManager.isContainer(this) && this.containedItems.length && a.addExtra(y.default.message(c.default.ItContains).addArgs(itemManager.getItemTranslations(this.containedItems).collect(y.default.formatList)));
            const o = this.inspectGrowth();
            if (a.addExtra(o && y.default.message(o).inContext(4).addArgs(y.default.message(c.default.ThePlant))),
            n)
                if (n.providesFire && void 0 !== this.decay)
                    a.addExtra(t(this.decay));
                else if (n.canGrow && void 0 !== this.spread) {
                    if (n.spreadMax) {
                        const e = this.inspectFertility();
                        a.addExtra(e && y.default.message(e).addArgs(y.default.message(c.default.ThePlant).inContext(4)))
                    }
                } else
                    n.isWaterSource && (void 0 !== this.decay && this.decay > 0 && a.addExtra(y.default.message(c.default.UnpurifiedWaterInStill)),
                    this.gatherReady && a.addExtra(y.default.message(c.default.PurifiedWaterInStill)));
            this.minDur && this.maxDur && a.addExtra(y.default.message(this.inspectDurability()).inContext(4).addArgs(y.default.message(c.default.It)))
        }
        changeType(e) {
            this.type = e,
            this._description = i.default[e]
        }
        isValid() {
            return this.getTile().doodad === this
        }
        getTile() {
            return game.getTileFromPoint(this)
        }
        canGrow() {
            const e = this.description();
            return !!e && (this.z === r.WorldZ.Cave ? !0 === e.canGrowInCaves : !0 === e.canGrow)
        }
        getGrowingStage() {
            if (void 0 !== this.gfx)
                return this.gfx < 3 ? r.GrowingStage.Germinating : this.gfx < 6 ? r.GrowingStage.Seedling : this.gfx < 9 ? r.GrowingStage.Vegetative : this.gfx < 12 ? r.GrowingStage.Budding : this.gfx < 15 ? r.GrowingStage.Flowering : this.gfx < 18 ? r.GrowingStage.Ripening : r.GrowingStage.Dead
        }
        setGrowingStage(e, t) {
            const a = this.description();
            a && a.canGrow && (this.gfx = 3 * e + C.default.int(3)),
            t && world.updateTile(this.x, this.y, this.z, this.getTile())
        }
        canPickup(e) {
            const t = this.description();
            if (!t)
                return !1;
            const a = this.getPickupTypes();
            return !!a && !1 !== modManager.getHook(g.Hook.CanPickupDoodad).call(e, this)
        }
        getPickupTypes() {
            const e = this.description();
            if (e)
                return e.pickUp
        }
        getActions() {}
        canGather() {
            const e = this.description();
            if (!e || !e.gather)
                return !1;
            const t = this.getGrowingStage();
            return void 0 !== t && void 0 !== e.gather[t]
        }
        isGatherable() {
            const e = this.description()
              , t = this.getGrowingStage();
            return !(!e || !e.gather || void 0 === t)
        }
        isEmbers() {
            const e = this.description();
            return !!e && !!(e.providesFire && void 0 !== this.decay && this.decay <= 200)
        }
        getDoodadInfo() {}
        canHarvest() {
            const e = this.description();
            if (!e || !e.harvest)
                return !1;
            const t = this.getGrowingStage();
            return void 0 !== t && void 0 !== e.harvest[t]
        }
        canTrample() {
            const e = this.description()
              , t = this.getGrowingStage();
            return void 0 !== t && e && (e.canTrampleWhenMature && t >= r.GrowingStage.Budding || t > r.GrowingStage.Germinating && t < r.GrowingStage.Budding)
        }
        checkForTrampling(e) {
            const t = C.default.percent();
            if (this.canTrample()) {
                const a = this.description()
                  , i = n.default.is(e, o.EntityType.Player);
                let s = 0;
                if (i) {
                    const e = a.skillUse;
                    if (e) {
                        const t = game.getSkillPercent(e);
                        void 0 !== t && t > 0 && (s = Math.floor(t / 10))
                    }
                }
                if (n.default.is(e, o.EntityType.Creature)) {
                    const i = e
                      , n = i.description();
                    if (n) {
                        if (n.helpPlants) {
                            if (i.isTamed() && (s = 10),
                            t - s <= 10) {
                                const t = this.getGrowthParticles();
                                t && game.particle.create(this.x, this.y, this.z, t);
                                const i = this.getGrowingStage();
                                a.canGrow && void 0 !== this.minDur && void 0 !== this.maxDur && this.minDur < this.maxDur && i !== r.GrowingStage.Dead && this.minDur++,
                                void 0 !== i && i < r.GrowingStage.Ripening && void 0 !== this.decay && (this.decay -= 20,
                                this.decay < 0 && (this.decay = 0)),
                                S.default.toAll(t=>t.ifVisible(this).source(T.Source.Action).type(S.MessageType.Good).send(c.default.YouSeeHelpingPlant, e.getName(), this.getName()))
                            }
                            return !1
                        }
                        if (!n.canTrample)
                            return !1
                    }
                    i.isHidden() && (i.ai |= o.AiType.Hostile,
                    i.ai &= ~o.AiType.Hidden)
                }
                if (t + s <= 30) {
                    const t = this.getGrowthParticles();
                    return t && game.particle.create(this.x, this.y, this.z, t),
                    void 0 !== this.minDur && this.minDur <= 1 ? i ? S.default.get(e).source(T.Source.Action).type(S.MessageType.Bad).send(c.default.TrampleIntoGround, this.getName()) : S.default.toAll(t=>t.ifVisible(this).source(T.Source.Action).type(S.MessageType.Bad).send(c.default.TrampledIntoGround, e.getName(), this.getName())) : i ? S.default.get(e).source(T.Source.Action).type(S.MessageType.Bad).send(c.default.Trampling, this.getName()) : S.default.toAll(t=>t.ifVisible(this).source(T.Source.Action).type(S.MessageType.Bad).send(c.default.YouSeeTrampling, e.getName(), this.getName())),
                    this.damage(!1, !0),
                    !0
                }
            }
            return !1
        }
        isDangerous(e) {
            const t = this.description();
            if (!t)
                return !1;
            const a = this.getGrowingStage();
            return !!(t.providesFire && e.getBurnDamage(!0, r.EquipType.Feet) >= 1 && !t.blockMove || t.damage && this.getDamage(e, r.EquipType.Feet) >= 1 && !t.blockMove && (!t.canGrow || t.canGrow && void 0 !== a && a >= r.GrowingStage.Budding) || this.canCauseStatus(e, r.EquipType.Feet) || t.isTrap)
        }
        getDamage(e, t) {
            const a = this.description();
            if (!a)
                return 0;
            let i = (a.damage ? a.damage : 0) + e.getMaxHealth() / 15;
            if (void 0 !== t) {
                const a = e.getEquippedItem(t);
                a && (i -= a.getBaseDefense() + 2)
            } else
                i -= Math.floor(e.defense.base / 3);
            return i
        }
        getOwner() {
            const e = this.ownerIdentifier ? game.getPlayerByIdentifier(this.ownerIdentifier) : void 0;
            return multiplayer.isConnected() ? e : e || localPlayer
        }
        damage(e=!1, t=!1, a=!1, n=!1) {
            if (void 0 !== this.minDur) {
                if (this.minDur <= 1 || e) {
                    const e = this.description();
                    if (void 0 !== this.hitchedCreature) {
                        const e = game.creatures[this.hitchedCreature];
                        e && (e.hitchedTo = void 0)
                    }
                    let a = this.getPickupTypes();
                    if (void 0 === a && e && e.revert) {
                        const t = i.default[e.revert];
                        t && t.pickUp && (a = t.pickUp)
                    }
                    if (a && !t) {
                        const e = itemManager.create(a[0], itemManager.getTileContainer(this.x, this.y, this.z), this.quality);
                        e.minDur = this.minDur - 1,
                        e.maxDur = this.maxDur,
                        void 0 !== this.ownerIdentifier && (e.ownerIdentifier = this.ownerIdentifier)
                    }
                    if (this.type === r.DoodadType.LockedWoodenChest && this.addTreasureChestLoot(),
                    e) {
                        const e = this;
                        itemManager.isContainer(e) && itemManager.placeItemsAroundLocation(e, this.x, this.y, this.z, !1)
                    }
                    const o = this.getGrowingStage();
                    if (void 0 !== o && e) {
                        if (!n && e.gather) {
                            const t = e.gather[o];
                            if (t)
                                for (let e = void 0 !== this.step ? this.step : 0; e < t.length; e++)
                                    if (t[e]) {
                                        const a = void 0 !== t[e].chance ? t[e].chance : 100
                                          , i = void 0 !== t[e].chanceOutOf ? t[e].chanceOutOf : 100;
                                        if (void 0 !== a && C.default.percent(0, i) > a || 100 === a) {
                                            if (t[e].type === r.ItemType.PlantRoots)
                                                continue;
                                            const a = itemManager.getQualityBasedOnSkill(this.quality, 0, !0)
                                              , i = itemManager.create(t[e].type, itemManager.getTileContainer(this.x, this.y, this.z), a);
                                            i.minDur = 0
                                        }
                                    }
                        }
                        if (e.isTree && o !== r.GrowingStage.Dead && o >= r.GrowingStage.Budding)
                            return this.setGrowingStage(r.GrowingStage.Dead, !0),
                            this.spread = void 0,
                            void (this.step = void 0)
                    }
                    doodadManager.remove(this)
                } else
                    this.minDur--;
                a || audio.queueEffect(t ? r.SfxType.Trample : r.SfxType.Hit, this.x, this.y, this.z)
            }
        }
        getDefaultDurability() {
            return 7 - C.default.int(3)
        }
        addTreasureChestLoot() {
            this.changeType(r.DoodadType.WoodenChest);
            const e = this
              , t = this.getTile();
            e.containedItems = [],
            delete e.containedWithin;
            const a = i.default[r.DoodadType.WoodenChest];
            let n, o;
            a && (e.weightCapacity = a.weightCapacity),
            world.updateTile(this.x, this.y, this.z, t),
            o = this.treasure ? [r.LootGroupType.High, r.LootGroupType.Treasure, r.LootGroupType.CaveChest] : [r.LootGroupType.Low, r.LootGroupType.High, r.LootGroupType.CaveChest, r.LootGroupType.CaveChest];
            const s = 3 + C.default.int(3);
            for (let e = 0; e <= s; e++) {
                const e = C.default.int(o.length)
                  , t = d.default[o[e]];
                if (t) {
                    n = C.default.getElement(t);
                    const e = itemManager.getRandomQuality(n, 200);
                    itemManager.create(n, this, e)
                }
            }
        }
        blocksMove() {
            const e = this.description();
            if (!e || void 0 !== e.weightCapacity || e.isLocked || e.providesFire)
                return !0;
            if (e.blockMove && !e.isLocked) {
                const e = this.getGrowingStage();
                if (void 0 === e || e > r.GrowingStage.Vegetative)
                    return !0
            }
            return !1
        }
        update() {
            const e = this.description();
            if (!e)
                return;
            this.processSpecials();
            const t = this.getTile()
              , a = t;
            this.processFire(e, t, a),
            this.processWell(),
            this.processSpread(e, a),
            this.processRegeneration(e, a),
            this.processDecay(e, t, a)
        }
        canCauseStatus(e, t) {
            const a = this.description();
            if (void 0 === a)
                return !1;
            const i = a.causesStatus;
            if (!i)
                return !1;
            const n = this.getGrowingStage();
            if (this.canGrow() && void 0 !== n && n < r.GrowingStage.Budding)
                return !1;
            if (t) {
                const a = e.getEquippedItem(t);
                if (a)
                    return !1
            }
            return !0
        }
        causeStatus(e, t) {
            const a = this.description();
            if (void 0 === a)
                return;
            if (!this.canCauseStatus(e, t))
                return;
            if (t) {
                const a = e.getEquippedItem(t);
                if (a)
                    return S.default.get(e).source(T.Source.Wellbeing, T.Source.Equipment, T.Source.Item).send(c.default.EquipmentPreventedStatusEffects, this.getName()),
                    void a.damage("HH")
            }
            const i = a.causesStatus;
            if (i)
                for (const t of i) {
                    let i = 0;
                    a.skillUse && (i = Math.floor(e.getSkill(a.skillUse) / 20));
                    const n = C.default.percent();
                    switch (t) {
                    case r.StatusType.Bleeding:
                        if (!e.hasStatus(r.StatusType.Bleeding) && n <= 30 - i) {
                            const t = e.getMaxHealth()
                              , a = C.default.intInRange(t / 25, t / 10);
                            S.default.get(e).source(T.Source.Wellbeing).type(S.MessageType.Bad).send(c.default.DoodadCauseStatus, this.getName(), y.default.message(c.default.Cut), a),
                            e.damage(-1 * a, c.default.DeathByBleeding),
                            e.setStatus(r.StatusType.Bleeding, !0, o.StatusEffectChangeReason.Gained),
                            I.default.get(e).write(h.default.Bleeding, this.getName())
                        }
                        break;
                    case r.StatusType.Poisoned:
                        if (!e.hasStatus(r.StatusType.Poisoned) && n <= 30 - i) {
                            const t = e.getMaxHealth()
                              , a = C.default.intInRange(t / 25, t / 10);
                            S.default.get(e).source(T.Source.Wellbeing).type(S.MessageType.Bad).send(c.default.DoodadCauseStatus, this.getName(), y.default.message(c.default.Poisoned), a),
                            e.damage(-1 * a, c.default.DeathByPoison, 0, !1),
                            e.setStatus(r.StatusType.Poisoned, !0, o.StatusEffectChangeReason.Gained),
                            I.default.get(e).write(h.default.Poisoned, this.getName())
                        }
                        break;
                    case r.StatusType.Burned:
                        if (!e.hasStatus(r.StatusType.Burned) && n <= 30 - i) {
                            const t = e.burn(!0, !0, r.EquipType.Feet);
                            void 0 !== t && S.default.get(e).source(T.Source.Wellbeing).type(S.MessageType.Bad).send(c.default.DoodadCauseStatus, this.getName(), y.default.message(c.default.Burned), t)
                        }
                    }
                }
        }
        setOffTrap(e, t) {
            const a = this.description();
            if (!a)
                return;
            const i = this.getTile();
            if (!i)
                return;
            const n = this.getPickupTypes();
            if (n && this.type !== r.DoodadType.SetExplosiveTrap && void 0 !== this.minDur) {
                const e = itemManager.create(n[0], itemManager.getTileContainer(this.x, this.y, this.z), this.quality);
                e.minDur = this.minDur - 1,
                e.maxDur = this.maxDur,
                e.revertFromDoodad(this)
            }
            doodadManager.remove(this),
            this.type !== r.DoodadType.SetExplosiveTrap || tileEventManager.get(i, w.TileEventType.Fire) || tileEventManager.create(w.TileEventType.Fire, this.x, this.y, this.z),
            e && t && S.default.get(e).ifVisible(this).source(T.Source.Combat).send(c.default.YouSetTheTrapOff)
        }
        getGrowthParticles() {
            const e = this.description()
              , t = this.getGrowingStage();
            return void 0 !== t && e.growthParticles && e.growthParticles[t] ? e.growthParticles[t] : e.particles
        }
        increaseFertility() {
            const e = this.description()
              , t = this.getGrowingStage();
            return !(!e.spreadMax || t !== r.GrowingStage.Ripening) && (!(void 0 !== this.spread && this.spread >= e.spreadMax) && (this.spread ? this.spread++ : this.spread = 1,
            !0))
        }
        onUnserialized() {
            this.description()
        }
        getNameTranslation(e, t) {
            return y.default.nameOf(p.Dictionary.Doodad, this, t, e)
        }
        getDescriptionTranslation() {
            return new y.default(p.Dictionary.Doodad,this.type,1)
        }
        inspectGrowth() {
            const e = this.description()
              , t = this.getGrowingStage();
            if (!e || !t)
                return;
            let a;
            if (e.gather && (a = this.step && this.step >= 1 ? c.default.PlantHasResourcesToGather : e.gather[t] && t !== r.GrowingStage.Ripening ? c.default.PlantReadyToGatherNotMaximal : e.gather[t] ? c.default.PlantReadyToGather : c.default.PlantGatheringWillDestroy),
            e.harvest && t !== r.GrowingStage.Dead) {
                const i = this.canHarvest();
                a = i ? this.step && this.step >= 1 ? c.default.PlantHasResourcesToHarvest : t !== r.GrowingStage.Ripening ? c.default.PlantReadyToHarvestNotMaximal : e.group && e.group === r.DoodadTypeGroup.GatheredPlant ? c.default.PlantCouldBeHarvested : c.default.PlantReadyToHarvest : c.default.PlantNotReadyToHarvest
            }
            return a
        }
        inspectFertility() {
            if (this.spread)
                return this.spread < 1 ? c.default.PlantIsNotFertile : this.spread <= 4 ? c.default.PlantIsFertile : c.default.PlantHighlyFertile
        }
        inspectDurability() {
            const e = void 0 !== this.minDur && void 0 !== this.maxDur ? this.minDur / this.maxDur : 1;
            return e >= 1 ? c.default.DoodadAppearsUnscathed : e >= .75 ? c.default.DoodadShowsSignsOfWear : e >= .5 ? c.default.DoodadAppearsDamaged : c.default.DoodadAppearsOnVergeOfBreaking
        }
        processSpecials() {
            switch (this.type) {
            case r.DoodadType.CreatureIdol:
                if (0 === C.default.int(20)) {
                    const e = C.default.int(10) + this.x - 5
                      , t = C.default.int(10) + this.y - 5;
                    void 0 !== creatureManager.spawnFromGroup(a.SpawnGroup.Any, e, t, this.z) && S.default.toAll(a=>a.ifVisible(new k.default(e,t,this.z)).source(T.Source.Creature).send(c.default.CreatureIdolAttractedCreature))
                }
            }
        }
        processFire(e, t, a) {
            if (e.providesFire) {
                if (!tileEventManager.get(t, w.TileEventType.Fire) && a.containedItems && a.containedItems.length > 0)
                    for (let e = 0; e < a.containedItems.length; e++) {
                        const t = a.containedItems[e]
                          , i = u.default[t.type];
                        if (i && void 0 !== i.onBurn && t.type !== r.ItemType.PileOfAsh) {
                            tileEventManager.create(w.TileEventType.Fire, this.x, this.y, this.z);
                            break
                        }
                    }
                if (void 0 !== this.decay) {
                    const e = tileEventManager.get(t, w.TileEventType.Fire);
                    e && void 0 !== e.decay && (this.decay = 2 * e.decay + 20)
                }
            }
        }
        processWell() {
            const e = game.wellData[A.getTileId(this.x, this.y, this.z)];
            if (e && e.waterType !== s.WaterType.None && e.quantity >= 0 && e.quantity < 20 && 0 === C.default.int(4e3)) {
                let t = !1;
                for (let a = this.x - 6; a <= this.x + 6; a++)
                    for (let i = this.y - 6; i <= this.y + 6; i++) {
                        const n = M.default[D.default.getType(game.getTile(a, i, this.z))];
                        if (n && n.water && !n.freshWater) {
                            e.waterType = s.WaterType.Seawater,
                            t = !0;
                            break
                        }
                    }
                e.waterType !== s.WaterType.Seawater || t || (e.waterType = s.WaterType.FreshWater),
                e.quantity++
            }
        }
        processSpread(e, t) {
            if (void 0 === this.spread || this.spread < 1 || t.containedItems && t.containedItems.length > 0)
                return;
            const a = C.default.int(300);
            if (0 === a && this.canGrow()) {
                let t = this.x + C.default.int(3) - 1
                  , a = this.y + C.default.int(3) - 1;
                multiplayer.addSyncCheck(f.MultiplayerSyncCheck.Random, `D:${t},${a}`);
                let i = game.getTile(t, a, this.z);
                if (i && void 0 !== i.doodad) {
                    const e = i.doodad.description();
                    e && !e.blockMove && (t += C.default.int(3) - 1,
                    a += C.default.int(3) - 1,
                    multiplayer.addSyncCheck(f.MultiplayerSyncCheck.Random, `D:${t},${a}`))
                }
                if ((this.type === r.DoodadType.ButtonMushrooms || this.type === r.DoodadType.FlyAmanita) && game.getReputation() <= -8e3 && 0 === C.default.int(800)) {
                    const e = Math.floor(3 + this.x - 1)
                      , t = Math.floor(3 + this.y - 1);
                    creatureManager.spawn(r.CreatureType.LivingMushroom, e, t, this.z)
                }
                if (i = game.getTile(t, a, this.z),
                game.isPositionEmpty(t, a, this.z)) {
                    let n = !0;
                    if (e.allowedTiles) {
                        n = !1;
                        for (const t of e.allowedTiles)
                            if (D.default.getType(i) === t) {
                                n = !0;
                                break
                            }
                    }
                    if (n) {
                        game.packGround(t, a, this.z);
                        const e = doodadManager.create(this.type, t, a, this.z);
                        if (e && this.quality) {
                            const t = C.default.percent();
                            this.quality === r.ItemQuality.Legendary ? e.quality = t >= 90 ? r.ItemQuality.None : t >= 75 ? r.ItemQuality.Remarkable : t >= 50 ? r.ItemQuality.Exceptional : this.quality : this.quality === r.ItemQuality.Exceptional ? e.quality = t >= 75 ? r.ItemQuality.None : t >= 50 ? r.ItemQuality.Remarkable : this.quality : this.quality === r.ItemQuality.Remarkable && (e.quality = t >= 50 ? r.ItemQuality.None : this.quality)
                        }
                        this.spread--
                    }
                }
            }
        }
        processRegeneration(e, t) {
            e.canGrow && void 0 !== this.minDur && void 0 !== this.maxDur && this.minDur < this.maxDur && (!t.containedItems || 0 === t.containedItems.length) && this.getGrowingStage() !== r.GrowingStage.Dead && 0 === C.default.int(1800) && this.minDur++
        }
        processDecay(e, t, a) {
            if (void 0 !== this.decay && -1 !== this.decay)
                if (this.decay >= 1 && !e.isUnlitTorch)
                    if (e.isWaterSource) {
                        if (this.type === r.DoodadType.SolarStill && game.time.getTime() <= .5) {
                            if (a.containedItems && a.containedItems.length > 0)
                                return;
                            this.decay--,
                            this.decay <= 0 && (this.gatherReady = !0,
                            world.updateTile(this.x, this.y, this.z, this.getTile()))
                        }
                    } else {
                        if (e.providesFire) {
                            const e = C.default.int(450);
                            0 === e && (game.isPositionFull(this.x, this.y, this.z) || itemManager.create(r.ItemType.PileOfAsh, itemManager.getTileContainer(this.x, this.y, this.z), r.ItemQuality.Random))
                        } else if (e.canGrow && a.containedItems && a.containedItems.length > 0)
                            return;
                        const i = this.isEmbers();
                        this.decay--;
                        const n = this.isEmbers();
                        i !== n && (world.updateTile(this.x, this.y, this.z, this.getTile()),
                        e.waterStill && (this.gatherReady = !0)),
                        D.default.getType(t) === r.TerrainType.FertileSoil && (C.default.int(4) <= 0 && this.decay--,
                        this.decay < 0 && (this.decay = 0))
                    }
                else if (0 === this.decay && !e.isWaterSource) {
                    if (this.decay = -1,
                    e.canGrow) {
                        if (!this.canGrow())
                            return void doodadManager.remove(this);
                        {
                            let a = this.getGrowingStage();
                            if (void 0 !== a)
                                if (a++,
                                this.step = void 0,
                                a <= r.GrowingStage.Ripening)
                                    this.setGrowingStage(a, !0),
                                    this.decay = e.decayMax,
                                    D.default.getType(t) === r.TerrainType.FertileSoil && this.increaseFertility();
                                else if (a === r.GrowingStage.Dead) {
                                    if (this.type === r.DoodadType.Grass)
                                        return game.changeTile(r.TerrainType.Grass, this.x, this.y, this.z, !0),
                                        void doodadManager.remove(this);
                                    if (this.type === r.DoodadType.Tumbleweed)
                                        return tileEventManager.create(w.TileEventType.TumblingTumbleweed, this.x, this.y, this.z),
                                        void doodadManager.remove(this);
                                    e.growthCycle && (this.setGrowingStage(r.GrowingStage.Budding, !0),
                                    this.decay = e.decayMax,
                                    D.default.getType(t) === r.TerrainType.FertileSoil && (this.spread = e.spreadMax))
                                } else
                                    this.decay = void 0
                        }
                    } else {
                        if (!e.revert)
                            return void doodadManager.remove(this);
                        if (e.isLitTorch)
                            return itemManager.create(r.ItemType.Charcoal, itemManager.getTileContainer(this.x, this.y, this.z), this.quality),
                            void doodadManager.remove(this);
                        this.changeType(e.revert)
                    }
                    world.updateTile(this.x, this.y, this.z, this.getTile())
                }
        }
    }
    __decorate([v.SaveProperty()], P.prototype, "containedItems", void 0),
    __decorate([v.SaveProperty()], P.prototype, "decay", void 0),
    __decorate([v.SaveProperty()], P.prototype, "gatherReady", void 0),
    __decorate([v.SaveProperty()], P.prototype, "gfx", void 0),
    __decorate([v.SaveProperty()], P.prototype, "id", void 0),
    __decorate([v.SaveProperty()], P.prototype, "itemOrders", void 0),
    __decorate([v.SaveProperty()], P.prototype, "maxDur", void 0),
    __decorate([v.SaveProperty()], P.prototype, "minDur", void 0),
    __decorate([v.SaveProperty()], P.prototype, "orientation", void 0),
    __decorate([v.SaveProperty()], P.prototype, "ownerIdentifier", void 0),
    __decorate([v.SaveProperty()], P.prototype, "quality", void 0),
    __decorate([v.SaveProperty()], P.prototype, "renamed", void 0),
    __decorate([v.SaveProperty()], P.prototype, "spread", void 0),
    __decorate([v.SaveProperty()], P.prototype, "treasure", void 0),
    __decorate([v.SaveProperty()], P.prototype, "type", void 0),
    __decorate([v.SaveProperty()], P.prototype, "weight", void 0),
    __decorate([v.SaveProperty()], P.prototype, "weightCapacity", void 0),
    __decorate([v.SaveProperty()], P.prototype, "x", void 0),
    __decorate([v.SaveProperty()], P.prototype, "y", void 0),
    __decorate([v.SaveProperty()], P.prototype, "z", void 0),
    __decorate([v.SaveProperty()], P.prototype, "legendary", void 0),
    __decorate([v.SaveProperty()], P.prototype, "step", void 0),
    __decorate([v.SaveProperty()], P.prototype, "hitchedCreature", void 0),
    function(e) {
        function t(t) {
            return t instanceof e
        }
        e.is = t
    }(P || (P = {})),
    t.default = P
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/helpers/IsCreatureKilledByHost", ["require", "exports", "doodad/doodads/Doodad", "entity/Entity", "entity/IEntity"], function(e, t, a, i, n) {
    function o(e, t, o) {
        return !!i.default.is(o, n.EntityType.Creature) && (t === e || (a.default.is(t) ? game.getPlayerByIdentifier(t.ownerIdentifier) === e : i.default.is(t, n.EntityType.Creature) && t.getOwner() === e))
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/KillCreatureRequirement", ["require", "exports", "language/Dictionaries", "language/Translation", "mod/IHookManager", "player/quest/requirement/helpers/IsCreatureKilledByHost", "player/quest/requirement/IRequirement", "player/quest/requirement/Requirement"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new s.Requirement({
        kills: 0
    }).setTrigger(n.Hook.OnEntityKill, (e,t,a)=>{
        if (!o.default(e.host, t, a))
            return !1;
        const [i,n] = e.requirement.options;
        return a.type === i && (e.updated = !0,
        e.requirement.data.kills++,
        e.requirement.data.kills >= n)
    }
    ).setTranslation(e=>{
        const [t,n] = e.requirement.options;
        return new i.default(a.Dictionary.QuestRequirement,r.RequirementType.KillCreature).addArgs(i.default.nameOf(a.Dictionary.Creature, t, n), e.requirement.completed ? n : e.requirement.data.kills, n)
    }
    ).setCompletionAmountGetter(e=>{
        const [,t] = e.requirement.options;
        return e.requirement.completed ? 1 : e.requirement.data.kills / t
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/KillCreaturesRequirement", ["require", "exports", "language/Dictionaries", "language/Translation", "mod/IHookManager", "player/quest/requirement/helpers/IsCreatureKilledByHost", "player/quest/requirement/IRequirement", "player/quest/requirement/Requirement"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new s.Requirement({
        kills: 0
    }).setTrigger(n.Hook.OnEntityKill, (e,t,a)=>{
        if (!o.default(e.host, t, a))
            return !1;
        const [i] = e.requirement.options;
        return e.updated = !0,
        e.requirement.data.kills++,
        e.requirement.data.kills >= i
    }
    ).setTranslation(e=>{
        const [t] = e.requirement.options;
        return new i.default(a.Dictionary.QuestRequirement,r.RequirementType.KillCreatures).addArgs(e.requirement.completed ? t : e.requirement.data.kills, t)
    }
    ).setCompletionAmountGetter(e=>{
        const [t] = e.requirement.options;
        return e.requirement.completed ? 1 : e.requirement.data.kills / t
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/LearnAnySkillRequirement", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/Misc", "language/Translation", "mod/IHookManager", "player/quest/requirement/IRequirement", "player/quest/requirement/Requirement", "utilities/enum/Enums", "utilities/iterable/Generators"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new l.Requirement({}).setTrigger(r.Hook.OnHumanSkillChange, (e,t)=>{
        const [i] = e.requirement.options;
        if (t !== e.host)
            return !1;
        e.updated = !0;
        const n = u.default.values(a.SkillType).reduce((e,a)=>Math.max(a, t.getSkill(e)), 0);
        return n >= i
    }
    ).setTranslation(e=>{
        const [t] = e.requirement.options
          , [r,l] = u.default.values(a.SkillType).reduce((t,[a,n])=>{
            const r = e.host.getSkill(t);
            return r <= n ? d.tuple(a, n) : d.tuple(new o.default(i.Dictionary.Skill,t), r)
        }
        , d.tuple(new o.default(i.Dictionary.Misc,n.MiscTranslation.Unknown), 0));
        return new o.default(i.Dictionary.QuestRequirement,s.RequirementType.LearnAnySkill).addArgs(r, e.requirement.completed ? t : l, t)
    }
    ).setCompletionAmountGetter(e=>{
        const [t] = e.requirement.options
          , i = u.default.values(a.SkillType).reduce((t,a)=>Math.max(a, e.host.getSkill(t)), 0);
        return e.requirement.completed ? 1 : i / t
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/LearnSkillRequirement", ["require", "exports", "language/Dictionaries", "language/Translation", "mod/IHookManager", "player/quest/requirement/IRequirement", "player/quest/requirement/Requirement"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new r.Requirement({}).setTrigger(n.Hook.OnHumanSkillChange, (e,t,a,i)=>{
        const [n,o] = e.requirement.options;
        return t === e.host && a === n && (e.updated = !0,
        i >= o)
    }
    ).setTranslation(e=>{
        const [t,n] = e.requirement.options;
        return new i.default(a.Dictionary.QuestRequirement,o.RequirementType.LearnSkill).addArgs(new i.default(a.Dictionary.Skill,t), e.requirement.completed ? n : e.host.getSkill(t), n)
    }
    ).setCompletionAmountGetter(e=>{
        const [t,a] = e.requirement.options;
        return e.requirement.completed ? 1 : e.host.getSkill(t) / a
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/LearnSkillsRequirement", ["require", "exports", "Enums", "language/Dictionaries", "language/Translation", "mod/IHookManager", "player/quest/requirement/IRequirement", "player/quest/requirement/Requirement", "utilities/enum/Enums", "utilities/math/Math2"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new s.Requirement({}).setTrigger(o.Hook.OnHumanSkillChange, (e,t)=>{
        const [i] = e.requirement.options;
        if (t !== e.host)
            return !1;
        e.updated = !0;
        const n = l.default.values(a.SkillType).reduce((e,a)=>a + t.getSkill(e), 0);
        return n >= i
    }
    ).setTranslation(e=>{
        const [t] = e.requirement.options
          , o = u.default.roundNumber(l.default.values(a.SkillType).reduce((t,a)=>a + e.host.getSkill(t), 0), 1);
        return new n.default(i.Dictionary.QuestRequirement,r.RequirementType.LearnSkills).addArgs(e.requirement.completed ? t : o, t)
    }
    ).setCompletionAmountGetter(e=>{
        const [t] = e.requirement.options
          , i = l.default.values(a.SkillType).reduce((t,a)=>a + e.host.getSkill(t), 0);
        return e.requirement.completed ? 1 : i / t
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/TameCreatureRequirement", ["require", "exports", "language/Dictionaries", "language/Translation", "mod/IHookManager", "player/quest/requirement/IRequirement", "player/quest/requirement/Requirement"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new r.Requirement({
        tames: 0
    }).setTrigger(n.Hook.OnCreatureTamed, (e,t,a)=>{
        if (a !== e.host)
            return !1;
        const [i,n] = e.requirement.options;
        return t.type === i && (e.updated = !0,
        e.requirement.data.tames++,
        e.requirement.data.tames >= n)
    }
    ).setTranslation(e=>{
        const [t,n] = e.requirement.options;
        return new i.default(a.Dictionary.QuestRequirement,o.RequirementType.TameCreature).addArgs(i.default.nameOf(a.Dictionary.Creature, t, n), e.requirement.completed ? n : e.requirement.data.tames, n)
    }
    ).setCompletionAmountGetter(e=>{
        const [,t] = e.requirement.options;
        return e.requirement.completed ? 1 : e.requirement.data.tames / t
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/requirement/TameCreaturesRequirement", ["require", "exports", "language/Dictionaries", "language/Translation", "mod/IHookManager", "player/quest/requirement/IRequirement", "player/quest/requirement/Requirement"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new r.Requirement({
        tames: 0
    }).setTrigger(n.Hook.OnCreatureTamed, (e,t,a)=>{
        if (a !== e.host)
            return !1;
        e.updated = !0,
        e.requirement.data.tames++;
        const [i] = e.requirement.options;
        return e.requirement.data.tames >= i
    }
    ).setTranslation(e=>{
        const [t] = e.requirement.options;
        return new i.default(a.Dictionary.QuestRequirement,o.RequirementType.TameCreatures).addArgs(e.requirement.completed ? t : e.requirement.data.tames, t)
    }
    ).setCompletionAmountGetter(e=>{
        const [t] = e.requirement.options;
        return e.requirement.completed ? 1 : e.requirement.data.tames / t
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/Requirements", ["require", "exports", "mod/IHookManager", "player/quest/requirement/BuildRequirement", "player/quest/requirement/CollectItemRequirement", "player/quest/requirement/CraftRequirement", "player/quest/requirement/DismantleRequirement", "player/quest/requirement/EquipRequirement", "player/quest/requirement/IRequirement", "player/quest/requirement/KillCreatureRequirement", "player/quest/requirement/KillCreaturesRequirement", "player/quest/requirement/LearnAnySkillRequirement", "player/quest/requirement/LearnSkillRequirement", "player/quest/requirement/LearnSkillsRequirement", "player/quest/requirement/Requirement", "player/quest/requirement/TameCreatureRequirement", "player/quest/requirement/TameCreaturesRequirement"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const f = {
        [l.RequirementType.SailToCivilization]: new h.Requirement({}).setTrigger(a.Hook.OnSailToCivilization, (e,t)=>e.host === t),
        [l.RequirementType.KillCreature]: u.default,
        [l.RequirementType.KillCreatures]: d.default,
        [l.RequirementType.CollectItem]: n.default,
        [l.RequirementType.LearnSkill]: c.default,
        [l.RequirementType.LearnSkills]: m.default,
        [l.RequirementType.LearnAnySkill]: p.default,
        [l.RequirementType.Equip]: s.default,
        [l.RequirementType.Craft]: o.default,
        [l.RequirementType.Dismantle]: r.default,
        [l.RequirementType.Build]: i.default,
        [l.RequirementType.TameCreature]: y.default,
        [l.RequirementType.TameCreatures]: g.default
    };
    t.default = f
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/quest/Quest", ["require", "exports", "language/Dictionaries", "language/Translation", "player/quest/Requirements", "utilities/Emitter", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class u extends o.default {
        constructor(e) {
            super(),
            this.type = e,
            this.requirements = [],
            this.children = [],
            this.requirementInstances = new Map,
            this._needsManualCompletion = !1
        }
        addRequirement(e, ...t) {
            return this.requirements.push(s.tuple(e, t)),
            this
        }
        setNeedsManualCompletion() {
            return this._needsManualCompletion = !0,
            this
        }
        addChildQuests(...e) {
            return this.children.push(...e),
            this
        }
        getChildren() {
            return this.children.values()
        }
        setTitle(e) {
            return this.title = e,
            this
        }
        setDescription(e) {
            return this.description = e,
            this
        }
        create(e=this.type) {
            if (void 0 === e)
                throw new Error("Unable to create quest of unknown type");
            return {
                type: e,
                requirements: this.createRequirements().collect(r.default.toArray),
                complete: !1
            }
        }
        getTitle(e) {
            return this.title || void 0 === this.type ? "function" == typeof this.title ? this.title(e) : this.title : new i.default(a.Dictionary.Quest,this.type)
        }
        getDescription(e) {
            return this.description || void 0 === this.type ? "function" == typeof this.description ? this.description(e) : this.description : new i.default(a.Dictionary.Quest,this.type,1)
        }
        getTriggers(e) {
            return e.requirements.values().map(e=>s.tuple(e, n.default[e.type].getTriggers()))
        }
        getHostTriggers(e) {
            return e.requirements.values().map(e=>s.tuple(e, n.default[e.type].getHostTriggers()))
        }
        *getRequirements(e, t) {
            for (const [a,i] of t.requirements.entries()) {
                const t = this.requirementInstances.get(i) || new d(e,i,a);
                this.requirementInstances.set(i, t),
                yield t
            }
        }
        getRequirement(e, t, a) {
            return this.requirementInstances.size || this.getRequirements(e, t).collect(r.default.last()),
            this.requirementInstances.get(a)
        }
        needsManualCompletion() {
            return this._needsManualCompletion
        }
        createRequirements() {
            return this.requirements.values().map(([e,t])=>this.createRequirement(e, ...t))
        }
        createRequirement(e, ...t) {
            return {
                type: e,
                options: t,
                hidden: !1,
                completed: !1,
                data: Object.assign({}, n.default[e].defaultData)
            }
        }
    }
    t.Quest = u;
    class d extends o.default {
        constructor(e, t, a) {
            super(),
            this.data = t,
            this.id = a,
            this.api = {
                host: e,
                requirement: t,
                updated: !1
            }
        }
        triggerInitialization() {
            const e = n.default[this.data.type]
              , t = e.getInitializeTrigger();
            return !!t && t(this.api)
        }
        getTranslation() {
            const e = n.default[this.data.type];
            return e.getTranslation(this.api)
        }
        getCompletionAmount() {
            const e = n.default[this.data.type];
            return e.getCompletionAmount(this.api)
        }
        getRelations() {
            const e = n.default[this.data.type];
            return e.getRelations(this.api)
        }
        setVisible() {
            return this.data.hidden = !1,
            this.emit("Visible"),
            this
        }
    }
    __decorate([l.Bound], d.prototype, "getTranslation", null),
    __decorate([l.Bound], d.prototype, "getCompletionAmount", null),
    t.RequirementInstance = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/IGameScreenApi", ["require", "exports"], function(e, t) {
    var a, i, n, o;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Messages = 0] = "Messages",
        e[e.Stats = 1] = "Stats",
        e[e.Quickslots = 2] = "Quickslots",
        e[e.MenuBar = 3] = "MenuBar"
    }(a = t.QuadrantComponentId || (t.QuadrantComponentId = {})),
    function(e) {
        e.HideDialog = "ShowDialog",
        e.ShowDialog = "HideDialog"
    }(i = t.GameScreenEvent || (t.GameScreenEvent = {})),
    function(e) {
        e[e.Note = 0] = "Note",
        e[e.QuestRequirement = 1] = "QuestRequirement",
        e[e.Misc = 2] = "Misc"
    }(n = t.PinType || (t.PinType = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.RealTime = 1] = "RealTime",
        e[e.Turn = 2] = "Turn"
    }(o = t.MessageTimestamp || (t.MessageTimestamp = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/component/Dialog", ["require", "exports", "Enums", "mod/IHookHost", "newui/component/Button", "newui/component/Component", "newui/component/Text", "newui/INewUi", "newui/screen/screens/game/Dialogs", "utilities/Async", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/math/Math2", "utilities/math/Vector2", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    var g, f;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.X = "x",
        e.Y = "y"
    }(g || (g = {})),
    function(e) {
        e[e.Top = 0] = "Top",
        e[e.TopRight = 1] = "TopRight",
        e[e.Right = 2] = "Right",
        e[e.BottomRight = 3] = "BottomRight",
        e[e.Bottom = 4] = "Bottom",
        e[e.BottomLeft = 5] = "BottomLeft",
        e[e.Left = 6] = "Left",
        e[e.TopLeft = 7] = "TopLeft",
        e[e.Header = 8] = "Header"
    }(f || (f = {}));
    const T = {
        [f.Top]: [g.Y],
        [f.TopRight]: [g.X, g.Y],
        [f.Right]: [g.X],
        [f.BottomRight]: [g.X, g.Y],
        [f.Bottom]: [g.Y],
        [f.BottomLeft]: [g.X, g.Y],
        [f.Left]: [g.X],
        [f.TopLeft]: [g.X, g.Y]
    }
      , S = {
        [g.X]: [l.Edge.Left, l.Edge.Right],
        [g.Y]: [l.Edge.Top, l.Edge.Bottom]
    }
      , I = {
        [l.Edge.Top]: g.Y,
        [l.Edge.Bottom]: g.Y,
        [l.Edge.Left]: g.X,
        [l.Edge.Right]: g.X
    }
      , v = {
        [f.Top]: {
            [g.Y]: l.Edge.Top
        },
        [f.TopRight]: {
            [g.X]: l.Edge.Right,
            [g.Y]: l.Edge.Top
        },
        [f.Right]: {
            [g.X]: l.Edge.Right
        },
        [f.BottomRight]: {
            [g.X]: l.Edge.Right,
            [g.Y]: l.Edge.Bottom
        },
        [f.Bottom]: {
            [g.Y]: l.Edge.Bottom
        },
        [f.BottomLeft]: {
            [g.X]: l.Edge.Left,
            [g.Y]: l.Edge.Bottom
        },
        [f.Left]: {
            [g.X]: l.Edge.Left
        },
        [f.TopLeft]: {
            [g.X]: l.Edge.Left,
            [g.Y]: l.Edge.Top
        }
    }
      , w = {
        [l.Edge.Top]: l.Edge.Bottom,
        [l.Edge.Bottom]: l.Edge.Top,
        [l.Edge.Left]: l.Edge.Right,
        [l.Edge.Right]: l.Edge.Left
    }
      , M = {
        [l.Edge.Top]: 1,
        [l.Edge.Bottom]: -1,
        [l.Edge.Left]: 1,
        [l.Edge.Right]: -1
    };
    function b(e, t) {
        const a = e === g.X ? window.innerWidth : window.innerHeight;
        return t / a * 100
    }
    function k(e, t) {
        const a = e === g.X ? window.innerWidth : window.innerHeight;
        return t / 100 * a
    }
    var C, D;
    !function(e) {
        e.GetDialogList = "GetDialogList",
        e.Close = "Close",
        e.Options = "Options",
        e.Resize = "Resize",
        e.Move = "Move",
        e.SwitchPanel = "SwitchPanel"
    }(C = t.DialogEvent || (t.DialogEvent = {}));
    class A extends o.default {
        constructor(e, t) {
            super(e.uiApi),
            this.gsapi = e,
            this.edges = {},
            this.panels = new Map,
            this.classes.add("dialog"),
            this.dataset.dialogId = `${l.DialogId[t]}`,
            this.id = t,
            this.append(this.header = new G(this.api).on(D.Move, this.onHeaderMove).on(D.MoveStart, this.onHandleMoveStart).on(D.MoveEnd, this.onHandleMoveEnd).on(C.Close, this.close), this.body = new o.default(this.api).classes.add("game-dialog-body"), this.footer = new o.default(this.api,"footer"), ...d.default .values(f).filter(e=>e!==f.Header).map(e=>new P(this.api, e).on(D.Move, this.onHandleMove).on(D.MoveStart, this.onHandleMoveStart).on(D.MoveEnd, this.onHandleMoveEnd))),
            this.on("Append", this.onAppend),
            this.api.on(s.UiApiEvent.Resize, this.resetPosition),
            this.listen("mousedown", this.focus);
            const a = l.default[this.id];
            this.setSizeAndPosition(a),
            hookManager.register(this, `NewUi:Game:Dialog${this.dataset.dialogId}`).until("Remove")
        }
        static makeTopDialog(e) {
            A.topDialog !== e && (A.topDialog = e,
            e.style.setProperty("--order", `${this.topOrder++}`),
            document.documentElement.style.setProperty("--order-total", `${this.topOrder}`))
        }
        get visiblePanel() {
            return this.panels.get(this.currentPanel)
        }
        addScrollableWrapper(e) {
            return new o.default(this.api).classes.add("game-dialog-scrollable-wrapper", "scrollable").schedule(e).appendTo(this.body)
        }
        addSettingsPanel() {
            return this.header.optionsButton.show().on(n.ButtonEvent.Activate, ()=>{
                "_settings" === this.currentPanel ? this.hideSettingsPanel() : this.showSettingsPanel()
            }
            ),
            this.addPanel("_settings")
        }
        showSettingsPanel() {
            this.lastPanel = this.currentPanel;
            const e = this.showPanel("_settings");
            for (const t of e.getChildren())
                "function" == typeof t.refresh && t.refresh();
            return this.header.backButton.show().on(n.ButtonEvent.Activate, this.hideSettingsPanel),
            this.once(C.SwitchPanel, this.hideSettingsPanel),
            this
        }
        onBindLoop(e, t) {
            return (t.wasPressed(a.Bindable.GameMoveToTile) || t.wasPressed(a.Bindable.GameFaceDirection)) && t.isMouseWithin(this) && (ui.screenInGame.blockedByNewUi = !0),
            e
        }
        async close() {
            return this.classes.add("hidden"),
            await u.sleep(100),
            !!this.classes.has("hidden") && (this.emit(C.Close),
            this.remove(),
            !0)
        }
        addPanel(e) {
            const t = new o.default(this.api).classes.add("game-dialog-panel", "scrollable", "hidden").data.set("panelId", `${e}`).appendTo(this.body);
            return this.panels.set(e, t),
            this.visiblePanel || (this.currentPanel = e,
            t.show()),
            t
        }
        showPanel(e) {
            const t = this.panels.get(e);
            return t && t !== this.visiblePanel ? (this.classes.remove("insta-animation"),
            this.visiblePanel.hide(),
            this.currentPanel = e,
            t.show(),
            this.emit(C.SwitchPanel, e, t),
            t) : t
        }
        getPanel(e) {
            return this.panels.get(e)
        }
        isPanelVisible(e) {
            return this.visiblePanel === this.panels.get(e)
        }
        setSizeAndPosition(e) {
            this.description = e;
            const {size: t, edges: a} = e;
            for (const [e,i] of a) {
                this.setEdgePosition(e, i);
                const a = I[e]
                  , n = i + M[e] * t[a] * this.getScale(a);
                this.setEdgePosition(w[e], n)
            }
            this.cacheLastEdges();
            for (const [e] of a)
                this.setEdgePosition(w[e], this.getNewEdgePositionOrSnap(w[e], 0));
            this.cacheLastEdges(),
            this.onHeaderMove(null, h.default.ZERO),
            this.emit(C.Resize)
        }
        setEdgePosition(e, t) {
            this.edges[e] = t,
            this.style.setProperty(`--position-${l.Edge[e].toLowerCase()}`, `${t}%`)
        }
        focus() {
            A.makeTopDialog(this.element)
        }
        markActive() {
            this.classes.after(10).add("active")
        }
        markInactive() {
            this.classes.remove("active")
        }
        hideSettingsPanel() {
            this.header.backButton.hide().cancel(n.ButtonEvent.Activate, this.hideSettingsPanel),
            this.showPanel(this.lastPanel)
        }
        saveEdgesForScale() {
            this.savedEdges = {
                scale: this.api.scale.getCurrent(),
                edges: Object.assign({}, this.edges)
            }
        }
        onAppend() {
            this.api.registerDataHost(`NewUi:Game:Dialog${this.dataset.dialogId}`, this),
            this.resetPosition(),
            this.saveEdgesForScale(),
            this.header.setText(()=>this.getName()),
            this.focus(),
            this.classes.until(350).add("insta-animation")
        }
        onHandleMoveStart() {
            this.cacheLastEdges(),
            this.markActive()
        }
        cacheLastEdges() {
            this.lastEdges = {
                [l.Edge.Top]: this.edges[l.Edge.Top],
                [l.Edge.Right]: this.edges[l.Edge.Right],
                [l.Edge.Bottom]: this.edges[l.Edge.Bottom],
                [l.Edge.Left]: this.edges[l.Edge.Left]
            }
        }
        onHandleMoveEnd() {
            this.markInactive()
        }
        onHandleMove(e, t) {
            A.makeTopDialog(this.element),
            this.saveEdgesForScale();
            const a = e.position;
            for (const e of T[a]) {
                const i = v[a][e];
                this.setEdgePosition(i, this.getNewEdgePositionOrSnap(i, t[e]))
            }
            this.emit(C.Resize)
        }
        onHeaderMove(e, t) {
            e && (A.makeTopDialog(this.element),
            this.saveEdgesForScale());
            for (const e of [g.X, g.Y]) {
                const [a,i] = this.getNewEdgePositionForAxis(e, t[e])
                  , n = this.lastEdges[a];
                let o = i - n;
                const r = w[a]
                  , s = this.lastEdges[r]
                  , l = s + o
                  , u = m.default.clamp(0, 100, l);
                l !== u ? (o = u - s,
                this.setEdgePosition(a, n + o),
                this.setEdgePosition(r, u)) : (this.setEdgePosition(a, i),
                this.setEdgePosition(r, l))
            }
            this.emit(C.Move)
        }
        getNewEdgePositionForAxis(e, t) {
            const a = this.getSnapPositionForAxis(e, t);
            if (a)
                return [a[0], a[1].position];
            {
                const a = S[e][0];
                return [a, m.default.clamp(0, 100, this.lastEdges[a] + b(e, t))]
            }
        }
        getSnapPositionForAxis(e, t) {
            return S[e].values().map(e=>c.tuple(e, this.getSnapPositionForEdge(e, t))).filter2(([e,t])=>void 0 !== t).collect(p.default.toArray).sort(([e,{difference: t}],[a,{difference: i}])=>t - i).collect(p.default.first())
        }
        getNewEdgePositionOrSnap(e, t) {
            const a = this.getNewEdgePosition(e, t)
              , i = this.getClosestSnapPosition(a, I[e]);
            return this.clampAxisLength(e, i ? i.position : a)
        }
        clampAxisLength(e, t) {
            const a = I[e]
              , i = this.getScale(a);
            let n = this.description.minSize[a] * i
              , o = this.description.maxSize[a] * i;
            if (this.description.square && a === g.Y) {
                const e = this.edges[l.Edge.Right] - this.edges[l.Edge.Left]
                  , t = k(g.X, e);
                n = o = b(g.Y, t)
            }
            const r = t - this.edges[w[e]]
              , s = r * M[e] * -1;
            if (s < n) {
                const a = s - n;
                t += M[e] * a
            } else if (s > o) {
                const a = o - s;
                t -= M[e] * a
            }
            return t
        }
        getSnapPositionForEdge(e, t) {
            const a = this.getNewEdgePosition(e, t);
            return this.getClosestSnapPosition(a, I[e])
        }
        getClosestSnapPosition(e, t) {
            const a = b(t, 5);
            return this.getSnapPositions(t).map(t=>({
                position: t,
                difference: Math.abs(t - e)
            })).filter(({difference: e})=>e < a).collect(p.default.toArray).sort(({difference: e},{difference: t})=>e - t).collect(p.default.first())
        }
        getSnapPositions(e) {
            return this.emit(C.GetDialogList).values().flatMap().filter(e=>e !== this).map(t=>t.getEdgePositionsOfAxis(e)).flatMap().include([0, 100])
        }
        getNewEdgePosition(e, t) {
            return m.default.clamp(0, 100, this.lastEdges[e] + b(I[e], t))
        }
        getEdgePositionsOfAxis(e) {
            return [this.edges[S[e][0]], this.edges[S[e][1]]]
        }
        getSize() {
            return c.pipe(g.X, g.Y).map(e=>c.tuple(e, this.getEdgePositionsOfAxis(e))).map(([e,[t,a]])=>c.tuple(e, Math.abs(t - a) / this.getScale(e))).collect(y.default.create)
        }
        getEdges() {
            return c.pipe(g.X, g.Y).map(e=>S[e]).map(e=>e.map(e=>c.tuple(e, Math.abs(this.edges[e] - 50)))).map(([e,t])=>e[1] > t[1] ? e : t).map(([e])=>c.tuple(e, this.edges[e])).collect(p.default.toArray)
        }
        getScale(e) {
            const t = Math.min(1, this.api.scale.getCurrent());
            return e === g.Y ? (1 / t + t) / 2 : 1 / t
        }
        resetPosition() {
            if (this.savedEdges && this.api.scale.getCurrent() === this.savedEdges.scale)
                return this.edges = Object.assign({}, this.savedEdges.edges),
                this.cacheLastEdges(),
                this.onHeaderMove(null, h.default.ZERO),
                void this.emit(C.Resize);
            this.setSizeAndPosition(Object.assign({}, this.description, {
                size: this.getSize(),
                edges: this.getEdges()
            }))
        }
    }
    A.topOrder = 1,
    __decorate([s.Save(s.SaveLocation.Both)], A.prototype, "edges", void 0),
    __decorate([y.Bound], A.prototype, "showSettingsPanel", null),
    __decorate([Override, i.HookMethod], A.prototype, "onBindLoop", null),
    __decorate([y.Bound], A.prototype, "close", null),
    __decorate([y.Bound], A.prototype, "focus", null),
    __decorate([y.Bound], A.prototype, "hideSettingsPanel", null),
    __decorate([y.Bound], A.prototype, "onAppend", null),
    __decorate([y.Bound], A.prototype, "onHandleMoveStart", null),
    __decorate([y.Bound], A.prototype, "onHandleMoveEnd", null),
    __decorate([y.Bound], A.prototype, "onHandleMove", null),
    __decorate([y.Bound], A.prototype, "onHeaderMove", null),
    __decorate([y.Bound], A.prototype, "resetPosition", null),
    t.default = A,
    function(e) {
        e.MoveStart = "MoveStart",
        e.Move = "Move",
        e.MoveEnd = "MoveEnd"
    }(D || (D = {}));
    class P extends o.default {
        get position() {
            return f[this.dataset.position]
        }
        constructor(e, t, a) {
            super(e, a),
            this.classes.add("handle"),
            this.dataset.position = f[t],
            this.drag = this.drag.bind(this),
            this.dragEnd = this.dragEnd.bind(this),
            this.element.addEventListener("mousedown", this.dragStart.bind(this))
        }
        dragStart(e) {
            this.lastMousePosition = new h.default(e.clientX,e.clientY),
            window.addEventListener("mousemove", this.drag),
            window.addEventListener("mouseup", this.dragEnd),
            this.emit(D.MoveStart)
        }
        drag(e) {
            this.emit(D.Move, new h.default(e.clientX,e.clientY).subtract(this.lastMousePosition))
        }
        dragEnd(e) {
            this.lastMousePosition = void 0,
            window.removeEventListener("mousemove", this.drag),
            window.removeEventListener("mouseup", this.dragEnd),
            this.emit(D.MoveEnd)
        }
    }
    class G extends P {
        constructor(e) {
            super(e, f.Header, "header"),
            this.classes.remove("handle"),
            this.backButton = new n.default(e).classes.add("game-dialog-button-back", "has-icon-before", "button-icon").hide().appendTo(this),
            this.text = new r.default(e).classes.add("game-dialog-title").appendTo(this),
            this.optionsButton = new n.default(e).classes.add("game-dialog-button-options", "has-icon-before", "button-icon").hide().appendTo(this),
            new n.default(e).classes.add("game-dialog-button-close", "has-icon-before", "button-icon").on(n.ButtonEvent.Activate, ()=>this.emit(C.Close)).appendTo(this)
        }
        setText(e) {
            this.text.setText(e)
        }
        refresh() {
            return this.text.refresh(),
            this
        }
    }
    t.Header = G
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/dialog/BookDialog", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Text", "newui/screen/screens/game/component/Dialog", "newui/screen/screens/game/Dialogs", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class u extends r.default {
        constructor(e) {
            super(e, s.DialogId.Book),
            this.header.getNthChild(0).classes.add("heading"),
            this.text = new o.Paragraph(this.api).setText(this.getText).appendTo(this.addScrollableWrapper())
        }
        getName() {
            return void 0 === this.book ? i.default.GameDialogBookName : new n.default(a.Dictionary.Book,this.book)
        }
        setBook(e) {
            this.book = e,
            this.header.refresh(),
            this.text.refresh()
        }
        getText() {
            return void 0 === this.book ? [] : new n.default(a.Dictionary.Book,this.book,1)
        }
    }
    __decorate([Override], u.prototype, "getName", null),
    __decorate([l.Bound], u.prototype, "getText", null),
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Decode", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "language/dictionary/Note", "language/Translation", "mod/IHookManager", "player/IMessageManager", "player/MessageManager", "utilities/math/Vector2", "utilities/math/Vector3", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    function y(e, t) {
        return e < 20 ? t <= 50 ? r.default.CartographyDistanceLowSkillNearby : r.default.CartographyDistanceLowSkillUnsure : e < 40 ? t <= 16 ? r.default.CartographyDistanceMedSkillVeryClose : t <= 50 ? r.default.CartographyDistanceMedSkillNearby : t <= 125 ? r.default.CartographyDistanceMedSkillFarAway : r.default.CartographyDistanceLowSkillUnsure : t <= 16 ? l.default.message(r.default.CartographyDistanceHighSkillExactDistance).addArgs(Math.floor(t)) : t <= 50 ? r.default.CartographyDistanceHighSkillNearby : t <= 125 ? r.default.CartographyDistanceHighSkillInRegion : r.default.CartographyDistanceHighSkillFarAway
    }
    function g(e, t, a) {
        if (e < 30)
            return r.default.None;
        let i = 4
          , n = 90
          , o = [r.default.East, r.default.South, r.default.West, r.default.North];
        e >= 90 ? (i = 16,
        n = 22.5,
        o = [r.default.East, r.default.EastSoutheast, r.default.Southeast, r.default.SouthSoutheast, r.default.South, r.default.SouthSouthwest, r.default.Southwest, r.default.WestSouthwest, r.default.West, r.default.WestNorthwest, r.default.Northwest, r.default.NorthNorthwest, r.default.North, r.default.NorthNortheast, r.default.Northeast, r.default.EastNortheast]) : e >= 60 && (i = 8,
        n = 45,
        o = [r.default.East, r.default.Southeast, r.default.South, r.default.Southwest, r.default.West, r.default.Northwest, r.default.North, r.default.Northeast]);
        const s = Math.atan2(t.y - a.y, t.x - a.x) / Math.PI * 180 + 180
          , l = Math.floor(s / n + .5);
        return o[l % i]
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        if (e.setDelay(25),
        !t.tatteredMap)
            return void p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(r.default.MapNotOfThisArea);
        e.setUpdateTablesAndWeight(),
        e.setPassTurn(),
        t.tatteredMap.reinitialize && (t.initializeMap(),
        delete t.tatteredMap.reinitialize);
        const a = new m.default(t.tatteredMap);
        if (t.type === o.ItemType.DrawnMap || t.used && void 0 !== t.used.map)
            return e.executor.isLocalPlayer() && modManager.getHook(u.Hook.OnReadMap).call(e.executor, {
                item: t,
                tilePosition: a
            }),
            e.setItemsUsed(),
            void p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(r.default.FullyDecodedMap);
        const i = e.executor.getSkill(o.SkillType.Cartography);
        if (e.executor.notes.write(s.default.TreasureHunting),
        i < h.default.percent(35))
            return e.setSoundEffect(o.SfxType.Fail),
            e.addSkillGains(o.SkillType.Cartography, .1),
            void p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(r.default.CouldNotDecipher);
        e.setItemsUsed(),
        e.addSkillGains(o.SkillType.Cartography),
        e.executor.isLocalPlayer() && modManager.getHook(u.Hook.OnReadMap).call(e.executor, {
            item: t,
            tilePosition: a,
            skillCheck: !0
        }),
        p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(i >= 50 ? r.default.FullyDecodedMap : r.default.PartiallyDecodedMap);
        const n = c.default.distance(e.executor, a)
          , f = y(i, n);
        p.default.get(e.executor).source(d.Source.Action).send(f);
        const T = g(i, new c.default(e.executor), a);
        p.default.get(e.executor).source(d.Source.Action).send(T ? r.default.CartographyDirection : r.default.CartographyDirectionUnsure, l.default.message(T))
    }
    ),
    t.getCartographyDistance = y,
    t.getCartographyDirection = g
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/dialog/MapDialog", ["require", "exports", "action/ActionExecutor", "action/actions/Decode", "action/IAction", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Misc", "language/dictionary/UiTranslation", "language/Translation", "mod/IHookHost", "newui/component/Button", "newui/component/Component", "newui/component/Text", "newui/INewUi", "newui/screen/screens/game/component/Dialog", "newui/screen/screens/game/Dialogs", "utilities/math/Vector2", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class I extends g.default {
        constructor(e) {
            super(e, f.DialogId.Map),
            this.textWrapper = new m.default(this.api).classes.add("text-wrapper").append(new h.Paragraph(this.api).setText(this.getDistance)).append(this.direction = new h.Paragraph(this.api).setText(this.getDirection)).append(new c.default(this.api).classes.add("button-icon", "has-icon-before", "icon-center", "button-reset").setTooltip(e=>e.addText(e=>e.setText(u.default.GameDialogMapTooltipDecode))).on(c.ButtonEvent.Activate, ()=>{
                a.default.get(n.ActionType.Decode).execute(localPlayer, this.map.item)
            }
            )).appendTo(this.body),
            this.canvas = new m.default(this.api,"canvas").classes.add("map-canvas").appendTo(this.body),
            this.on(g.DialogEvent.Resize, this.onResize)
        }
        getName() {
            return this.map && this.map.item && this.map.item.renamed ? new d.default(r.Dictionary.Misc,l.MiscTranslation.Renamed).addArgs(this.map.item.renamed) : u.default.GameDialogMapName
        }
        decode(e) {
            this.map = e,
            this.decodeSkill = localPlayer.getSkill(o.SkillType.Cartography),
            this.decodePosition = new T.default(localPlayer),
            this.mapCanvas = game.makeMiniMap(e),
            this.api.refreshTranslations(this),
            this.textWrapper.toggle(this.map.item.type === o.ItemType.TatteredMap),
            this.onResize()
        }
        onDigTreasure(e, t) {
            e.isLocalPlayer() && this.close()
        }
        getDistance() {
            if (!this.map)
                return d.default.message(s.default.None);
            const e = T.default.distance(this.decodePosition, this.map.tilePosition);
            this.direction.toggle(0 !== e);
            const t = i.getCartographyDistance(this.decodeSkill, e);
            return "number" == typeof t ? d.default.message(t) : t
        }
        getDirection() {
            if (!this.map)
                return d.default.message(s.default.None);
            const e = i.getCartographyDirection(this.decodeSkill, this.decodePosition, this.map.tilePosition);
            return d.default.message(e ? s.default.CartographyDirection : s.default.CartographyDirectionUnsure).addArgs(d.default.message(e))
        }
        onResize() {
            if (!this.mapCanvas)
                return;
            const e = this.canvas.element
              , t = this.body.element;
            let a = t.clientHeight
              , i = t.clientWidth;
            const n = getComputedStyle(t);
            a -= parseFloat(n.paddingTop || "0") + parseFloat(n.paddingBottom || "0"),
            i -= parseFloat(n.paddingLeft || "0") + parseFloat(n.paddingRight || "0"),
            e.width = e.height = Math.min(a - this.textWrapper.element.clientHeight, i);
            const o = e.getContext("2d");
            if (!o)
                throw new Error("Invalid map canvas context");
            o.drawImage(this.mapCanvas, 0, 0, e.width, e.height)
        }
    }
    __decorate([Override], I.prototype, "getName", null),
    __decorate([p.HookMethod(y.NEWUI_HOOK_PRIORITY)], I.prototype, "onDigTreasure", null),
    __decorate([S.Bound], I.prototype, "getDistance", null),
    __decorate([S.Bound], I.prototype, "getDirection", null),
    __decorate([S.Bound], I.prototype, "onResize", null),
    t.default = I
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/CheckButton", ["require", "exports", "newui/component/Button", "utilities/Objects"], function(e, t, a, i) {
    var n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Change = "Change"
    }(n = t.CheckButtonEvent || (t.CheckButtonEvent = {}));
    class o extends a.default {
        constructor(e) {
            super(e),
            this._checked = !1,
            this.classes.add("menu-check-button", "has-icon-before"),
            this.on(a.ButtonEvent.Activate, this.toggleChecked)
        }
        get checked() {
            return this._checked
        }
        setChecked(e, t=!0) {
            return this.trySetChecked(e, t),
            this
        }
        trySetChecked(e, t=!0) {
            if (t) {
                if (this._checked !== e) {
                    this._checked = e;
                    const t = this.emit(n.Change, e);
                    for (const a of t)
                        if (!1 === a)
                            return this._checked = !e,
                            this.emit(n.Change, !e),
                            !1;
                    this.classes.toggle(e, "checked")
                }
            } else
                this._checked = e,
                this.classes.toggle(e, "checked");
            return !0
        }
        toggleChecked() {
            this.setChecked(!this._checked)
        }
        refresh() {
            return this.setChecked(this.refreshMethod()),
            this
        }
        setRefreshMethod(e) {
            return this.refreshMethod = e,
            this.refresh(),
            this
        }
        setText(e) {
            return this.text.setText(e),
            this
        }
        addDescription(e) {
            return this.classes.add("menu-check-button-description"),
            super.addDescription(e)
        }
    }
    __decorate([i.Bound], o.prototype, "toggleChecked", null),
    __decorate([i.Bound], o.prototype, "refresh", null),
    __decorate([Override], o.prototype, "setText", null),
    __decorate([Override], o.prototype, "addDescription", null),
    t.CheckButton = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/RangeInput", ["require", "exports", "newui/component/Component", "utilities/Objects"], function(e, t, a, i) {
    var n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Change = "Change",
        e.Finish = "Finish"
    }(n = t.RangeInputEvent || (t.RangeInputEvent = {}));
    class o extends a.default {
        constructor(e) {
            super(e, "input"),
            this.clampOnRefresh = !0,
            this.classes.add("menu-range-input"),
            this.attributes.set("type", "range"),
            this.attributes.set("min", "0"),
            this.attributes.set("max", "100"),
            this.attributes.set("step", "1"),
            this.value = 0,
            this.element.addEventListener("input", e=>{
                this._value = +this.element.value,
                this.update(n.Change)
            }
            ),
            this.element.addEventListener("change", ()=>{
                this.emit(n.Finish, this._value)
            }
            ),
            this.element.addEventListener("mousedown", e=>{
                e.stopPropagation()
            }
            ),
            this.element.addEventListener("mouseup", e=>{
                e.stopPropagation()
            }
            )
        }
        get value() {
            return this._value
        }
        set value(e) {
            e = this.clampOnRefresh ? Math.min(Math.max(e, this.min), this.max) : e,
            this._value !== e && (this._value = e,
            this.element.value = `${e}`,
            this.update(n.Finish))
        }
        get min() {
            return +this.attributes.get("min")
        }
        get max() {
            return +this.attributes.get("max")
        }
        get step() {
            return +this.attributes.get("step")
        }
        clamp() {
            return this.value = Math.min(Math.max(this.value, this.min), this.max),
            this
        }
        setStep(e) {
            return this.element.setAttribute("step", `${e}`),
            this
        }
        setMax(e, t=!0) {
            return this.element.setAttribute("max", `${e}`),
            t ? this.clamp() : this.update(),
            this
        }
        setMin(e, t=!0) {
            return this.element.setAttribute("min", `${e}`),
            t ? this.clamp() : this.update(),
            this
        }
        update(e) {
            const t = this._value
              , a = this.min === this.max ? 100 : (t - this.min) / (this.max - this.min) * 100;
            this.element.style.setProperty("--percent", `${a}`),
            e && this.emit(e, t)
        }
        refresh() {
            const e = this.refreshMethod();
            return this.value !== e && (this.value = e),
            this
        }
        setRefreshMethod(e) {
            return this.refreshMethod = e,
            this.refresh(),
            this
        }
        noClampOnRefresh() {
            return this.clampOnRefresh = !1,
            this
        }
    }
    __decorate([Override], o.prototype, "element", void 0),
    __decorate([i.Bound], o.prototype, "refresh", null),
    t.RangeInput = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/RangeInputValueDisplay", ["require", "exports", "newui/component/Component", "newui/component/Text"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        constructor(e) {
            super(e),
            this.classes.add("menu-range-row-value"),
            this.text = new i.default(this.api).appendTo(this)
        }
        setText(e) {
            return this.text.setText(e),
            this
        }
        refresh() {
            return this.text.refresh(),
            this
        }
    }
    t.RangeInputValueDisplay = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/RangeRow", ["require", "exports", "language/dictionary/UiTranslation", "newui/component/BlockRow", "newui/component/Button", "newui/component/RangeInput", "newui/component/RangeInputValueDisplay", "newui/component/Text"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l extends i.BlockRow {
        constructor(e) {
            super(e),
            this._disabled = !1,
            this.classes.add("menu-range-row"),
            this.heading = new s.Heading(this.api).classes.add("label").appendTo(this),
            this.rangeInput = new o.RangeInput(this.api).classes.add("menu-hasbg").on(o.RangeInputEvent.Finish, (e,t)=>{
                this.emit(o.RangeInputEvent.Finish, t),
                this.updateDisplay(t)
            }
            ).on(o.RangeInputEvent.Change, (e,t)=>{
                this.emit(o.RangeInputEvent.Change, t),
                this.updateDisplay(t)
            }
            ).appendTo(this)
        }
        get value() {
            return this.rangeInput.value
        }
        set value(e) {
            this.rangeInput.value = e
        }
        get disabled() {
            return this._disabled
        }
        setDisabled(e) {
            return this._disabled = e,
            this.classes.toggle(e, "disabled"),
            this
        }
        editRange(e) {
            return e(this.rangeInput),
            this
        }
        setLabel(e) {
            return this.heading.schedule(e),
            this
        }
        setDisplayValue(e) {
            return e ? (this.rangeInputValueDisplay = this.rangeInputValueDisplay || new r.RangeInputValueDisplay(this.api).setText(()=>!0 === e ? [{
                content: `${this.rangeInput.value}`
            }] : e(this.rangeInput.value)).appendTo(this),
            this.updateDisplay(this.rangeInput.value),
            this) : (this.rangeInputValueDisplay && (this.rangeInputValueDisplay.remove(),
            this.rangeInputValueDisplay = void 0),
            this)
        }
        addDefaultButton(e) {
            return this.classes.add("has-default-button").append(new n.default(this.api).classes.add("button-icon", "has-icon-before", "icon-center", "button-reset").setTooltip(e=>e.addHeading(e=>e.setText(a.default.MenuSharedButtonDefault))).on(n.ButtonEvent.Activate, e ? ()=>this.rangeInput.value = e() : this.rangeInput.refresh).appendTo(this))
        }
        refresh() {
            return this.heading.refresh(),
            this.rangeInput.refresh(),
            this
        }
        updateDisplay(e) {
            this.rangeInputValueDisplay && this.rangeInputValueDisplay.refresh()
        }
    }
    t.RangeRow = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/shared/ChatMessagePacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedSharedPacket", "newui/screen/screens/game/static/Messages"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o extends i.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            n.default.sendChatMessage(this.player, this.message)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.String)], o.prototype, "message", void 0),
    __decorate([Override], o.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], o.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], o.prototype, "process", null),
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/dialog/MessagesEditFiltersDialog", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Button", "newui/component/CheckButton", "newui/component/Component", "newui/component/Input", "newui/component/LabelledRow", "newui/screen/screens/game/component/Dialog", "newui/screen/screens/game/Dialogs", "player/IMessageManager", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    var g, f;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Edit = "Edit",
        e.Reset = "Reset"
    }(g = t.MessagesEditFiltersDialogEvent || (t.MessagesEditFiltersDialogEvent = {})),
    function(e) {
        e[e.Filters = 0] = "Filters",
        e[e.EditFilter = 1] = "EditFilter"
    }(f || (f = {}));
    class T extends d.default {
        constructor(e) {
            super(e, p.DialogId.MessagesEditFilters),
            this.filters = {},
            this.editingFilter = "",
            this.addPanel(f.Filters).append(new s.default(this.api).classes.add("messages-edit-filters-action-row").append(new o.default(this.api).classes.add("messages-edit-filters-button-new", "simple-button").setText(i.default.GameDialogMessagesEditFiltersButtonNew).on(o.ButtonEvent.Activate, this.editFilter(""))).append(new o.default(this.api).classes.add("messages-edit-filters-button-reset", "simple-button").setText(i.default.GameDialogMessagesEditFiltersButtonReset).on(o.ButtonEvent.Activate, this.resetFilters))).append(this.filterContainer = new s.default(this.api)).on("Show", ()=>this.initializeFilters(this.filters)),
            this.addPanel(f.EditFilter).append(new u.LabelledRow(this.api).setLabel(e=>e.classes.remove("heading").setText(i.default.GameDialogMessagesEditFiltersLabelName)).append(this.name = new l.default(this.api).classes.add("simple-button").setDefault(()=>this.editingFilter).on(l.InputEvent.Change, this.onEditName))).append(new s.default(this.api).classes.add("messages-edit-filters-action-row").append(new o.default(this.api).classes.add("warning", "simple-button").setText(i.default.GameDialogMessagesEditFiltersButtonDelete).on(o.ButtonEvent.Activate, this.deleteFilter)).append(new o.default(this.api).classes.add("simple-button").setText(i.default.GameDialogMessagesEditFiltersButtonSave).on(o.ButtonEvent.Activate, this.saveFilter))).append(this.sourceButtons = m.default.values(c.Source).filter(e=>e !== c.Source.All).map(e=>new r.CheckButton(this.api).classes.add("edit-filter-source-button", "icon-no-scale").setText(new n.default(a.Dictionary.Source,e)).setRefreshMethod(this.isFilteredIn(e)).data.set("source", c.Source[e])).collect(h.default.toArray))
        }
        initializeFilters(e) {
            return this.filters = e,
            this.filterContainer.dump(),
            this.filterContainer.append(...y.default .keys(this.filters).filter(e=>e!==n.default .ui(i.default .GameMessagesFilterAll).getString()).map(e=>new o.default (this.api).classes.add("edit-filter-button").setText(n.default .generator(e)).on(o.ButtonEvent.Activate, this.editFilter(e)))),
            this
        }
        getName() {
            return i.default.GameDialogMessagesEditFiltersName
        }
        editFilter(e) {
            return ()=>{
                this.showPanel(f.EditFilter),
                this.editingFilter = e,
                this.name.clear();
                for (const e of this.sourceButtons)
                    e.refresh()
            }
        }
        isFilteredIn(e) {
            return ()=>{
                const t = this.filters[this.editingFilter];
                return t ? this.filters[this.editingFilter].includes(c.Source[e]) : e === c.Source.Game
            }
        }
        deleteFilter() {
            delete this.filters[this.editingFilter],
            this.emit(g.Edit),
            this.showPanel(f.Filters)
        }
        async saveFilter() {
            if ("" !== this.name.text) {
                if (this.editingFilter !== this.name.text && Object.keys(this.filters).includes(this.name.text)) {
                    const e = await newui.interrupt(i.default .GameDialogMessagesEditFiltersInterruptSaveOverExisting).withDescription(i.default .GameDialogMessagesEditFiltersInterruptSaveOverExistingDescription).withConfirmation();
                    if (!e)
                        return void this.name.classes.until(250).add("shake")
                }
                delete this.filters[this.editingFilter],
                this.filters[this.name.text] = this.sourceButtons.filter(e=>e.checked).map(e=>e.data.get("source")),
                this.emit(g.Edit),
                this.showPanel(f.Filters)
            } else
                this.name.classes.until(250).add("shake")
        }
        onEditName(e, t) {
            e.classes.toggle("" === t, "error")
        }
        async resetFilters() {
            const e = await newui.interrupt(i.default .GameDialogMessagesEditFiltersInterruptResetConfirm).withDescription(i.default .GameDialogMessagesEditFiltersInterruptResetConfirmDescription).withConfirmation();
            e && this.emit(g.Reset)
        }
    }
    __decorate([Override], T.prototype, "getName", null),
    __decorate([y.Bound], T.prototype, "deleteFilter", null),
    __decorate([y.Bound], T.prototype, "saveFilter", null),
    __decorate([y.Bound], T.prototype, "onEditName", null),
    __decorate([y.Bound], T.prototype, "resetFilters", null),
    t.default = T
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/component/Spacer", ["require", "exports", "newui/component/Component"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        constructor(e) {
            super(e),
            this.classes.add("menu-separator")
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/Block", ["require", "exports", "newui/component/Component", "newui/component/Text"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        constructor(e) {
            super(e),
            this.classes.add("menu-block")
        }
        addText(e) {
            return new i.default(this.api).schedule(e).appendTo(this),
            this
        }
    }
    t.Block = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/character/Character", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.LastUse = 0] = "LastUse",
        e[e.Name = 1] = "Name",
        e[e.UseCount = 2] = "UseCount"
    }(a = t.CharacterSort || (t.CharacterSort = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/util/Misc", ["require", "exports", "newui/screen/screens/menu/component/IMenu"], function(e, t, a) {
    function i(e) {
        if ("function" == typeof e)
            return ()=>{
                i(e())
            }
            ;
        e.character.lastUse = Date.now(),
        e.character.useCount++,
        game.play(e)
    }
    function n(e, t) {
        return (...a)=>{
            o(e, t, ...a)
        }
    }
    function o(e, t, ...i) {
        const n = newui.getVisibleScreen();
        e === a.MenuId.BACK ? n.backOneMenu() : ("function" == typeof e && (e = e()),
        n.showMenu(e, t ? e=>t(e, ...i) : void 0))
    }
    function r(e) {
        if ("object" == typeof e && e.isDedicatedServer) {
            const t = saveDataGlobal.multiplayerPreviousGames[e.matchmakingServer];
            if (t)
                return void i({
                    multiplayerServerToJoin: e,
                    character: t
                })
        }
        o(a.MenuId.CharacterSelection, t=>t.gameOptions.multiplayerServerToJoin = e)
    }
    function s(e) {
        const t = modManager.canLoadFromIdentifier(e);
        let a = "error";
        if (t.loadable) {
            a = "notenabled";
            for (const t of modManager.getIndexFromPublishId(e))
                if (modManager.isEnabled(t)) {
                    a = "enabled";
                    break
                }
        }
        return [t.name, a]
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.startGame = i,
    t.menuSwitcher = n,
    t.switchMenu = o,
    t.switchToJoinServer = r,
    t.isModLoadable = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/HelpArticle", ["require", "exports", "language/Dictionaries", "language/segment/HeadingSegment", "language/segment/LinkSegment", "language/Translation", "newui/component/Block", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/help/HelpArticleDescriptions", "newui/util/Misc", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class c extends l.default {
        constructor(e, t) {
            super(e, `help-${u.HelpArticle[t]}`),
            this.canCancel = !0;
            const [s,,l,d] = o.default.getAll(a.Dictionary.HelpArticle, t);
            this.setTitle(e=>e.setText(s)),
            this.setDescription(e=>e.setText(l)),
            new r.Block(e).append(new m(e).setText(d.withSegments(!0, n.default, i.default))).appendTo(this.content)
        }
    }
    t.default = c;
    class m extends s.default {
        refresh() {
            super.refresh();
            for (const e of this.getChildren())
                e.setLinkHandler(e=>!(!Array.isArray(e) || "HelpArticle" !== e[0]) && (d.switchMenu(()=>new c(this.api,u.HelpArticle[e[1]])),
                !0));
            return this
        }
    }
    __decorate([p.Bound, Override], m.prototype, "refresh", null)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/promise/ResolvablePromise", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a extends Promise {
        constructor(e) {
            let t, a;
            super((e,i)=>{
                t = (t=>{
                    this._isResolved = !0,
                    e(t)
                }
                ),
                a = i
            }
            ),
            this._isResolved = !1,
            this.resolve = t,
            this.reject = a,
            e && e(t, a)
        }
        get isResolved() {
            return this._isResolved
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("resources/IResourceLoader", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Corpse = 0] = "Corpse",
        e[e.Creature = 1] = "Creature",
        e[e.DifficultyOptionsIcon = 2] = "DifficultyOptionsIcon",
        e[e.Doodad = 3] = "Doodad",
        e[e.DoodadItem = 4] = "DoodadItem",
        e[e.Equip = 5] = "Equip",
        e[e.Hairstyle = 6] = "Hairstyle",
        e[e.HelpArticleIcon = 7] = "HelpArticleIcon",
        e[e.Item = 8] = "Item",
        e[e.MenuBarButtonIcon = 9] = "MenuBarButtonIcon",
        e[e.Mound = 10] = "Mound",
        e[e.Music = 11] = "Music",
        e[e.Overlay = 12] = "Overlay",
        e[e.Sleep = 13] = "Sleep",
        e[e.SoundEffect = 14] = "SoundEffect",
        e[e.StatIcon = 15] = "StatIcon",
        e[e.StatusEffect = 16] = "StatusEffect",
        e[e.StatusEffectIcon = 17] = "StatusEffectIcon",
        e[e.Terrain = 18] = "Terrain",
        e[e.TileEvent = 19] = "TileEvent"
    }(a = t.PathType || (t.PathType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("audio/IMusic", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("audio/Music", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.musicDescriptions = {}
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("audio/SoundEffects", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.soundEffectDescriptions = {}
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/stats/IStatDisplayDescription", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/stats/Attack", ["require", "exports", "entity/IStats", "Enums", "item/Items", "language/dictionary/Message", "language/dictionary/UiTranslation", "language/Messages", "language/Translation", "utilities/math/Math2"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const d = {
        color: "#FFF22E",
        displayType: a.StatDisplayType.Attribute,
        displayOrder: 2,
        getFormatted: (e,t)=>l.default.ui(r.default.GameStatsStatAttack).get(t.value + e.attackFromEquip.leftHand, t.value + e.attackFromEquip.rightHand),
        tooltip: (e,t,a)=>{
            e.setNoCache();
            const n = u.default.roundNumber(localPlayer.getSkill(i.SkillType.Tactics) / 12.5, 0) + 1;
            e.addParagraph(e=>e.setText(()=>l.default.ui(r.default.GameStatsStatAttackTooltipTactics).get(n))),
            e.addParagraph(e=>e.setText(()=>l.default.ui(r.default.GameStatsStatAttackTooltipLeftHand).get(localPlayer.attackFromEquip.leftHand, p(i.EquipType.LeftHand)))),
            e.addParagraph(e=>e.setText(()=>l.default.ui(r.default.GameStatsStatAttackTooltipRightHand).get(localPlayer.attackFromEquip.rightHand, p(i.EquipType.RightHand))))
        }
    };
    function p(e) {
        const t = ui.screenInGame.getEquipSlotItemElement(e);
        if (t.children().length > 0) {
            const e = game.items[t.children().data("item-id")];
            if (e) {
                const t = e.type
                  , a = n.itemDescriptions[t];
                if (a && a.damageType)
                    return s.fullDamageType([a.damageType])
            }
        }
        return l.default.message(o.default.Blunt)
    }
    t.default = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/stats/Defense", ["require", "exports", "entity/IStats", "Enums", "language/dictionary/UiTranslation", "language/Translation"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const r = {
        color: "#00FFF5",
        displayType: a.StatDisplayType.Attribute,
        displayOrder: 3,
        getFormatted: (e,t)=>o.default.ui(n.default.GameStatsStatGeneric).get(e.defense.base + e.defense.parrying),
        tooltip: (e,t,a)=>{
            e.setNoCache(),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatDefenseTooltipParrying).get(localPlayer.defense.parrying))),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatDefenseTooltipBase).get(localPlayer.defense.base))),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatDefenseTooltipBlunt).get(localPlayer.defenses[i.DamageType.Blunt]))),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatDefenseTooltipPiercing).get(localPlayer.defenses[i.DamageType.Piercing]))),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatDefenseTooltipSlashing).get(localPlayer.defenses[i.DamageType.Slashing]))),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatDefenseTooltipFire).get(localPlayer.defenses[i.DamageType.Fire])))
        }
    };
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/stats/Reputation", ["require", "exports", "entity/Human", "entity/IStats", "language/dictionary/UiTranslation", "language/Translation"], function(e, t, a, i, n, o) {
    function r(e) {
        let t;
        const a = e.getReputation();
        return t = a >= 5e4 ? n.default.GameStatsStatReputationTooltipDifficultySimple : a >= 25e3 ? n.default.GameStatsStatReputationTooltipDifficultyVeryEasy : a >= 5e3 ? n.default.GameStatsStatReputationTooltipDifficultyEasy : a >= -5e3 ? n.default.GameStatsStatReputationTooltipDifficultyMedium : a >= -25e3 ? n.default.GameStatsStatReputationTooltipDifficultyHard : a >= -5e4 ? n.default.GameStatsStatReputationTooltipDifficultyVeryHard : n.default.GameStatsStatReputationTooltipDifficultyInsane
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const s = {
        color: "#F205FF",
        displayType: i.StatDisplayType.Attribute,
        displayOrder: 0,
        getFormatted: (e,t)=>o.default.ui(n.default.GameStatsStatGeneric).get(e.getReputation()),
        imagePath: (e,t)=>{
            const a = "static/image/ui/icons/stat/";
            return `${a}${e.getReputation() < 0 ? "malign" : "benign"}`
        }
        ,
        tooltip: (e,t,s)=>{
            e.setNoCache(),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatReputationTooltipDifficulty).get(o.default.ui(r(t))))),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatReputationTooltipBenignity).get(t.getStat(i.Stat.Benignity).value, a.REPUTATION_MAX))),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatReputationTooltipMalignity).get(t.getStat(i.Stat.Malignity).value, a.REPUTATION_MAX))),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatReputationTooltipScore).get(t.score))),
            e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatReputationTooltipTurn).get(t.turns))),
            multiplayer.isConnected() && e.addParagraph(e=>e.setText(()=>o.default.ui(n.default.GameStatsStatReputationTooltipTicks).get(game.time.ticks)))
        }
    };
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/stats/StatDisplayDescriptions", ["require", "exports", "entity/IStats", "language/dictionary/UiTranslation", "newui/screen/screens/game/static/stats/Attack", "newui/screen/screens/game/static/stats/Defense", "newui/screen/screens/game/static/stats/Reputation", "utilities/Async"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const l = {};
    function u(e, t) {
        return (a,i,n,o)=>{
            const r = Object.assign({}, n, {
                percent: n.value / (n.max || 1),
                oldValue: o
            });
            t(e(r), a, i, r)
        }
    }
    function d(...e) {
        return (t,a)=>{
            a.classes.toggle(t, ...e)
        }
    }
    async function p(e, t) {
        t.classes.toggle(e, "shake"),
        e && (await s.sleep(250),
        t.classes.remove("shake"))
    }
    t.when = u,
    t.toggleClasses = d,
    t.shake = p,
    l[a.Stat.Health] = {
        color: "#FF0000",
        displayType: a.StatDisplayType.Statbar,
        displayOrder: 0,
        tooltip: e=>e.addText(e=>e.setText(i.default.GameStatsStatHealthTooltip)),
        onChange: [u(e=>e.percent < .1, d("flash")), u(e=>e.value < (e.oldValue || 0), p)]
    },
    l[a.Stat.Stamina] = {
        color: "#00E00B",
        displayType: a.StatDisplayType.Statbar,
        displayOrder: 1,
        tooltip: e=>e.addText(e=>e.setText(i.default.GameStatsStatStaminaTooltip)),
        onChange: [u(e=>e.percent < .1, d("flash")), u(e=>e.value < (e.oldValue || 0), p)]
    },
    l[a.Stat.Hunger] = {
        color: "#A33AFF",
        displayType: a.StatDisplayType.Statbar,
        displayOrder: 2,
        tooltip: e=>e.addText(e=>e.setText(i.default.GameStatsStatHungerTooltip)),
        onChange: [u(e=>e.percent < .1, d("flash")), u(e=>e.value < (e.oldValue || 0), p)]
    },
    l[a.Stat.Thirst] = {
        color: "#00B4FF",
        displayType: a.StatDisplayType.Statbar,
        displayOrder: 3,
        tooltip: e=>e.addText(e=>e.setText(i.default.GameStatsStatThirstTooltip)),
        onChange: [u(e=>e.percent < .1, d("flash")), u(e=>e.value < (e.oldValue || 0), p)]
    },
    l[a.Stat.Reputation] = r.default,
    l[a.Stat.Weight] = {
        displayType: a.StatDisplayType.Attribute,
        displayOrder: 1,
        tooltip: e=>e.addText(e=>e.setText(i.default.GameStatsStatWeightTooltip)),
        onChange: [u(e=>e.percent > .9, d("flash"))],
        color: (e,t)=>{
            const a = t;
            return a.value > a.max ? "#FF0000" : "#FFFFFF"
        }
    },
    l[a.Stat.Attack] = n.default,
    l[a.Stat.Defense] = o.default,
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/pause/DifficultyOptionsIcons", ["require", "exports", "entity/IStats", "Enums", "game/Challenge", "game/TimeManager", "language/Dictionaries", "language/dictionary/Misc", "language/dictionary/UiTranslation", "language/Translation", "player/IPlayer"], function(e, t, a, i, n, o, r, s, l, u, d) {
    var p;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Peaceful = 0] = "Peaceful",
        e[e.Respawn = 1] = "Respawn",
        e[e.EternalNight = 2] = "EternalNight",
        e[e.Time = 3] = "Time",
        e[e.Benignity = 4] = "Benignity",
        e[e.Malignity = 5] = "Malignity",
        e[e.Health = 6] = "Health",
        e[e.Stamina = 7] = "Stamina",
        e[e.Hunger = 8] = "Hunger",
        e[e.Thirst = 9] = "Thirst",
        e[e.Bleeding = 10] = "Bleeding",
        e[e.Poisoned = 11] = "Poisoned",
        e[e.Burned = 12] = "Burned",
        e[e.Skills = 13] = "Skills",
        e[e.NoItems = 14] = "NoItems",
        e[e.Weight = 15] = "Weight"
    }(p = t.DifficultyOptionsIcon || (t.DifficultyOptionsIcon = {}));
    const c = new o.default(0)
      , m = {
        [p.Peaceful]: {
            check: e=>e.peaceful,
            tooltip: e=>e.addText(e=>e.setText(l.default.DifficultyOptionsPeaceful))
        },
        [p.Respawn]: {
            check: e=>e.respawn,
            tooltip: e=>e.addText(e=>e.setText(l.default.DifficultyOptionsRespawn))
        },
        [p.EternalNight]: {
            check: n.isEternalNight,
            tooltip: e=>e.addText(e=>e.setText(l.default.DifficultyOptionsEternalNight))
        },
        [p.Time]: {
            check: e=>!m[p.EternalNight].check(e) && (void 0 !== e.time.dayPercent && e.time.dayPercent !== c.dayPercent || void 0 !== e.time.dayLength && e.time.dayLength !== c.dayLength || 0 !== e.time.initial || e.time.frozen),
            tooltip: (e,t)=>e.addList(0 === t.time.initial ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsTimeInitial).addArgs(new o.default(0).getTranslation(t.time.initial))), t.time.frozen ? e=>e.setText(l.default.DifficultyOptionsTimeFrozen) : void 0, t.time.frozen || void 0 === t.time.dayLength ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsTimeDayLength).addArgs(t.time.dayLength)), t.time.frozen || void 0 === t.time.dayPercent ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsTimeDayPercent).addArgs(100 * t.time.dayPercent, 100 - 100 * t.time.dayPercent)))
        },
        [p.Benignity]: {
            check: e=>1 !== e.player.reputation.benignityMultiplier || 0 !== e.player.reputation.initialBenignity,
            tooltip: (e,t)=>e.addList(0 === t.player.reputation.initialBenignity ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsBenignityInitial).addArgs(t.player.reputation.initialBenignity)), 1 === t.player.reputation.benignityMultiplier ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsBenignityMultiplier).addArgs(t.player.reputation.benignityMultiplier)))
        },
        [p.Malignity]: {
            check: e=>1 !== e.player.reputation.malignityMultiplier || 0 !== e.player.reputation.initialMalignity,
            tooltip: (e,t)=>e.addList(0 === t.player.reputation.initialMalignity ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsMalignityInitial).addArgs(t.player.reputation.initialMalignity)), 1 === t.player.reputation.malignityMultiplier ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsMalignityMultiplier).addArgs(t.player.reputation.malignityMultiplier)))
        },
        [p.Health]: {
            check: e=>h(e, a.Stat.Health) || h(e, a.Stat.Strength),
            tooltip: g(a.Stat.Health)
        },
        [p.Stamina]: {
            check: e=>h(e, a.Stat.Stamina),
            tooltip: g(a.Stat.Stamina)
        },
        [p.Hunger]: {
            check: e=>h(e, a.Stat.Hunger),
            tooltip: g(a.Stat.Hunger)
        },
        [p.Thirst]: {
            check: e=>h(e, a.Stat.Thirst),
            tooltip: g(a.Stat.Thirst)
        },
        [p.Weight]: {
            check: e=>h(e, a.Stat.Strength),
            tooltip: g(a.Stat.Weight)
        },
        [p.Bleeding]: {
            check: e=>y(e, i.StatusType.Bleeding),
            tooltip: f(i.StatusType.Bleeding)
        },
        [p.Poisoned]: {
            check: e=>y(e, i.StatusType.Poisoned),
            tooltip: f(i.StatusType.Poisoned)
        },
        [p.Burned]: {
            check: e=>y(e, i.StatusType.Burned),
            tooltip: f(i.StatusType.Burned)
        },
        [p.Skills]: {
            check: e=>!e.player.randomSkills || e.player.skills.size > 0,
            tooltip: (e,t)=>{
                e.addList(t.player.randomSkills ? void 0 : e=>e.setText(l.default.DifficultyOptionsNoRandomSkills), ...t.player.skills.entries().map(([e, t])=>[1===t.gainMultiplier?void 0:a=>a.setText(u.default .ui(l.default .DifficultyOptionsSkillGainMultiplier).addArgs(new u.default (r.Dictionary.Skill, e).inContext(3), t.gainMultiplier)), t.initial?a=>a.setText(u.default .ui(l.default .DifficultyOptionsSkillInitial).addArgs(new u.default (r.Dictionary.Skill, e).inContext(3), t.initial)):void 0]).flatMap())
            }
        },
        [p.NoItems]: {
            check: e=>!1 === e.player.initialItems,
            tooltip: e=>e.addText(e=>e.setText(l.default.DifficultyOptionsNoItems))
        }
    };
    function h(e, t) {
        const a = e.player.stats.get(t);
        return !!a && (1 !== a.changeTimerMultiplier || void 0 !== a.initialValue || void 0 !== a.maxValue)
    }
    function y(e, t) {
        const a = e.player.statusEffects.get(t);
        return !!a && (1 !== a.passChanceMultiplier || 1 !== a.effectRateMultiplier || 1 !== a.effectMultiplier || a.untreatable || a.startWith)
    }
    function g(e) {
        return (t,i)=>{
            const n = i.player.stats.get(e) || {};
            if (!n)
                return;
            const o = i.player.stats.get(a.Stat.Strength)
              , s = e === a.Stat.Health && o && o.initialValue || e === a.Stat.Weight && o && o.initialValue && o.initialValue + d.STRENGTH_BONUS || n.maxValue
              , p = new u.default(r.Dictionary.Stat,e).inContext(3);
            t.addList(void 0 === n.initialValue ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsStatInitial).addArgs(p, n.initialValue)), void 0 === s ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsStatMax).addArgs(p, s)), void 0 === n.changeTimerMultiplier || 1 === n.changeTimerMultiplier ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsStatMultiplier).addArgs(p, n.changeTimerMultiplier)))
        }
    }
    function f(e) {
        return (t,a)=>{
            const i = a.player.statusEffects.get(e);
            if (!i)
                return;
            const o = new u.default(r.Dictionary.StatusEffect,e,0).inContext(3);
            if (n.isPermanentEffect(e))
                return void t.addText(e=>e.setText(u.default.ui(l.default.DifficultyOptionsStatusEffectPermanent).addArgs(o)));
            const d = new u.default(r.Dictionary.StatusEffect,e,1).inContext(3);
            t.addList(i.startWith ? e=>e.setText(u.default.ui(l.default.DifficultyOptionsStatusEffectStartWith).addArgs(o)) : void 0, i.untreatable ? e=>e.setText(u.default.ui(l.default.DifficultyOptionsStatusEffectUntreatable).addArgs(new u.default(r.Dictionary.Misc,s.MiscTranslation.ReformatSingularNoun).addArgs(void 0, 2, !1, d).inContext(3))) : void 0, 1 === i.passChanceMultiplier ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsStatusEffectPassChanceMultiplier).addArgs(d, i.passChanceMultiplier)), 1 === i.effectRateMultiplier ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsStatusEffectRateMultiplier).addArgs(d, i.effectRateMultiplier)), 1 === i.effectMultiplier ? void 0 : e=>e.setText(u.default.ui(l.default.DifficultyOptionsStatusEffectMultiplier).addArgs(d, i.effectMultiplier)))
        }
    }
    t.default = m
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/dictionary/HumanName", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.First = 0] = "First",
        e[e.Last = 1] = "Last",
        e[e.Full = 2] = "Full"
    }(a || (a = {})),
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/Customizations", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/HumanName", "language/Translation", "utilities/Color", "utilities/enum/Enums"], function(e, t, a, i, n, o, r, s) {
    function l(e) {
        const t = {}
          , a = Object.keys(e).length / 2;
        for (let i = 0; i < a; i++)
            t[i] = {
                color: r.default(e[i])
            };
        return t
    }
    function u() {
        return {
            hairStyle: a.HairStyle[s.default.getRandom(a.HairStyle)],
            hairColor: a.HairColor[s.default.getRandom(a.HairColor)],
            skinColor: a.SkinColor[s.default.getRandom(a.SkinColor)]
        }
    }
    function d() {
        return {
            name: new o.default(i.Dictionary.HumanName,n.default.Full).getString(),
            customization: u()
        }
    }
    var p;
    function c(e, i) {
        if (e === p.Skin) {
            const e = a.SkinColor[i];
            if ("number" == typeof e)
                return t.skinColorDescriptions[e]
        } else {
            const e = a.HairColor[i];
            if ("number" == typeof e)
                return t.hairColorDescriptions[e]
        }
        return {
            color: r.default(i)
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.hairstyleDescriptions = {},
    t.hairstyleDescriptions[a.HairStyle.Spike] = {
        name: "Spike"
    },
    t.hairstyleDescriptions[a.HairStyle.Bun] = {
        name: "Bun"
    },
    t.hairstyleDescriptions[a.HairStyle.Ponytail] = {
        name: "Ponytail"
    },
    t.hairstyleDescriptions[a.HairStyle.Afro] = {
        name: "Afro"
    },
    t.hairstyleDescriptions[a.HairStyle.Bouncy] = {
        name: "Bouncy"
    },
    t.hairstyleDescriptions[a.HairStyle.Dreads] = {
        name: "Dreads"
    },
    t.hairstyleDescriptions[a.HairStyle.Shaved] = {
        name: "Shaved"
    },
    t.hairstyleDescriptions[a.HairStyle.Long] = {
        name: "Long"
    },
    t.hairstyleDescriptions[a.HairStyle.Mohawk] = {
        name: "Mohawk"
    },
    t.hairColorDescriptions = l(a.HairColor),
    t.skinColorDescriptions = l(a.SkinColor),
    t.generateRandomCustomization = u,
    t.generateRandomCharacter = d,
    function(e) {
        e.Hair = "hairColor",
        e.Skin = "skinColor"
    }(p = t.ColorType || (t.ColorType = {})),
    t.getColorDescription = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/Overlays", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.overlayDescriptions = {}
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("tile/events/Fire", ["require", "exports", "Enums", "item/Items", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "tile/ITileEvent", "tile/Terrains", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d) {
    function p(e, t, n) {
        const o = e.description();
        if (o)
            if (!o.onBurn && e.disassembly && o.flammable)
                for (const a of e.disassembly)
                    p(a, t, !0);
            else if (o.onBurn)
                for (const i of o.onBurn)
                    i !== a.ItemType.None && itemManager.create(i, t, e.quality);
            else if (o.burnsLike)
                for (const a of o.burnsLike) {
                    const n = i.default[a];
                    if (n && n.onBurn)
                        for (const a of n.onBurn)
                            itemManager.create(a, t, e.quality)
                }
            else if (n) {
                const a = itemManager.create(e.type, t, e.quality);
                a.weight = e.weight,
                a.minDur = e.minDur,
                a.maxDur = e.maxDur,
                e.legendary && (a.legendary = e.legendary)
            }
    }
    function c(e, t, a, n, o) {
        if (t)
            for (let r = e || 0; r < t.length; r++)
                if (t[r]) {
                    const e = void 0 !== t[r].chance ? t[r].chance : 100
                      , s = void 0 !== t[r].chanceOutOf ? t[r].chanceOutOf : 100;
                    if (void 0 !== e && u.default.percent(0, s) > e || 100 === e) {
                        const e = i.default[t[r].type];
                        if (void 0 !== o.decay && o.decay >= 1) {
                            const e = itemManager.createFake(t[r].type, n).getStokeFireValue();
                            o.decay += e || 2
                        }
                        if (e && e.onBurn)
                            for (const t of e.onBurn)
                                itemManager.create(t, a, n)
                    }
                }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.dissassemblyBurn = p,
    t.harvestGatherBurn = c;
    const m = {
        spreadMax: 14,
        decayMax: 160,
        animated: !0,
        update(e) {
            const t = game.getTileFromPoint(e)
              , m = d.default.getType(t);
            let h = !1;
            if (void 0 !== e.spread && e.spread > 0) {
                const t = u.default.int(80);
                if (0 === t) {
                    const t = u.default.int(3) - 1 + e.x
                      , a = u.default.int(3) - 1 + e.y;
                    if (game.isFlammable(t, a, e.z)) {
                        const i = tileEventManager.create(e.type, t, a, e.z);
                        i && (i.spread = Math.round(u.default.float())),
                        e.spread--
                    }
                }
            }
            if (void 0 !== e.decay && e.decay >= 1) {
                const d = itemManager.getTileContainer(e.x, e.y, e.z)
                  , y = t.doodad;
                if (y) {
                    const t = y.description();
                    if (t && t.isFlammable && (e.decay += 2,
                    0 === u.default.int(20))) {
                        if (void 0 !== y.minDur && y.minDur <= 1) {
                            const n = y.getGrowingStage();
                            if (y.disassembly)
                                for (const t of y.disassembly) {
                                    p(t, d, !1);
                                    const a = t.getStokeFireValue();
                                    e.decay += a || 2
                                }
                            else if (n && (t.gather && t.gather[n] || t.harvest && t.harvest[n]))
                                t.harvest && c(y.step ? y.step : 0, t.harvest[n], d, y.quality, e),
                                t.gather && c(y.step ? y.step : 0, t.gather[n], d, y.quality, e);
                            else if (t.burnsLike)
                                for (const a of t.burnsLike) {
                                    const t = itemManager.createFake(a, y.quality).getStokeFireValue();
                                    e.decay += t || 2;
                                    const n = i.default[a];
                                    if (n && n.onBurn)
                                        for (const e of n.onBurn)
                                            itemManager.create(e, d, y.quality);
                                    else if (n && n.burnsLike)
                                        for (const e of n.burnsLike) {
                                            const t = i.default[e];
                                            if (t && t.onBurn)
                                                for (const e of t.onBurn)
                                                    itemManager.create(e, d, y.quality)
                                        }
                                    else
                                        n && n.disassemble ? p(itemManager.createFake(a, y.quality), d, !1) : itemManager.create(a, d, y.quality)
                                }
                            else
                                n !== a.GrowingStage.Germinating && (itemManager.create(a.ItemType.PileOfAsh, d, y.quality),
                                h = !0)
                        }
                        y.damage(!1, !0, !1, !0)
                    }
                }
                const g = t;
                if (g.containedItems)
                    for (let t = 0; t < g.containedItems.length; t++) {
                        const s = g.containedItems[t]
                          , d = i.default[s.type];
                        if (d) {
                            if ((d.onBurn || s.disassembly && d.flammable || d.burnsLike) && (0 === t && (e.decay += 2),
                            0 === u.default.int(15)))
                                if (void 0 !== s.minDur && s.minDur > 0)
                                    0 === u.default.int(Math.min(4, Math.floor(t / 4))) && s.damage("F");
                                else {
                                    const t = s.getStokeFireValue();
                                    if (e.decay += t || 2,
                                    d.burnsLike)
                                        for (const e of d.burnsLike) {
                                            const t = i.default[e];
                                            if (t && t.onBurn)
                                                for (const e of t.onBurn)
                                                    itemManager.create(e, g, s.quality);
                                            else
                                                itemManager.create(e, g, s.quality)
                                        }
                                    else
                                        p(s, g, !1);
                                    h = !0,
                                    itemManager.isInGroup(s.type, a.ItemTypeGroup.Liquid) && (r.default.toAll(t=>t.ifVisible(e).source(o.Source.Item).send(n.default.WaterPutOutFire)),
                                    e.decay = 0),
                                    itemManager.breakContainerOnTile(s, e.x, e.y, e.z)
                                }
                            if (s.type === a.ItemType.PileOfAsh) {
                                if (0 === u.default.int(120)) {
                                    const t = l.default[m];
                                    t && t.passable && m !== a.TerrainType.Lava && m !== a.TerrainType.CoolingLava && game.changeTile(a.TerrainType.Ash, e.x, e.y, e.z, !0)
                                }
                                if (0 === u.default.int(420)) {
                                    itemManager.remove(s);
                                    break
                                }
                            }
                        }
                    }
                const f = t.corpses;
                if (f)
                    for (const t of f)
                        void 0 !== t.decay && (t.decay -= 200,
                        e.decay += 20);
                const T = t.events;
                T && T.filter(e=>e.type !== s.TileEventType.Fire).forEach(e=>{
                    tileEventManager.remove(e)
                }
                );
                const S = u.default.int(160);
                if (0 === S && m !== a.TerrainType.Ash && t.doodad) {
                    const i = t.doodad.description();
                    i && i.isFlammable && game.changeTile(a.TerrainType.Ash, e.x, e.y, e.z, !0)
                }
                h || 0 !== u.default.int(500) || itemManager.create(a.ItemType.PileOfAsh, itemManager.getTileContainer(e.x, e.y, e.z), a.ItemQuality.Random),
                e.decay--
            }
            if (void 0 !== e.decay && e.decay <= 0 && m !== a.TerrainType.Ash) {
                const i = l.default[m];
                if (i && i.flammable && m !== a.TerrainType.Lava && m !== a.TerrainType.CoolingLava)
                    game.changeTile(a.TerrainType.Ash, e.x, e.y, e.z, !1);
                else if (t.doodad) {
                    const i = t.doodad.description();
                    i && i.isFlammable && game.changeTile(a.TerrainType.Ash, e.x, e.y, e.z, !0)
                }
            }
        }
    };
    t.default = m
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("tile/events/Fungus", ["require", "exports", "Enums", "tile/ITileEvent", "utilities/Random"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const o = {
        items: [{
            type: a.ItemType.HoneyFungus
        }],
        skillUse: a.SkillType.Mycology,
        particles: {
            r: 235,
            g: 208,
            b: 172
        },
        spreadMax: 1,
        create(e) {
            e.gfx = n.default.int(3)
        },
        update(e) {
            if (void 0 === e.spread || e.spread <= 0)
                return;
            const t = n.default.bool();
            if (!t)
                return;
            const o = e.x + n.default.int(3) - 1
              , r = e.y + n.default.int(3) - 1
              , s = game.getTile(o, r, e.z);
            if (!s)
                return;
            const l = s.events;
            if (l)
                return;
            const u = s;
            if (u.containedItems)
                return;
            const d = s.corpses;
            if (d)
                return;
            const p = s.doodad;
            if (void 0 !== p && p.type === a.DoodadType.MapleTree) {
                const t = p.getGrowingStage();
                void 0 !== t && t >= a.GrowingStage.Budding && (tileEventManager.create(i.TileEventType.HoneyFungus, o, r, e.z),
                e.spread--)
            }
        }
    };
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("tile/events/Tumbleweed", ["require", "exports", "doodad/Doodads", "Enums", "tile/ITileEvent", "tile/Terrains", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const l = {
        items: [{
            type: i.ItemType.Twigs
        }, {
            type: i.ItemType.TumbleweedSeeds
        }],
        skillUse: i.SkillType.Botany,
        particles: {
            r: 146,
            g: 97,
            b: 65
        },
        graphicVariation: !0,
        isFlammable: !0,
        update(e) {
            const t = game.getTile(e.x, e.y, e.z);
            if (!t)
                return;
            if (!(t.doodad || t.creature || t.npc || t.corpses || 0 !== r.default.int(200) || game.isPlayerAtPosition(e.x, e.y, e.z))) {
                const n = a.default[i.DoodadType.Tumbleweed];
                if (n && n.allowedTiles)
                    for (const a of n.allowedTiles)
                        if (s.default.getType(t) === a)
                            return doodadManager.create(i.DoodadType.Tumbleweed, e.x, e.y, e.z, {
                                gfx: r.default.int(3)
                            }),
                            tileEventManager.remove(e),
                            void itemManager.create(i.ItemType.Twigs, itemManager.getTileContainer(e.x + r.default.int(3) - 1, e.y + r.default.int(3) - 1, e.z))
            }
            const l = s.default.getType(t)
              , u = t.doodad;
            if (l === i.TerrainType.Lava)
                return void tileEventManager.create(n.TileEventType.Fire, e.x, e.y, e.z);
            if (u) {
                const t = u.description();
                if (t && t.providesFire)
                    return void tileEventManager.create(n.TileEventType.Fire, e.x, e.y, e.z)
            }
            if (0 !== r.default.int(15))
                return;
            const d = e.x + r.default.int(3) - 1
              , p = e.y + r.default.int(3) - 1
              , c = game.getTile(d, p, e.z);
            if (!c)
                return;
            const m = c.events;
            if (m)
                return;
            if (game.isTileFull(c))
                return;
            if (u) {
                const e = u.description();
                if (e && e.blockMove)
                    return
            }
            const h = o.default[l];
            h && (!h.passable || h.water || h.shallowWater) || (void 0 !== e.gfx && (e.gfx++,
            e.gfx >= 3 && (e.gfx = 0)),
            tileEventManager.moveTo(e, d, p, e.z))
        }
    };
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("tile/TileEvents", ["require", "exports", "tile/events/Fire", "tile/events/Fungus", "tile/events/Tumbleweed", "tile/ITileEvent"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const r = {};
    r[o.TileEventType.Fire] = a.default,
    r[o.TileEventType.HoneyFungus] = i.default,
    r[o.TileEventType.TumblingTumbleweed] = n.default,
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("resources/ResourcePath", ["require", "exports", "audio/Music", "audio/SoundEffects", "creature/Creatures", "doodad/Doodads", "entity/IStats", "entity/StatusEffects", "Enums", "item/Items", "newui/screen/screens/game/static/menubar/MenuBarButtonDescriptions", "newui/screen/screens/game/static/stats/StatDisplayDescriptions", "newui/screen/screens/menu/menus/help/HelpArticleDescriptions", "newui/screen/screens/menu/menus/pause/DifficultyOptionsIcons", "player/Customizations", "renderer/Overlays", "resources/IResourceLoader", "tile/ITileEvent", "tile/Terrains", "tile/TileEvents", "utilities/Log", "utilities/string/Strings"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const w = {
        [g.PathType.Corpse]: g.PathType.Creature,
        [g.PathType.Creature]: {
            enumObject: l.CreatureType,
            descriptions: n.creatureDescriptions
        },
        [g.PathType.Doodad]: {
            enumObject: l.DoodadType,
            descriptions: o.doodadDescriptions
        },
        [g.PathType.DoodadItem]: {
            enumObject: l.ItemType,
            descriptions: u.itemDescriptions
        },
        [g.PathType.Item]: {
            enumObject: l.ItemType,
            descriptions: u.itemDescriptions
        },
        [g.PathType.Sleep]: g.PathType.Item,
        [g.PathType.Equip]: g.PathType.Item,
        [g.PathType.Terrain]: {
            enumObject: l.TerrainType,
            descriptions: T.terrainDescriptions
        },
        [g.PathType.Hairstyle]: {
            enumObject: l.HairStyle,
            descriptions: h.hairstyleDescriptions
        },
        [g.PathType.SoundEffect]: {
            enumObject: l.SfxType,
            descriptions: i.soundEffectDescriptions
        },
        [g.PathType.Music]: {
            enumObject: l.Music,
            descriptions: a.musicDescriptions
        },
        [g.PathType.Overlay]: {
            enumObject: l.OverlayType,
            descriptions: y.overlayDescriptions
        },
        [g.PathType.StatIcon]: {
            enumObject: r.Stat,
            descriptions: p.default
        },
        [g.PathType.HelpArticleIcon]: {
            enumObject: c.HelpArticle,
            descriptions: c.default
        },
        [g.PathType.StatusEffectIcon]: {
            enumObject: l.StatusType
        },
        [g.PathType.Mound]: {
            enumObject: l.TerrainType
        },
        [g.PathType.TileEvent]: {
            enumObject: f.TileEventType,
            descriptions: S.default
        },
        [g.PathType.StatusEffect]: {
            enumObject: l.StatusType,
            descriptions: s.default
        },
        [g.PathType.MenuBarButtonIcon]: {
            enumObject: d.MenuBarButtonType,
            descriptions: d.default
        },
        [g.PathType.DifficultyOptionsIcon]: {
            enumObject: m.DifficultyOptionsIcon,
            descriptions: m.default
        }
    };
    function M(e) {
        const t = w[e];
        return "object" == typeof t ? t : w[t]
    }
    const b = new I.default(I.LogSource.ResourceLoader,"Path");
    var k;
    !function(e) {
        function t(e, t, s) {
            let l = `static/${n(e)}/`;
            const u = o(e);
            l += u ? `${u}/` : "",
            l += `${r(e)}/`;
            const {enumObject: d, descriptions: p} = M(e);
            return t in d ? l += `${i(d, t, p)}` : (b.warn(`The given index ${t} does not exist in the enum for ${g.PathType[e]}`),
            l += "_unknown_"),
            (l = a(l, p, t, s)).replace(/\\/g, "/")
        }
        function a(e, t, a, i) {
            const n = void 0 !== t ? t[a] : void 0
              , o = n && n.modIndex;
            if (void 0 !== o && modManager.isValid(o)) {
                const t = modManager.getPath(o);
                (i = (i || n.imagePath || "").replace(/\\/g, "/")) && (/^\w:[\\/]/.test(i) && !i.startsWith(t) ? b.warn(`Mods may not access resources outside of their own directory. The path "${i}" is invalid. Falling back to default.`) : e = v.default.stripParentDirectoryAccessorsFromPath(i));
                const a = steamworks.isElectron() ? steamworks.getAbsolutePath(t) : "";
                e.startsWith(a) && (e = e.slice(a.length)),
                e = e.startsWith(t) ? e : `${t}/${e}`
            } else if (i)
                return i;
            return e
        }
        function i(e, t, a) {
            let i = e[t].toLowerCase();
            const n = i.indexOf("_");
            i = n >= 0 ? i.slice(n + 1) : i;
            const o = void 0 !== a ? a[t] : void 0
              , r = o && o.modIndex;
            if (void 0 === r || !modManager.isValid(r))
                return i;
            const s = `mod${modManager.getName(r)}`.toLowerCase().replace(/(?!#)\W/g, "");
            return i.startsWith(s) ? i.slice(s.length) : i
        }
        function n(e) {
            switch (e) {
            case g.PathType.Music:
            case g.PathType.SoundEffect:
                return "sound";
            default:
                return "image"
            }
        }
        function o(e) {
            switch (e) {
            case g.PathType.Equip:
            case g.PathType.Hairstyle:
            case g.PathType.Sleep:
            case g.PathType.StatusEffect:
                return "character";
            case g.PathType.MenuBarButtonIcon:
            case g.PathType.StatusEffectIcon:
            case g.PathType.StatIcon:
            case g.PathType.HelpArticleIcon:
            case g.PathType.DifficultyOptionsIcon:
                return "ui/icons"
            }
        }
        function r(e) {
            switch (e) {
            case g.PathType.DoodadItem:
                return "doodad";
            case g.PathType.MenuBarButtonIcon:
                return "menubar";
            case g.PathType.StatIcon:
                return "stat";
            case g.PathType.StatusEffect:
                return "status";
            case g.PathType.StatusEffectIcon:
                return "effect";
            case g.PathType.HelpArticleIcon:
                return "helparticle";
            case g.PathType.DifficultyOptionsIcon:
                return "difficultyoptions";
            default:
                return g.PathType[e].toString().toLowerCase()
            }
        }
        e.getPath = t,
        e.getModPath = a,
        e.getResourceName = i,
        e.getPathResourceType = n,
        e.getPathDomain = o,
        e.getPathTypeName = r
    }(k || (k = {})),
    t.default = k
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/util/Style", ["require", "exports", "resources/ResourcePath"], function(e, t, a) {
    var i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        function t(e, t, i="png", n=!1, o) {
            let r = "number" == typeof e ? a.default.getPath(e, t, o) : e;
            i = `.${i}`,
            r.endsWith(i) || (r += i);
            const s = resourceLoader.getImageOverride(r);
            return r = s && s.imagePath || r,
            `url("${r = /^[a-zA-Z]+:\/[^/]/.test(r) ? `file://${r}` : n ? `../../${r}` : `${steamworks.isElectron() ? "./" : "/"}${r}`}")`
        }
        e.getImagePath = t
    }(i || (i = {})),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/HelpMenu", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/UiTranslation", "language/segment/HeadingSegment", "language/segment/LinkSegment", "language/Translation", "mod/IHookHost", "newui/component/BlockRow", "newui/component/Button", "newui/component/Component", "newui/component/Input", "newui/component/LabelledRow", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/screen/screens/menu/menus/help/HelpArticleDescriptions", "newui/screen/screens/menu/menus/HelpArticle", "newui/util/Misc", "newui/util/Style", "resources/IResourceLoader", "utilities/Async", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/Objects", "utilities/promise/ResolvablePromise"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class D extends y.default {
        constructor(e) {
            super(e, h.MenuId.Help),
            this.articles = new Map,
            this.canShowArticle = new C.default,
            this.setTitle(e=>e.setText(n.default.MenuHelpTitle)),
            this.setDescription(e=>e.setText(n.default.MenuHelpDescription)),
            this.canCancel = !0,
            new m.LabelledRow(e).setLabel(e=>e.setText(n.default.MenuHelpLabelSearch)).append(this.searchInput = new c.default(e).on(c.InputEvent.Change, this.filterArticles)).appendTo(this.content),
            new g.default(e).appendTo(this.content);
            const t = {};
            for (const a of M.default.values(f.HelpArticle)) {
                const i = `${f.default[a].section}`
                  , n = t[i] = t[i] || new p.default(this.api).classes.add("help-section").appendTo(this.content)
                  , o = f.default[a].important
                  , r = n.getChildren().collect(b.default.toArray);
                let s = r.collect(b.default.last());
                if (!s || s.childCount > 1 || s.classes.has("filled") || o) {
                    const t = r[r.length - 2];
                    s = t && t.childCount < 2 && !t.classes.has("filled") ? t : new u.BlockRow(e).appendTo(n)
                }
                this.articles.set(a, new A(e,a).appendTo(s)),
                o && s.classes.add("filled")
            }
            this.on("Show", async()=>w.sleep(600).then(this.canShowArticle.resolve))
        }
        async showArticle(e) {
            await this.canShowArticle;
            const t = this.articles.get(e);
            return t && t.activate(!1),
            this
        }
        onBindLoop(e, t) {
            return e = super.onBindLoop(e, t),
            t.wasPressed(a.Bindable.DialogHelp) && !e && (S.switchMenu(h.MenuId.BACK),
            e = a.Bindable.DialogHelp),
            e
        }
        filterArticles() {
            const e = this.searchInput.text.toLowerCase();
            for (const [t,a] of this.articles.entries())
                a.toggle(s.default.getAll(i.Dictionary.HelpArticle, t).some(t=>t.withSegments(!0, r.default, o.default).getString().toLowerCase().includes(e)));
            for (const e of this.findDescendants(".help-section"))
                e.classList.toggle("hidden", !e.querySelector(".help-article-button:not(.hidden)"))
        }
    }
    __decorate([Override, l.HookMethod], D.prototype, "onBindLoop", null),
    __decorate([k.Bound], D.prototype, "filterArticles", null),
    t.default = D;
    class A extends d.default {
        constructor(e, t) {
            super(e),
            this.classes.add("help-article-button", "icon-no-scale");
            const [a,n] = s.default.getAll(i.Dictionary.HelpArticle, t);
            this.setText(()=>a),
            this.addDescription(e=>e.setText(()=>n)),
            this.on(d.ButtonEvent.Activate, S.menuSwitcher(()=>new T.default(this.api,t)));
            const o = this.getArticleIcon(t);
            o && this.classes.add("has-icon-before").style.setProperty("--help-icon", o)
        }
        getArticleIcon(e) {
            const t = f.default[e];
            return !(!t || !t.image) && I.default.getImagePath(v.PathType.HelpArticleIcon, e, void 0, !0, !0 === t.image ? void 0 : t.image)
        }
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/dialog/NotesDialog", ["require", "exports", "game/TimeManager", "language/Dictionaries", "language/dictionary/Note", "language/dictionary/UiTranslation", "language/Translation", "mod/IHookHost", "newui/component/Button", "newui/component/CheckButton", "newui/component/Text", "newui/INewUi", "newui/screen/screens/game/component/Dialog", "newui/screen/screens/game/Dialogs", "newui/screen/screens/menu/component/IMenu", "player/note/NoteManager", "utilities/enum/Enums", "utilities/iterable/Generators", "utilities/math/Math2", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S) {
    var I;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.ShowNote = 0] = "ShowNote"
    }(I = t.NotesDialogEvent || (t.NotesDialogEvent = {}));
    class v extends c.default {
        constructor(e) {
            super(e, m.DialogId.Notes),
            this.noteLinks = [],
            this.current = 0,
            this.classes.add("game-notes"),
            this.addSettingsPanel().append(new u.CheckButton(this.api).setText(o.default.GameDialogNotesSettingsPinUnreadNotesAutomatically).setRefreshMethod(()=>e.messages.pinNotesAutomatically).on(u.CheckButtonEvent.Change, (t,a)=>{
                e.messages.pinNotesAutomatically = a
            }
            )),
            this.addPanel("note").append(new d.Heading(this.api).classes.add("game-note-title").setText(w(()=>this.current))).append(new d.default(this.api).classes.add("game-note-time").setText(M(()=>this.current))).append(new d.default(this.api).classes.add("game-note-body").setText(b(()=>this.current))).append(this.learnMoreLink = new d.default(this.api).classes.add("game-note-learn-more").setText(o.default.GameDialogNotesLinkLearnMore).listen("click", this.learnMore));
            const t = this.addPanel("notes").on("Show", this.refreshNotesPanel);
            for (const e of f.range(g.default.getLength(n.default)))
                new k(this.api,e).on(l.ButtonEvent.Activate, this.showNote.bind(this, e)).appendTo(t).schedule(e=>this.noteLinks.push(e));
            this.footer.append(new l.default(this.api).classes.add("game-notes-button-previous", "has-icon-before", "button-icon").on(l.ButtonEvent.Activate, this.previousNote), this.noteId = new l.default(this.api).classes.add("game-note-number").on(l.ButtonEvent.Activate, this.onNoteNumberActivate).setText(()=>r.default.ui(o.default.GameDialogNotesNoteNumber).get(this.current + 1, g.default.getLength(n.default))), new l.default(this.api).classes.add("game-notes-button-next", "has-icon-before", "button-icon").on(l.ButtonEvent.Activate, this.nextNote)),
            this.on("Append", this.onShow)
        }
        onWrittenNote(e, t) {
            e.isLocalPlayer() && (this.isPanelVisible("note") ? this.showNote(this.current) : this.refreshNotesPanel())
        }
        getName() {
            return o.default.GameDialogNotesName
        }
        showNote(e) {
            this.emit(I.ShowNote, e),
            this.current = e = T.default.mod(e, g.default.getLength(n.default)),
            this.note = localPlayer.notes.getNote(e),
            this.getPanel("note").classes.toggle(!this.note, "game-note-locked");
            const t = this.note && y.noteDescriptions[n.default[this.note.id]];
            return this.learnMoreLink.toggle(!(!t || !t.learnMore)),
            this.showPanel("note").schedule(this.api.refreshTranslations, this.noteId),
            this
        }
        previousNote() {
            this.showNote(this.current - 1)
        }
        nextNote() {
            this.showNote(this.current + 1)
        }
        onShow() {
            this.showNote(this.current)
        }
        onNoteNumberActivate() {
            this.showPanel(this.isPanelVisible("note") ? "notes" : "note")
        }
        refreshNotesPanel() {
            for (const e of this.noteLinks)
                e.refreshText()
        }
        learnMore() {
            const e = y.noteDescriptions[n.default[this.note.id]].learnMore;
            this.api.interrupt().withMenu(h.MenuId.Help, async t=>t.showArticle(e))
        }
    }
    function w(e) {
        return ()=>{
            const t = localPlayer.notes.getNote(e());
            return t ? new r.default(i.Dictionary.Note,n.default[t.id],n.NoteTranslation.Name) : o.default.GameDialogNotesNoteLockedTitle
        }
    }
    function M(e) {
        return ()=>{
            const t = localPlayer.notes.getNote(e());
            return t ? r.default.ui(o.default.GameDialogNotesNoteTime).get(t.time.day, game.time.getTranslation(t.time.time, t.time.skilled ? a.TimeFormat.TwelveHourNoMinute : a.TimeFormat.PartOfDay)) : []
        }
    }
    function b(e) {
        return ()=>{
            const t = localPlayer.notes.getNote(e());
            return t ? new r.default(i.Dictionary.Note,n.default[t.id],n.NoteTranslation.Note).get(...t.args) : o.default.GameDialogNotesNoteLockedDescription
        }
    }
    __decorate([p.Save(p.SaveLocation.Local)], v.prototype, "current", void 0),
    __decorate([s.HookMethod(p.NEWUI_HOOK_PRIORITY)], v.prototype, "onWrittenNote", null),
    __decorate([Override], v.prototype, "getName", null),
    __decorate([S.Bound], v.prototype, "previousNote", null),
    __decorate([S.Bound], v.prototype, "nextNote", null),
    __decorate([S.Bound], v.prototype, "onShow", null),
    __decorate([S.Bound], v.prototype, "onNoteNumberActivate", null),
    __decorate([S.Bound], v.prototype, "refreshNotesPanel", null),
    __decorate([S.Bound], v.prototype, "learnMore", null),
    t.default = v;
    class k extends l.default {
        constructor(e, t) {
            super(e),
            this.classes.add("game-note-link"),
            this.attributes.set("intercept", "all"),
            this.setText(()=>r.default.ui(o.default.GameDialogNotesLinkId).get(t + 1)),
            this.title = new d.default(this.api).setText(w(()=>t)).appendTo(this),
            this.time = new d.default(this.api).setText(M(()=>t)).appendTo(this)
        }
        refreshText() {
            return super.refreshText(),
            this.title.refresh(),
            this.time.refresh(),
            this
        }
    }
    __decorate([Override, S.Bound], k.prototype, "refreshText", null)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/dialog/QuestDialog", ["require", "exports", "language/dictionary/UiTranslation", "language/segment/LinkSegment", "language/Translation", "newui/component/Button", "newui/component/Component", "newui/component/IComponent", "newui/component/Text", "newui/INewUi", "newui/screen/screens/game/component/Dialog", "newui/screen/screens/game/Dialogs", "newui/screen/screens/game/IGameScreenApi", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/menus/help/HelpArticleDescriptions", "utilities/Async", "utilities/iterable/Collectors", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class T extends d.default {
        constructor(e) {
            super(e, p.DialogId.Quests),
            this.current = 0,
            this.header.backButton.on(o.ButtonEvent.Activate, ()=>this.showPanel("quests")),
            this.on(d.DialogEvent.SwitchPanel, this.onSwitchPanel),
            localPlayer.quests.on(1, (e,t)=>this.addQuest(t)),
            localPlayer.quests.on([0, 3], this.onQuestOrRequirementComplete),
            this.addPanel("quests").append(this.questsActiveHeading = new l.Heading(this.api).hide().setText(a.default.GameDialogQuestsActiveQuests)).append(this.questsActiveWrapper = new r.default(this.api)).append(this.questsCompletedHeading = new l.Heading(this.api).hide().setText(a.default.GameDialogQuestsCompletedQuests)).append(this.questsCompletedWrapper = new r.default(this.api));
            const t = localPlayer.quests.getQuests();
            t.forEach(this.addQuest),
            t.length || y.sleep(1).then(()=>{
                this.gsapi.closeDialog(p.DialogId.Quests)
            }
            ),
            this.addPanel("quest").append(new l.Heading(this.api).classes.add("game-quest-title").setText(this.getTitle)).append(new v(this.api).classes.add("game-quest-description").setText(this.getDescription)).append(),
            this.requirementsHeading = new l.Paragraph(this.api).setText(a.default.GameDialogQuestsRequirements).appendTo(this.footer),
            this.requirements = new r.default(this.api).classes.add("game-quest-requirements", "scrollable").appendTo(this.footer),
            this.childQuestsHeading = new l.Paragraph(this.api).setText(a.default.GameDialogQuestsChildQuests).appendTo(this.footer),
            this.childQuests = new r.default(this.api).classes.add("game-quest-children", "scrollable").appendTo(this.footer),
            this.completeQuestButton = new o.default(this.api).setText(a.default.GameDialogQuestsCompleteQuest).on(o.ButtonEvent.Activate, ()=>{
                const e = this.getQuest();
                e && e.complete()
            }
            ).appendTo(this.footer),
            void 0 !== this.current && this.showQuest(this.current)
        }
        getName() {
            return a.default.GameDialogQuestsName
        }
        showQuest(e) {
            this.current = e,
            this.showPanel("quest").schedule(this.api.refreshTranslations).element.scrollTop = 0,
            this.api.highlights.end(this);
            const t = this.getQuest();
            return t ? (this.refreshFooter(t),
            this) : this
        }
        refreshFooter(e) {
            if (this.requirements.dump(),
            this.childQuests.dump(),
            e.data.complete) {
                const t = localPlayer.quests.getQuests();
                for (const a of e.getChildren()) {
                    const e = t.find(e=>e.data.type === a);
                    this.childQuests.append(e && new S(this.api,e).on(o.ButtonEvent.Activate, this.showQuest.bind(this, e.id)))
                }
            } else
                for (const t of e.getRequirements())
                    this.addRequirementRow(e, t);
            this.requirementsHeading.toggle(!!this.requirements.childCount),
            this.childQuestsHeading.toggle(!!this.childQuests.childCount),
            this.completeQuestButton.toggle(e.getRequirements().every(e=>e.data.completed) && e.needsManualCompletion()),
            this.footer.classes.toggle(!!this.requirements.childCount || !!this.childQuests.childCount || !this.completeQuestButton.classes.has("hidden"), "display")
        }
        addRequirementRow(e, t) {
            const a = t.getRelations();
            function i({id: [a,i]}) {
                return a === e.id && i === t.id
            }
            a.length && this.api.highlights.start(this, {
                selectors: a,
                iterations: 5
            });
            const n = new I(this.api,t).on("Update", ()=>s.classes.toggle(this.getPins().any(i), "pinned"))
              , s = new o.default(this.api,void 0,!1).classes.add("has-icon-before", "button-icon", "button-pin").classes.toggle(this.getPins().any(i), "pinned");
            new r.default(this.api).classes.add("game-quest-requirement").append(s, n).listen("click", ()=>{
                if (t.data.completed)
                    return;
                const a = this.getPins().filter(i).collect(g.default.first());
                s.classes.toggle(!a, "pinned"),
                a ? a.remove() : this.gsapi.messages.pinQuestRequirement(e, t)
            }
            ).appendTo(this.requirements);
            const l = this.until("Remove");
            l.bind(this.gsapi.messages, 0, (e,t)=>{
                i(t) && s.classes.add("pinned")
            }
            ),
            l.bind(this.gsapi.messages, 1, (e,t)=>{
                i(t) && s.classes.remove("pinned")
            }
            )
        }
        addQuest(e) {
            return new S(this.api,e).appendTo(e.data.complete ? this.questsCompletedWrapper : this.questsActiveWrapper, s.AppendStrategy.Prepend).on(o.ButtonEvent.Activate, this.showQuest.bind(this, e.id)).on("Complete", e=>{
                e.appendTo(this.questsCompletedWrapper, s.AppendStrategy.Prepend),
                this.questsCompletedHeading.show(),
                0 === this.questsActiveWrapper.childCount && this.questsActiveHeading.hide()
            }
            ),
            e.data.complete ? this.questsCompletedHeading.show() : this.questsActiveHeading.show(),
            this
        }
        getQuest() {
            return localPlayer.quests.getQuests()[this.current]
        }
        getPins() {
            return this.gsapi.messages.getPins().filter(e=>e.type === c.PinType.QuestRequirement)
        }
        getTitle() {
            const e = this.getQuest();
            return e && e.getTitle()
        }
        getDescription() {
            const e = this.getQuest()
              , t = e && e.getDescription();
            return t && t.withSegments(!0, i.default),
            t
        }
        onSwitchPanel(e, t) {
            this.header.backButton.toggle("quest" === t),
            this.requirements.dump(),
            this.childQuests.dump(),
            this.footer.classes.remove("display")
        }
        onQuestOrRequirementComplete(e, t) {
            if (!this.isPanelVisible("quest"))
                return;
            const a = localPlayer.quests.getQuests();
            a[this.current] === t && this.refreshFooter(t)
        }
    }
    __decorate([u.Save(u.SaveLocation.Local)], T.prototype, "current", void 0),
    __decorate([Override], T.prototype, "getName", null),
    __decorate([f.Bound], T.prototype, "showQuest", null),
    __decorate([f.Bound], T.prototype, "addQuest", null),
    __decorate([f.Bound], T.prototype, "getTitle", null),
    __decorate([f.Bound], T.prototype, "getDescription", null),
    __decorate([f.Bound], T.prototype, "onSwitchPanel", null),
    __decorate([f.Bound], T.prototype, "onQuestOrRequirementComplete", null),
    t.default = T;
    class S extends o.default {
        constructor(e, t) {
            super(e),
            this.quest = t,
            this.classes.add("game-quest-link"),
            this.progressRow = new r.default(e).classes.add("unlockable-row").append(new l.default(e).setText(this.getQuestTranslation)).appendTo(this),
            this.refresh(),
            this.until("Remove").bind(t, [0, 2], this.refresh)
        }
        refresh() {
            let e = this.quest.getCompletionAmount();
            return 0 === this.quest.getRequirements().collect(g.default.toArray).length && (e = 1),
            this.progressRow.style.setProperty("--percent", `${100 * e}`),
            e >= 1 && !this.quest.needsManualCompletion() && (this.progressRow.classes.add("unlocked"),
            this.emit("Complete")),
            this.progressRow.getNthChild(0).refresh(),
            this
        }
        getQuestTranslation() {
            const e = this.quest.getRequirements().collect(g.default.toArray);
            return n.default.ui(a.default.GameDialogQuestsLink).addArgs(this.quest.getTitle(), e.filter(e=>e.data.completed).length, e.length)
        }
    }
    __decorate([f.Bound], S.prototype, "refresh", null),
    __decorate([f.Bound], S.prototype, "getQuestTranslation", null);
    class I extends r.default {
        constructor(e, t) {
            super(e),
            this.requirement = t,
            this.classes.add("unlockable-row"),
            this.text = new l.default(e).setText(t.getTranslation).appendTo(this),
            this.refresh(),
            this.until("Remove").bind(t, ["Update", "Met", "Visible"], this.refresh);
            const a = t.getRelations();
            a.length && this.setHighlight({
                selectors: a
            })
        }
        refresh() {
            const e = this.requirement.getCompletionAmount();
            return this.style.setProperty("--percent", `${100 * e}`),
            e >= 1 && this.classes.add("unlocked"),
            this.text.refresh(),
            this.toggle(!this.requirement.data.hidden),
            this.emit("Update"),
            this
        }
    }
    __decorate([f.Bound], I.prototype, "refresh", null);
    class v extends l.Paragraph {
        refresh() {
            super.refresh();
            for (const e of this.getChildren())
                e.setLinkHandler(e=>!(!Array.isArray(e) || "HelpArticle" !== e[0]) && (this.api.interrupt().withMenu(m.MenuId.Help, async t=>t.showArticle(h.HelpArticle[e[1]])),
                !0));
            return this
        }
    }
    __decorate([f.Bound, Override], v.prototype, "refresh", null)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/enum/IEnum", ["require", "exports"], function(e, t) {
    var a, i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.NAME = Symbol("NAME"),
        e.OFFICIAL_MAX = Symbol("OFFICIAL_MAX"),
        e.MOD_START = Symbol("MOD_START"),
        e.LENGTH = Symbol("LENGTH")
    }(a = t.EnumProperty || (t.EnumProperty = {})),
    function(e) {
        e[e.CreatureType = 0] = "CreatureType",
        e[e.Bindable = 1] = "Bindable",
        e[e.ActionType = 2] = "ActionType",
        e[e.ItemType = 3] = "ItemType",
        e[e.TerrainType = 4] = "TerrainType",
        e[e.DoodadType = 5] = "DoodadType",
        e[e.Message = 6] = "Message",
        e[e.SkillType = 7] = "SkillType",
        e[e.HairStyle = 8] = "HairStyle",
        e[e.HairColor = 9] = "HairColor",
        e[e.SkinColor = 10] = "SkinColor",
        e[e.Dictionary = 11] = "Dictionary",
        e[e.Music = 12] = "Music",
        e[e.SoundEffect = 13] = "SoundEffect",
        e[e.Command = 14] = "Command",
        e[e.Stat = 15] = "Stat",
        e[e.StatusEffect = 16] = "StatusEffect",
        e[e.MenuBarButton = 17] = "MenuBarButton",
        e[e.CorpseType = 18] = "CorpseType",
        e[e.TileEventType = 19] = "TileEventType",
        e[e.OverlayType = 20] = "OverlayType",
        e[e.MessageSource = 21] = "MessageSource",
        e[e.NPCType = 22] = "NPCType",
        e[e.HelpArticle = 23] = "HelpArticle",
        e[e.Note = 24] = "Note",
        e[e.Dialog = 25] = "Dialog",
        e[e.InterruptChoice = 26] = "InterruptChoice",
        e[e.ItemTypeGroup = 27] = "ItemTypeGroup",
        e[e.InspectType = 28] = "InspectType",
        e[e.DailyChallengeModifier = 29] = "DailyChallengeModifier",
        e[e.Quest = 30] = "Quest",
        e[e.QuestRequirement = 31] = "QuestRequirement"
    }(i = t.EnumId || (t.EnumId = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/data/ISaveData", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/data/SaveData", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.saveDataVersionUnknown = "Unknown";
    class i {
        constructor() {
            this.gameState = a.PlayerState.None,
            this.saveManagerSaveTime = 0,
            this.saveManagerTicks = 0,
            this.saveManagerScore = 0,
            this.modManagerSaveData = {},
            this.modManagerUnloadable = {},
            this.multiplayerState = {
                enable: !1
            },
            this.utilitiesEnumsAllocated = {},
            this.clientStore = new Map
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("utilities/Files", ["require", "exports"], function(e, t) {
    function a(e) {
        let t = JSON.stringify(e, null, "\t");
        return t = (t = (t = (t = t.replace(/\t("[^\n\r]*?"|null|\d+)\s*?(?=\])/g, "$1")).replace(/\t((?:"[^\n\r:]*?"|null|\d+),)\s*?(?=\t(?:"|null|\d+))/g, "$1 ")).replace(/\[\s*(?=["\]]|null|\d+)/g, "[")).replace(/("|null|\d+),(?:(?=\s)[^\r\n]){2,}(?="|null|\d+)/g, "$1, ")
    }
    var i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        async function t(e) {
            return fetch(`${e}${-1 === e.indexOf("?") ? "?" : "&"}_=${(new Date).getTime()}`)
        }
        async function i(e) {
            return t(e).then(async e=>e.text())
        }
        async function n(e) {
            return t(e).then(async e=>e.json())
        }
        async function o(e) {
            return t(e).then(async e=>e.arrayBuffer())
        }
        function r(e, t, i=!0, n=!1) {
            const o = URL.createObjectURL(new Blob([i ? n ? a(t) : JSON.stringify(t) : t],{
                type: "text/json"
            }));
            ui.setObjectUrl(o);
            const r = document.createElement("a");
            r.href = o,
            r.download = e,
            r.click(),
            r.remove()
        }
        async function s(e) {
            const t = e.target.files;
            if (t && t[0])
                return new Promise((a,i)=>{
                    const n = new FileReader;
                    n.onloadend = (e=>{
                        const t = e.target.result;
                        let o;
                        t || i(n.error);
                        try {
                            o = JSON.parse(t)
                        } catch (e) {
                            i(e)
                        }
                        a(o)
                    }
                    ),
                    n.readAsText(t[0], "ascii"),
                    $(e.target).val("")
                }
                )
        }
        e.get = t,
        e.getText = i,
        e.getJson = n,
        e.getArrayBuffer = o,
        e.download = r,
        e.upload = s
    }(i || (i = {})),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Version", ["require", "exports", "language/dictionary/UiTranslation", "language/Translation"], function(e, t, a, i) {
    var n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        const t = /^(beta|release)?(\d+)\.(\d+)(?:\.(\d+))?$/;
        function n(e) {
            const a = e.match(t);
            if (!a)
                throw new Error("Version string must be in the format '(beta|release)#.#(.#)?'");
            return {
                str: e,
                stage: a[1] ? a[1] : "beta",
                major: parseInt(a[2], 10),
                minor: parseInt(a[3], 10),
                patch: a[4] ? parseInt(a[4], 10) : 0
            }
        }
        function o(e, t) {
            return e.stage === t.stage && e.major === t.major && e.minor === t.minor && e.patch === t.patch
        }
        function r(e=gameVersion) {
            const t = "string" == typeof e ? n(e) : e;
            return i.default.ui(a.default.MiscVersion).getString("beta" === t.stage, t.major, t.minor, t.patch)
        }
        e.getVersionInfo = n,
        e.isSameVersion = o,
        e.getVersionDisplayString = r
    }(n || (n = {})),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/loadgame/SaveSlot", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/InterruptChoice", "language/dictionary/Message", "language/dictionary/UiTranslation", "language/Translation", "mod/IModInfo", "newui/component/Button", "newui/component/IComponent", "newui/component/InputButton", "newui/util/Misc", "save/data/SaveData", "utilities/Files", "utilities/Log", "utilities/Objects", "utilities/string/Strings", "utilities/Version"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T) {
    var S;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Rename = "Rename",
        e.Delete = "Delete"
    }(S = t.SaveSlotEvent || (t.SaveSlotEvent = {}));
    class I extends p.default {
        constructor(e, t) {
            super(e, e=>e.setMaxLength(28)),
            this.classes.add("save-slot", "icon-no-scale"),
            this.slotData.slot = t,
            this.setText(s.default.generator(()=>this.dataset.name || "")),
            this.setTooltip(this.getTooltip),
            this.addButton(e=>e.classes.add("button-edit").setTooltip(e=>e.addHeading(e=>e.setText(r.default.MenuLoadGameSaveButtonEditNameTooltip))).on(u.ButtonEvent.Activate, ()=>this.editMode = !0)),
            this.addButton(e=>e.classes.add("button-export").setTooltip(e=>e.addHeading(e=>e.setText(r.default.MenuLoadGameSaveButtonExportTooltip))).on(u.ButtonEvent.Activate, this.export)),
            this.addButton(e=>e.classes.add("button-delete").setTooltip(e=>e.addHeading(e=>e.setText(r.default.MenuLoadGameSaveButtonDeleteTooltip))).on(u.ButtonEvent.Activate, this.delete)),
            this.on(p.InputButtonEvent.Done, this.rename),
            this.load()
        }
        get slotData() {
            return this.jsonData()
        }
        async load() {
            const e = this.slotData
              , t = await saveManager.loadPartial(e.slot)
              , i = {};
            saveManager.loadPartialData(t, i, "gameSlotName"),
            saveManager.loadPartialData(t, i, "gameState"),
            saveManager.loadPartialData(t, i, "gameBaseSeed"),
            saveManager.loadPartialData(t, i, "gameCreationTime"),
            saveManager.loadPartialData(t, i, "saveManagerOriginalVersion"),
            saveManager.loadPartialData(t, i, "saveManagerTicks"),
            saveManager.loadPartialData(t, i, "saveManagerDifficulty"),
            saveManager.loadPartialData(t, i, "saveManagerScore"),
            saveManager.loadPartialData(t, i, "saveManagerDeathBy"),
            saveManager.loadPartialData(t, i, "saveTime"),
            saveManager.loadPartialData(t, i, "modsUnloadable"),
            saveManager.loadPartialData(t, i, "gameThumbnail"),
            this.dataset.name = i.gameSlotName,
            this.dataset.state = a.PlayerState[i.gameState || a.PlayerState.None],
            this.deathby = i.saveManagerDeathBy,
            this.refreshText(),
            e.score = void 0 === i.saveManagerScore ? -1 : i.saveManagerScore,
            e.turns = i.saveManagerTicks || -1,
            e.difficulty = void 0 === i.saveManagerDifficulty ? -1 : i.saveManagerDifficulty,
            e.modsUnloadable = i.modsUnloadable,
            e.saveTime = i.saveTime,
            e.createdTime = i.gameCreationTime || -1,
            this.dataset.originalVersion = i.saveManagerOriginalVersion || m.saveDataVersionUnknown,
            void 0 !== i.gameBaseSeed && (this.dataset.seed = `${i.gameBaseSeed}`),
            void 0 !== i.gameThumbnail && (this.classes.add("has-icon-before"),
            this.style.setProperty("--thumbnail", `url("${i.gameThumbnail}")`))
        }
        getTooltip(e) {
            e.setLocation(d.TooltipLocation.CenterRight),
            e.classes.add("save-slot-tooltip"),
            this.dataset.state !== a.PlayerState[a.PlayerState.None] && this.deathby && e.addParagraph(e=>e.setText(s.default.message(this.dataset.state === a.PlayerState[a.PlayerState.Ghost] ? o.default.Killed : o.default.ReturnedToCivilization).addArgs(this.deathby)).classes.add(this.dataset.state === a.PlayerState[a.PlayerState.Ghost] ? "bad" : "good")),
            void 0 !== this.dataset.seed && e.addParagraph(e=>e.setText(s.default.ui(r.default.MenuLoadGameSaveTooltipLabelSeed).addArgs(this.dataset.seed))),
            -1 !== this.slotData.score && e.addParagraph(e=>e.setText(s.default.ui(r.default.MenuLoadGameSaveTooltipLabelScore).addArgs(this.slotData.score))),
            e.addParagraph(e=>e.setText(s.default.ui(r.default.MenuLoadGameSaveTooltipLabelSaveTime).addArgs(new Date(this.slotData.saveTime).toLocaleString()))),
            -1 !== this.slotData.difficulty && e.addParagraph(e=>e.setText(s.default.ui(r.default.MenuLoadGameSaveTooltipLabelDifficulty).addArgs(new s.default(i.Dictionary.Difficulty,this.slotData.difficulty)))),
            this.slotData.createdTime >= 0 && e.addParagraph(e=>e.setText(s.default.ui(r.default.MenuLoadGameSaveTooltipLabelCreatedTime).addArgs(new Date(this.slotData.createdTime).toLocaleString())));
            const t = this.slotData.turns;
            if (-1 !== t && e.addParagraph(e=>e.setText(s.default.ui(r.default.MenuLoadGameSaveTooltipLabelTurns).addArgs(t))),
            void 0 !== this.slotData.modsUnloadable) {
                const t = Object.keys(this.slotData.modsUnloadable).filter(e=>!this.slotData.modsUnloadable[e].unloadable);
                t.length && e.addParagraph(e=>e.setText(s.default.ui(r.default.MenuLoadGameSaveTooltipLabelMods).addArgs(t.values().map(c.isModLoadable).map(([e,t])=>s.default.ui(r.default.MenuLoadGameSaveTooltipMod).addArgs(e, `text-color-dependency-${t}`)).collect(s.default.formatList))))
            }
            if (saveDataGlobal.options.developerMode) {
                const t = this.dataset.originalVersion === m.saveDataVersionUnknown ? s.default.ui(r.default.MiscSaveVersionUnknown).get() : T.default.getVersionDisplayString(this.dataset.originalVersion);
                e.addParagraph(e=>e.setText(s.default.ui(r.default.MenuLoadGameSaveTooltipLabelOriginalVersion).addArgs(t)))
            }
            return e
        }
        async rename(e, t) {
            if ("" === t)
                return;
            const a = {
                gameSlotName: t
            };
            await saveManager.savePartialData(this.slotData.slot,a,"gameSlotName","gameSlotName"),
            this.dataset.name = t,
            this.refreshText(),
            this.emit(S.Rename)
        }
        async delete() {
            const e = await this.api.interrupt(()=>s.default .ui(r.default .MenuLoadGameInterruptDeleteSave).get(this.dataset.name)).withDescription(r.default .MenuLoadGameInterruptDeleteSaveDescription).withConfirmation();
            e && (await saveManager.deleteSlot(this.slotData.slot),
            this.emit(S.Delete))
        }
        async export() {
            let e = n.default.LocalFile;
            switch (steamworks.isElectron() && (e = await this.api.interrupt(s.default .ui(r.default .MenuLoadGameInterruptExportType)).withDescription(s.default .ui(r.default .MenuLoadGameInterruptExportTypeDescription)).withChoice(n.default .SteamWorkshop,n.default .LocalFile,n.default .Cancel)),
            e) {
            case n.default.SteamWorkshop:
                this.exportToWorkshop();
                break;
            case n.default.LocalFile:
                this.exportToFile()
            }
        }
        async exportToWorkshop() {
            await this.api.interrupt(r.default .MenuLoadGameInterruptLoadingExportingSave).withDescription(r.default .MenuLoadGameInterruptLoadingExportingSaveDescription).withLoading();
            const e = this.dataset.name
              , t = await steamworks.createSaveGameMod(e,this.slotData.slot);
            if (t) {
                const t = await modManager.setupMod(e,l.ModType.Local,l.ModState.Temporary);
                if (void 0 !== t) {
                    await this.api.interrupt(r.default .MenuLoadGameInterruptPublishingSave).withDescription(r.default .MenuLoadGameInterruptPublishingSaveDescription).withLoading();
                    const a = await steamworks.publishMod(t).catch (e=>this.onPublishError);
                    modManager.removeMod(t),
                    steamworks.deleteSaveGameMod(e),
                    await this.api.hideLoadingInterrupt(),
                    steamworks.openWorkshop(a)
                }
            }
            await this.api.hideLoadingInterrupt()
        }
        onPublishError(e) {
            y.default.error(y.LogSource.Ui)("publishMod", e),
            this.api.interrupt(s.default.generator(e)).withInfo()
        }
        async exportToFile() {
            await this.api.interrupt(r.default .MenuLoadGameInterruptLoadingExportingSave).withDescription(r.default .MenuLoadGameInterruptLoadingExportingSaveDescription).withLoading();
            const e = await saveManager.exportSave(this.slotData.slot);
            h.default.download(`${I.getFileName(this.dataset.name)}-${f.default.generateTimestamp()}.json`, e),
            await this.api.hideLoadingInterrupt()
        }
        static getFileName(e="Wayward-") {
            return e.replace(f.matchNotLanguageLetters, "_")
        }
    }
    __decorate([g.Bound], I.prototype, "getTooltip", null),
    __decorate([g.Bound], I.prototype, "rename", null),
    __decorate([g.Bound], I.prototype, "delete", null),
    __decorate([g.Bound], I.prototype, "export", null),
    __decorate([g.Bound], I.prototype, "onPublishError", null),
    t.SaveSlot = I
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Arrays", ["require", "exports", "utilities/Random"], function(e, t, a) {
    var i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        function t(e, t, a=1) {
            void 0 === t && (t = e,
            e = 0);
            const i = [];
            for (let n = e; n < t; n += a)
                i.push(n);
            return i
        }
        function i(e, t) {
            if (e === t)
                return !0;
            if (!e || !t || e.length !== t.length)
                return !1;
            const a = e.length;
            for (let i = 0; i < a; i++)
                if (e[i] !== t[i])
                    return !1;
            return !0
        }
        function n(e, t, i=!0) {
            if (e.length <= t)
                return [...e];
            const n = [];
            for (let o = 0; o < t; ) {
                const t = e[(i ? a.default : a.generalRandom).int(e.length)];
                n.includes(t) || (n.push(t),
                o++)
            }
            return n
        }
        function o(e, t=a.generalRandom) {
            let i = e.length, n, o;
            for (; 0 !== i; )
                o = t.int(i),
                n = e[i -= 1],
                e[i] = e[o],
                e[o] = n;
            return e
        }
        function r(e, t, a) {
            const i = e.indexOf(t);
            return void 0 === a && (a = -1 === i),
            a ? i >= 0 ? i : e.push(t) : (e.splice(i, 1),
            -1)
        }
        e.range = t,
        e.equals = i,
        e.random = n,
        e.shuffle = o,
        e.toggle = r
    }(i || (i = {})),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/Messages", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Misc", "language/dictionary/Note", "language/dictionary/UiTranslation", "language/Translation", "mod/IHookHost", "multiplayer/packets/shared/ChatMessagePacket", "newui/BindingManager", "newui/component/Button", "newui/component/Component", "newui/component/ContextMenu", "newui/component/IComponent", "newui/component/Input", "newui/component/Text", "newui/INewUi", "newui/screen/IScreen", "newui/screen/screens/game/component/QuadrantComponent", "newui/screen/screens/game/dialog/MessagesEditFiltersDialog", "newui/screen/screens/game/dialog/NotesDialog", "newui/screen/screens/game/Dialogs", "newui/screen/screens/game/IGameScreenApi", "newui/screen/screens/menu/menus/loadgame/SaveSlot", "player/IMessageManager", "player/MessageManager", "utilities/Arrays", "utilities/Async", "utilities/enum/Enums", "utilities/Files", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Log", "utilities/Objects", "utilities/string/Strings"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L, O) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.DEFAULT_MAX_MESSAGES = 30;
    const F = 3
      , _ = Symbol("EditMessages");
    class H extends I.default {
        constructor(e) {
            super(e),
            this.pinNotesAutomatically = !0,
            this.filters = H.defaultFilters,
            this.selectedFilter = H.allFilterName,
            this.showSendButton = !0,
            this.showOptionsButton = !0,
            this.messageTimestamps = b.MessageTimestamp.None,
            this.maxMessages = t.DEFAULT_MAX_MESSAGES,
            this.pinnedNotes = [],
            this.seenNotes = [],
            this.pinnedQuestRequirements = [],
            this.messagesToDisplay = [],
            this.classes.add("game-messages"),
            this.log = new m.default(this.api).classes.add("game-log", "scrollable").appendTo(this),
            this.pinnedMessages = new m.default(this.api).classes.add("game-messages-pinned").appendTo(this),
            new c.default(this.api).classes.add("game-messages-options", "has-icon-before", "simple-button", "icon-no-scale").on(c.ButtonEvent.Activate, this.showOptions).appendTo(this),
            this.filter = new c.default(this.api).classes.add("game-messages-filter", "simple-button").attributes.set("intercept", "all").on(c.ButtonEvent.Activate, this.openFilterMenu).setText(()=>l.default.ui(s.default.GameMessagesFilter).get(this.selectedFilter)).appendTo(this),
            this.input = new g.default(this.api).setShouldBlurWhenEnterPressed(!1).classes.add("game-chat").on(g.InputEvent.Enter, this.sendMessage).appendTo(this),
            this.sendButton = new c.default(this.api).classes.add("game-send", "simple-button").attributes.set("intercept", "all").setText(s.default.GameMessagesButtonSend).on(c.ButtonEvent.Activate, this.sendMessage).appendTo(this),
            new m.default(this.api).classes.add("game-messages-scrollbar-intercepter").appendTo(this),
            this.on("Append", ()=>{
                this.schedule(5, this.scrollToNewest)
            }
            ),
            this.gsapi ? this.gsapi.on(b.GameScreenEvent.ShowDialog, this.onShowDialog) : hookManager.register(this, "MessagesDedicatedServerPauseMenu").until("Remove"),
            this.on(I.QuadrantComponentEvent.ChangeQuadrant, this.scrollToNewest),
            game.isChallenge && this.pinRequirementsFromQuest(localPlayer.quests.getQuests()[0]),
            localPlayer.quests.on(1, this.onQuestGet),
            localPlayer.quests.on(3, this.onRequirementComplete),
            this.once(T.UiApiEvent.LoadedFromSave, ()=>{
                for (const e of Object.keys(this.filters))
                    if (this.filters[e].some(e=>"number" == typeof e))
                        return void (this.filters = H.defaultFilters);
                if (this.pinnedNotes.forEach(this.addPinnedNote),
                this.pinnedQuestRequirements.forEach(this.addPinnedQuestRequirement),
                this.pinnedQuestRequirements.length < F)
                    e: for (const e of localPlayer.quests.getQuests()) {
                        const t = e.getRequirements().collect(x.default.toArray);
                        e.needsManualCompletion() && !t.length && this.pinQuestRequirement(e);
                        for (const a of t)
                            if (!a.data.completed && !a.data.hidden && !this.pinnedQuestRequirements.some(([t,i])=>t === e.id && i === a.id) && (this.pinQuestRequirement(e, a),
                            this.pinnedQuestRequirements.length >= F))
                                break e
                    }
                if (this.pinnedNotes.length < F && this.pinNotesAutomatically)
                    for (let e = 0; e < localPlayer.notes.notes.length && (this.pinnedNotes.includes(e) || this.seenNotes.includes(e) || (this.onWrittenNote(localPlayer, e),
                    !(this.pinnedNotes.length >= F))); e++)
                        ;
                this.changeFilter(this.selectedFilter),
                this.setMessageTimestampMode(this.messageTimestamps),
                this.setShouldShowSendButton(this.showSendButton),
                this.setShouldShowOptionsButton(this.showOptionsButton)
            }
            ),
            this.api.registerDataHost(this.gsapi ? "Messages" : "ServerMessages", this)
        }
        static sendChatMessage(e, t) {
            const i = new d.default;
            return i.pid = e.id,
            i.message = t,
            multiplayer.syncPacket(i, ()=>{
                const i = e.isServer() ? l.default.ui(s.default.MiscPlayerNameServer) : e.getName();
                E.default.info(E.LogSource.Chat)(`${i.getString()}: ${t}`),
                D.default.toAll(a=>a.source(!0, C.Source.Chat).send(e.isServer() ? n.default.ChatServerMessage : n.default.ChatPlayerMessage, i, l.default.defaultInterpolator.interpolate(t))),
                audio.queueEffect(a.SfxType.Chat, 0, 0, 0, void 0, void 0, !0)
            }
            , !0),
            this
        }
        static get allFilterName() {
            return l.default.ui(s.default.GameMessagesFilterAll).getString()
        }
        static get defaultFilters() {
            return {
                [H.allFilterName]: [C.Source[C.Source.All]],
                [l.default.ui(s.default.GameMessagesFilterGame).getString()]: [C.Source[C.Source.Game]],
                [l.default.ui(s.default.GameMessagesFilterChat).getString()]: [C.Source[C.Source.Chat]]
            }
        }
        get preferredQuadrant() {
            return H.preferredQuadrant
        }
        getID() {
            return b.QuadrantComponentId.Messages
        }
        getName() {
            return l.default.ui(s.default.GameQuadrantElementMessages).get()
        }
        getPins() {
            return this.pinnedMessages.getChildren().filter(e=>e)
        }
        getMessageTimestampMode() {
            return this.messageTimestamps
        }
        setMessageTimestampMode(e) {
            return this.messageTimestamps = e,
            this.attributes.set("timestamp", b.MessageTimestamp[e]),
            this
        }
        shouldShowSendButton() {
            return this.showSendButton
        }
        setShouldShowSendButton(e) {
            return this.showSendButton = e,
            this.sendButton.toggle(e),
            this
        }
        shouldShowOptionsButton() {
            return this.showOptionsButton
        }
        setShouldShowOptionsButton(e) {
            return this.showOptionsButton = e && !steamworks.isDedicatedServer(),
            this.classes.toggle(this.showOptionsButton, "show-options-button"),
            this
        }
        getMaxMessages() {
            return this.maxMessages
        }
        setMaxMessages(e) {
            return this.maxMessages = e,
            this.refreshLog(),
            this
        }
        scrollToNewest() {
            const e = I.Quadrant[this.dataset.quadrant];
            e === I.Quadrant.TopLeft || e === I.Quadrant.Top || e === I.Quadrant.TopRight ? this.log.element.scrollTop = 0 : this.log.element.scrollTop = 999999999999
        }
        sendPinnedMessage(e) {
            const t = this.pinnedMessages.getChildren().filter(t=>t.type === e.type).collect(x.default.toArray);
            return t.length >= F && t[0].remove(),
            this.schedule(10, 10, this.scrollToNewest),
            e.appendTo(this.pinnedMessages)
        }
        pinQuestRequirement(e, t) {
            const a = t ? t.id : -1
              , i = this.getPins().filter(({type: e})=>e === b.PinType.QuestRequirement).filter(({id: [t,i]})=>t === e.id && i === a).collect(x.default.first());
            if (i)
                return i;
            const n = B.tuple(e.id, a);
            return this.pinnedQuestRequirements.push(n),
            this.addPinnedQuestRequirement(n)
        }
        onDisplayMessage(e, t, a=!1) {
            if (!e.isLocalPlayer() || this.isMessageFilteredOut(t.source))
                return;
            const i = this.element.querySelector(`[data-message-id="${t.id}"]`);
            i || (this.messagesToDisplay.push([t, a]),
            this.schedule(5, 5, this.updateMessages))
        }
        onWrittenNote(e, t) {
            e.isLocalPlayer() && this.pinNotesAutomatically && (this.pinnedNotes.push(t),
            this.addPinnedNote(t))
        }
        onBindLoop(e, t) {
            return super.onBindLoop(e, t),
            t.wasPressed(a.Bindable.DialogMessagesChatFocus) && !e && this.api.isScreenVisible(S.ScreenId.Game) && (this.input.focus(),
            e = a.Bindable.DialogMessagesChatFocus,
            p.bindingManager.removeAllPressStates()),
            e
        }
        sendMessage() {
            let e = this.input.text.trim();
            return !!e && (this.input.clear(),
            e.startsWith("/") ? this.runCommand(e.slice(1)) : (e.startsWith("\\/") && (e = e.slice(1)),
            H.sendChatMessage(localPlayer, e)),
            !0)
        }
        getContextMenuDescription() {
            return this.element.matches(".dialog > .game-dialog-body > *") || !this.gsapi ? this.getMessagesContextMenu() : [...this.getMessagesContextMenu(), ["show as dialog", {
                translation: l.default.ui(s.default.GameMessagesContextMenuShowAsDialog),
                onActivate: ()=>{
                    this.gsapi && this.gsapi.openDialog(M.DialogId.Messages)
                }
            }], ...super.getContextMenuDescription()]
        }
        addPinnedNote(e) {
            const t = localPlayer.notes.getNote(e)
              , a = new l.default(i.Dictionary.Note,r.default[t.id]).get()
              , n = this.sendPinnedMessage(new W(this.api,b.PinType.Note,e).classes.add("notification").setText(l.default.ui(s.default.GameMessagesNewNote).addArgs(a)).on(c.ButtonEvent.Activate, t=>{
                t.remove(),
                this.gsapi.openDialog(M.DialogId.Notes).showNote(e)
            }
            ));
            this.until("WillRemove").bind(n, "Remove", ()=>{
                A.default.toggle(this.pinnedNotes, e, !1),
                A.default.toggle(this.seenNotes, e, !0)
            }
            );
            const o = document.querySelectorAll(".notification");
            for (const e of o)
                e.classList.remove("notification");
            P.sleep(1).then(()=>{
                for (const e of o)
                    e.classList.add("notification")
            }
            )
        }
        addPinnedQuestRequirement([e,t]) {
            const a = localPlayer.quests.getQuests().find(t=>t.id === e)
              , n = a.getRequirements().filter(e=>e.id === t).collect(x.default.first());
            if (-1 !== t && !n)
                return;
            const o = new W(this.api,b.PinType.QuestRequirement,B.tuple(a.id, t)).classes.add("game-messages-quest-requirement").setText(n ? n.getTranslation : new l.default(i.Dictionary.Quest,a.data.type)).on(c.ButtonEvent.Activate, ()=>this.gsapi.openDialog(M.DialogId.Quests).showQuest(a.id)).on("Remove", ()=>{
                const a = this.pinnedQuestRequirements.findIndex(([a,i])=>a === e && i === t);
                a >= 0 && this.pinnedQuestRequirements.splice(a, 1),
                this.emit(1, o)
            }
            )
              , r = o.until("Remove");
            if (n) {
                r.bind(n, "Update", o.refreshText),
                r.bind(n, "Met", this.unpinRequirement(o));
                const e = n.getRelations();
                e.length && o.setHighlight({
                    selectors: e
                })
            }
            return r.bind(a, 2, this.unpinRequirement(o)),
            this.sendPinnedMessage(o),
            this.emit(0, o),
            o
        }
        unpinRequirement(e) {
            return async()=>{
                e.classes.add("requirement-met"),
                await P.sleep(4e3),
                e.remove()
            }
        }
        onQuestGet(e, t) {
            this.pinRequirementsFromQuest(t)
        }
        onRequirementComplete(e, t, a) {
            this.pinRequirementsFromQuest(t)
        }
        pinRequirementsFromQuest(e) {
            if (this.hasIncompletePinnedRequirementFromAnotherQuest(e))
                return;
            const t = e.getRequirements().filter(e=>!e.data.hidden).collect(x.default.toArray);
            for (let a = 0; a < t.length; a++) {
                const i = t[a];
                if (!i.data.completed) {
                    this.pinQuestRequirement(e, i);
                    const t = this.getPins().filter(N).collect(x.default.toArray);
                    if (t.length >= F)
                        break
                }
            }
        }
        hasIncompletePinnedRequirementFromAnotherQuest(e) {
            return this.pinnedQuestRequirements.length && this.pinnedQuestRequirements.some(([t,a])=>t !== e.id && localPlayer.quests.getQuests().some(e=>e.id === t && e.getRequirements().any(e=>e.id === a && !e.data.completed)))
        }
        showOptions() {
            this.gsapi && this.gsapi.openDialog(M.DialogId.Messages).showSettingsPanel()
        }
        updateMessages() {
            for (const [e,t] of this.messagesToDisplay) {
                const a = new m.default(this.api,"span").classes.add("game-message").append(void 0 !== e.time && new f.default(this.api).classes.add("timestamp", "timestamp-realtime").setText(l.default.generator(new Date(e.time).toLocaleTimeString()))).append(void 0 !== e.turn && new f.default(this.api).classes.add("timestamp", "timestamp-turn").setText(l.default.ui(s.default.GameMessagesTurn).addArgs(e.turn))).append(new f.default(this.api).setText(l.default.deserialize(e.message).addReformatter(new l.default(i.Dictionary.Misc,o.MiscTranslation.Message).addArgs(e.type && D.MessageType[e.type].toLowerCase()))));
                a.dataset.messageId = `${e.id}`,
                a.appendTo(this.log, t ? "prepend" : void 0),
                this.log.childCount > this.maxMessages && this.log.getChildren().collect(x.default.first()).remove()
            }
            this.messagesToDisplay.splice(0, 1 / 0),
            this.scrollToNewest()
        }
        *messages(e=this.maxMessages) {
            let t = 0;
            for (const a of localPlayer.messages.getMessageHistory())
                if (!this.isMessageFilteredOut(a.source) && (yield a,
                ++t > e))
                    break
        }
        getMessagesContextMenu() {
            return [["copy log", {
                translation: l.default.ui(s.default.GameMessagesContextMenuCopy),
                onActivate: ()=>{
                    let e = "";
                    for (const t of this.messages())
                        e = `${f.default.toString(l.default.deserialize(t.message))}\n${e}`;
                    const t = document.createElement("textarea");
                    t.value = e,
                    document.body.appendChild(t),
                    t.select(),
                    document.execCommand("copy"),
                    t.remove()
                }
            }], ["export history", {
                translation: l.default.ui(s.default.GameMessagesContextMenuExport),
                onActivate: ()=>{
                    let e = "";
                    for (const t of this.messages(1 / 0))
                        e = `${f.default.toString(l.default.deserialize(t.message))}\n${e}`;
                    R.default.download(`${k.SaveSlot.getFileName(saveData.gameSlotName)}-messages-${O.default.generateTimestamp()}.txt`, e, !1)
                }
            }], ["clear all messages", {
                translation: l.default.ui(s.default.GameMessagesContextMenuClear),
                onActivate: async()=>{
                    const e = await this.api.interrupt(s.default .GameMessagesContextMenuClearInterrupt).withDescription(s.default .GameMessagesContextMenuClearInterruptDescription).withConfirmation();
                    e && (localPlayer.messages.clear(),
                    this.changeFilter(this.selectedFilter))
                }
            }]]
        }
        runCommand(e) {
            const t = e.indexOf(" ")
              , o = -1 !== t ? e.substring(0, t) : e
              , r = -1 !== t ? e.substring(t + 1).trim() : "";
            let s = G.default.values(a.Command).filter(e=>new l.default(i.Dictionary.Command,e).getString().toUpperCase() === o.toUpperCase()).collect(x.default.first());
            void 0 === s && (s = G.default.entries(a.Command).filter(([e])=>e.toUpperCase() === o.toUpperCase()).map(([,e])=>e).collect(x.default.first())),
            void 0 !== s ? commandManager.execute(localPlayer, s, r) : localPlayer.messages.source(C.Source.Command).send(n.default.ChatUnknownCommand, o)
        }
        isMessageFilteredOut(e) {
            for (const t of this.filters[this.selectedFilter])
                if (e.includes(C.Source[t]))
                    return !1;
            return !0
        }
        openFilterMenu() {
            const e = this.api.getVisibleScreen();
            if (!e)
                return;
            const t = p.bindingManager.getMouse();
            L.default.keys(this.filters).map(e=>B.tuple(e, {
                translation: l.default.generator(e),
                onActivate: this.changeFilter.bind(this, e)
            })).include(this.gsapi ? [[_, {
                translation: s.default.GameMessagesFiltersEdit,
                create: e=>e.classes.add("has-icon-before", "button-edit"),
                onActivate: this.editFilters
            }]] : []).collect(e=>new h.default(this.api,...e)).addAllDescribedOptions().setPosition(t.x, t.y).schedule(e.setContextMenu)
        }
        changeFilter(e) {
            this.selectedFilter = e,
            this.selectedFilter in this.filters || (this.selectedFilter = H.allFilterName),
            this.filter.refreshText(),
            this.refreshLog()
        }
        refreshLog() {
            this.log.dump();
            for (const e of this.messages())
                this.onDisplayMessage(localPlayer, e, !0)
        }
        onShowDialog(e, t) {
            switch (t.id) {
            case M.DialogId.Notes:
                {
                    const e = t;
                    e.on(w.NotesDialogEvent.ShowNote, this.onShowNote);
                    break
                }
            case M.DialogId.MessagesEditFilters:
                t.initializeFilters(this.filters).on(v.MessagesEditFiltersDialogEvent.Edit, this.onFiltersEdited).on(v.MessagesEditFiltersDialogEvent.Reset, this.onFiltersReset)
            }
        }
        onShowNote(e, t) {
            const a = this.getPins().filter(e=>e.type === b.PinType.Note && e.id === t).collect(x.default.first());
            a && (a.remove(),
            this.seenNotes.push(t))
        }
        editFilters() {
            this.gsapi.openDialog(M.DialogId.MessagesEditFilters)
        }
        onFiltersEdited(e) {
            this.filters = e.filters,
            this.changeFilter(this.selectedFilter)
        }
        onFiltersReset() {
            this.filters = H.defaultFilters,
            this.gsapi.openDialog(M.DialogId.MessagesEditFilters).initializeFilters(this.filters),
            this.changeFilter(H.allFilterName)
        }
    }
    H.preferredQuadrant = I.Quadrant.BottomLeft,
    __decorate([Override], H.prototype, "preferredQuadrant", null),
    __decorate([T.Save(T.SaveLocation.Both)], H.prototype, "pinNotesAutomatically", void 0),
    __decorate([T.Save(T.SaveLocation.Both)], H.prototype, "filters", void 0),
    __decorate([T.Save(T.SaveLocation.Both)], H.prototype, "selectedFilter", void 0),
    __decorate([T.Save(T.SaveLocation.Both)], H.prototype, "showSendButton", void 0),
    __decorate([T.Save(T.SaveLocation.Both)], H.prototype, "showOptionsButton", void 0),
    __decorate([T.Save(T.SaveLocation.Both)], H.prototype, "messageTimestamps", void 0),
    __decorate([T.Save(T.SaveLocation.Both)], H.prototype, "maxMessages", void 0),
    __decorate([T.Save(T.SaveLocation.Local)], H.prototype, "pinnedNotes", void 0),
    __decorate([T.Save(T.SaveLocation.Local)], H.prototype, "seenNotes", void 0),
    __decorate([T.Save(T.SaveLocation.Local)], H.prototype, "pinnedQuestRequirements", void 0),
    __decorate([Override], H.prototype, "getID", null),
    __decorate([Override], H.prototype, "getName", null),
    __decorate([L.Bound], H.prototype, "getMessageTimestampMode", null),
    __decorate([L.Bound], H.prototype, "shouldShowSendButton", null),
    __decorate([L.Bound], H.prototype, "shouldShowOptionsButton", null),
    __decorate([L.Bound], H.prototype, "getMaxMessages", null),
    __decorate([L.Bound], H.prototype, "scrollToNewest", null),
    __decorate([u.HookMethod(T.NEWUI_HOOK_PRIORITY)], H.prototype, "onDisplayMessage", null),
    __decorate([u.HookMethod(T.NEWUI_HOOK_PRIORITY)], H.prototype, "onWrittenNote", null),
    __decorate([u.HookMethod, Override], H.prototype, "onBindLoop", null),
    __decorate([L.Bound], H.prototype, "sendMessage", null),
    __decorate([Override], H.prototype, "getContextMenuDescription", null),
    __decorate([L.Bound], H.prototype, "addPinnedNote", null),
    __decorate([L.Bound], H.prototype, "addPinnedQuestRequirement", null),
    __decorate([L.Bound], H.prototype, "onQuestGet", null),
    __decorate([L.Bound], H.prototype, "onRequirementComplete", null),
    __decorate([L.Bound], H.prototype, "showOptions", null),
    __decorate([L.Bound], H.prototype, "updateMessages", null),
    __decorate([L.Bound], H.prototype, "openFilterMenu", null),
    __decorate([L.Bound], H.prototype, "onShowDialog", null),
    __decorate([L.Bound], H.prototype, "onShowNote", null),
    __decorate([L.Bound], H.prototype, "editFilters", null),
    __decorate([L.Bound], H.prototype, "onFiltersEdited", null),
    __decorate([L.Bound], H.prototype, "onFiltersReset", null),
    t.default = H;
    class W extends c.default {
        constructor(e, t, a) {
            super(e),
            this.type = t,
            this.id = a,
            this.classes.add("simple-button", "game-message", "game-message-pinned"),
            this.attributes.set("intercept", "all"),
            new c.default(this.api).classes.add("has-icon-before", "game-message-pinned-button-dismiss").on(c.ButtonEvent.Activate, this.remove).appendTo(this, y.AppendStrategy.Prepend)
        }
    }
    function N(e) {
        if (e.type !== b.PinType.QuestRequirement)
            return !1;
        const {id: [t,a]} = e
          , i = localPlayer.quests.getQuests().find(e=>e.id === t);
        if (!i)
            return !1;
        const n = i.getRequirements().filter(e=>e.id === a).collect(x.default.first());
        return !!n && !n.data.completed
    }
    t.PinnedMessage = W
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/dialog/MessagesDialog", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/CheckButton", "newui/component/Dropdown", "newui/component/Input", "newui/component/LabelledRow", "newui/component/RangeInput", "newui/component/RangeRow", "newui/screen/screens/game/component/Dialog", "newui/screen/screens/game/component/QuadrantComponent", "newui/screen/screens/game/Dialogs", "newui/screen/screens/game/IGameScreenApi", "newui/screen/screens/game/static/Messages", "utilities/enum/Enums", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class T extends p.default {
        constructor(e) {
            super(e, m.DialogId.Messages),
            this.addPanel("main").classes.remove("scrollable").append(this.gsapi.messages),
            this.addSettingsPanel().append(new l.LabelledRow(this.api).classes.add("dropdown-label").setLabel(e=>e.setText(i.default.GameDialogMessagesOptionTimestamp)).append(new r.default(this.api).setRefreshMethod(()=>({
                defaultOption: this.gsapi.messages.getMessageTimestampMode(),
                options: g.default.values(h.MessageTimestamp).map(e=>[e, t=>t.setText(new n.default(a.Dictionary.MessagesTimestampMode,e))])
            })).on(r.DropdownEvent.Selection, (e,t)=>this.gsapi.messages.setMessageTimestampMode(t)))).append(new o.CheckButton(this.api).setText(i.default.GameDialogMessagesOptionShowSendButton).setRefreshMethod(this.gsapi.messages.shouldShowSendButton).on(o.CheckButtonEvent.Change, (e,t)=>this.gsapi.messages.setShouldShowSendButton(t))).append(new o.CheckButton(this.api).setText(i.default.GameDialogMessagesOptionShowOptionsButton).setRefreshMethod(this.gsapi.messages.shouldShowOptionsButton).on(o.CheckButtonEvent.Change, (e,t)=>this.gsapi.messages.setShouldShowOptionsButton(t))).append(new d.RangeRow(this.api).setLabel(e=>e.setText(i.default.GameDialogMessagesOptionMaxMessages)).editRange(e=>e.setMin(y.DEFAULT_MAX_MESSAGES).setStep(5).setMax(500).setRefreshMethod(this.gsapi.messages.getMaxMessages)).addDefaultButton(()=>y.DEFAULT_MAX_MESSAGES).setDisplayValue(!0).on(u.RangeInputEvent.Finish, (e,t)=>this.gsapi.messages.setMaxMessages(t))).append(new o.CheckButton(this.api).setText(i.default.GameDialogNotesSettingsPinUnreadNotesAutomatically).setRefreshMethod(()=>e.messages.pinNotesAutomatically).on(o.CheckButtonEvent.Change, (t,a)=>{
                e.messages.pinNotesAutomatically = a
            }
            )),
            this.gsapi.messages.input.on(s.InputEvent.Focus, this.onFocus).on(s.InputEvent.Blur, this.onBlur),
            this.on("WillRemove", this.willRemove),
            this.until("Remove").bind(this.gsapi.messages, c.QuadrantComponentEvent.ChangeQuadrant, this.close)
        }
        getName() {
            return i.default.GameDialogMessagesName
        }
        onFocus() {
            this.markActive()
        }
        onBlur() {
            this.markInactive()
        }
        willRemove() {
            this.gsapi.messages.input.cancel(s.InputEvent.Focus, this.onFocus).cancel(s.InputEvent.Blur, this.onBlur),
            this.gsapi.messages.appendTo(this.gsapi.getQuadrantContainer())
        }
    }
    __decorate([Override], T.prototype, "getName", null),
    __decorate([f.Bound], T.prototype, "onFocus", null),
    __decorate([f.Bound], T.prototype, "onBlur", null),
    __decorate([f.Bound], T.prototype, "willRemove", null),
    t.default = T
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/Milestones", ["require", "exports", "action/IAction", "creature/Creatures", "Enums", "language/dictionary/Note", "player/IMilestone", "utilities/enum/Enums"], function(e, t, a, i, n, o, r, s) {
    function l() {
        return s.default.values(n.CreatureType).filter(e=>!!i.default[e] && "number" == typeof i.default[e].tamingDifficulty).reduce((e,t)=>t + 1, 0)
    }
    function u() {
        return s.default.values(n.CreatureType).filter(e=>!!i.creatureDescriptions[e]).length()
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.getTamableCount = l,
    t.getKillableCount = u,
    t.milestones = Array(),
    t.default = t.milestones,
    t.milestones[r.MilestoneType.Abnormalizer] = {
        amount: 25,
        visibility: r.MilestoneVisibility.Invisible
    },
    t.milestones[r.MilestoneType.Chef] = {
        amount: 25
    },
    t.milestones[r.MilestoneType.Crafter] = {
        amount: 250
    },
    t.milestones[r.MilestoneType.Exterminator] = {
        amount: 1e3
    },
    t.milestones[r.MilestoneType.Gardener] = {
        amount: 50
    },
    t.milestones[r.MilestoneType.Gatherer] = {
        amount: 1e3
    },
    t.milestones[r.MilestoneType.Hunter] = {
        amount: 100
    },
    t.milestones[r.MilestoneType.Locksmith] = {
        amount: 10
    },
    t.milestones[r.MilestoneType.ReaperOfSouls] = {
        amount: 50,
        visibility: r.MilestoneVisibility.Invisible
    },
    t.milestones[r.MilestoneType.Survivor] = {
        amount: 1e4
    },
    t.milestones[r.MilestoneType.Thrower] = {
        amount: 500
    },
    t.milestones[r.MilestoneType.Trapper] = {
        amount: 10
    },
    t.milestones[r.MilestoneType.TreasureHunter] = {
        amount: 10
    },
    t.milestones[r.MilestoneType.Collector] = {
        amount: s.default.getLength(n.ItemType) - 1,
        dataType: r.MilestoneDataType.Counter
    },
    t.milestones[r.MilestoneType.Explorer] = {
        amount: s.default.getLength(n.TerrainType),
        dataType: r.MilestoneDataType.Counter
    },
    t.milestones[r.MilestoneType.Grandmaster] = {
        amount: 100,
        dataType: r.MilestoneDataType.Check
    },
    t.milestones[r.MilestoneType.Prepared] = {
        amount: 10,
        dataType: r.MilestoneDataType.Counter
    },
    t.milestones[r.MilestoneType.Doctor] = {
        amount: 3,
        dataType: r.MilestoneDataType.Counter
    },
    t.milestones[r.MilestoneType.Artificer] = {
        amount: 1,
        visibility: r.MilestoneVisibility.Hidden
    },
    t.milestones[r.MilestoneType.Seafarer] = {
        amount: 1,
        visibility: r.MilestoneVisibility.Hidden
    },
    t.milestones[r.MilestoneType.Navigator] = {
        amount: 1,
        visibility: r.MilestoneVisibility.Hidden
    },
    t.milestones[r.MilestoneType.DragonSlayer] = {
        amount: 1,
        visibility: r.MilestoneVisibility.Invisible
    },
    t.milestones[r.MilestoneType.Treasurer] = {
        amount: 5,
        dataType: r.MilestoneDataType.Counter,
        visibility: r.MilestoneVisibility.Invisible
    },
    t.milestones[r.MilestoneType.Pulchritudinous] = {
        amount: 10,
        dataType: r.MilestoneDataType.Counter,
        visibility: r.MilestoneVisibility.Hidden
    },
    t.milestones[r.MilestoneType.Friendly] = {
        amount: 25
    },
    t.milestones[r.MilestoneType.Malevolent] = {
        amount: 64e3,
        dataType: r.MilestoneDataType.Check
    },
    t.milestones[r.MilestoneType.Benevolent] = {
        amount: 64e3,
        dataType: r.MilestoneDataType.Check
    },
    t.milestones[r.MilestoneType.Boundless] = {
        amount: 125,
        dataType: r.MilestoneDataType.Check
    },
    t.milestones[r.MilestoneType.Talented] = {
        amount: 1e3,
        dataType: r.MilestoneDataType.Check
    },
    t.milestones[r.MilestoneType.Weathered] = {
        amount: 1e5
    },
    t.milestones[r.MilestoneType.Seasoned] = {
        amount: 1e6
    },
    t.milestones[r.MilestoneType.Pacifier] = {
        amount: l(),
        dataType: r.MilestoneDataType.Counter
    },
    t.milestones[r.MilestoneType.Merchant] = {
        amount: 100
    },
    t.milestones[r.MilestoneType.Notekeeper] = {
        amount: s.default.getLength(o.default),
        dataType: r.MilestoneDataType.Check
    },
    t.milestones[r.MilestoneType.Operator] = {
        amount: s.default.getLength(a.ActionType) - 1,
        dataType: r.MilestoneDataType.Counter
    },
    t.milestones[r.MilestoneType.Huntsman] = {
        amount: u(),
        dataType: r.MilestoneDataType.Counter
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/dialog/MilestonesDialog", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Component", "newui/component/Input", "newui/component/SortRow", "newui/component/Text", "newui/screen/screens/game/component/Dialog", "newui/screen/screens/game/Dialogs", "player/IMilestone", "player/Milestones", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g) {
    var f;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Name = 0] = "Name",
        e[e.Progress = 1] = "Progress"
    }(f || (f = {}));
    class T extends u.default {
        constructor(e) {
            super(e, d.DialogId.Milestones);
            const t = this.addScrollableWrapper();
            this.milestones = m.default.values(p.MilestoneType).map(e=>y.tuple(e, new o.default(this.api).classes.add("unlockable-row").append(new l.default(this.api).setText(this.getMilestoneReadout(e))).setTooltip(t=>t.addText(t=>t.setText(this.getTooltip(e)))).appendTo(t).schedule(1, this.updateMilestone, e))).collect(h.default.toMap),
            this.until(u.DialogEvent.Close).bind(localPlayer, "MilestoneUpdate", this.updateMilestone),
            this.sortRow = new s.default(this.api).setRefreshMethod(()=>({
                sortEnum: f,
                defaultSort: f.Name,
                initializeOption: (e,[t])=>e.setText(n.default.ui(`GameDialogMilestonesSort${t}`))
            })).on(s.SortRowEvent.Sort, this.sort).appendTo(this.footer),
            new r.default(this.api).setPlaceholder(i.default.MiscFilter).on(r.InputEvent.Change, this.filter).appendTo(this.footer),
            this.sort()
        }
        getName() {
            return i.default.GameDialogMilestonesName
        }
        updateMilestone(e, t) {
            const a = this.getMilestoneAmount(t)
              , i = this.milestones.get(t).classes.toggle(a === c.default[t].amount, "unlocked");
            i.style.setProperty("--percent", `${a / c.default[t].amount * 100}`),
            i.getNthChild(0).refresh()
        }
        sort(e, t=this.sortRow.sort, a=this.sortRow.sortDirection) {
            this.milestones.entries().collect(h.default.toArray).sort(this.sortMilestones(t)).values(a).forEach(([,e])=>e.appendTo(e.getParent()))
        }
        sortMilestones(e) {
            return ([t],[i])=>{
                switch (e) {
                case f.Name:
                    return new n.default(a.Dictionary.Milestone,t).getString().localeCompare(new n.default(a.Dictionary.Milestone,i).getString());
                case f.Progress:
                    return this.getMilestoneAmount(i) / c.default[i].amount - this.getMilestoneAmount(t) / c.default[t].amount
                }
            }
        }
        filter(e, t) {
            this.milestones.entries().forEach(([e,a])=>a.toggle("" === t || this.getFilterString(e).includes(t.toLowerCase())))
        }
        getFilterString(e) {
            return [this.visibility(e) !== p.MilestoneVisibility.Invisible || this.isMilestoneComplete(e) ? new n.default(a.Dictionary.Milestone,e).getString() : n.default.ui(i.default.GameDialogMilestonesInvisibleMilestone).getString(), l.default.toString(this.getTooltip(e))].join("\n").toLowerCase()
        }
        getTooltip(e) {
            if (!this.isMilestoneComplete(e))
                switch (this.visibility(e)) {
                case p.MilestoneVisibility.Hidden:
                    return i.default.GameDialogMilestonesTooltipHidden;
                case p.MilestoneVisibility.Invisible:
                    return i.default.GameDialogMilestonesTooltipInvisible
                }
            return new n.default(a.Dictionary.Milestone,e,1)
        }
        getMilestoneReadout(e) {
            return ()=>{
                const t = this.visibility(e);
                let o = n.default.ui(i.default.GameDialogMilestonesInvisibleMilestone);
                (t !== p.MilestoneVisibility.Invisible || this.isMilestoneComplete(e)) && (o = new n.default(a.Dictionary.Milestone,e));
                const r = this.getMilestoneAmount(e);
                let s = n.default.ui(i.default.GameDialogMilestonesProgressHidden);
                return (t !== p.MilestoneVisibility.Hidden || this.isMilestoneComplete(e)) && (s = n.default.ui(i.default.GameDialogMilestonesProgress).addArgs(r, c.default[e].amount)),
                n.default.ui(i.default.GameDialogMilestonesMilestone).addArgs(o, s)
            }
        }
        isMilestoneComplete(e) {
            return this.getMilestoneAmount(e) === c.default[e].amount
        }
        getMilestoneAmount(e) {
            const t = saveDataGlobal.playerMilestoneData[e];
            return void 0 === t ? 0 : -1 === t.amount ? c.default[e].amount : t.amount || 0
        }
        visibility(e) {
            const t = this.getMilestoneAmount(e)
              , a = c.default[e].visibility || p.MilestoneVisibility.Visible;
            return a === p.MilestoneVisibility.Visible || -1 === t ? p.MilestoneVisibility.Visible : a
        }
    }
    __decorate([Override], T.prototype, "getName", null),
    __decorate([g.Bound], T.prototype, "updateMilestone", null),
    __decorate([g.Bound], T.prototype, "sort", null),
    __decorate([g.Bound], T.prototype, "filter", null),
    t.default = T
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/ChoiceList", ["require", "exports", "newui/component/BlockRow", "newui/component/CheckButton", "utilities/Objects"], function(e, t, a, i, n) {
    var o;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Choose = "Selection"
    }(o = t.ChoiceListEvent || (t.ChoiceListEvent = {}));
    class r extends a.BlockRow {
        constructor(e) {
            super(e),
            this._disabled = !1,
            this.classes.add("menu-choice-list")
        }
        get choice() {
            return this._selection
        }
        get disabled() {
            return this._disabled
        }
        setDisabled(e) {
            return this._disabled = e,
            this.classes.toggle(e, "disabled"),
            this
        }
        setChoices(...e) {
            return this.dump().append(e.values().flatMap().map(e=>e.on(i.CheckButtonEvent.Change, this.onChoiceChange)))
        }
        refresh() {
            return this.choose(this.refreshMethod(this)),
            this
        }
        setRefreshMethod(e) {
            return this.refreshMethod = e,
            this.refresh(),
            this
        }
        choose(e) {
            if (e && this._selection !== e) {
                this._selection = e,
                e.setChecked(!0, !1),
                e.setDisabled(!0);
                for (const t of this.getChildren().filter(t=>t !== e))
                    t.setChecked(!1),
                    t.setDisabled(!1);
                this.emit(o.Choose, e)
            }
        }
        findChoice(e) {
            for (const t of this.getChildren())
                if (e(t))
                    return t
        }
        onChoiceChange(e, t) {
            if (t)
                this.choose(e);
            else if (this.choice === e)
                return !1;
            return !0
        }
    }
    __decorate([n.Bound], r.prototype, "setChoices", null),
    __decorate([n.Bound], r.prototype, "refresh", null),
    __decorate([n.Bound], r.prototype, "onChoiceChange", null),
    t.default = r;
    class s extends i.CheckButton {
        constructor(e, t) {
            super(e),
            this.id = t,
            this.classes.add("menu-choice", "menu-text-not-heading", "menu-check-button-description")
        }
    }
    t.Choice = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/dialog/QuickSettingsDialog", ["require", "exports", "Enums", "language/dictionary/UiTranslation", "newui/component/CheckButton", "newui/component/ChoiceList", "newui/component/Component", "newui/component/IComponent", "newui/component/Text", "newui/INewUi", "newui/screen/screens/game/component/Dialog", "newui/screen/screens/game/Dialogs", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class m extends d.default {
        constructor(e) {
            super(e, p.DialogId.QuickSettings),
            this.refreshables = [],
            this.api.on(u.UiApiEvent.InterruptClose, this.refresh);
            const t = this.addPanel("");
            new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonAutoGatherHarvest).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuOptionsButtonAutoGatherHarvestTooltip))).setRefreshMethod(()=>saveDataGlobal.options.autoGatherHarvest).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "autoGatherHarvest", t)
            }
            ).appendTo(t),
            new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonDropOnGatherHarvest).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuOptionsButtonDropOnGatherHarvestTooltip))).setRefreshMethod(()=>saveDataGlobal.options.dropOnGatherHarvest).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "dropOnGatherHarvest", t)
            }
            ).appendTo(t),
            new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonAutoPickup).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuOptionsButtonAutoPickupTooltip))).setRefreshMethod(()=>saveDataGlobal.options.autoPickup).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "autoPickup", t)
            }
            ).appendTo(t),
            new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonWarnOnDangerousActions).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuOptionsButtonWarnOnDangerousActionsTooltip))).setRefreshMethod(()=>saveDataGlobal.options.warnOnDangerousActions).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "warnOnDangerousActions", t)
            }
            ).appendTo(t),
            new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonKeepSortActive).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuOptionsButtonKeepSortActiveTooltip))).setRefreshMethod(()=>saveDataGlobal.options.keepSortActive).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "keepSortActive", t)
            }
            ).appendTo(t),
            new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonProtectCraftingItemsInInventory).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuOptionsButtonProtectCraftingItemsInInventoryTooltip))).setRefreshMethod(()=>saveDataGlobal.options.protectedCraftingItems).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "protectedCraftingItems", t)
            }
            ).appendTo(t),
            new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonProtectCraftingItemContainers).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuOptionsButtonProtectCraftingItemsContainersTooltip))).setRefreshMethod(()=>saveDataGlobal.options.protectedCraftingItemContainers).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "protectedCraftingItemContainers", t)
            }
            ).appendTo(t),
            new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonUseAdjacentContainers).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuOptionsButtonUseAdjacentContainersTooltip))).setRefreshMethod(()=>saveDataGlobal.options.useAdjacentContainers).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "useAdjacentContainers", t)
            }
            ).appendTo(t),
            new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonHideEquippedHeadgear).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuOptionsButtonHideEquippedHeadgearTooltip))).setRefreshMethod(()=>saveDataGlobal.options.hideEquippedHeadgear).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "hideEquippedHeadgear", t)
            }
            ).appendTo(t),
            new r.default(this.api).classes.add("choice-section").append(new l.default(this.api).setText(i.default.MenuOptionsHeadingWarnWhenBreakingItems)).append(new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonWarnWhenBreakingItemsOnUse).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonWarnWhenBreakingItemsOnUseTooltip))).setRefreshMethod(()=>saveDataGlobal.options.warnWhenBreakingItems).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                saveDataGlobal.options.warnWhenBreakingItems = t
            }
            )).append(new n.CheckButton(this.api).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonWarnWhenBreakingItemsOnCraft).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonWarnWhenBreakingItemsOnCraftTooltip))).setRefreshMethod(()=>saveDataGlobal.options.warnWhenBreakingItemsOnCraft).schedule(this.addRefreshable).on(n.CheckButtonEvent.Change, (e,t)=>{
                saveDataGlobal.options.warnWhenBreakingItemsOnCraft = t
            }
            )).appendTo(t),
            new o.default(this.api).setChoices(new o.Choice(this.api,a.DropLocation.Facing).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonDropLocationFacing), new o.Choice(this.api,a.DropLocation.Feet).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonDropLocationFeet), new o.Choice(this.api,a.DropLocation.FeetWhenFacingBlocked).classes.add("icon-no-scale").setText(i.default.MenuOptionsButtonDropLocationFeetWhenFacingBlocked)).setRefreshMethod(e=>e.findChoice(e=>e.id === saveDataGlobal.options.dropLocation)).schedule(this.addRefreshable).on(o.ChoiceListEvent.Choose, (e,t)=>{
                game.updateOption(localPlayer, "dropLocation", t.id)
            }
            ).appendTo(t)
        }
        getName() {
            return i.default.GameDialogQuickSettingsName
        }
        refresh() {
            for (const e of this.refreshables)
                e.refresh();
            return this
        }
        addRefreshable(e) {
            this.refreshables.push(e)
        }
    }
    __decorate([Override], m.prototype, "getName", null),
    __decorate([c.Bound], m.prototype, "refresh", null),
    __decorate([c.Bound], m.prototype, "addRefreshable", null),
    t.default = m
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/Skills", ["require", "exports", "entity/IStats", "Enums", "save/ISerializer"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o {
        constructor() {
            this.bonus = 0,
            this.core = 0
        }
    }
    function r() {
        const e = {};
        for (const t in i.SkillType)
            isNaN(t) || (e[t] = new o);
        return e
    }
    function s(e) {
        switch (e) {
        case i.RecipeLevel.Simple:
            return 0;
        case i.RecipeLevel.Intermediate:
            return game.isChallenge ? 10 : 25;
        case i.RecipeLevel.Advanced:
            return game.isChallenge ? 25 : 55;
        case i.RecipeLevel.Expert:
            return game.isChallenge ? 40 : 80
        }
        return 0
    }
    __decorate([n.SaveProperty()], o.prototype, "bonus", void 0),
    __decorate([n.SaveProperty()], o.prototype, "core", void 0),
    t.SkillLevel = o,
    t.skillSet = r,
    t.skillChance = s,
    t.skillDescriptions = {},
    t.skillDescriptions[i.SkillType.Chemistry] = {
        attribute: a.Stat.Metabolism,
        reputation: -5
    },
    t.skillDescriptions[i.SkillType.Anatomy] = {
        attribute: a.Stat.Metabolism,
        reputation: 5
    },
    t.skillDescriptions[i.SkillType.Marksmanship] = {
        attribute: a.Stat.Strength,
        reputation: -30
    },
    t.skillDescriptions[i.SkillType.Blacksmithing] = {
        attribute: a.Stat.Strength,
        reputation: -25
    },
    t.skillDescriptions[i.SkillType.Botany] = {
        attribute: a.Stat.Metabolism,
        reputation: 10
    },
    t.skillDescriptions[i.SkillType.Camping] = {
        attribute: a.Stat.Stamina
    },
    t.skillDescriptions[i.SkillType.Cartography] = {
        attribute: a.Stat.Stamina,
        reputation: 5
    },
    t.skillDescriptions[i.SkillType.Claythrowing] = {
        attribute: a.Stat.Stamina,
        reputation: 5
    },
    t.skillDescriptions[i.SkillType.Cooking] = {
        attribute: a.Stat.Metabolism,
        reputation: 10
    },
    t.skillDescriptions[i.SkillType.Fishing] = {
        attribute: a.Stat.Stamina
    },
    t.skillDescriptions[i.SkillType.Fletching] = {
        attribute: a.Stat.Stamina,
        reputation: -15
    },
    t.skillDescriptions[i.SkillType.Glassblowing] = {
        attribute: a.Stat.Stamina
    },
    t.skillDescriptions[i.SkillType.Leatherworking] = {
        attribute: a.Stat.Strength,
        reputation: -10
    },
    t.skillDescriptions[i.SkillType.LockPicking] = {
        attribute: a.Stat.Stamina,
        reputation: -20
    },
    t.skillDescriptions[i.SkillType.Lumberjacking] = {
        attribute: a.Stat.Strength,
        reputation: -25
    },
    t.skillDescriptions[i.SkillType.Mining] = {
        attribute: a.Stat.Strength,
        reputation: -20
    },
    t.skillDescriptions[i.SkillType.Mycology] = {
        attribute: a.Stat.Metabolism,
        reputation: 5
    },
    t.skillDescriptions[i.SkillType.Parrying] = {
        attribute: a.Stat.Strength,
        reputation: 5
    },
    t.skillDescriptions[i.SkillType.Stonecrafting] = {
        attribute: a.Stat.Strength,
        reputation: -5
    },
    t.skillDescriptions[i.SkillType.Swimming] = {
        attribute: a.Stat.Stamina
    },
    t.skillDescriptions[i.SkillType.Tactics] = {
        attribute: a.Stat.Strength,
        reputation: -45
    },
    t.skillDescriptions[i.SkillType.Tailoring] = {
        attribute: a.Stat.Stamina
    },
    t.skillDescriptions[i.SkillType.Throwing] = {
        attribute: a.Stat.Stamina,
        reputation: -20
    },
    t.skillDescriptions[i.SkillType.Tinkering] = {
        attribute: a.Stat.Stamina,
        reputation: -5
    },
    t.skillDescriptions[i.SkillType.Trapping] = {
        attribute: a.Stat.Stamina,
        reputation: -20
    },
    t.skillDescriptions[i.SkillType.Woodworking] = {
        attribute: a.Stat.Strength,
        reputation: -5
    },
    t.skillDescriptions[i.SkillType.Taming] = {
        attribute: a.Stat.Stamina,
        reputation: 20
    },
    t.skillDescriptions[i.SkillType.Gardening] = {
        attribute: a.Stat.Stamina,
        reputation: 20
    },
    t.skillDescriptions[i.SkillType.Bartering] = {
        attribute: a.Stat.Stamina,
        reputation: 10
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/dialog/SkillsDialog", ["require", "exports", "entity/IStats", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Component", "newui/component/Input", "newui/component/SortRow", "newui/component/Text", "newui/screen/screens/game/component/Dialog", "newui/screen/screens/game/Dialogs", "player/Skills", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T) {
    var S;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Name = 0] = "Name",
        e[e.Level = 1] = "Level"
    }(S || (S = {}));
    class I extends c.default {
        constructor(e) {
            super(e, m.DialogId.Skills);
            const t = this.addScrollableWrapper();
            this.skills = y.default.values(i.SkillType).map(e=>f.tuple(e, new l.default(this.api).classes.add("unlockable-row").append(new p.default(this.api).setText(this.getSkillReadout(e))).setTooltip(this.getTooltip(e)).appendTo(t).schedule(1, this.updateSkill, e))).collect(g.default.toMap),
            this.until(c.DialogEvent.Close).bind(localPlayer, "SkillChange", this.updateSkill),
            this.sortRow = new d.default(this.api).setRefreshMethod(()=>({
                sortEnum: S,
                defaultSort: S.Name,
                initializeOption: (e,[t])=>e.setText(s.default.ui(`GameDialogSkillsSort${t}`))
            })).on(d.SortRowEvent.Sort, this.sort).appendTo(this.footer),
            this.inputFilter = new u.default(this.api).setPlaceholder(r.default.MiscFilter).on(u.InputEvent.Change, this.filter).appendTo(this.footer),
            this.sort()
        }
        getName() {
            return r.default.GameDialogSkillsName
        }
        updateSkill(e, t) {
            const a = localPlayer.getSkill(t)
              , i = this.skills.get(t).toggle(this.shouldShowSkill(t, this.inputFilter.text)).classes.toggle(a >= 100, "unlocked");
            i.style.setProperty("--percent", `${a}`),
            i.getNthChild(0).refresh()
        }
        sort(e, t=this.sortRow.sort, a=this.sortRow.sortDirection) {
            this.skills.entries().collect(g.default.toArray).sort(this.sortSkills(t)).values(a).forEach(([,e])=>e.appendTo(e.getParent()))
        }
        sortSkills(e) {
            return ([t],[a])=>{
                switch (e) {
                case S.Name:
                    return new s.default(n.Dictionary.Skill,t).getString().localeCompare(new s.default(n.Dictionary.Skill,a).getString());
                case S.Level:
                    return localPlayer.getSkill(a) - localPlayer.getSkill(t)
                }
            }
        }
        filter(e, t) {
            this.skills.entries().forEach(([e,a])=>a.toggle(this.shouldShowSkill(e, t)))
        }
        shouldShowSkill(e, t) {
            return 0 !== localPlayer.getSkill(e) && ("" === t || this.getFilterString(e).includes(t.toLowerCase()))
        }
        getFilterString(e) {
            const t = this.getSkillAttributeMessage(e);
            return [new s.default(n.Dictionary.Skill,e).getString(), new s.default(n.Dictionary.Skill,e,1).getString(), ...t?[s.default.message(t).getString()]:[]].join("\n").toLowerCase()
        }
        getSkillReadout(e) {
            return ()=>s.default.ui(r.default.GameDialogSkillsSkill).addArgs(new s.default(n.Dictionary.Skill,e).inContext(3), localPlayer.getSkill(e))
        }
        getTooltip(e) {
            return t=>{
                const a = h.skillDescriptions[e];
                if (!a)
                    return t;
                t.classes.add("skill-tooltip");
                const i = [[]];
                for (const t of new s.default(n.Dictionary.Skill,e,1).get()) {
                    const e = t.content.split(/\n\s*-\s+/);
                    for (let a = 0; a < e.length; a++)
                        i.collect(g.default.last()).push(Object.assign({}, t, {
                            content: e[a].replace(/^\s*-\s*/, "")
                        })),
                        a < e.length - 1 && i.push([])
                }
                new l.default(this.api,"ul").append(i.map(e=>new p.default(this.api,"li").setText(()=>e))).appendTo(t);
                const o = a.reputation;
                void 0 !== o && t.addParagraph(e=>e.setText(s.default.ui(r.default.GameDialogSkillsTooltipReputationImpact).addArgs(o)));
                const u = this.getSkillAttributeMessage(e);
                return u && t.addParagraph(e=>e.setText(s.default.ui(r.default.GameDialogSkillsTooltipCanIncrease).addArgs(s.default.message(u)))),
                t
            }
        }
        getSkillAttributeMessage(e) {
            if (h.skillDescriptions[e] && h.skillDescriptions[e].attribute)
                switch (h.skillDescriptions[e].attribute) {
                case a.Stat.Strength:
                    return o.default.Strength;
                case a.Stat.Stamina:
                    return o.default.Dexterity;
                case a.Stat.Metabolism:
                    return o.default.Metabolism
                }
        }
    }
    __decorate([Override], I.prototype, "getName", null),
    __decorate([T.Bound], I.prototype, "updateSkill", null),
    __decorate([T.Bound], I.prototype, "sort", null),
    __decorate([T.Bound], I.prototype, "filter", null),
    t.default = I
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/DialogMap", ["require", "exports", "newui/screen/screens/game/dialog/BookDialog", "newui/screen/screens/game/dialog/MapDialog", "newui/screen/screens/game/dialog/MessagesDialog", "newui/screen/screens/game/dialog/MessagesEditFiltersDialog", "newui/screen/screens/game/dialog/MilestonesDialog", "newui/screen/screens/game/dialog/NotesDialog", "newui/screen/screens/game/dialog/QuestDialog", "newui/screen/screens/game/dialog/QuickSettingsDialog", "newui/screen/screens/game/dialog/SkillsDialog", "newui/screen/screens/game/Dialogs"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const c = {
        [p.DialogId.Messages]: n.default,
        [p.DialogId.Notes]: s.default,
        [p.DialogId.MessagesEditFilters]: o.default,
        [p.DialogId.QuickSettings]: u.default,
        [p.DialogId.Skills]: d.default,
        [p.DialogId.Milestones]: r.default,
        [p.DialogId.Book]: a.default,
        [p.DialogId.Map]: i.default,
        [p.DialogId.Quests]: l.default
    };
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/menubar/MenuBarButton", ["require", "exports", "language/dictionary/UiTranslation", "language/Translation", "mod/IHookHost", "mod/IHookManager", "newui/component/Button", "newui/component/IComponent", "newui/screen/IScreen", "newui/screen/screens/game/static/menubar/MenuBarButtonDescriptions", "newui/util/Style", "resources/IResourceLoader"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class c extends r.default {
        constructor(e, t) {
            super(e.uiApi),
            this.classes.add("game-menubar-button", "has-icon-before", "button-icon"),
            this.attributes.set("intercept", "all"),
            this.dataset.buttonType = u.MenuBarButtonType[t];
            const a = u.default[t];
            this.bindable = a.bindable,
            this.onActivate = a.onActivate,
            this.gsapi = e,
            this.api.highlights.register(this, [s.HighlightType.MenuBarButton, t]),
            a.tooltip && this.setTooltip(this.getTooltip.bind(this, a.tooltip)),
            this.on(r.ButtonEvent.Activate, a.onActivate.bind(a, e)),
            this.style.setProperty("--menu-bar-button-icon", this.getStatIcon()),
            a.imageWidth && this.style.setProperty("--img-w", `${a.imageWidth}`),
            a.imageHeight && this.style.setProperty("--img-h", `${a.imageHeight}`),
            this.bindable && hookManager.register(this, `NewUi:MenuBarButton:${this.dataset.buttonType}`).until("Remove"),
            this.schedule(a.onCreate)
        }
        getStatIcon() {
            const e = u.MenuBarButtonType[this.dataset.buttonType];
            return d.default.getImagePath(p.PathType.MenuBarButtonIcon, e, void 0, !0)
        }
        onBindLoop(e, t) {
            return t.wasPressed(this.bindable) && !e && this.api.isScreenVisible(l.ScreenId.Game) && this.onActivate(this.gsapi) && (e = this.bindable),
            e
        }
        getTooltip(e, t) {
            return e(t),
            this.bindable ? t.addText(e=>e.setText(()=>i.default.ui(a.default.GameMenuBarButtonTooltipBindable).get(this.bindable))) : t
        }
    }
    __decorate([Override, n.HookMethod(o.HookPriority.Low)], c.prototype, "onBindLoop", null),
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/MenuBar", ["require", "exports", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Component", "newui/screen/screens/game/component/QuadrantComponent", "newui/screen/screens/game/IGameScreenApi", "newui/screen/screens/game/static/menubar/MenuBarButton", "newui/screen/screens/game/static/menubar/MenuBarButtonDescriptions", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class c extends o.default {
        constructor(e) {
            super(e),
            this.groups = new Map,
            this.classes.add("game-menubar", "scrollable"),
            this.refresh()
        }
        get preferredQuadrant() {
            return c.preferredQuadrant
        }
        get buttons() {
            return this._buttons
        }
        refresh() {
            for (const [e,t] of [...this.groups.entries()])
                t.remove(),
                this.groups.delete(e);
            this._buttons = u.default.values(l.MenuBarButtonType).map(e=>p.tuple(e, this.addButton(e))).filter2(([,e])=>e).collect(d.default.toMap)
        }
        getID() {
            return r.QuadrantComponentId.MenuBar
        }
        getName() {
            return i.default.ui(a.default.GameQuadrantElementMenuBar).get()
        }
        addButton(e) {
            const t = l.default[e];
            if (!t)
                return;
            const a = t.group
              , i = this.groups.get(a) || new n.default(this.api).classes.add("game-menubar-group").appendTo(this);
            return this.groups.set(a, i),
            new s.default(this.gsapi,e).appendTo(i)
        }
    }
    c.preferredQuadrant = o.Quadrant.Top,
    __decorate([Override], c.prototype, "preferredQuadrant", null),
    __decorate([Override], c.prototype, "getID", null),
    __decorate([Override], c.prototype, "getName", null),
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/Quickslots", ["require", "exports", "language/dictionary/UiTranslation", "language/Translation", "newui/screen/screens/game/component/QuadrantComponent", "newui/screen/screens/game/IGameScreenApi"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends n.default {
        constructor(e) {
            super(e),
            this.classes.add("game-quickslots")
        }
        get preferredQuadrant() {
            return r.preferredQuadrant
        }
        getID() {
            return o.QuadrantComponentId.Quickslots
        }
        getName() {
            return i.default.ui(a.default.GameQuadrantElementQuickslots).get()
        }
    }
    r.preferredQuadrant = n.Quadrant.TopRight,
    __decorate([Override], r.prototype, "preferredQuadrant", null),
    __decorate([Override], r.prototype, "getID", null),
    __decorate([Override], r.prototype, "getName", null),
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/stats/component/Stat", ["require", "exports", "entity/IEntity", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Component", "newui/component/IComponent", "newui/component/Text", "newui/screen/screens/game/static/stats/StatDisplayDescriptions", "newui/util/Style", "resources/IResourceLoader", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class h extends o.default {
        constructor(e, t, i) {
            super(e),
            this.stat = i,
            this.classes.add("game-stat", "has-icon-before"),
            this.entity = t,
            this.api.highlights.register(this, [r.HighlightType.Stat, i]),
            this.style.setProperty("--stat-order", `${this.getDisplayOrder()}`),
            this.entity.on(a.EntityEvent.StatChanged, this.onStatChange.bind(this)),
            this.entity.on(a.EntityEvent.StatMaxChanged, this.onStatChange.bind(this))
        }
        getStat() {
            return this.entity.getStat(this.stat)
        }
        getStatValue() {
            const e = this.getStat()
              , t = l.default[this.stat];
            return t && t.getFormatted ? t.getFormatted(this.entity, e) : e ? this.getGenericStatValue(e) : [{
                content: "Unknown"
            }]
        }
        getStatColor() {
            const e = l.default[this.stat];
            return e && e.color ? "function" == typeof e.color ? e.color(this.entity, this.getStat()) : e.color : "white"
        }
        getStatIcon() {
            const e = l.default[this.stat];
            let t;
            return e && e.imagePath && (t = "function" == typeof e.imagePath ? e.imagePath(this.entity, this.getStat()) : e.imagePath),
            u.default.getImagePath(d.PathType.StatIcon, this.stat, void 0, !0, t)
        }
        getDisplayOrder() {
            const e = l.default[this.stat];
            return e && "number" == typeof e.displayOrder ? e.displayOrder : 100
        }
        getGenericStatValue(e) {
            return e.max ? n.default.ui(i.default.GameStatsStatGenericWithMax).get(e.value, e.max) : n.default.ui(i.default.GameStatsStatGeneric).get(e.value)
        }
        onStatChange(e, t, a, i) {
            if (void 0 !== t && t.type !== this.stat)
                return;
            this.getDisplayElement().setText(this.getStatValue),
            this.style.setProperty("--stat-color", this.getStatColor()),
            this.style.setProperty("--stat-icon", this.getStatIcon());
            const n = l.default[this.stat];
            if (t = t || this.getStat(),
            n && n.tooltip && this.getTooltipElement().setTooltip(this.getTooltip),
            n && n.onChange)
                for (const e of n.onChange)
                    e(this, this.entity, t, a);
            i && i.important && ui.highlight(3, this.element)
        }
        getTooltipElement() {
            return this.getDisplayElement()
        }
        getTooltip(e) {
            e.style.setProperty("--stat-color", this.getStatColor());
            const t = l.default[this.stat];
            return e.schedule(t.tooltip, this.entity, this.stat).setMaxWidth(300).setLocation(r.TooltipLocation.Mouse)
        }
    }
    __decorate([m.Bound], h.prototype, "getStatValue", null),
    __decorate([m.Bound], h.prototype, "getTooltip", null),
    t.StatElement = h;
    class y extends h {
        constructor(e, t, a) {
            super(e, t, a),
            this.bar = new o.default(e).classes.add("game-stat-display").attributes.set("display-type", "bar").appendTo(this).append(this.text = new s.default(e)),
            this.onStatChange()
        }
        getDisplayElement() {
            return this.text
        }
        getGenericStatValue(e) {
            return n.default.ui(i.default.GameStatsStatbar).get(super.getGenericStatValue(e), Math.ceil(e.value / e.max * 100))
        }
        onStatChange(e, t, a) {
            super.onStatChange(e, t, a);
            const i = (t = this.getStat()).max || 1;
            this.bar.style.setProperty("--stat-percent", `${t.value / i}`)
        }
        getTooltipElement() {
            return this.bar
        }
    }
    __decorate([Override], y.prototype, "getDisplayElement", null),
    __decorate([Override], y.prototype, "getGenericStatValue", null),
    __decorate([Override], y.prototype, "onStatChange", null),
    __decorate([Override], y.prototype, "getTooltipElement", null),
    t.Statbar = y;
    class g extends h {
        constructor(e, t, a) {
            super(e, t, a),
            this.attribute = new s.default(e).classes.add("game-stat-display").attributes.set("display-type", "attribute").appendTo(this),
            this.onStatChange()
        }
        getDisplayElement() {
            return this.attribute
        }
    }
    __decorate([Override], g.prototype, "getDisplayElement", null),
    t.StatAttribute = g;
    class f extends o.default {
        get statbars() {
            return this._statbars
        }
        constructor(e, t, a) {
            super(e),
            this.classes.add("game-stat-container"),
            this.attributes.set("display-type", "bar"),
            this._statbars = a.map(e=>c.tuple(e, new y(this.api,t,e).appendTo(this))).collect(p.default.toMap)
        }
    }
    t.Statbars = f;
    class T extends o.default {
        get stats() {
            return this._stats
        }
        constructor(e, t, a) {
            super(e),
            this.classes.add("game-stat-container"),
            this.attributes.set("display-type", "attribute"),
            this._stats = a.map(e=>c.tuple(e, new g(this.api,t,e).appendTo(this))).collect(p.default.toMap)
        }
    }
    t.StatAttributes = T
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/stats/component/StatusEffects", ["require", "exports", "entity/IEntity", "entity/StatusEffects", "Enums", "language/Dictionaries", "language/Translation", "newui/component/Component", "newui/component/IComponent", "newui/util/Style", "resources/IResourceLoader", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class c extends s.default {
        constructor(e, t) {
            super(e),
            this.effectIcons = new Map,
            this.classes.add("game-status-effects"),
            this.entity = t,
            t.on(a.EntityEvent.StatusChange, this.onStatusChange);
            for (const e in t.status) {
                const a = e;
                this.onStatusChange(t, n.StatusType[a], t.status[a])
            }
        }
        onStatusChange(e, t, a) {
            a ? this.effectIcons.has(t) || this.effectIcons.set(t, new m(this.api,t,this.entity).appendTo(this)) : this.effectIcons.has(t) && (this.effectIcons.get(t).remove(),
            this.effectIcons.delete(t))
        }
    }
    __decorate([p.Bound], c.prototype, "onStatusChange", null),
    t.default = c;
    class m extends s.default {
        constructor(e, t, a) {
            super(e),
            this.classes.add("game-status-effect"),
            this.setTooltip(this.getTooltip),
            this.entity = a,
            this.dataset.statusEffect = n.StatusType[t],
            this.style.setProperty("--status-effect-icon", this.getIcon())
        }
        get status() {
            return n.StatusType[this.dataset.statusEffect]
        }
        getIcon() {
            const e = n.StatusType[this.dataset.statusEffect]
              , t = i.default[e];
            let a;
            return t && t.iconPath && (a = "function" == typeof t.iconPath ? t.iconPath(this.entity) : t.iconPath),
            u.default.getImagePath(d.PathType.StatusEffectIcon, e, void 0, !0, a)
        }
        getTooltip(e) {
            return e.setLocation(l.TooltipLocation.Mouse).addText(e=>e.setText(new r.default(o.Dictionary.StatusEffect,this.status).inContext(3)))
        }
    }
    __decorate([p.Bound], m.prototype, "getTooltip", null)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/static/Stats", ["require", "exports", "entity/IStats", "language/dictionary/UiTranslation", "language/Translation", "newui/screen/screens/game/component/QuadrantComponent", "newui/screen/screens/game/IGameScreenApi", "newui/screen/screens/game/static/stats/component/Stat", "newui/screen/screens/game/static/stats/component/StatusEffects", "newui/screen/screens/game/static/stats/StatDisplayDescriptions", "utilities/enum/Enums", "utilities/iterable/Collectors"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class c extends o.default {
        constructor(e, t) {
            super(e),
            this.classes.add("game-stats", "scrollable"),
            this.setPlayer(t)
        }
        get preferredQuadrant() {
            return c.preferredQuadrant
        }
        setPlayer(e) {
            this.player = e,
            this.refresh()
        }
        getID() {
            return r.QuadrantComponentId.Stats
        }
        getName() {
            return n.default.ui(i.default.GameQuadrantElementStats).get()
        }
        async refresh() {
            this.dump();
            const e = this.getStatsIterables()
              , t = e.iterate(m(a.StatDisplayType.Statbar)).collect(e=>new s.Statbars(this.api,this.player,e)).appendTo(this)
              , i = e.iterate(m(a.StatDisplayType.Attribute)).collect(e=>new s.StatAttributes(this.api,this.player,e)).appendTo(this)
              , n = e.iterate(m(a.StatDisplayType.Auto)).collect(p.default.toArray);
            new l.default(this.api,this.player).appendTo(this)
        }
        getStatsIterables() {
            return d.default.values(a.Stat).filter(e=>e in u.default && a.Stat[e]in this.player.stats).collect(p.default.split(e=>this.getStatDisplayType(this.player, this.player.getStat(e))))
        }
        getStatDisplayType(e, t) {
            const i = u.default[t.type]
              , n = i && void 0 !== i.displayType
              , o = i && n ? i.displayType : a.StatDisplayType.None;
            return a.StatDisplayType[o]
        }
    }
    function m(e) {
        return a.StatDisplayType[e]
    }
    c.preferredQuadrant = o.Quadrant.TopLeft,
    __decorate([Override], c.prototype, "preferredQuadrant", null),
    __decorate([Override], c.prototype, "getID", null),
    __decorate([Override], c.prototype, "getName", null),
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/util/movement/PathOverlayArrows", ["require", "exports", "Enums", "player/IPlayer", "utilities/math/Vector2"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const o = [a.Direction.North, a.Direction.East, a.Direction.South, a.Direction.West];
    function r(e, t, r, s, l) {
        let u = n.default.ZERO;
        if (l) {
            u.x = 16 * o.indexOf(i.getDirectionFromMovement(l.x - r.x, l.y - r.y));
            const a = Math.min(8, t);
            u.y = 16 * Math.floor(Math.max(0, a - (t - e)) / a * 3)
        } else
            u = new n.default(0,48);
        return {
            type: a.OverlayType.Arrows,
            size: 16,
            offsetX: u.x,
            offsetY: u.y
        }
    }
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/util/movement/PathOverlayFootPrints", ["require", "exports", "Enums", "player/IPlayer", "utilities/math/Vector2", "utilities/Objects"], function(e, t, a, i, n, o) {
    function r(...e) {
        return e.join("-")
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const s = o.default.create([[r(a.Direction.South, a.Direction.North), n.default.ZERO], [r(a.Direction.West, a.Direction.East), new n.default(16,0)], [r(a.Direction.North, a.Direction.South), new n.default(32,0)], [r(a.Direction.East, a.Direction.West), new n.default(48,0)], [r(a.Direction.South, a.Direction.East), new n.default(0,16)], [r(a.Direction.South, a.Direction.West), new n.default(16,16)], [r(a.Direction.North, a.Direction.East), new n.default(32,16)], [r(a.Direction.North, a.Direction.West), new n.default(48,16)], [r(a.Direction.West, a.Direction.North), new n.default(0,32)], [r(a.Direction.West, a.Direction.South), new n.default(16,32)], [r(a.Direction.East, a.Direction.North), new n.default(32,32)], [r(a.Direction.East, a.Direction.South), new n.default(48,32)]])
      , l = {
        [a.Direction.West]: a.Direction.East,
        [a.Direction.East]: a.Direction.West,
        [a.Direction.North]: a.Direction.South,
        [a.Direction.South]: a.Direction.North
    };
    function u(e, t, o, u, d) {
        let p = n.default.ZERO;
        if (d) {
            const e = [l[i.getDirectionFromMovement(o.x - u.x, o.y - u.y)], ...d?[i.getDirectionFromMovement(d.x-o.x, d.y-o.y)]:[]];
            (p = s[r(...e)]) || (p = n.default.ZERO)
        } else
            p = new n.default(0,48);
        return {
            type: a.OverlayType.FootPrints,
            size: 16,
            offsetX: p.x,
            offsetY: p.y
        }
    }
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/util/movement/PathOverlayWalkDots", ["require", "exports", "Enums", "player/IPlayer", "utilities/math/Vector2", "utilities/Objects"], function(e, t, a, i, n, o) {
    function r(...e) {
        return e.sort().join("-")
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const s = o.default.create([[r(a.Direction.South), n.default.ZERO], [r(a.Direction.East, a.Direction.South), new n.default(16,0)], [r(a.Direction.West, a.Direction.South), new n.default(32,0)], [r(a.Direction.North, a.Direction.South), new n.default(0,16)], [r(a.Direction.East, a.Direction.North), new n.default(16,16)], [r(a.Direction.West, a.Direction.North), new n.default(32,16)], [r(a.Direction.North), new n.default(0,32)], [r(a.Direction.East), new n.default(16,32)], [r(a.Direction.West, a.Direction.East), new n.default(32,32)], [r(a.Direction.West), new n.default(32,32)]])
      , l = {
        [a.Direction.West]: a.Direction.East,
        [a.Direction.East]: a.Direction.West,
        [a.Direction.North]: a.Direction.South,
        [a.Direction.South]: a.Direction.North
    };
    function u(e, t, n, o, u) {
        const d = [l[i.getDirectionFromMovement(n.x - o.x, n.y - o.y)], ...u?[i.getDirectionFromMovement(u.x-n.x, u.y-n.y)]:[]]
          , p = s[r(...d)];
        return {
            type: a.OverlayType.WalkDots,
            size: 16,
            offsetX: p.x,
            offsetY: p.y
        }
    }
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/util/movement/WalkToTileHandler", ["require", "exports", "creature/Pathing", "Enums", "game/IGame", "mod/IHookManager", "newui/screen/screens/game/util/movement/PathOverlayArrows", "newui/screen/screens/game/util/movement/PathOverlayFootPrints", "newui/screen/screens/game/util/movement/PathOverlayWalkDots", "tile/Terrains", "utilities/Objects", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class c {
        constructor() {
            this.overlays = [],
            this.overlayType = i.OverlayType.FootPrints,
            this.canResetTarget = !1
        }
        handle(e, t) {
            if (e.wasPressed(i.Bindable.GameMoveToTile) && e.isMouseWithin(t, !0) || this.canResetTarget && e.isDown(i.Bindable.GameMoveToTile) && e.mouseStartWasWithin(t, !0)) {
                this.canResetTarget = !1;
                const t = renderer.screenToTile(e.mouseX, e.mouseY);
                return this.reset(t, !1),
                (t.x === localPlayer.x && t.y === localPlayer.y || t.x === localPlayer.nextX && t.y === localPlayer.nextY) && this.reset(void 0, !1),
                (!this.previewPath || this.previewPath && 0 === this.previewPath.length) && (this.previewPath = this.findPath(t)),
                localPlayer.walkAlongPath(this.previewPath),
                !0
            }
            if (!localPlayer.hasWalkPath() && e.isDown(i.Bindable.GameMoveToTilePreview)) {
                const t = renderer.screenToTile(e.mouseX, e.mouseY);
                return (!this.previewTarget || t.x !== this.previewTarget.x || t.y !== this.previewTarget.y) && (this.previewPath = this.findPath(t),
                this.previewPath ? this.updateOverlay(this.previewPath) : this.resetOverlays(),
                this.previewTarget = t,
                game.updateView(n.RenderSource.PlayerWalkToTilePathPreview, !1),
                !1)
            }
            if (!localPlayer.hasWalkPath())
                return this.resetOverlays() && game.updateView(n.RenderSource.PlayerWalkToTilePathReset, !1),
                this.previewPath = void 0,
                !1;
            const a = modManager.getHook(o.Hook.ShouldStopWalkToTileMovement).call();
            (!0 === a || void 0 === a && localPlayer.getWeightStatus() === i.WeightStatus.Overburdened) && (this.reset(),
            game.updateView(n.RenderSource.PlayerWalkToTilePathOverburdened, !1));
            const r = localPlayer.getTile()
              , s = this.overlays.find(e=>e.tile === r);
            return void 0 !== s && p.default.Overlay.remove(r, s.overlay),
            !0
        }
        onMoveComplete() {
            this.canResetTarget = !0
        }
        onPlayerWalkToTilePath(e) {
            e ? this.updateOverlay(e) : (this.resetOverlays(),
            this.canResetTarget = !0),
            game.updateView(n.RenderSource.PlayerWalkToTilePath, !1)
        }
        reset(e, t=!0) {
            localPlayer.hasWalkPath() && (t && localPlayer.walkAlongPath(void 0),
            this.previewPath = void 0,
            this.resetOverlays(e),
            e || (this.canResetTarget = !0))
        }
        resetOverlays(e) {
            if (this.previewTarget && e && this.previewTarget.x === e.x && this.previewTarget.y === e.y)
                return !1;
            if (this.previewTarget || this.overlays.length > 0) {
                this.previewTarget = void 0;
                for (const e of this.overlays)
                    p.default.Overlay.remove(e.tile, e.overlay);
                return this.overlays.length = 0,
                !0
            }
            return !1
        }
        findPath(e) {
            return a.findPath(localPlayer.getPoint(), e, localPlayer.z, (e,t)=>a.isWalkToTileBlocked(localPlayer, e, t, !0), this.getTilePenalty)
        }
        getTilePenalty(e) {
            let t = 0;
            const a = p.default.getType(e)
              , i = u.default[a];
            return i && i.water && (t += 5),
            e.doodad && e.doodad.canTrample() && (t += 10),
            modManager.getHook(o.Hook.GetTilePenalty, t).call(t, e)
        }
        updateOverlay(e) {
            this.resetOverlays();
            const t = this.getOverlayRenderMethod();
            for (let a = 1; a < e.length; a++) {
                const i = e[a - 1]
                  , n = e[a]
                  , o = e[a + 1]
                  , r = game.getTile(n.x, n.y, localPlayer.z)
                  , s = t(a, e.length, n, i, o);
                void 0 !== s && (p.default.Overlay.add(r, s),
                this.overlays.push({
                    tile: r,
                    overlay: s
                }))
            }
        }
        getOverlayRenderMethod() {
            switch (this.overlayType) {
            case i.OverlayType.WalkDots:
                return l.default;
            case i.OverlayType.Arrows:
                return r.default;
            case i.OverlayType.FootPrints:
                return s.default
            }
        }
    }
    __decorate([d.Bound], c.prototype, "getTilePenalty", null),
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/RendererConstants", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.emptyUint8Array = isEdge ? new Uint8Array(0) : null,
    t.subTileSize = 8
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/util/movement/MovementHandler", ["require", "exports", "Enums", "mod/IHookManager", "newui/screen/screens/game/util/movement/WalkToTileHandler", "renderer/RendererConstants", "utilities/math/Math2", "utilities/math/Vector2"], function(e, t, a, i, n, o, r, s) {
    var l;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.X = "x",
        e.Y = "y"
    }(l || (l = {}));
    const u = {
        [l.X]: [a.Direction.West, a.Direction.East],
        [l.Y]: [a.Direction.North, a.Direction.South]
    };
    function d(e, t, a) {
        return e[1] && !t[1] ? e[0] : t[1] && !e[1] ? t[0] : a
    }
    function p() {
        const e = game.getExactCameraPosition()
          , t = new s.default(window.innerWidth / 2,window.innerHeight / 2);
        return e.equals(modManager.getHook(i.Hook.GetCameraPosition, e).call(e)) ? t : t.subtract(new s.default(game.getCameraPosition()).subtract(localPlayer).multiply(2 * o.subTileSize * renderer.getTileScale()))
    }
    function c(e) {
        return e < r.π / 4 || e > r.π / 4 * 7 ? a.Direction.East : e < r.π / 4 * 3 ? a.Direction.South : e < r.π / 4 * 5 ? a.Direction.West : a.Direction.North
    }
    function m(e) {
        return e < r.π / 6 || e > r.π / 6 * 11 ? [a.Direction.East, a.Direction.None] : e < r.π / 3 ? [a.Direction.East, a.Direction.South] : e < r.π / 3 * 2 ? [a.Direction.South, a.Direction.None] : e < r.π / 6 * 5 ? [a.Direction.West, a.Direction.South] : e < r.π / 6 * 7 ? [a.Direction.West, a.Direction.None] : e < r.π / 3 * 4 ? [a.Direction.West, a.Direction.North] : e < r.π / 3 * 5 ? [a.Direction.North, a.Direction.None] : [a.Direction.North, a.Direction.East]
    }
    function h(e, t) {
        const [i,n] = u[e];
        return d([i, t[i]], [n, t[n]], a.Direction.None)
    }
    function y(e) {
        const t = {
            [a.Direction.None]: !1,
            [a.Direction.West]: e.isDown(a.Bindable.GameMoveLeft),
            [a.Direction.East]: e.isDown(a.Bindable.GameMoveRight),
            [a.Direction.North]: e.isDown(a.Bindable.GameMoveUp),
            [a.Direction.South]: e.isDown(a.Bindable.GameMoveDown)
        }
          , i = Math.min(t[a.Direction.West] ? e.timeDown(a.Bindable.GameMoveLeft) : Number.MAX_SAFE_INTEGER, t[a.Direction.East] ? e.timeDown(a.Bindable.GameMoveRight) : Number.MAX_SAFE_INTEGER)
          , n = Math.min(t[a.Direction.North] ? e.timeDown(a.Bindable.GameMoveUp) : Number.MAX_SAFE_INTEGER, t[a.Direction.South] ? e.timeDown(a.Bindable.GameMoveDown) : Number.MAX_SAFE_INTEGER)
          , o = [h(l.X, t), h(l.Y, t)];
        return i < n && o.reverse(),
        o
    }
    class g {
        constructor(e) {
            this.gameScreen = e,
            this.walkToTileHandler = new n.default,
            this.lastMove = a.Direction.South,
            this.intent = {}
        }
        handle(e) {
            if (!1 === modManager.getHook(i.Hook.CanClientMove).call(e))
                this.intent.intent = void 0;
            else {
                const t = this.handleBinds(e);
                t || this.walkToTileHandler.reset()
            }
            localPlayer.updateMovementIntent(this.intent)
        }
        onMoveStart() {
            this.lastMove = this.intent.intent
        }
        onMoveComplete() {
            this.walkToTileHandler.onMoveComplete()
        }
        onPlayerDamage(e) {
            (e.human || e.creature) && this.walkToTileHandler.reset()
        }
        onPlayerDeath() {
            this.walkToTileHandler.reset()
        }
        onPlayerWalkToTilePath(e) {
            this.walkToTileHandler.onPlayerWalkToTilePath(e)
        }
        handleBinds(e) {
            if (this.intent.intent = void 0,
            e.isDown(a.Bindable.GameFaceUp))
                return localPlayer.faceDirection(a.Direction.North, saveDataGlobal.options.directionTurnDelay),
                !1;
            if (e.isDown(a.Bindable.GameFaceDown))
                return localPlayer.faceDirection(a.Direction.South, saveDataGlobal.options.directionTurnDelay),
                !1;
            if (e.isDown(a.Bindable.GameFaceLeft))
                return localPlayer.faceDirection(a.Direction.West, saveDataGlobal.options.directionTurnDelay),
                !1;
            if (e.isDown(a.Bindable.GameFaceRight))
                return localPlayer.faceDirection(a.Direction.East, saveDataGlobal.options.directionTurnDelay),
                !1;
            if (e.isDown(a.Bindable.GameFaceDirection) && this.mouseWithin(e)) {
                const t = s.default.direction(p(), e.mousePosition).toRadians() + r.π;
                return localPlayer.faceDirection(c(t), saveDataGlobal.options.mouseTurnDelay),
                !1
            }
            const t = y(e);
            return !(t.length > 0 && this.processDirectionBinds(t, saveDataGlobal.options.directionTurnDelay)) && (e.isDown(a.Bindable.GameIdle) ? (this.intent.intent = "idle",
            !1) : (this.walkToTileHandler.handle(e, this.gameScreen) && (this.intent.intent = void 0,
            this.intent.turnDelay = void 0),
            !(e.isDown(a.Bindable.GameMoveDirection) && !e.isDown(a.Bindable.GameMoveToTile) && this.mouseWithin(e)) || (this.processMoveDirection(e),
            !1)))
        }
        processMoveDirection(e) {
            const t = p()
              , i = s.default.squaredDistance(t, e.mousePosition);
            if (i < Math.pow(8 * renderer.getZoom(), 2))
                return void (this.intent.intent = "idle");
            const n = s.default.direction(t, e.mousePosition).toRadians() + r.π;
            !saveDataGlobal.options.alternatingDirectionMovement || i < Math.pow(200 * newui.scale.getCurrent(), 2) ? this.processDirectionBinds([c(n), a.Direction.None], saveDataGlobal.options.mouseTurnDelay) : this.processDirectionBinds(m(n), saveDataGlobal.options.mouseTurnDelay)
        }
        processDirectionBinds([e,t], i) {
            if (this.intent.turnDelay = i,
            e !== a.Direction.None && t !== a.Direction.None && saveDataGlobal.options.alternatingDirectionMovement)
                this.intent.intent = e === this.lastMove ? t : e,
                this.intent.turnDelay = void 0;
            else {
                if (e === a.Direction.None && t === a.Direction.None)
                    return !1;
                this.intent.intent = e !== a.Direction.None ? e : t
            }
            return !0
        }
        mouseWithin(e) {
            return e.mouseStartWasWithin(this.gameScreen, !0)
        }
    }
    t.default = g
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/tooltip/Tooltip", ["require", "exports", "newui/component/Component", "newui/component/IComponent", "newui/component/Text", "utilities/Async", "utilities/math/Vector2", "utilities/Objects"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l extends a.default {
        constructor(e, t) {
            super(e),
            this.source = t,
            this.cache = !0,
            this.classes.add("tooltip", "hidden"),
            this.setLocation(i.TooltipLocation.Mouse),
            this.on("Show", this.onShow),
            this.on(["Hide", "Remove"], this.onHide),
            t.on("Hide", this.hide),
            this.onShow()
        }
        get location() {
            return i.TooltipLocation[this.dataset.tooltipLocation]
        }
        setLocation(e) {
            return this.dataset.tooltipLocation = i.TooltipLocation[e],
            this
        }
        setMaxWidth(e) {
            return "number" == typeof e && (e = `calc(${e}px * var(--scale-floor))`),
            this.style.setProperty("--max-width", e || null),
            this
        }
        setNoCache() {
            return this.cache = !1,
            this
        }
        addText(e) {
            return new n.default(this.api).appendTo(this).schedule(e),
            this
        }
        addHeading(e) {
            return this.addText(t=>t.classes.add("tooltip-heading").schedule(e)),
            this
        }
        addParagraph(e) {
            return new n.Paragraph(this.api).appendTo(this).schedule(e),
            this
        }
        addList(...e) {
            return new a.default(this.api,"ul").append(e.map(e=>"function" != typeof e ? void 0 : new a.default(this.api,"li").append(new n.default(this.api).schedule(e)))).appendTo(this),
            this
        }
        updatePosition(e) {
            const t = this.source.getBox()
              , a = this.getBox();
            switch (this.location) {
            case i.TooltipLocation.Mouse:
                {
                    const t = e ? Object.assign({}, e) : {
                        x: -1e3,
                        y: -1e3
                    };
                    t.x += 20,
                    t.x + a.width > window.innerWidth && (t.x -= 20 + a.width),
                    t.y + a.height > window.innerHeight && (t.y -= a.height),
                    this.element.style.left = `${t.x}px`,
                    this.element.style.top = `${t.y}px`;
                    break
                }
            case i.TooltipLocation.AboveLeft:
                this.element.style.left = `${t.left}px`,
                this.element.style.top = `calc(${t.top - a.height}px - var(--tooltip-padding-top))`;
                break;
            case i.TooltipLocation.AboveRight:
                this.element.style.left = `${t.left + t.width - a.width}px`,
                this.element.style.top = `calc(${t.top - a.height}px - var(--tooltip-padding-top))`;
                break;
            case i.TooltipLocation.BeneathLeft:
                this.element.style.left = `${t.left}px`,
                this.element.style.top = `calc(${t.top + t.height}px + var(--tooltip-padding-bottom))`;
                break;
            case i.TooltipLocation.BeneathRight:
                this.element.style.left = `${t.left + t.width - a.width}px`,
                this.element.style.top = `calc(${t.top + t.height}px + var(--tooltip-padding-bottom))`;
                break;
            case i.TooltipLocation.TopLeft:
                this.element.style.left = `calc(${t.left - a.width}px - var(--tooltip-padding-left))`,
                this.element.style.top = `${t.top}px`;
                break;
            case i.TooltipLocation.TopRight:
                this.element.style.left = `calc(${t.left + t.width}px + var(--tooltip-padding-right))`,
                this.element.style.top = `${t.top}px`;
                break;
            case i.TooltipLocation.CenterLeft:
                this.element.style.left = `calc(${t.left - a.width}px - var(--tooltip-padding-left))`,
                this.element.style.top = `${t.top + t.height / 2 - a.height / 2}px`;
                break;
            case i.TooltipLocation.CenterRight:
                this.element.style.left = `calc(${t.left + t.width}px + var(--tooltip-padding-right))`,
                this.element.style.top = `${t.top + t.height / 2 - a.height / 2}px`;
                break;
            case i.TooltipLocation.BottomLeft:
                this.element.style.left = `calc(${t.left - a.width}px - var(--tooltip-padding-left))`,
                this.element.style.top = `${t.top + t.height - a.height}px`;
                break;
            case i.TooltipLocation.BottomRight:
                this.element.style.left = `calc(${t.left + t.width}px + var(--tooltip-padding-right))`,
                this.element.style.top = `${t.top + t.height - a.height}px`
            }
            return this
        }
        onShow() {
            this.dumpFast(),
            this.onHide(),
            document.addEventListener("mousemove", this.onMouseMove),
            this.updatePosition(),
            o.sleep(10).then(()=>this.updatePosition().classes.remove("hidden"))
        }
        onHide() {
            document.removeEventListener("mousemove", this.onMouseMove)
        }
        onMouseMove(e) {
            if (this.location !== i.TooltipLocation.Mouse)
                return;
            const t = new r.default(e.clientX,e.clientY);
            this.updatePosition(t.raw()),
            this.emit("Move", t)
        }
    }
    __decorate([s.Bound], l.prototype, "onShow", null),
    __decorate([s.Bound], l.prototype, "onHide", null),
    __decorate([s.Bound], l.prototype, "onMouseMove", null),
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/game/WorldTooltip", ["require", "exports", "game/inspection/IInspection", "game/inspection/Inspect", "language/Dictionaries", "language/dictionary/Misc", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Component", "newui/component/Text", "player/MessageManager", "utilities/Async", "utilities/math/Vector3", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class h {
        constructor(e, t) {
            this.api = e,
            t.setTooltip(this.initializeTooltip)
        }
        initializeTooltip(e) {
            return this.tooltip = e,
            e.classes.add("world-tooltip"),
            e.on("Move", this.onTooltipMove),
            e.on("Remove", ()=>delete this.tooltip),
            e
        }
        update(e=!1) {
            this.onTooltipMove(void 0, void 0, e)
        }
        onTooltipMove(e, t=this.lastMousePosition, a=!1) {
            t && this.tooltip && (this.lastMousePosition = t,
            t = renderer.screenToTile(...t.xy),
            !a && t.equals(this.lastPosition) || (this.lastPosition = t,
            this.refreshTooltip(t, a),
            p.sleep(1).then(()=>{
                this.tooltip && this.tooltip.updatePosition(this.lastMousePosition.raw())
            }
            )))
        }
        refreshTooltip(e, t=!1) {
            if (t || this.tooltip.classes.until(1).add("invisible"),
            this.tooltip.dump(),
            !localPlayer.canSeePosition(e.x, e.y, localPlayer.z, !0))
                return;
            const p = i.default.inspect(localPlayer, new c.default(e,localPlayer.z), a.InspectionContext.Tooltip);
            for (const e of p)
                new l.default(this.api).classes.add("block").append(e.content.map(e=>new (e.title ? u.Heading : u.Paragraph)(this.api).classes.toggle(!!e.extra, "extra").setText(e.text.inContext(e.text.context || (e.title ? 3 : 0)).addReformatter(e.messageType ? new s.default(n.Dictionary.Misc,o.MiscTranslation.Message).addArgs(d.MessageType[e.messageType].toLowerCase()) : void 0)))).appendTo(this.tooltip).style.setProperty("--border", e.border || "");
            this.tooltip.findDescendants(".extra").length && this.tooltip.addParagraph(e=>e.classes.add("show-extra-information").setText(r.default.GameTooltipShowMoreInformation))
        }
    }
    __decorate([m.Bound], h.prototype, "initializeTooltip", null),
    __decorate([m.Bound], h.prototype, "onTooltipMove", null),
    t.default = h
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/GameScreen", ["require", "exports", "action/ActionExecutor", "action/IAction", "Enums", "game/IGame", "language/dictionary/Message", "mod/IHookHost", "multiplayer/IMultiplayer", "newui/BindingManager", "newui/component/Button", "newui/component/Component", "newui/INewUi", "newui/screen/IScreen", "newui/screen/Screen", "newui/screen/screens/game/component/Dialog", "newui/screen/screens/game/component/QuadrantComponent", "newui/screen/screens/game/DialogMap", "newui/screen/screens/game/Dialogs", "newui/screen/screens/game/IGameScreenApi", "newui/screen/screens/game/static/MenuBar", "newui/screen/screens/game/static/Messages", "newui/screen/screens/game/static/Quickslots", "newui/screen/screens/game/static/Stats", "newui/screen/screens/game/util/movement/MovementHandler", "newui/screen/screens/game/WorldTooltip", "player/IMessageManager", "utilities/Async", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class x extends h.default {
        constructor(e) {
            super(e, m.ScreenId.Game),
            this.dialogs = new Map,
            this.visibleDialogs = {},
            this.quadrantComponentQuadrants = {},
            this.quadrantMap = new Map,
            this.gameCanvas = p.default.get(document.getElementById("game")),
            this.classes.add(),
            this.worldTooltipHandler = new k.default(e,this.gameCanvas),
            new d.default(this.api).classes.add("pause-icon", "has-icon-before", "button-icon").on(d.ButtonEvent.Activate, ()=>{
                multiplayer.isConnected() && !multiplayer.isServer() || game.setPaused(!1, game.getTurnMode() === n.TurnMode.RealTime)
            }
            ).appendTo(this),
            this.once("Show", this.create);
            const t = this.until("Remove");
            t.bind(e, c.UiApiEvent.Resize, this.updateQuadrantPositions),
            t.bind(e, c.UiApiEvent.InterruptClose, this.tryShowWorldTooltip),
            t.bind(game, [o.GameEvent.Pause, o.GameEvent.Resume], this.updatePauseIcon),
            t.bind(multiplayer, [l.MultiplayerEvent.Connect, l.MultiplayerEvent.Disconnect], this.updatePauseIcon),
            this.updatePauseIcon()
        }
        get uiApi() {
            return this.api
        }
        create() {
            this.gameCanvas.classes.toggle(localPlayer.state === n.PlayerState.Ghost, "death"),
            this.api.registerDataHost("GameScreen", this),
            this.quadrantContainer = new p.default(this.api).classes.add("game-quadrants").appendTo(this),
            [this.stats = new M.default(this,localPlayer), this.quickslots = new w.default(this), this.messages = new v.default(this), this.menuBar = new I.default(this)].forEach(this.addQuadrantElement),
            this.schedule(500, this.updateQuadrantPositions),
            this.toggleDialogs(this.visibleDialogs),
            this.movementHandler = new b.default(this.gameCanvas.element)
        }
        openDialog(e) {
            let t = this.dialogs.get(e);
            if (t)
                t.classes.remove("hidden").focus();
            else
                try {
                    t = new f.default[e](this,e),
                    A.default.isModded(T.DialogId, e) && Object.defineProperty(t, "getID", {
                        value: ()=>e
                    }),
                    t.appendTo(this).on(y.DialogEvent.GetDialogList, ()=>this.dialogs.values()).on(y.DialogEvent.Close, this.onDialogClose),
                    this.dialogs.set(e, t),
                    this.visibleDialogs[e] = !0,
                    this.emit(S.GameScreenEvent.ShowDialog, t)
                } catch (t) {
                    G.default.error(G.LogSource.NewUi, G.LogSource.Game)("Failed to initialize dialog", T.DialogId[e], t)
                }
            return t
        }
        async closeDialog(e) {
            const t = this.dialogs.get(e);
            t && await t.close() && this.emit(S.GameScreenEvent.HideDialog, e)
        }
        toggleDialog(e, t) {
            const a = this.dialogs.get(e);
            a && !a.classes.has("hidden") ? !0 !== t && this.closeDialog(e) : !1 !== t && this.openDialog(e)
        }
        toggleDialogs(e) {
            let t, a;
            for ([t,a] of R.default.entries(e))
                t = +t,
                T.default[t] && !1 !== T.default[t].saveOpen && f.default[t] && this.toggleDialog(t, a)
        }
        getQuadrantComponent(e) {
            return this.quadrantMap.values().filter(t=>t.getID() === e).collect(P.default.first())
        }
        getQuadrantContainer() {
            return this.quadrantContainer
        }
        isMouseWithin() {
            return u.bindingManager.isMouseWithin(this.gameCanvas, !0)
        }
        wasMouseStartWithin() {
            return u.bindingManager.mouseStartWasWithin(this.gameCanvas, !0)
        }
        onBindLoop(e, t) {
            if (this.api.getVisibleScreen() !== this)
                return e;
            if (e = super.onBindLoop(e, t),
            document.documentElement.classList.toggle("showing-extra-information", saveDataGlobal.options.alwaysShowMoreInformation || t.isDown(n.Bindable.GameMoreInformation)),
            t.wasPressed(n.Bindable.GameScreenshotMode) && !e && (this.classes.toggle("screenshot-mode"),
            ui.toggleUIDisplay(this.classes.has("screenshot-mode")),
            e = n.Bindable.GameScreenshotMode),
            t.wasPressed(n.Bindable.MenuCancel) && !e && (this.classes.has("screenshot-mode") && (this.classes.remove("screenshot-mode"),
            ui.toggleUIDisplay(this.classes.has("screenshot-mode")),
            e = n.Bindable.MenuCancel),
            "INPUT" === document.activeElement.tagName && (e = n.Bindable.MenuCancel)),
            t.wasPressed(n.Bindable.GameInspect) && !e && this.isMouseWithin()) {
                const o = renderer.screenToTile(t.mouseX, t.mouseY);
                if (!localPlayer.canSeePosition(o.x, o.y, localPlayer.z, !0))
                    return localPlayer.messages.source(C.Source.Action).send(r.default.CannotSeeHere),
                    e;
                a.default.get(i.ActionType.Inspect).execute(localPlayer, {
                    x: o.x,
                    y: o.y,
                    z: localPlayer.z
                }),
                e = n.Bindable.GameInspect
            }
            return t.wasPressed(n.Bindable.GameZoomIn) && !e && this.isMouseWithin() && (game.addZoomLevel(1),
            e = n.Bindable.GameZoomIn,
            t.removePressState(n.Bindable.GameZoomIn)),
            t.wasPressed(n.Bindable.GameZoomOut) && !e && this.isMouseWithin() && (game.addZoomLevel(-1),
            e = n.Bindable.GameZoomOut,
            t.removePressState(n.Bindable.GameZoomOut)),
            this.movementHandler.handle(t),
            e
        }
        onGameStart(e, t) {
            this.stats.setPlayer(localPlayer),
            this.gameCanvas.classes.toggle(localPlayer.state === n.PlayerState.Ghost, "death").classes.remove("respawn-on-death")
        }
        onMove(e, t, a, i, n) {
            e.isLocalPlayer() && this.movementHandler.onMoveStart()
        }
        onMoveComplete(e) {
            e.isLocalPlayer() && this.movementHandler.onMoveComplete(),
            this.worldTooltipHandler.update()
        }
        onPlayerDamage(e, t) {
            e.isLocalPlayer() && this.movementHandler.onPlayerDamage(t)
        }
        onPlayerDeath(e) {
            e.isLocalPlayer() && (this.movementHandler.onPlayerDeath(),
            this.gameCanvas.classes.add(game.getDifficultyOptions().respawn ? "respawn-on-death" : "death"))
        }
        onPlayerWalkToTilePath(e, t) {
            e.isLocalPlayer() && this.movementHandler.onPlayerWalkToTilePath(t)
        }
        onGameTickEnd() {
            this.gameCanvas.classes.toggle(localPlayer.state === n.PlayerState.Ghost, "death").classes.remove("respawn-on-death"),
            this.worldTooltipHandler.update(!0)
        }
        onOpenBook(e, t) {
            e.isLocalPlayer() && this.openDialog(T.DialogId.Book).setBook(t)
        }
        onReadMap(e, t) {
            e.isLocalPlayer() && this.openDialog(T.DialogId.Map).decode(t)
        }
        addQuadrantElement(e) {
            e.on(g.QuadrantComponentEvent.ChangeQuadrant, this.onQuadrantElementChange),
            e.on(g.QuadrantComponentEvent.GetQuadrantElementList, ()=>this.quadrantMap.values());
            let t = this.quadrantComponentQuadrants[e.getID()];
            void 0 === t ? ((t = e.preferredQuadrant) === g.Quadrant.None || this.quadrantMap.get(t)) && (t = this.getUnusedQuadrant()) : this.quadrantMap.get(t) && (t = this.getUnusedQuadrant()),
            e.setQuadrant(t)
        }
        onQuadrantElementChange(e, t, a) {
            const i = this.quadrantMap.get(t);
            t !== g.Quadrant.None && (this.quadrantMap.set(t, e),
            this.quadrantComponentQuadrants[e.getID()] = t),
            a !== g.Quadrant.None && (i ? (this.quadrantMap.set(a, i),
            this.quadrantComponentQuadrants[i.getID()] = a) : this.quadrantMap.delete(a)),
            i && i.setQuadrant(a, !1),
            t === g.Quadrant.None ? e.store() : e.appendTo(this.quadrantContainer),
            this.schedule(100, this.updateQuadrantPositions)
        }
        updateQuadrantPositions() {
            if (!this.quadrantContainer)
                return;
            const e = this.quadrantMap.get(g.Quadrant.Top)
              , t = this.quadrantMap.get(g.Quadrant.Bottom);
            this.quadrantContainer.classes.toggle(!!e, "has-top-quadrant"),
            this.quadrantContainer.classes.toggle(!!t, "has-bottom-quadrant"),
            this.quadrantContainer.style.setProperty("--top-quadrant-height", `${e ? e.getBox().height : 0}px`),
            this.quadrantContainer.style.setProperty("--bottom-quadrant-height", `${t ? t.getBox().height : 0}px`)
        }
        getUnusedQuadrant() {
            return A.default.values(g.Quadrant).filter(e=>e !== g.Quadrant.None && !this.quadrantMap.has(e)).collect(P.default.first(g.Quadrant.None))
        }
        onDialogClose(e) {
            const t = e.id;
            this.dialogs.delete(t),
            this.visibleDialogs[t] = !1
        }
        updatePauseIcon() {
            this.classes.toggle(game.getTurnMode() === n.TurnMode.RealTime || multiplayer.isConnected(), "has-pause-icon"),
            this.classes.toggle(game.paused, "paused"),
            this.classes.toggle(!multiplayer.isConnected() || multiplayer.isServer(), "unpausable")
        }
        async tryShowWorldTooltip() {
            await D.sleep(100),
            this.gameCanvas.forceShowTooltip()
        }
    }
    __decorate([c.Save(c.SaveLocation.Both)], x.prototype, "visibleDialogs", void 0),
    __decorate([c.Save(c.SaveLocation.Both)], x.prototype, "quadrantComponentQuadrants", void 0),
    __decorate([R.Bound], x.prototype, "create", null),
    __decorate([Override, s.HookMethod], x.prototype, "onBindLoop", null),
    __decorate([s.HookMethod(c.NEWUI_HOOK_PRIORITY)], x.prototype, "onGameStart", null),
    __decorate([s.HookMethod(c.NEWUI_HOOK_PRIORITY)], x.prototype, "onMove", null),
    __decorate([s.HookMethod(c.NEWUI_HOOK_PRIORITY)], x.prototype, "onMoveComplete", null),
    __decorate([s.HookMethod(c.NEWUI_HOOK_PRIORITY)], x.prototype, "onPlayerDamage", null),
    __decorate([s.HookMethod(c.NEWUI_HOOK_PRIORITY)], x.prototype, "onPlayerDeath", null),
    __decorate([s.HookMethod(c.NEWUI_HOOK_PRIORITY)], x.prototype, "onPlayerWalkToTilePath", null),
    __decorate([s.HookMethod(c.NEWUI_HOOK_PRIORITY)], x.prototype, "onGameTickEnd", null),
    __decorate([s.HookMethod(c.NEWUI_HOOK_PRIORITY)], x.prototype, "onOpenBook", null),
    __decorate([s.HookMethod(c.NEWUI_HOOK_PRIORITY)], x.prototype, "onReadMap", null),
    __decorate([R.Bound], x.prototype, "addQuadrantElement", null),
    __decorate([R.Bound], x.prototype, "onQuadrantElementChange", null),
    __decorate([R.Bound], x.prototype, "updateQuadrantPositions", null),
    __decorate([R.Bound], x.prototype, "onDialogClose", null),
    __decorate([R.Bound], x.prototype, "updatePauseIcon", null),
    __decorate([R.Bound], x.prototype, "tryShowWorldTooltip", null),
    t.default = x
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/SortRow", ["require", "exports", "language/dictionary/UiTranslation", "newui/component/Button", "newui/component/Dropdown", "newui/component/LabelledRow", "newui/screen/screens/GameScreen", "save/ISaveManager", "utilities/enum/Enums", "utilities/iterable/Generators"], function(e, t, a, i, n, o, r, s, l, u) {
    var d;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Sort = "Sort"
    }(d = t.SortRowEvent || (t.SortRowEvent = {}));
    class p extends o.LabelledRow {
        constructor(e) {
            super(e),
            this._sortDirection = s.SortDirection.More,
            this.disabledSorts = [],
            this.classes.add("sort-row", "menu-input-row"),
            this.setLabel(e=>e.setText(a.default.MiscSortBy)),
            this.dropdown = new n.default(this.api).appendTo(this),
            this.dropdown.on(n.DropdownEvent.Selection, (e,t)=>{
                this._sort = t,
                this.triggerSort()
            }
            );
            const t = new i.default(this.api).classes.add("button-sort-direction", "has-icon-before", "icon-center", "icon-no-scale").setTooltip(e=>e[newui.getVisibleScreen()instanceof r.default ? "addText" : "addHeading"](e=>e.setText(a.default.MiscSortDirection))).on(i.ButtonEvent.Activate, ()=>{
                t.classes.toggle("reverse"),
                this._sortDirection = this._sortDirection === s.SortDirection.Less ? s.SortDirection.More : s.SortDirection.Less,
                t.classes.toggle(this._sortDirection === s.SortDirection.Less, "reverse"),
                this.emit("Sort", this._sort, this._sortDirection)
            }
            ).appendTo(this)
        }
        get sort() {
            return this._sort
        }
        get sortDirection() {
            return this._sortDirection
        }
        setDisabledSorts(e, t=!1) {
            return this.disabledSorts = [...e],
            t && this.dropdown.refresh(),
            this
        }
        setRefreshMethod(e) {
            return this.refreshMethod = e,
            this.refresh(),
            this
        }
        refresh() {
            return this.dropdown.setRefreshMethod(()=>{
                const e = this.refreshMethod();
                return {
                    defaultOption: this._sort = e.defaultSort,
                    options: l.default.entries(e.sortEnum).filter(([,e])=>!this.disabledSorts.includes(e)).map(([t,a])=>u.tuple(a, i=>e.initializeOption(i, [t, a])))
                }
            }
            ),
            this
        }
        triggerSort() {
            this.emit(d.Sort, this._sort, this._sortDirection)
        }
        async triggerSortAsync() {
            return this.emitAsync(d.Sort, this._sort, this._sortDirection)
        }
    }
    t.default = p
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/character/CharacterPreview", ["require", "exports", "Enums", "newui/component/Component", "newui/component/IComponent", "newui/util/Style", "player/Customizations", "resources/IResourceLoader", "utilities/Color"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class u extends i.default {
        constructor(e) {
            super(e, "svg", n.Namespace.SVG),
            this.filters = {}
        }
        createFilter(e) {
            return this.filters[e] = new i.default(this.api,"filter",n.Namespace.SVG).setId(e).append(new i.default(this.api,"feColorMatrix",n.Namespace.SVG).attributes.set("type", "matrix")).appendTo(this),
            this
        }
        setFilterColor(e, t) {
            this.filters[e].getNthChild(0).attributes.set("values", l.default.getSVGColorMatrix(t))
        }
    }
    t.SVG = u;
    class d extends i.default {
        constructor(e, t, a) {
            super(e),
            this._loaded = !1,
            this.classes.add("menu-character-preview"),
            this.append([this.elementPreviewBody = this.addPreviewLayer("menu-character-preview-body"), this.elementPreviewPants = this.addPreviewLayer("menu-character-preview-pants"), this.elementPreviewShirt = this.addPreviewLayer("menu-character-preview-shirt"), this.elementPreviewHairShadow = this.addPreviewLayer("menu-character-preview-hair-shadow"), this.elementPreviewHair = this.addPreviewLayer("menu-character-preview-hair"), this.elementPreviewHairAccessory = this.addPreviewLayer("menu-character-preview-hair-accessory")]),
            this.rotate(0),
            this.customization = t,
            a ? this.filters = a : (this.filters = {
                skin: `filter-skin-${Math.random().toString().slice(2)}`,
                hair: `filter-hair-${Math.random().toString().slice(2)}`
            },
            document.getElementById(this.filters.skin) || document.getElementById(this.filters.hair) || (this.svg = new u(e).appendTo(this),
            this.svg.createFilter(this.filters.skin),
            this.svg.createFilter(this.filters.hair))),
            this.elementPreviewBody.style.setProperty("--filter", `url("#${this.filters.skin}")`),
            this.elementPreviewHairShadow.style.setProperty("--filter", `url("#${this.filters.skin}")`),
            this.elementPreviewHair.style.setProperty("--filter", `url("#${this.filters.hair}")`)
        }
        get loaded() {
            return this._loaded
        }
        getFilters() {
            return {
                skin: this.filters.skin,
                hair: this.filters.hair
            }
        }
        update() {
            this._loaded = !0,
            this.elementPreviewBody.style.backgroundImage = o.default.getImagePath("static/image/character/body"),
            this.elementPreviewPants.style.backgroundImage = o.default.getImagePath("static/image/character/equip/tatteredpants"),
            this.elementPreviewShirt.style.backgroundImage = o.default.getImagePath("static/image/character/equip/tatteredshirt");
            let e = "none";
            return a.HairStyle[this.customization.hairStyle] !== a.HairStyle.None && "number" == typeof a.HairStyle[this.customization.hairStyle] && (e = o.default.getImagePath(s.PathType.Hairstyle, a.HairStyle[this.customization.hairStyle])),
            this.elementPreviewHair.style.backgroundImage = e,
            this.elementPreviewHairShadow.style.backgroundImage = e,
            this.elementPreviewHairAccessory.style.backgroundImage = e,
            "number" != typeof a.HairStyle[this.customization.hairStyle] && (this._loaded = !1),
            this.updateCharacterPreviewFilter(r.ColorType.Skin, !1),
            this.updateCharacterPreviewFilter(r.ColorType.Hair),
            this
        }
        rotate(e) {
            this.style.setProperty("--rotation-offset", `${[2, 3, 1, 0][e]}`)
        }
        updateCharacterPreviewFilter(e, t=!0) {
            if (this.svg) {
                const t = r.getColorDescription(e, this.customization[e]);
                if (t) {
                    const a = e === r.ColorType.Skin ? this.filters.skin : this.filters.hair;
                    this.svg.setFilterColor(a, t.color)
                }
            }
            t && this.repaint()
        }
        addPreviewLayer(e) {
            return new i.default(this.api).classes.add("menu-character-preview-layer", e)
        }
    }
    t.default = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/character/CharacterButton", ["require", "exports", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Button", "newui/component/Text", "newui/screen/screens/menu/menus/character/CharacterPreview"], function(e, t, a, i, n, o, r) {
    var s;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Delete = "Delete",
        e.Customize = "Customize"
    }(s = t.CharacterEvent || (t.CharacterEvent = {}));
    class l extends n.default {
        get character() {
            return this._character
        }
        constructor(e, t) {
            super(e),
            this.classes.add("menu-character", "menu-text-not-heading"),
            this._character = t,
            this.text.remove(),
            this.preview = new r.default(e,t.customization).update().appendTo(this),
            new o.Heading(e).setText(i.default.generator(t.name)).appendTo(this),
            this.setDisabled(!this.preview.loaded),
            this.addButton(e=>e.classes.add("button-edit").setTooltip(e=>e.addHeading(e=>e.setText(a.default.MenuCharacterSelectionCharacterButtonCustomizeTooltip))).on(n.ButtonEvent.Activate, ()=>{
                this.emit(s.Customize, t)
            }
            )),
            this.addButton(e=>e.classes.add("button-delete").setTooltip(e=>e.addHeading(e=>e.setText(a.default.MenuCharacterSelectionCharacterButtonDeleteTooltip))).on(n.ButtonEvent.Activate, ()=>{
                this.emit(s.Delete, t)
            }
            )),
            new o.Paragraph(e).append(new o.default(e).setText(()=>i.default.ui(a.default.MenuCharacterSelectionLabelLastUse).get(new Date(t.lastUse).toLocaleString()))).append(new o.default(e).setText(()=>i.default.ui(a.default.MenuCharacterSelectionLabelUseCount).get(t.useCount))).appendTo(this)
        }
    }
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/character/HairstyleChoice", ["require", "exports", "Enums", "newui/component/ChoiceList", "newui/screen/screens/menu/menus/character/CharacterPreview", "utilities/enum/Enums"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends i.default {
        constructor(e, t, a) {
            super(e),
            this.baseCustomization = t,
            this.filters = a,
            this.classes.add("menu-character-hairstyle-list", "menu-choice-list-small"),
            this.classes.remove("menu-text", "menu-check-button", "has-icon-before")
        }
        select(e, t=!1) {
            for (const t of this.getChildren())
                if (t.hairstyle === e)
                    return void t.setChecked(!0);
            if (t)
                throw new Error("Invalid hairstyle")
        }
        refreshChoices() {
            o.default.values(a.HairStyle).map(e=>new s(this.api,e,this.baseCustomization,this.filters)).collect(this.setChoices)
        }
        update() {
            for (const e of this.getChildren())
                e.update()
        }
        rotate(e) {
            for (const t of this.getChildren())
                t.rotate(e)
        }
    }
    t.HairstyleList = r;
    class s extends i.Choice {
        constructor(e, t, a, i) {
            super(e, void 0),
            this._hairstyle = t,
            this.baseCustomization = a,
            this.classes.add("menu-character-hairstyle"),
            this.update(),
            this.preview = new n.default(e,this.customization,i).appendTo(this),
            this.preview.update(),
            this.text.remove()
        }
        get hairstyle() {
            return this._hairstyle
        }
        update() {
            this.customization || (this.customization = {}),
            this.customization.hairColor = this.baseCustomization.hairColor,
            this.customization.skinColor = this.baseCustomization.skinColor,
            this.customization.hairStyle = a.HairStyle[this.hairstyle]
        }
        rotate(e) {
            this.preview.rotate(e)
        }
    }
    t.HairstyleChoice = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/character/Swatch", ["require", "exports", "newui/component/ChoiceList", "utilities/Color", "utilities/Objects"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o extends a.default {
        constructor(e, t) {
            super(e),
            this.colors = t,
            this.classes.add("menu-character-swatch-list", "menu-choice-list-small"),
            this.classes.remove("menu-text", "menu-check-button", "has-icon-before")
        }
        select(e, t=!1) {
            for (const t of this.getChildren())
                if (t.color === this.colors[e])
                    return void t.setChecked(!0);
            if (t)
                throw new Error("Invalid swatch")
        }
        refreshChoices() {
            n.default.values(this.colors).map(e=>new r(this.api,e)).collect(this.setChoices)
        }
    }
    t.SwatchList = o;
    class r extends a.Choice {
        constructor(e, t) {
            super(e, void 0),
            this.color = t,
            this.classes.add("menu-character-swatch"),
            this.style.setProperty("--swatch", i.default.getCSS(t.color)),
            this.text.remove()
        }
    }
    t.Swatch = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/character/CharacterCreationMenu", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/HumanName", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Block", "newui/component/Button", "newui/component/ChoiceList", "newui/component/Component", "newui/component/Input", "newui/component/LabelledRow", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/character/CharacterPreview", "newui/screen/screens/menu/menus/character/HairstyleChoice", "newui/screen/screens/menu/menus/character/Swatch", "newui/util/Misc", "player/Customizations", "utilities/enum/Enums", "utilities/Files", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M) {
    function b(e, t) {
        for (const a in e)
            if (t === e[a])
                return a
    }
    function k(e, t) {
        return e.hairColor === t.hairColor && e.skinColor === t.skinColor && e.hairStyle === t.hairStyle
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class C extends h.default {
        constructor(e) {
            super(e, "character-creation"),
            this.rotation = 0,
            this.customization = {},
            this.defaultName = "",
            this.setTitle(e=>e.setText(o.default.MenuCharacterCreationTitle)),
            this.setDescription(e=>e.setText(o.default.MenuCharacterCreationDescription)),
            this.create(),
            this.on("Show", this.onShow),
            this.on("Hide", ()=>delete this.gameOptions)
        }
        setGameOptions(e) {
            return this.gameOptions = e,
            this
        }
        randomizeName() {
            this.defaultName = new r.default(i.Dictionary.HumanName,n.default.Full).getString(),
            this.inputName.setDefault(()=>this.defaultName),
            this.inputName.clear()
        }
        randomize() {
            this.hairstyleList.select(I.default.getRandom(a.HairStyle)),
            this.swatchesHair.select(I.default.getRandom(a.HairColor)),
            this.swatchesSkin.select(I.default.getRandom(a.SkinColor)),
            this.hairstyleList.update(),
            this.elementCharacterPreview.update()
        }
        onShow() {
            this.startButton.setText(this.gameOptions && void 0 !== this.gameOptions.multiplayerServerToJoin ? o.default.MenuCharacterCreationButtonJoinGame : o.default.MenuCharacterCreationButtonStartGame),
            this.hairstyleList.refreshChoices(),
            this.swatchesHair.refreshChoices(),
            this.swatchesSkin.refreshChoices(),
            this.inputName.text = this.defaultName = "",
            this.randomize(),
            this.randomizeName(),
            this.elementCharacterPreview.update(),
            this.gameOptions.character && (this.hairstyleList.select(a.HairStyle[this.gameOptions.character.customization.hairStyle]),
            this.swatchesHair.select(a.HairColor[this.gameOptions.character.customization.hairColor]),
            this.swatchesSkin.select(a.SkinColor[this.gameOptions.character.customization.skinColor]),
            this.inputName.text = this.gameOptions.character.name,
            this.inputName.setDefault(()=>this.gameOptions.character.name),
            this.defaultName = "")
        }
        create() {
            new c.LabelledRow(this.api).classes.add("menu-input-row").setLabel(e=>e.setText(o.default.MenuCharacterCreationLabelName)).append(this.inputName = new p.default(this.api)).append(new l.default(this.api).setText(o.default.MenuCharacterCreationButtonRandomizeName).on(l.ButtonEvent.Activate, this.randomizeName)).appendTo(this.content);
            const e = `#character-import-${Math.random().toString().slice(2)}`;
            new s.Block(this.api).classes.add("menu-character-editor").append(this.createEditorButton("button-import", "label").attributes.set("for", e).setTooltip(e=>e.addHeading(e=>e.setText(o.default.MenuCharacterCreationButtonImportTooltip))), new d.default(this.api,"input").setId(e).attributes.set("type", "file").on("InputChange", async(e,t)=>{
                let i;
                try {
                    i = await v.default .upload(t),
                    this.hairstyleList.select(a.HairStyle[i.customization.hairStyle], !0),
                    this.swatchesHair.select(a.HairColor[i.customization.hairColor], !0),
                    this.swatchesSkin.select(a.SkinColor[i.customization.skinColor], !0)
                } catch (e) {
                    return w.default.warn(e),
                    void this.api.interrupt(o.default.MenuCharacterCreationInterruptImportCharacterFailure, o.default.MenuCharacterCreationInterruptImportCharacterFailureDescription).withInfo()
                } finally {
                    e.element.value = null
                }
                this.inputName.text = i.name,
                this.hairstyleList.update(),
                this.elementCharacterPreview.update()
            }
            ), this.createEditorButton("button-export").setTooltip(e=>e.addHeading(e=>e.setText(o.default.MenuCharacterCreationButtonExportTooltip))).on(l.ButtonEvent.Activate, ()=>{
                v.default.download(`${this.inputName.text}.json`, {
                    name: this.inputName.text,
                    customization: {
                        hairStyle: this.customization.hairStyle,
                        hairColor: this.customization.hairColor,
                        skinColor: this.customization.skinColor
                    }
                })
            }
            ), this.createEditorButton("button-rotate-left").setTooltip(e=>e.addHeading(e=>e.setText(o.default.MenuCharacterCreationButtonRotateLeftTooltip))).on(l.ButtonEvent.Activate, ()=>{
                this.rotate(-1)
            }
            ), this.createEditorButton("button-rotate-right").setTooltip(e=>e.addHeading(e=>e.setText(o.default.MenuCharacterCreationButtonRotateRightTooltip))).on(l.ButtonEvent.Activate, ()=>{
                this.rotate(1)
            }
            ), this.createEditorButton("button-random").setTooltip(e=>e.addHeading(e=>e.setText(o.default.MenuCharacterCreationButtonRandomizeTooltip))).on(l.ButtonEvent.Activate, this.randomize), this.elementCharacterPreview = new y.default(this.api,this.customization), new m.Heading(this.api).setText(o.default.MenuCharacterCreationHeadingHairStyle), this.hairstyleList = new g.HairstyleList(this.api,this.customization,this.elementCharacterPreview.getFilters()).on(u.ChoiceListEvent.Choose, (e,t)=>{
                this.customization.hairStyle = a.HairStyle[t.hairstyle],
                this.elementCharacterPreview.update()
            }
            ), new m.Heading(this.api).setText(o.default.MenuCharacterCreationHeadingSkinTone), this.swatchesSkin = new f.SwatchList(this.api,S.skinColorDescriptions).on(u.ChoiceListEvent.Choose, (e,t)=>{
                this.customization.skinColor = a.SkinColor[+(b(S.skinColorDescriptions, t.color) || 0)],
                this.elementCharacterPreview.update()
            }
            ), new m.Heading(this.api).setText(o.default.MenuCharacterCreationHeadingHairColor), this.swatchesHair = new f.SwatchList(this.api,S.hairColorDescriptions).on(u.ChoiceListEvent.Choose, (e,t)=>{
                this.customization.hairColor = a.HairColor[+(b(S.hairColorDescriptions, t.color) || 0)],
                this.elementCharacterPreview.update()
            }
            )).appendTo(this.content),
            this.startButton = new l.default(this.api).on(l.ButtonEvent.Activate, ()=>{
                const e = this.inputName.text
                  , t = this.customization
                  , a = this.gameOptions.character;
                a && a.name === e && k(a.customization, t) || saveDataGlobal.characters.push(this.gameOptions.character = {
                    name: e,
                    customization: t,
                    lastUse: Date.now(),
                    useCount: 0
                }),
                T.startGame(this.gameOptions)
            }
            ).appendTo(this.content)
        }
        createEditorButton(e, t) {
            return new l.default(this.api,t).classes.add("has-icon-before", "button-icon", e)
        }
        rotate(e) {
            this.rotation = (this.rotation + e + 4) % 4,
            this.elementCharacterPreview.rotate(this.rotation),
            this.hairstyleList.rotate(this.rotation)
        }
    }
    __decorate([M.Bound], C.prototype, "randomizeName", null),
    __decorate([M.Bound], C.prototype, "randomize", null),
    __decorate([M.Bound], C.prototype, "onShow", null),
    t.default = C
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/CharacterSelectionMenu", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Button", "newui/component/SortRow", "newui/component/Text", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/screen/screens/menu/menus/character/Character", "newui/screen/screens/menu/menus/character/CharacterButton", "newui/screen/screens/menu/menus/character/CharacterCreationMenu", "newui/util/Misc", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class g extends u.default {
        constructor(e) {
            super(e, l.MenuId.CharacterSelection),
            this.gameOptions = {},
            this.setTitle(e=>e.setText(i.default.MenuCharacterSelectionTitle)),
            this.setDescription(e=>e.setText(i.default.MenuCharacterSelectionDescription)),
            this.on("Show", this.onShow)
        }
        create() {
            this.content.dump(),
            new o.default(this.api).setText(i.default.MenuCharacterSelectionButtonNewCharacter).on(o.ButtonEvent.Activate, h.menuSwitcher(this.getCharacterCreationMenu, e=>e.setGameOptions(this.gameOptions))).appendTo(this.content),
            new d.default(this.api).appendTo(this.content),
            this.characterRows = [],
            this.headingNoCharacters = new s.Heading(this.api).setText(i.default.MenuCharacterSelectionHeadingNoCharacters).appendTo(this.content),
            this.sortRow = new r.default(this.api).setRefreshMethod(()=>({
                sortEnum: p.CharacterSort,
                defaultSort: p.CharacterSort.LastUse,
                initializeOption: (e,[,t])=>e.setText(()=>new n.default(a.Dictionary.CharacterSort,t))
            })).on(r.SortRowEvent.Sort, (e,t,a)=>{
                this.sortCharacters()
            }
            ).appendTo(this.content),
            this.refresh()
        }
        refresh() {
            for (const e of this.characterRows)
                e.remove();
            const e = 0 === saveDataGlobal.characters.length;
            if (this.headingNoCharacters.toggle(e),
            this.sortRow.toggle(!e),
            !e) {
                for (let e = 0; e < saveDataGlobal.characters.length; e++) {
                    const t = e
                      , a = saveDataGlobal.characters[e];
                    this.characterRows.push(new c.default(this.api,a).appendTo(this.content).on(o.ButtonEvent.Activate, e=>{
                        h.startGame(Object.assign({}, this.gameOptions, {
                            character: a
                        }))
                    }
                    ).on(c.CharacterEvent.Customize, h.menuSwitcher(this.getCharacterCreationMenu, e=>e.setGameOptions(Object.assign({}, this.gameOptions, {
                        character: a
                    })))).on(c.CharacterEvent.Delete, async e=>{
                        const a = await this.api.interrupt(()=>n.default .ui(i.default .MenuCharacterSelectionInterruptDeleteCharacter).get(e.character.name)).withConfirmation();
                        a && (saveDataGlobal.characters.splice(t, 1),
                        e.remove(),
                        this.characterRows.splice(this.characterRows.indexOf(e), 1),
                        0 === this.characterRows.length && this.refresh())
                    }
                    ))
                }
                this.sortCharacters()
            }
        }
        onShow() {
            this.wentBackTo() ? delete this.gameOptions.character : this.create()
        }
        sortCharacters() {
            const e = this.sortRow.sort
              , t = this.sortRow.sortDirection;
            this.characterRows.sort((a,i)=>{
                const n = a.character
                  , o = i.character;
                switch (e) {
                case p.CharacterSort.Name:
                    return n.name.localeCompare(o.name) * t;
                case p.CharacterSort.LastUse:
                    return (o.lastUse - n.lastUse) * t;
                case p.CharacterSort.UseCount:
                    return (o.useCount - n.useCount) * t
                }
            }
            );
            for (const e of this.characterRows)
                e.appendTo(this.content)
        }
        getCharacterCreationMenu() {
            return this.characterCreationMenu = this.characterCreationMenu || new m.default(this.api)
        }
    }
    __decorate([y.Bound], g.prototype, "onShow", null),
    __decorate([y.Bound], g.prototype, "getCharacterCreationMenu", null),
    t.default = g
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/data/ISaveDataGlobal", ["require", "exports"], function(e, t) {
    var a, i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Ordered = 0] = "Ordered",
        e[e.Shuffle = 1] = "Shuffle",
        e[e.Dynamic = 2] = "Dynamic"
    }(a = t.MusicPlaylist || (t.MusicPlaylist = {})),
    function(e) {
        e.Default = "default",
        e.LowPower = "low-power",
        e.HighPerformance = "high-performance"
    }(i = t.PowerMode || (t.PowerMode = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/component/HighscoreRow", ["require", "exports", "game/Difficulty", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Block", "newui/component/Component", "newui/component/Text"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class d extends s.Block {
        constructor(e, t) {
            super(e),
            this._place = 0,
            this.classes.add("menu-highscore"),
            this._highscore = t,
            this.headingPlace = new u.Heading(e).classes.add("menu-highscore-place").setText(r.default.ui(o.default.MenuHighscoresHighscoreLabelPlace).addArgs(()=>this.place)).appendTo(this),
            new u.Heading(e).classes.add("menu-highscore-name").setText(r.default.ui(o.default.MenuHighscoresHighscoreTitle).addArgs(()=>this.highscore && this.highscore.characterName || r.default.ui(o.default.MenuHighscoresCharacterNameUnknown)).addArgs(()=>this.highscore && this.highscore.name || "")).appendTo(this),
            this.difficulty = new l.default(e).classes.add("icon-difficulty", "has-icon-before", "icon-center").setTooltip(e=>this.highscore ? e.addHeading(e=>e.setText(r.default.ui(o.default.MenuHighscoresHighscoreLabelDifficulty).addArgs(new r.default(i.Dictionary.Difficulty,this.highscore.difficulty)))) : e).appendTo(this),
            this.deathBy = new u.default(e).classes.add("menu-highscore-deathby").setText(r.default.ui(o.default.MenuHighscoresHighscoreLabelDeathBy).addArgs(()=>this.highscore && this.highscore.message)).appendTo(this),
            new u.default(e).classes.add("menu-highscore-score").setText(r.default.ui(o.default.MenuHighscoresHighscoreLabelScore).addArgs(()=>this.highscore && this.highscore.score)).appendTo(this),
            new u.default(e).classes.add("menu-highscore-turns").setText(r.default.ui(o.default.MenuHighscoresHighscoreLabelTurns).addArgs(()=>this.highscore && this.highscore.turns)).appendTo(this),
            new u.default(e).classes.add("menu-highscore-date").setText(r.default.ui(o.default.MenuHighscoresHighscoreLabelDate).addArgs(()=>this.highscore && new Date(this.highscore.date).toLocaleString())).appendTo(this),
            this.highscore = t
        }
        get highscore() {
            return this._highscore
        }
        set highscore(e) {
            this._highscore = e,
            this.api.refreshTranslations(this),
            this.difficulty.data.set("difficulty", a.Difficulty[e ? e.difficulty : a.Difficulty.Casual]);
            const t = e && ("string" == typeof e.message ? e.message : r.default.deserialize(e.message).getString())
              , i = t === r.default.message(n.default.ReturnedToCivilization).getString();
            this.deathBy.classes.toggle(i, "menu-highscore-win")
        }
        get place() {
            return this._place
        }
        set place(e) {
            this._place = e,
            this.headingPlace.refresh()
        }
    }
    t.HighscoreRow = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/highscores/IHighscoresMenu", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Score = 0] = "Score",
        e[e.Recency = 1] = "Recency",
        e[e.SaveName = 2] = "SaveName"
    }(a = t.HighscoreSort || (t.HighscoreSort = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/HighscoresMenu", ["require", "exports", "game/Difficulty", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Component", "newui/component/Dropdown", "newui/component/SortRow", "newui/screen/screens/menu/component/HighscoreRow", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/highscores/IHighscoresMenu", "utilities/enum/Enums", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const y = "all";
    class g extends p.default {
        constructor(e) {
            super(e, d.MenuId.Highscores),
            this.setTitle(e=>e.setText(n.default.MenuHighscoresTitle)),
            this.setDescription(e=>e.setText(n.default.MenuHighscoresDescription)),
            this.create(),
            this.on("Show", this.refresh)
        }
        create() {
            this.content.append([this.filterRow = new s.default(this.api).setRefreshMethod(()=>({
                defaultOption: a.Difficulty.Hardcore,
                options: m.default.values(a.Difficulty).map(e=>[e, t=>t.setText(new o.default(i.Dictionary.Difficulty,e))]).include([[y, e=>e.setText(n.default.MenuHighscoresDifficultyFilterAll)]])
            })).on(s.DropdownEvent.Selection, (e,t,a)=>{
                a || this.filter(t)
            }
            ), this.sortRow = new l.default(this.api).setRefreshMethod(()=>({
                sortEnum: c.HighscoreSort,
                defaultSort: c.HighscoreSort.Score,
                initializeOption: (e,[,t])=>e.setText(new o.default(i.Dictionary.HighscoreSort,t))
            })).on(l.SortRowEvent.Sort, async(e,t,a)=>{
                this.sort(t, a)
            }
            ), this.highscoresWrapper = new r.default(this.api)]),
            this.refresh()
        }
        refresh() {
            this.highscoresWrapper.dump(),
            this.highscores = [];
            for (const e of saveDataGlobal.gameHighscores)
                this.highscores.push(new u.HighscoreRow(this.api,e));
            this.sort(this.sortRow.sort, this.sortRow.sortDirection),
            this.filter(this.filterRow.selection),
            this.api.refreshTranslations(this.highscoresWrapper)
        }
        sort(e, t) {
            this.highscoresWrapper.append(this.highscores.sort((a,i)=>{
                switch (e) {
                case c.HighscoreSort.SaveName:
                    return a.highscore.name.localeCompare(i.highscore.name) * t;
                case c.HighscoreSort.Recency:
                    return (i.highscore.date - a.highscore.date) * t;
                case c.HighscoreSort.Score:
                    return (i.highscore.score - a.highscore.score) * t
                }
            }
            ))
        }
        filter(e) {
            for (const t of this.highscores)
                t.toggle(e === y || t.highscore.difficulty === e);
            let t = [...this.highscores];
            e !== y && (t = t.filter(t=>t.highscore.difficulty === e)),
            t.sort((e,t)=>t.highscore.score - e.highscore.score).forEach((e,t)=>{
                e.place = t + 1
            }
            )
        }
    }
    __decorate([h.Bound], g.prototype, "refresh", null),
    t.default = g
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/util/IInterrupt", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Info = 0] = "Info",
        e[e.Confirm = 1] = "Confirm",
        e[e.Choice = 2] = "Choice",
        e[e.Input = 3] = "Input",
        e[e.Loading = 4] = "Loading",
        e[e.Menu = 5] = "Menu"
    }(a = t.InterruptType || (t.InterruptType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/InterruptMenu", ["require", "exports", "language/Dictionaries", "language/dictionary/InterruptChoice", "language/segment/LinkSegment", "language/Translation", "newui/component/BlockRow", "newui/component/Button", "newui/component/Component", "newui/component/Input", "newui/component/Text", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/util/IInterrupt", "utilities/Arrays", "utilities/Async"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    var g;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Resolve = "Resolve"
    }(g = t.InterruptMenuEvent || (t.InterruptMenuEvent = {}));
    class f extends c.default {
        constructor(e) {
            super(e, p.MenuId.Interrupt),
            this.settingOptionsQueue = [],
            this.isResolved = !1,
            this.classes.add("menu-clearbg"),
            this.content.append(this.interruptTitle = new d.Heading(this.api).classes.add("interrupt-title"), this.interruptDescription = new d.Paragraph(this.api).setSegments(n.default), this.input = new u.default(this.api), this.loadingElement = new l.default(this.api).classes.add("loading").append(h.default.range(9).map(e=>new l.default(this.api).classes.add(`block-${e}`))), this.choiceRow = new r.BlockRow(this.api).classes.add("interrupt-choices")),
            this.on(c.MenuEvent.CancelBind, (e,t=!0)=>{
                t && this.cancelInterrupt()
            }
            ),
            this.on(c.MenuEvent.EnterBind, ()=>{
                if (this.isResolved)
                    return;
                this.api.playActivateSound();
                const e = this.choiceRow.getChildren();
                for (const t of e)
                    +t.attributes.get("choice-id") === i.default.Yes && this.choose(i.default.Yes),
                    +t.attributes.get("choice-id") === i.default.Ok && this.choose(i.default.Ok)
            }
            ),
            this.on("Hide", ()=>{
                this.isResolved = !0,
                this.emit(g.Resolve)
            }
            )
        }
        get type() {
            return this._type
        }
        async setOptions(e) {
            if (this.isResolved = !1,
            this.settingOptionsQueue.push(e),
            !(this.settingOptionsQueue.length > 1))
                for (; this.settingOptionsQueue[0]; ) {
                    if (e = this.settingOptionsQueue[0],
                    this.choiceRow.dump(),
                    this._type = e.type,
                    this.canCancel = !1,
                    void 0 === this._type && (e.choices ? this._type = m.InterruptType.Choice : e.input ? this._type = m.InterruptType.Input : "number" == typeof e.menuId ? this._type = m.InterruptType.Menu : this._type = m.InterruptType.Info),
                    this._type === m.InterruptType.Menu)
                        return;
                    this.setText(e.title, e.description);
                    let t = [i.default.Ok];
                    switch (this._type) {
                    case m.InterruptType.Input:
                        e.input && (this.input.schedule(e.input),
                        e.canCancel && (this.canCancel = !0,
                        t.push(i.default.Cancel),
                        "function" == typeof e.canCancel && this.until([c.MenuEvent.CancelBind, "Hide"]).bind(this, c.MenuEvent.CancelBind, e.canCancel)));
                        break;
                    case m.InterruptType.Confirm:
                        this.canCancel = !0,
                        t = [i.default.Yes, i.default.No];
                        break;
                    case m.InterruptType.Loading:
                        t = e.canCancel ? [i.default.Cancel] : [],
                        e.canCancel && (this.canCancel = !0,
                        "function" == typeof e.canCancel && this.until([c.MenuEvent.CancelBind, "Hide"]).bind(this, c.MenuEvent.CancelBind, e.canCancel));
                        break;
                    default:
                        e.choices && (t = e.choices,
                        this.canCancel = e.choices.includes(i.default.Cancel))
                    }
                    t && this.choiceRow.append(t.map(e=>new s.default(this.api).attributes.set("choice-id", `${e}`).setText(new o.default(a.Dictionary.InterruptChoice,e)).on(s.ButtonEvent.Activate, ()=>{
                        this.choose(e)
                    }
                    ))),
                    this.input.toggle(this._type === m.InterruptType.Input),
                    this._type === m.InterruptType.Input && y.sleep(200).then(()=>{
                        this.input.focus()
                    }
                    ),
                    this.loadingElement.toggle(this._type === m.InterruptType.Loading),
                    e.specialType ? this.dataset.specialType = e.specialType : delete this.dataset.specialType,
                    this.settingOptionsQueue.shift()
                }
        }
        setText(e, t) {
            this.interruptTitle.setText(e),
            this.interruptDescription.setText(t)
        }
        async cancelInterrupt() {
            switch (this._type) {
            case m.InterruptType.Loading:
            case m.InterruptType.Input:
                this.choose(i.default.Cancel);
                break;
            case m.InterruptType.Confirm:
                this.choose(i.default.No);
                break;
            default:
                this.choiceRow.getChildren().any(e=>e.attributes.get("choice-id") === `${i.default.Cancel}`) ? this.choose(i.default.Cancel) : this.choiceRow.getChildren().any(e=>e.attributes.get("choice-id") === `${i.default.No}`) && this.choose(i.default.No)
            }
        }
        async choose(e) {
            if (e === i.default.Cancel && this.canCancel) {
                this.emit(c.MenuEvent.CancelBind, !1);
                const e = this.api.getVisibleScreen();
                e && "function" == typeof e.backOneMenu && e.backOneMenu()
            }
            this.isResolved = !0,
            await this.emitAsync(g.Resolve,e)
        }
        async waitFor() {
            return new Promise(e=>{
                this.isResolved ? e() : this.once(g.Resolve, (t,a)=>{
                    switch (this._type) {
                    case m.InterruptType.Input:
                        return void (a === i.default.Cancel ? e() : e(this.input.text));
                    case m.InterruptType.Confirm:
                        return void e(a === i.default.Yes);
                    case m.InterruptType.Info:
                        return void e();
                    default:
                        return void e(a)
                    }
                }
                )
            }
            )
        }
    }
    t.default = f
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/JoinServerMenu", ["require", "exports", "language/dictionary/UiTranslation", "newui/component/Button", "newui/component/Input", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/util/Misc", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class d extends r.default {
        constructor(e) {
            super(e, o.MenuId.JoinServer),
            this.setTitle(e=>e.setText(a.default.MenuJoinServerTitle)),
            this.setDescription(e=>e.setText(a.default.MenuJoinServerDescription)),
            this.serverInput = new n.default(this.api).setPlaceholder(a.default.MenuJoinServerInputPlaceholder).classes.add("usefixer").on(n.InputEvent.Enter, this.onInputEnter).on(n.InputEvent.Change, this.onInputChange).appendTo(this.content),
            new s.default(this.api).appendTo(this),
            this.joinButton = new i.default(this.api).setText(a.default.MenuJoinServerNext).on(i.ButtonEvent.Activate, ()=>{
                this.onInputEnter(this.serverInput)
            }
            ).setDisabled(!0).appendTo(this.content);
            const t = saveDataGlobal.lastServerJoined;
            void 0 !== t && t.length > 0 && (this.serverInput.text = t,
            this.serverInput.setDefault(()=>this.serverInput.text)),
            this.on("Show", this.onShow)
        }
        onShow() {
            this.wentBackTo() || this.serverInput.clear()
        }
        onInputEnter(e) {
            "" !== e.text && (saveDataGlobal.lastServerJoined = e.text,
            l.switchToJoinServer(this.getServerToJoin()))
        }
        onInputChange(e, t) {
            this.joinButton.setDisabled(0 === t.length)
        }
        getServerToJoin() {
            return multiplayer.convertGameCodeToServerInfo(this.serverInput.text.trim())
        }
    }
    __decorate([u.Bound], d.prototype, "onShow", null),
    __decorate([u.Bound], d.prototype, "onInputEnter", null),
    __decorate([u.Bound], d.prototype, "onInputChange", null),
    t.default = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/newgame/customgameoptions/CustomGameOptionsTab", ["require", "exports", "newui/screen/screens/menu/component/Menu", "utilities/Objects"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.Tab {
        constructor(e, t) {
            super(e, t),
            this.refreshables = []
        }
        addRefreshables(...e) {
            return this.refreshables.push(...e),
            this
        }
    }
    var o;
    __decorate([i.Bound], n.prototype, "addRefreshables", null),
    t.default = n,
    function(e) {
        e[e.General = 0] = "General",
        e[e.Time = 1] = "Time",
        e[e.Reputation = 2] = "Reputation",
        e[e.Stats = 3] = "Stats",
        e[e.StatusEffects = 4] = "StatusEffects",
        e[e.Skills = 5] = "Skills",
        e[e.Inventory = 6] = "Inventory"
    }(o = t.CustomGameOptionsSection || (t.CustomGameOptionsSection = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/newgame/customgameoptions/TabGeneral", ["require", "exports", "language/dictionary/UiTranslation", "newui/component/CheckButton", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/newgame/customgameoptions/CustomGameOptionsTab"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends o.default {
        constructor(e, t) {
            super(e, o.CustomGameOptionsSection.General),
            this.setText(a.default.MenuCustomGameOptionsHeadingGeneral),
            new n.MenuSection(e).setTitle(e=>e.setText(a.default.MenuCustomGameOptionsHeadingGeneral)).addContent(new i.CheckButton(this.api).setText(a.default.MenuCustomGameOptionsPeaceful).addDescription(e=>e.setText(a.default.MenuCustomGameOptionsPeacefulDescription)).setRefreshMethod(()=>t().peaceful).on(i.CheckButtonEvent.Change, (e,a)=>{
                t().peaceful = a
            }
            ).schedule(this.addRefreshables)).addContent(new i.CheckButton(this.api).setText(a.default.MenuCustomGameOptionsRespawnOnDeath).addDescription(e=>e.setText(a.default.MenuCustomGameOptionsRespawnOnDeathDescription)).setRefreshMethod(()=>t().respawn).on(i.CheckButtonEvent.Change, (e,a)=>{
                t().respawn = a
            }
            ).schedule(this.addRefreshables)).schedule(this.setSection)
        }
    }
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/newgame/customgameoptions/TabInventory", ["require", "exports", "language/dictionary/UiTranslation", "newui/component/CheckButton", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/newgame/customgameoptions/CustomGameOptionsTab"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends o.default {
        constructor(e, t) {
            super(e, o.CustomGameOptionsSection.Inventory),
            this.setText(a.default.MenuCustomGameOptionsHeadingInventory),
            new n.MenuSection(e).setTitle(e=>e.setText(a.default.MenuCustomGameOptionsHeadingInventory)).addContent(new i.CheckButton(this.api).setText(a.default.MenuCustomGameOptionsRandomItems).addDescription(e=>e.setText(a.default.MenuCustomGameOptionsRandomItemsDescription)).setRefreshMethod(()=>!0 === t().player.initialItems).on(i.CheckButtonEvent.Change, (e,a)=>{
                t().player.initialItems = a
            }
            ).schedule(this.addRefreshables)).schedule(this.setSection)
        }
    }
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/newgame/customgameoptions/Multiplier", ["require", "exports"], function(e, t) {
    function a(e) {
        return 0 === e ? -4 : e >= 1 ? e : -1 * ((e = 1 / e) - 2)
    }
    function i(e) {
        return -4 === e ? 0 : e > 0 ? e : 1 / (e = -1 * e + 2)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.convertRateModifierActualToRange = a,
    t.convertRateModifierRangeToActual = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/newgame/customgameoptions/TabReputation", ["require", "exports", "language/Dictionaries", "language/dictionary/Misc", "language/dictionary/UiTranslation", "language/Translation", "newui/component/CheckButton", "newui/component/IComponent", "newui/component/RangeRow", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/newgame/customgameoptions/CustomGameOptionsTab", "newui/screen/screens/menu/menus/newgame/customgameoptions/Multiplier"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class c extends d.default {
        constructor(e, t) {
            super(e, d.CustomGameOptionsSection.Reputation),
            this.setText(n.default.MenuCustomGameOptionsHeadingReputation),
            new u.MenuSection(e).setTitle(e=>e.setText(n.default.MenuCustomGameOptionsHeadingReputation)).addContent(new l.RangeRow(this.api).setLabel(e=>e.setText(n.default.MenuCustomGameOptionsBenignityInitial)).editRange(e=>e.setStep(1e3).setMin(0).setMax(64e3).setRefreshMethod(()=>p.convertRateModifierActualToRange(t().player.reputation.initialBenignity)).schedule(this.addRefreshables).on(r.CheckButtonEvent.Change, (e,a)=>t().player.reputation.initialBenignity = a)).setDisplayValue(e=>new o.default(a.Dictionary.Misc,i.MiscTranslation.Thing).get(e))).addContent(new l.RangeRow(this.api).setLabel(e=>e.setText(n.default.MenuCustomGameOptionsBenignityMultiplier)).editRange(e=>e.setStep(1).setMin(-4).setMax(4).setRefreshMethod(()=>p.convertRateModifierActualToRange(t().player.reputation.benignityMultiplier)).schedule(this.addRefreshables).on(r.CheckButtonEvent.Change, (e,a)=>t().player.reputation.benignityMultiplier = p.convertRateModifierRangeToActual(a))).setDisplayValue(e=>new o.default(a.Dictionary.Misc,i.MiscTranslation.Thing).get(+p.convertRateModifierRangeToActual(e).toFixed(2))).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).addText(e=>e.setText(n.default.MenuCustomGameOptionsBenignityMultiplierTooltip)))).addContent(new l.RangeRow(this.api).setLabel(e=>e.setText(n.default.MenuCustomGameOptionsMalignityInitial)).editRange(e=>e.setStep(1e3).setMin(0).setMax(64e3).setRefreshMethod(()=>p.convertRateModifierActualToRange(t().player.reputation.initialMalignity)).schedule(this.addRefreshables).on(r.CheckButtonEvent.Change, (e,a)=>t().player.reputation.initialMalignity = a)).setDisplayValue(e=>new o.default(a.Dictionary.Misc,i.MiscTranslation.Thing).get(e))).addContent(new l.RangeRow(this.api).setLabel(e=>e.setText(n.default.MenuCustomGameOptionsMalignityMultiplier)).editRange(e=>e.setStep(1).setMin(-4).setMax(4).setRefreshMethod(()=>p.convertRateModifierActualToRange(t().player.reputation.malignityMultiplier)).schedule(this.addRefreshables).on(r.CheckButtonEvent.Change, (e,a)=>t().player.reputation.malignityMultiplier = p.convertRateModifierRangeToActual(a))).setDisplayValue(e=>new o.default(a.Dictionary.Misc,i.MiscTranslation.Thing).get(+p.convertRateModifierRangeToActual(e).toFixed(2))).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).addText(e=>e.setText(n.default.MenuCustomGameOptionsMalignityMultiplierTooltip)))).schedule(this.setSection)
        }
    }
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/newgame/customgameoptions/TabSkills", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/Misc", "language/dictionary/UiTranslation", "language/Translation", "newui/component/BlockRow", "newui/component/Button", "newui/component/CheckButton", "newui/component/Component", "newui/component/Dropdown", "newui/component/IComponent", "newui/component/RangeInput", "newui/component/RangeRow", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/newgame/customgameoptions/CustomGameOptionsTab", "newui/screen/screens/menu/menus/newgame/customgameoptions/Multiplier", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class M extends f.default {
        constructor(e, t) {
            super(e, f.CustomGameOptionsSection.Skills),
            this.options = t,
            this.skillComponentMap = new Map,
            this.setText(o.default.MenuCustomGameOptionsHeadingSkills),
            new g.MenuSection(e).setTitle(e=>e.setText(o.default.MenuCustomGameOptionsHeadingSkills)).addContent(new u.CheckButton(this.api).setText(o.default.MenuCustomGameOptionsSkillsGenerateRandom).addDescription(e=>e.setText(o.default.MenuCustomGameOptionsSkillsGenerateRandomDescription)).setRefreshMethod(()=>t().player.randomSkills).on(u.CheckButtonEvent.Change, (e,a)=>{
                t().player.randomSkills = a
            }
            )).addContent(this.skillsWrapper = new d.default(this.api)).addContent(new s.BlockRow(this.api).classes.add("prefer-not-last").append(this.addSkillConfigDropdown = new p.default(this.api).setRefreshMethod(()=>({
                defaultOption: "none",
                options: [["none", e=>e.setText(o.default.MenuCustomGameOptionsSkillNone)]].values().include(S.default.values(a.SkillType).collect(I.default.toArray).map(e=>v.tuple(e, new r.default(i.Dictionary.Skill,e).inContext(3))).sort(([,e],[,t])=>e.getString().localeCompare(t.getString())).map(([e])=>v.tuple(e, t=>t.setText(new r.default(i.Dictionary.Skill,e).inContext(3)))))
            }))).append(new l.default(this.api).setText(o.default.MenuCustomGameOptionsSkillConfigure).on(l.ButtonEvent.Activate, this.addSkill))).schedule(this.setSection)
        }
        addSkill() {
            const e = this.addSkillConfigDropdown.selection;
            if ("none" === e || this.skillComponentMap.get(e))
                return;
            const t = this.options().player.skills
              , a = t.get(e) || {
                gainMultiplier: 1
            };
            t.set(e, a || {
                gainMultiplier: 1
            }),
            this.skillComponentMap.set(e, new k(this.api,e,a).on(b.Delete, a=>{
                this.skillComponentMap.delete(e),
                t.delete(e),
                a.remove()
            }
            ).schedule(1, e=>e.element.closest(".scrollable").scrollTop += e.element.offsetHeight).schedule(this.addRefreshables).appendTo(this.skillsWrapper)),
            this.sortSkills()
        }
        sortSkills() {
            this.skillComponentMap.entries().map(([e,t])=>v.tuple(new r.default(i.Dictionary.Skill,e).getString(), t)).collect(I.default.toArray).sort(([e],[t])=>e.localeCompare(t)).forEach(([,e])=>e.appendTo(this.skillsWrapper))
        }
    }
    var b;
    __decorate([w.Bound], M.prototype, "addSkill", null),
    t.default = M,
    function(e) {
        e.Delete = "Delete"
    }(b || (b = {}));
    class k extends d.default {
        constructor(e, t, a) {
            super(e),
            this.classes.add("skill-configuration", "menu-block"),
            new y.Heading(e).setText(new r.default(i.Dictionary.Skill,t).inContext(3)).appendTo(this),
            new l.default(e).classes.add("button-delete", "has-icon-before", "button-icon").on(l.ButtonEvent.Activate, ()=>this.emit(b.Delete)).setTooltip(e=>e.addHeading(e=>e.setText(o.default.MenuCharacterSelectionCharacterButtonDeleteTooltip))).appendTo(this),
            this.rangeInitial = new h.RangeRow(e).classes.add("skill-initial", "menu-clearbg").setLabel(e=>e.setText(o.default.MenuCustomGameOptionsSkillInitial)).editRange(e=>e.setMin(0).setMax(100).setRefreshMethod(()=>a.initial || 0).on(m.RangeInputEvent.Change, (e,t)=>a.initial = t)).setDisplayValue(r.default.ui(o.default.MenuSharedValuePercentage).get).appendTo(this),
            this.rangeMultiplier = new h.RangeRow(e).classes.add("skill-multiplier", "menu-clearbg").setLabel(e=>e.setText(o.default.MenuCustomGameOptionsSkillMultiplier)).editRange(e=>e.setMin(-4).setMax(4).setRefreshMethod(()=>T.convertRateModifierActualToRange(a.gainMultiplier || 1)).on(m.RangeInputEvent.Change, (e,t)=>a.gainMultiplier = T.convertRateModifierRangeToActual(t))).setDisplayValue(e=>new r.default(i.Dictionary.Misc,n.MiscTranslation.Thing).get(+T.convertRateModifierRangeToActual(e).toFixed(2))).setTooltip(e=>e.setLocation(c.TooltipLocation.CenterRight).addText(e=>e.setText(o.default.MenuCustomGameOptionsSkillMultiplierTooltip))).appendTo(this)
        }
        refresh() {
            return this.rangeInitial.refresh(),
            this.rangeMultiplier.refresh(),
            this
        }
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/CheckButtonRange", ["require", "exports", "language/Translation", "newui/component/CheckButton", "newui/component/Component", "newui/component/RangeInput", "newui/component/RangeInputValueDisplay", "utilities/Objects"], function(e, t, a, i, n, o, r, s) {
    var l;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Change = "Change2"
    }(l = t.CheckButtonRangeEvent || (t.CheckButtonRangeEvent = {}));
    class u extends i.CheckButton {
        constructor(e, t) {
            super(e),
            this.classes.add("check-button-range"),
            this.valueWhenDisabled = t,
            this.rangeWrapper = new n.default(this.api).classes.add("check-button-range-range-wrapper").appendTo(this),
            this.rangeInput = new o.RangeInput(this.api).classes.add("uses-pointer-events").setRefreshMethod(()=>100 * saveDataGlobal.options.volumeMusic).on(o.RangeInputEvent.Change, this.change).appendTo(this.rangeWrapper),
            this.on(i.CheckButtonEvent.Change, this.change)
        }
        setValueWhenDisabled(e) {
            return this.valueWhenDisabled = e,
            this
        }
        editRange(e) {
            return e(this.rangeInput),
            this
        }
        setDisplayValue(e) {
            return e ? (this.rangeInputValueDisplay = this.rangeInputValueDisplay || new r.RangeInputValueDisplay(this.api).setText(()=>!0 === e ? [{
                content: `${this.rangeInput.value}`
            }] : "number" == typeof e ? a.default.ui(e).addArgs(this.rangeInput.value, this.checked) : e(this.rangeInput.value, this.checked)).appendTo(this.rangeWrapper),
            this.updateDisplay(),
            this) : (this.rangeInputValueDisplay && (this.rangeInputValueDisplay.remove(),
            this.rangeInputValueDisplay = void 0),
            this)
        }
        refresh() {
            return super.refresh(),
            this.rangeInput.refresh(),
            this.rangeInputValueDisplay && this.rangeInputValueDisplay.refresh(),
            this
        }
        change() {
            this.emit(l.Change, this.checked ? this.rangeInput.value : this.valueWhenDisabled),
            this.updateDisplay()
        }
        updateDisplay() {
            this.rangeInputValueDisplay && this.rangeInputValueDisplay.refresh()
        }
    }
    __decorate([Override], u.prototype, "refresh", null),
    __decorate([s.Bound], u.prototype, "change", null),
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/newgame/customgameoptions/TabStats", ["require", "exports", "entity/IStats", "language/Dictionaries", "language/dictionary/Misc", "language/dictionary/UiTranslation", "language/Translation", "newui/component/CheckButtonRange", "newui/component/IComponent", "newui/component/RangeInput", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/newgame/customgameoptions/CustomGameOptionsTab", "newui/screen/screens/menu/menus/newgame/customgameoptions/Multiplier"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class h extends c.default {
        constructor(e, t) {
            function h(e, a=!1) {
                let i = t().player.stats.get(e);
                return a && !i && t().player.stats.set(e, i = {
                    changeTimerMultiplier: 1
                }),
                i || {}
            }
            super(e, c.CustomGameOptionsSection.Stats),
            this.setText(o.default.MenuCustomGameOptionsHeadingStats),
            new p.MenuSection(e).setTitle(e=>e.setText(o.default.MenuCustomGameOptionsHeadingStats)).addContent(...[a.Stat.Strength, a.Stat.Health, a.Stat.Stamina, a.Stat.Hunger, a.Stat.Thirst].map(e=>[new d.Heading(this.api).setText(new r.default (i.Dictionary.Stat, e).inContext(3)).setTooltip(e!==a.Stat.Strength?void 0:e=>e.setLocation(l.TooltipLocation.CenterRight).addText(e=>e.setText(o.default .MenuCustomGameOptionsStatStrengthTooltip))), new s.default (this.api).setText(o.default .MenuCustomGameOptionsStatStarting).setRefreshMethod(()=>void 0!==h(e).initialValue).editRange(t=>t.setMin(5).setMax(100).setRefreshMethod(()=>h(e).initialValue||100).schedule(this.addRefreshables).on(u.RangeInputEvent.Change, (t, a)=>h(e, !0).initialValue=a)).on(s.CheckButtonRangeEvent.Change, (t, a)=>h(e, !0).initialValue=a).setDisplayValue(e===a.Stat.Strength?o.default .MenuCustomGameOptionsStatMaxDisplay:o.default .MenuCustomGameOptionsStatStartingDisplay), e===a.Stat.Health||e===a.Stat.Strength?void 0:new s.default (this.api).setText(o.default .MenuCustomGameOptionsStatMax).setRefreshMethod(()=>void 0!==h(e).maxValue).editRange(t=>t.setMin(5).setMax(100).setRefreshMethod(()=>h(e).maxValue||y[e]).schedule(this.addRefreshables).on(u.RangeInputEvent.Change, (t, a)=>h(e, !0).maxValue=a)).on(s.CheckButtonRangeEvent.Change, (t, a)=>h(e, !0).maxValue=a).setDisplayValue(o.default .MenuCustomGameOptionsStatMaxDisplay), e===a.Stat.Strength?void 0:new s.default (this.api).setChecked(!0).setText(o.default .MenuCustomGameOptionsStatMultiplier).editRange(t=>t.setMin(-2).setMax(5).setRefreshMethod(()=>m.convertRateModifierActualToRange(h(e).changeTimerMultiplier||2)).schedule(this.addRefreshables).on(u.RangeInputEvent.Change, (t, a)=>h(e, !0).changeTimerMultiplier=m.convertRateModifierRangeToActual(a))).setDisplayValue((e, t)=>t?new r.default (i.Dictionary.Misc, n.MiscTranslation.Thing).addArgs(+m.convertRateModifierRangeToActual(e-1).toFixed(2)):r.default .ui(o.default .MenuCustomGameOptionsStatNoChange)).setTooltip(t=>t.setLocation(l.TooltipLocation.CenterRight).addText(t=>t.setText(r.default .ui(e===a.Stat.Stamina||e===a.Stat.Health?o.default .MenuCustomGameOptionsStatRegenerationMultiplierTooltip:o.default .MenuCustomGameOptionsStatMultiplierTooltip).addArgs(new r.default (i.Dictionary.Stat, e)))))])).schedule(this.setSection)
        }
    }
    t.default = h;
    const y = {
        [a.Stat.Health]: 50,
        [a.Stat.Stamina]: 75,
        [a.Stat.Hunger]: 25,
        [a.Stat.Thirst]: 25
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/newgame/customgameoptions/TabStatusEffects", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/Misc", "language/dictionary/UiTranslation", "language/Translation", "newui/component/CheckButton", "newui/component/IComponent", "newui/component/RangeInput", "newui/component/RangeRow", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/newgame/customgameoptions/CustomGameOptionsTab", "newui/screen/screens/menu/menus/newgame/customgameoptions/Multiplier"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class y extends m.default {
        constructor(e, t) {
            function y(e, a=!1) {
                let i = t().player.statusEffects.get(e);
                return a && !i && t().player.statusEffects.set(e, i = {
                    startWith: !1,
                    untreatable: !1,
                    passChanceMultiplier: 1,
                    effectMultiplier: 1,
                    effectRateMultiplier: 1
                }),
                i || {}
            }
            super(e, m.CustomGameOptionsSection.StatusEffects),
            this.setText(o.default.MenuCustomGameOptionsHeadingStatusEffects),
            new c.MenuSection(e).setTitle(e=>e.setText(o.default.MenuCustomGameOptionsHeadingStatusEffects)).addContent(...[a.StatusType.Bleeding, a.StatusType.Poisoned, a.StatusType.Burned].map(e=>[new p.Heading(this.api).setText(new r.default (i.Dictionary.StatusEffect, e).inContext(3)), new s.CheckButton(this.api).setText(r.default .ui(o.default .MenuCustomGameOptionsStatusEffectStartWith).addArgs(new r.default (i.Dictionary.StatusEffect, e).inContext(3))).setRefreshMethod(()=>!0===y(e).startWith).on(s.CheckButtonEvent.Change, (t, a)=>{y(e, !0).startWith=a}), new s.CheckButton(this.api).setText(o.default .MenuCustomGameOptionsStatusEffectUntreatable).setRefreshMethod(()=>!0===y(e).untreatable).on(s.CheckButtonEvent.Change, (t, a)=>{y(e, !0).untreatable=a}).setTooltip(e=>e.setLocation(l.TooltipLocation.CenterRight).addText(e=>e.setText(o.default .MenuCustomGameOptionsStatusEffectUntreatableTooltip))), new d.RangeRow(this.api).setLabel(e=>e.setText(o.default .MenuCustomGameOptionsStatusEffectPassChanceMultiplier)).editRange(t=>t.setMin(-4).setMax(4).setRefreshMethod(()=>h.convertRateModifierActualToRange(y(e).passChanceMultiplier||1)).schedule(this.addRefreshables).on(u.RangeInputEvent.Change, (t, a)=>y(e, !0).passChanceMultiplier=h.convertRateModifierRangeToActual(a))).setDisplayValue(e=>new r.default (i.Dictionary.Misc, n.MiscTranslation.Thing).get(+h.convertRateModifierRangeToActual(e).toFixed(2))).setTooltip(t=>t.setLocation(l.TooltipLocation.CenterRight).addText(t=>t.setText(r.default .ui(o.default .MenuCustomGameOptionsStatusEffectPassChanceMultiplierTooltip).addArgs(new r.default (i.Dictionary.StatusEffect, e)))))])).schedule(this.setSection)
        }
    }
    t.default = y
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/newgame/customgameoptions/TabTime", ["require", "exports", "game/Difficulty", "game/TimeManager", "language/Dictionaries", "language/dictionary/Misc", "language/dictionary/UiTranslation", "language/Translation", "newui/component/CheckButton", "newui/component/IComponent", "newui/component/RangeInput", "newui/component/RangeRow", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/newgame/customgameoptions/CustomGameOptionsTab"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class h extends m.default {
        constructor(e, t) {
            let h, y, g, f;
            super(e, m.CustomGameOptionsSection.Time),
            this.setText(r.default.MenuCustomGameOptionsHeadingTime);
            const T = new i.default(0)
              , S = t().time.dayLength = T.dayLength
              , I = t().time.dayPercent = T.dayPercent;
            new c.MenuSection(e).setTitle(e=>e.setText(r.default.MenuCustomGameOptionsHeadingTime)).addContent(new l.CheckButton(this.api).setText(r.default.MenuCustomGameOptionsEternalNight).addDescription(e=>e.setText(r.default.MenuCustomGameOptionsEternalNightDescription)).setRefreshMethod(()=>t().time.frozen && t().time.initial === a.TIME_ETERNAL_NIGHT).on(l.CheckButtonEvent.Change, (e,i)=>{
                t().time.frozen = i,
                i ? (t().time.initial = a.TIME_ETERNAL_NIGHT,
                delete t().time.dayPercent,
                delete t().time.dayLength) : (t().time.dayLength = g.value,
                t().time.dayPercent = f.value),
                h.refresh().setDisabled(i),
                y.refresh().setDisabled(i),
                g.setDisabled(i),
                f.setDisabled(i)
            }
            ).schedule(this.addRefreshables)).addContent(h = new l.CheckButton(this.api).setText(r.default.MenuCustomGameOptionsTimeFrozen).setRefreshMethod(()=>t().time.frozen).on(l.CheckButtonEvent.Change, (e,a)=>{
                t().time.frozen = a,
                a ? (delete t().time.dayPercent,
                delete t().time.dayLength) : (t().time.dayLength = g.value,
                t().time.dayPercent = f.value),
                g.setDisabled(a),
                f.setDisabled(a)
            }
            ).schedule(this.addRefreshables)).addContent(y = new p.RangeRow(this.api).setLabel(e=>e.setText(r.default.MenuCustomGameOptionsTimeInitial)).editRange(e=>e.setMin(0).setMax(1).setStep(.01).setRefreshMethod(()=>t().time.initial).on(d.RangeInputEvent.Finish, (e,a)=>{
                t().time.initial = a
            }
            )).setDisplayValue(e=>T.setTime(e).getTranslation(e)).addDefaultButton(()=>0)).addContent(g = new p.RangeRow(this.api).setLabel(e=>e.setText(r.default.MenuCustomGameOptionsTimeDayLength)).editRange(e=>e.setMin(100).setMax(12800).setStep(100).setRefreshMethod(()=>t().time.dayLength).on(d.RangeInputEvent.Finish, (e,a)=>{
                t().time.dayLength = a
            }
            )).setDisplayValue(new s.default(n.Dictionary.Misc,o.MiscTranslation.Thing).get).addDefaultButton(()=>S).setTooltip(e=>e.setLocation(u.TooltipLocation.CenterRight).addText(e=>e.setText(s.default.ui(r.default.MenuCustomGameOptionsTimeDayLengthTooltip)))).schedule(this.addRefreshables)).addContent(f = new p.RangeRow(this.api).setLabel(e=>e.setText(r.default.MenuCustomGameOptionsTimeDayPercent)).editRange(e=>e.setMin(0).setMax(1).setStep(.005).setRefreshMethod(()=>t().time.dayPercent).on(d.RangeInputEvent.Finish, (e,a)=>{
                t().time.dayPercent = a
            }
            )).setDisplayValue(e=>new s.default(n.Dictionary.Misc,o.MiscTranslation.Thing).get((100 * e).toFixed(3))).addDefaultButton(()=>I).setTooltip(e=>e.setLocation(u.TooltipLocation.CenterRight).addText(e=>e.setText(s.default.ui(r.default.MenuCustomGameOptionsTimeDayPercentTooltip)))).schedule(this.addRefreshables)).schedule(this.setSection)
        }
    }
    t.default = h
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/newgame/CustomGameOptionsMenu", ["require", "exports", "language/dictionary/UiTranslation", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/newgame/customgameoptions/TabGeneral", "newui/screen/screens/menu/menus/newgame/customgameoptions/TabInventory", "newui/screen/screens/menu/menus/newgame/customgameoptions/TabReputation", "newui/screen/screens/menu/menus/newgame/customgameoptions/TabSkills", "newui/screen/screens/menu/menus/newgame/customgameoptions/TabStats", "newui/screen/screens/menu/menus/newgame/customgameoptions/TabStatusEffects", "newui/screen/screens/menu/menus/newgame/customgameoptions/TabTime", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class c extends i.default {
        constructor(e, t) {
            super(e, "CustomGameOptions"),
            this.refreshables = [],
            this.setTitle(e=>e.setText(a.default.MenuCustomGameOptionsTitle)),
            this.setDescription(e=>e.setText(a.default.MenuCustomGameOptionsDescription));
            const i = [new n.default(e,t), new d.default(e,t), new r.default(e,t), new l.default(e,t), new u.default(e,t), new s.default(e,t), new o.default(e,t)];
            this.addTabs(i),
            this.refreshables.concat(...i.map(e=>e.refreshables)),
            this.on("Show", this.refresh)
        }
        refresh() {
            for (const e of this.refreshables)
                e.refresh()
        }
    }
    __decorate([p.Bound], c.prototype, "refresh", null),
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/NewGameMenu", ["require", "exports", "Enums", "game/Difficulty", "game/IGame", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "multiplayer/IMultiplayer", "newui/component/Button", "newui/component/CheckButton", "newui/component/ChoiceList", "newui/component/IComponent", "newui/component/Input", "newui/component/LabelledRow", "newui/component/RangeRow", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/screen/screens/menu/menus/newgame/CustomGameOptionsMenu", "newui/util/Misc", "save/ISaveManager", "steamworks/ISteamworks", "utilities/enum/Enums", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class k extends f.default {
        constructor(e) {
            super(e, g.MenuId.NewGame),
            this.difficultyOptions = i.getDefaultDifficultyOptions(i.Difficulty.Hardcore),
            this.setTitle(e=>e.setText(r.default.MenuNewGameTitle)),
            this.setDescription(e=>e.setText(r.default.MenuNewGameDescription)),
            this.create(),
            this.on("Show", this.refresh)
        }
        create() {
            this.content.childCount > 0 || (new h.LabelledRow(this.api).setLabel(e=>e.setText(r.default.MenuNewGameLabelEditName)).append(this.inputName = new m.default(this.api).setDefault(this.getDefaultSaveName).on(m.InputEvent.Change, (e,t)=>{
                this.buttonNext.setDisabled(0 === t.length)
            }
            )).appendTo(this.content),
            this.inputSeedRow = new h.LabelledRow(this.api).setLabel(e=>e.setText(r.default.MenuNewGameLabelEditSeed)).append(this.inputSeed = new m.default(this.api).setPlaceholder(r.default.MenuNewGamePlaceholderEditSeed)).appendTo(this.content),
            this.difficulty = new p.default(this.api).on(p.ChoiceListEvent.Choose, (e,t)=>{
                this.inputSeedRow.classes.toggle(t.difficulty === i.Difficulty.Challenge, "disabled"),
                this.updateDifficultyOptions()
            }
            ).setChoices(M.default.values(i.Difficulty).map(e=>new C(this.api,e).on("CustomizeDifficulty", I.menuSwitcher(this.getCustomGameOptionsMenu)).on("UpdateDailyChallenge", this.updateDifficultyOptions))).appendTo(this.content),
            this.multiplayerMode = new p.default(this.api).on(p.ChoiceListEvent.Choose, (e,t)=>{
                const a = t !== this.choiceSingleplayer;
                this.lobbyType.toggle(a),
                this.inputPVP.toggle(a),
                this.maxPlayersRow.toggle(a),
                this.tickSpeedRow.toggle(a),
                a && this.choiceTurnModeManual.checked && this.turnMode.choose(this.choiceTurnModeSimulated),
                this.choiceTurnModeManual.setDisabled(a),
                !a && this.choiceTurnModeSimulated.checked && this.turnMode.choose(this.choiceTurnModeManual),
                this.choiceTurnModeSimulated.setDisabled(!a)
            }
            ).setChoices(this.choiceSingleplayer = new p.Choice(this.api,void 0).setText(r.default.MenuNewGameChoiceSingleplayer).addDescription(e=>e.setText(r.default.MenuNewGameChoiceSingleplayerDescription)), this.choiceMultiplayer = new p.Choice(this.api,void 0).setText(r.default.MenuNewGameChoiceMultiplayer).addDescription(e=>e.setText(r.default.MenuNewGameChoiceMultiplayerDescription))).appendTo(this.content),
            this.turnMode = new p.default(this.api).on(p.ChoiceListEvent.Choose, (e,t)=>{
                const a = this.choiceMultiplayer.checked;
                a && this.turnMode.choice === this.choiceTurnModeManual ? this.turnMode.choose(this.choiceTurnModeRealTime) : a || this.turnMode.choice !== this.choiceTurnModeSimulated || this.turnMode.choose(this.choiceTurnModeManual),
                this.choiceTurnModeManual.setDisabled(a),
                this.choiceTurnModeSimulated.setDisabled(!a)
            }
            ).setChoices(this.choiceTurnModeManual = new p.Choice(this.api,void 0).setText(r.default.MenuNewGameChoiceTurnModeManual).addDescription(e=>e.setText(r.default.MenuNewGameChoiceTurnModeManualDescription)), this.choiceTurnModeSimulated = new p.Choice(this.api,void 0).setText(r.default.MenuNewGameChoiceTurnModeSimulated).addDescription(e=>e.setText(r.default.MenuNewGameChoiceTurnModeSimulatedDescription)), this.choiceTurnModeRealTime = new p.Choice(this.api,void 0).setText(r.default.MenuNewGameChoiceTurnModeRealTime).addDescription(e=>e.setText(r.default.MenuNewGameChoiceTurnModeRealTimeDescription))).appendTo(this.content),
            this.lobbyType = new p.default(this.api).setChoices(this.choiceLobbyFriends = new p.Choice(this.api,void 0).setText(r.default.MenuSharedMultiplayerChoiceLobbyTypeFriends).addDescription(e=>e.setText(r.default.MenuSharedMultiplayerChoiceLobbyTypeFriendsDescription)), this.choiceLobbyPublic = new p.Choice(this.api,void 0).setText(r.default.MenuSharedMultiplayerChoiceLobbyTypePublic).addDescription(e=>e.setText(r.default.MenuSharedMultiplayerChoiceLobbyTypePublicDescription)), new p.Choice(this.api,void 0).setText(r.default.MenuSharedMultiplayerChoiceLobbyTypePrivate).addDescription(e=>e.setText(r.default.MenuSharedMultiplayerChoiceLobbyTypePrivateDescription))).appendTo(this.content),
            this.inputPVP = new d.CheckButton(this.api).setText(r.default.MenuSharedMultiplayerChoicePVP).addDescription(e=>e.setText(r.default.MenuSharedMultiplayerChoicePVPDescription)).appendTo(this.content),
            this.maxPlayersRow = new y.RangeRow(this.api).editRange(e=>e.setMin(2).setMax(l.maxPlayers).setRefreshMethod(()=>l.maxPlayers)).setLabel(e=>e.setText(r.default.MenuSharedMultiplayerMaxPlayers)).addDefaultButton().setDisplayValue(!0).appendTo(this.content),
            this.tickSpeedRow = new y.RangeRow(this.api).editRange(e=>e.setMin(Math.round(a.TickSpeed.Min * n.interval)).setMax(Math.round(a.TickSpeed.Max * n.interval)).setRefreshMethod(()=>Math.round(saveDataGlobal.options.realTimeTickSpeed * n.interval))).setLabel(e=>e.setText(r.default.MenuSharedRealTimeTickSpeedLabel)).addDefaultButton(()=>Math.round(a.TickSpeed.Default * n.interval)).setDisplayValue(s.default.ui(r.default.MenuSharedValueTickSpeed).get).appendTo(this.content),
            new T.default(this.api).appendTo(this.content),
            this.buttonNext = new u.default(this.api).setText(steamworks.isDedicatedServer() ? r.default.MenuNewGameButtonStartServer : r.default.MenuNewGameButtonNext).on(u.ButtonEvent.Activate, this.getStartClickHandler()).appendTo(this.content))
        }
        updateDifficultyOptions() {
            let e;
            this.difficulty.choice.isDailyChallenge && (e = 1e3 * Math.floor(Date.now() / 1e3 / 60 / 60 / 24)),
            this.difficultyOptions = i.getDefaultDifficultyOptions(this.difficulty.choice.difficulty, e),
            this.inputName.changed || this.inputName.clear(!0)
        }
        async refresh() {
            if (this.wentBackTo())
                return;
            steamworks.isDedicatedServer() ? (this.multiplayerMode.choose(this.choiceMultiplayer),
            this.choiceSingleplayer.setDisabled(!0),
            this.turnMode.choose(this.choiceTurnModeSimulated),
            this.lobbyType.choose(this.choiceLobbyPublic),
            this.choiceTurnModeManual.setDisabled(!0),
            this.choiceLobbyFriends.setDisabled(!0)) : (this.multiplayerMode.choose(this.choiceSingleplayer),
            this.turnMode.choose(this.choiceTurnModeManual),
            this.lobbyType.choose(this.choiceLobbyFriends)),
            this.inputPVP.setChecked(!1),
            this.maxPlayersRow.refresh(),
            this.tickSpeedRow.refresh(),
            this.slot = await saveManager.getFirstFreeSlot(),
            this.inputName.clear(),
            this.inputSeed.clear();
            const e = await saveManager.getSaveCount()
              , t = e >= v.SLOT_COUNT_MAX;
            t ? this.difficulty.choose(this.difficulty.findChoice(e=>e.difficulty === i.Difficulty.Challenge)) : this.difficulty.choose(this.difficulty.findChoice(e=>e.difficulty === i.Difficulty.Hardcore));
            for (const e of this.difficulty.getChildren())
                e.disabled || e.setDisabled(t);
            t ? this.difficulty.setTooltip(e=>e.addText(e=>e.setText(()=>s.default.ui(r.default.MenuNewGameChoiceDifficultyTooltipMaxSaves).get(v.SLOT_COUNT_MAX))).setLocation(c.TooltipLocation.CenterRight)) : this.difficulty.removeTooltip()
        }
        getStartClickHandler() {
            return steamworks.isDedicatedServer() ? ()=>{
                game.play(this.getPlayOptions())
            }
            : I.menuSwitcher(g.MenuId.CharacterSelection, e=>e.gameOptions = this.getPlayOptions())
        }
        getPlayOptions() {
            let e;
            const t = this.turnMode.choice === this.choiceTurnModeManual ? a.TurnMode.Manual : this.turnMode.choice === this.choiceTurnModeSimulated ? a.TurnMode.Simulated : a.TurnMode.RealTime;
            this.multiplayerMode.choice === this.choiceMultiplayer && (e = {
                pvp: this.inputPVP.checked,
                turnMode: t,
                lobbyType: this.lobbyType.choice === this.choiceLobbyFriends ? w.LobbyType.FriendsOnly : this.lobbyType.choice === this.choiceLobbyPublic ? w.LobbyType.Public : w.LobbyType.Private,
                maxPlayers: this.maxPlayersRow.value,
                tickSpeed: this.tickSpeedRow.value / n.interval,
                syncChecks: l.getDefaultMultiplayerOptions().syncChecks
            });
            let o = this.inputSeed.text || void 0;
            return this.difficulty.choice.difficulty === i.Difficulty.Challenge && (o = void 0,
            this.difficulty.choice.isDailyChallenge && (o = 1e3 * Math.floor(Date.now() / 1e3 / 60 / 60 / 24))),
            {
                slot: this.slot,
                name: this.inputName.text,
                seed: o,
                difficulty: this.difficulty.choice.difficulty,
                difficultyOptions: this.difficultyOptions,
                multiplayer: e,
                turnMode: t
            }
        }
        getCustomGameOptionsMenu() {
            return this.customGameOptionsMenu = this.customGameOptionsMenu || new S.default(this.api,()=>this.difficultyOptions)
        }
        getDefaultSaveName() {
            return this.difficulty.choice && this.difficulty.choice.difficulty === i.Difficulty.Challenge ? this.difficulty.choice.isDailyChallenge ? s.default.ui(r.default.MiscSaveNameDailyChallenge).getString((new Date).toLocaleDateString()) : s.default.ui(r.default.MiscSaveNameChallenge).getString() : s.default.ui(r.default.MiscSaveNameDefault).getString("number" == typeof this.slot ? this.slot + 1 : "")
        }
    }
    __decorate([b.Bound], k.prototype, "updateDifficultyOptions", null),
    __decorate([b.Bound], k.prototype, "refresh", null),
    __decorate([b.Bound], k.prototype, "getCustomGameOptionsMenu", null),
    __decorate([b.Bound], k.prototype, "getDefaultSaveName", null),
    t.default = k;
    class C extends p.Choice {
        constructor(e, t) {
            super(e, void 0),
            this.difficulty = t,
            this.isDailyChallenge = !1,
            this.attributes.set("difficulty", i.Difficulty[t]),
            this.setText(s.default.ui(r.default.MenuNewGameChoiceDifficulty).addArgs(new s.default(o.Dictionary.Difficulty,t))),
            this.addDescription(e=>e.setText(new s.default(o.Dictionary.Difficulty,t,1))),
            t === i.Difficulty.Custom && this.addButton(e=>e.classes.add("button-options").setText(r.default.MenuNewGameChoiceDifficultyTooltipCustomGameOptions).on(u.ButtonEvent.Activate, this.customizeDifficulty)),
            t === i.Difficulty.Challenge && (this.isDailyChallenge = !0,
            this.addButton(()=>new d.CheckButton(this.api).classes.add("button-daily-challenge", "menu-clearbg").setChecked(!0).setText(r.default.MenuNewGameChoiceDifficultyChallengeDaily).setTooltip(e=>e.setLocation(c.TooltipLocation.CenterRight).addText(e=>e.setText(r.default.MenuNewGameChoiceDifficultyChallengeDailyTooltip))).on(d.CheckButtonEvent.Change, (e,t)=>{
                this.isDailyChallenge = t,
                this.emit("UpdateDailyChallenge")
            }
            ))),
            this.addButton(e=>e.setDisabled().classes.add("icon-difficulty", "has-icon-before", "icon-center").data.set("difficulty", i.Difficulty[t]))
        }
        customizeDifficulty() {
            this.emit("CustomizeDifficulty")
        }
    }
    __decorate([b.Bound], C.prototype, "customizeDifficulty", null)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/LoadGameMenu", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Button", "newui/component/Component", "newui/component/SortRow", "newui/component/Text", "newui/screen/IScreen", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/screen/screens/menu/menus/loadgame/SaveSlot", "newui/util/Misc", "save/ISaveManager", "steamworks/ISteamworks", "utilities/Files", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class I extends p.default {
        constructor(e) {
            super(e, d.MenuId.LoadGame),
            this.isMultiplayer = !1,
            this.slots = [],
            this.setTitle(e=>e.setText(i.default.MenuLoadGameTitle)),
            this.setDescription(e=>e.setText(i.default.MenuLoadGameDescription));
            const t = async()=>{
                this.isVisible() && (await this.refresh(),
                this.api.refreshTranslations(this))
            }
            ;
            steamworks.on(g.SteamworksEvent.OverlayHidden, t),
            this.on("Remove", ()=>{
                steamworks.cancel(g.SteamworksEvent.OverlayHidden, t)
            }
            ),
            this.on(p.MenuEvent.GoBackFrom, ()=>{
                this.isMultiplayer = !1
            }
            )
        }
        async onBeforeShow() {
            if (!this.wentBackTo())
                return this.api.interrupt(i.default.MenuLoadGameInterruptLoading).withDescription(i.default.MenuLoadGameInterruptLoadingDescription).withLoading(this.refresh)
        }
        async refresh() {
            this.api.isScreenVisible(u.ScreenId.Interrupt) || await this.api.interrupt(i.default .MenuLoadGameInterruptLoading).withDescription(i.default .MenuLoadGameInterruptLoadingDescription).withLoading(),
            this.content.dump();
            const e = new s.default(this.api).setRefreshMethod(()=>({
                sortEnum: y.SaveSort,
                defaultSort: y.SaveSort.SaveTime,
                initializeOption: (e,[,t])=>e.setText(new n.default(a.Dictionary.SaveSlotSort,t))
            })).appendTo(this.content).on(s.SortRowEvent.Sort, async(e,t,a)=>{
                this.sort = t,
                this.sortDirection = a,
                await this.sortSlots(t,a)
            }
            )
              , t = await saveManager.getUsedSlots();
            this.slotsWrapper = new r.default(this.api).appendTo(this.content);
            for (const e of t)
                this.addSlot(e);
            await e.triggerSortAsync(),
            new c.default(this.api).appendTo(this.content),
            this.slotsRemainingHeading = new l.Heading(this.api).setText(()=>n.default.ui(i.default.MenuLoadGameSlotsRemaining).get(y.SLOT_COUNT_MAX - Object.keys(this.slots).length)).appendTo(this.content),
            this.newGameButton = new o.default(this.api).setText(i.default.MenuLoadGameButtonNewGame).on(o.ButtonEvent.Activate, h.menuSwitcher(d.MenuId.NewGame, e=>e.schedule(1, ()=>{
                this.isMultiplayer && e.multiplayerMode.choose(e.choiceMultiplayer)
            }
            ))).appendTo(this.content);
            const p = `#new-game-import-${Math.random().toString().slice(2)}`;
            this.newGameButton.addButton(e=>this.importButton = e.setElement("label").classes.add("button-import").attributes.set("for", p).setTooltip(e=>e.addHeading(e=>e.setText(i.default.MenuLoadGameButtonNewGameButtonImportTooltip))).schedule(()=>{
                e.element.addEventListener("click", e=>{
                    e.stopPropagation()
                }
                )
            }
            )),
            new r.default(this.api,"input").setId(p).classes.add("internal-button-import").attributes.set("type", "file").attributes.set("accept", ".json").on("InputChange", this.onImport).appendTo(this.newGameButton),
            await this.updateNewGameButton(),
            await this.api.hideLoadingInterrupt()
        }
        async onImport(e, t) {
            let a;
            await this.api.interrupt(i.default .MenuLoadGameInterruptLoadingImportingSave).withDescription(i.default .MenuLoadGameInterruptLoadingImportingSaveDescription).withLoading();
            try {
                a = await f.default .upload(t)
            } catch (e) {
                return T.default.warn(e),
                void await this.api.interrupt(i.default .MenuLoadGameInterruptImportSaveFailure).withDescription(i.default .MenuLoadGameInterruptImportSaveFailureDescription).withInfo()
            } finally {
                e.element.value = null
            }
            const n = await saveManager.getFirstFreeSlot();
            if (void 0 !== n) {
                const e = await saveManager.importSave(n,a);
                await this.api.hideLoadingInterrupt(),
                void 0 === e ? await this.api.interrupt(i.default .MenuLoadGameInterruptImportSaveFailure).withDescription(i.default .MenuLoadGameInterruptImportSaveFailureDescription).withInfo() : (this.addSlot(n),
                this.sortSlots(),
                await this.updateNewGameButton(),
                this.slotsRemainingHeading.refresh())
            }
        }
        async updateNewGameButton() {
            const e = await saveManager.getSaveCount();
            this.importButton.toggle(e < y.SLOT_COUNT_MAX)
        }
        addSlot(e) {
            this.slots[e] = new m.SaveSlot(this.api,e).appendTo(this.slotsWrapper).on(m.SaveSlotEvent.Delete, async()=>{
                await this.deleteSlot(e)
            }
            ).on(m.SaveSlotEvent.Rename, ()=>{
                this.sort === y.SaveSort.Name && this.sortSlots(this.sort, this.sortDirection)
            }
            ).on(o.ButtonEvent.Activate, e=>{
                game.requestPlay({
                    slot: e.slotData.slot,
                    multiplayer: !!this.isMultiplayer || void 0
                })
            }
            )
        }
        async deleteSlot(e) {
            this.slots[e].remove(),
            delete this.slots[e],
            this.slotsRemainingHeading.refresh(),
            await this.updateNewGameButton()
        }
        async sortSlots(e=this.sort, t=this.sortDirection) {
            const a = await saveManager.getUsedSlotsSorted(e,t);
            for (const e of a)
                this.slots[e].appendTo(this.slotsWrapper)
        }
    }
    __decorate([Override], I.prototype, "onBeforeShow", null),
    __decorate([S.Bound], I.prototype, "refresh", null),
    __decorate([S.Bound], I.prototype, "onImport", null),
    t.default = I
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/main/component/SocialRow", ["require", "exports", "language/dictionary/UiTranslation", "newui/component/Button"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        constructor(e) {
            super(e),
            this.classes.add("button-no-action"),
            this.setText(a.default.MenuNewsHeadingSocial),
            this.addButton(e=>e.classes.add("button-discord").setTooltip(e=>e.addHeading(e=>e.setText(a.default.MenuNewsButtonDiscord))).on(i.ButtonEvent.Activate, ()=>{
                steamworks.openUrl("https://discord.gg/wayward")
            }
            )),
            this.addButton(e=>e.classes.add("button-reddit").setTooltip(e=>e.addHeading(e=>e.setText(a.default.MenuNewsButtonReddit))).on(i.ButtonEvent.Activate, ()=>{
                steamworks.openUrl("https://www.reddit.com/r/Wayward/")
            }
            )),
            this.addButton(e=>e.classes.add("button-twitter").setTooltip(e=>e.addHeading(e=>e.setText(a.default.MenuNewsButtonTwitter))).on(i.ButtonEvent.Activate, ()=>{
                steamworks.openUrl("https://twitter.com/wayward_game")
            }
            )),
            this.addButton(e=>e.classes.add("button-facebook").setTooltip(e=>e.addHeading(e=>e.setText(a.default.MenuNewsButtonFacebook))).on(i.ButtonEvent.Activate, ()=>{
                steamworks.openUrl("https://www.facebook.com/waywardgame")
            }
            ))
        }
    }
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/main/AboutMenu", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Block", "newui/component/Component", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/main/component/SocialRow", "newui/util/Style", "utilities/string/Interpolator", "utilities/Version"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    var m;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Programming = 0] = "Programming",
        e[e.Design = 1] = "Design",
        e[e.Web = 2] = "Web",
        e[e.Art = 3] = "Art",
        e[e.PR = 4] = "PR",
        e[e.UX = 5] = "UX",
        e[e.Music = 6] = "Music"
    }(m = t.Responsibility || (t.Responsibility = {}));
    const h = [{
        firstName: "Vaughn",
        lastName: "Royko",
        nickname: "Drathy",
        fileName: "drathy",
        responsibilities: [m.Programming, m.Design, m.Web, m.PR],
        isCurrentMember: !0
    }, {
        firstName: "Gary",
        lastName: "Wilber",
        nickname: "Spacetech",
        fileName: "spacetech",
        responsibilities: [m.Programming],
        isCurrentMember: !0
    }, {
        firstName: "Dusty",
        lastName: "Melling",
        nickname: "Goaticide",
        fileName: "goaticide",
        responsibilities: [m.Art, m.Design],
        isCurrentMember: !0
    }, {
        firstName: "Mackenzie",
        lastName: "McClane",
        nickname: "Yuudaari",
        fileName: "yuudaari",
        responsibilities: [m.Programming, m.UX],
        isCurrentMember: !0
    }, {
        firstName: "Austin",
        lastName: "Dhillon",
        fileName: "austin",
        responsibilities: [m.Music],
        isCurrentMember: !0
    }, {
        firstName: "Frank",
        lastName: "Sasto",
        nickname: "Sassafrass",
        responsibilities: [m.Programming]
    }]
      , y = [{
        firstName: "Richard",
        nickname: "Orillian",
        lastName: "Hobson"
    }, {
        firstName: "Vlad",
        nickname: "vlsd",
        lastName: "Seghete"
    }, {
        firstName: "Unstoppable Carl",
        lastName: "Olsen"
    }, {
        firstName: "Justin",
        nickname: "boxofrox",
        lastName: "Charette"
    }, {
        firstName: "Frank",
        lastName: "Orechio"
    }, {
        firstName: "Drachlen"
    }, {
        firstName: "Joshua",
        nickname: "jday",
        lastName: "Day"
    }, {
        firstName: "Oddmund",
        nickname: "oddmunds",
        lastName: "Strømme"
    }]
      , g = ["Greenworks", "Electron", "TypeScript", "Node.js", "jQuery", "jQueryUI", "lz-string", "jQuery contextMenu", "jQuery UI Touch Punch", "Fixedsys Excelsior"];
    class f extends l.default {
        constructor(e) {
            super(e, "about"),
            this.setTitle(e=>e.setText(i.default.MenuAboutTitle)),
            this.setDescription(e=>e.setText(i.default.MenuAboutDescription)),
            new l.MenuSection(this.api).setTitle(e=>e.setText(()=>p.interpolateSectioned("Wayward {0} © Unlok, 2011-{1}", c.default.getVersionDisplayString(), (new Date).getFullYear()))).addContent(new o.Block(this.api).addText(e=>e.setText(i.default.MenuAboutGameDescription)), new u.default(this.api)).appendTo(this.content),
            new l.MenuSection(this.api).setTitle(e=>e.setText(i.default.MenuAboutSectionTeam)).addContent(new o.Block(this.api).append(h.filter(e=>e.isCurrentMember).map(e=>new T(this.api,e)))).appendTo(this.content),
            new l.MenuSection(this.api).setTitle(e=>e.setText(i.default.MenuAboutSectionContributors)).addContent(new o.Block(this.api).append(h.filter(e=>!e.isCurrentMember).map(e=>new T(this.api,e)))).appendTo(this.content),
            new l.MenuSection(this.api).setTitle(e=>e.setText(i.default.MenuAboutSectionSpecialThanks)).addContent(new o.Block(this.api).append(y.map(e=>new T(this.api,e)), new s.default(this.api).setText(i.default.MenuAboutTextSpecialThanksTestorsAndDonators))).appendTo(this.content),
            new l.MenuSection(this.api).setTitle(e=>e.setText(i.default.MenuAboutSectionLibraries)).addContent(new o.Block(this.api).append(new s.Paragraph(this.api).setText(i.default.MenuAboutSectionLibrariesDescription), new r.default(this.api,"ul").classes.add("menu-about-libraries").append(g.map(e=>new s.default(this.api,"li").setText(n.default.generator(e)).classes.add("menu-about-library"))))).appendTo(this.content)
        }
    }
    t.default = f;
    class T extends r.default {
        constructor(e, t) {
            const o = t;
            if (super(e),
            this.classes.add(o.isCurrentMember ? "menu-about-team-member" : "menu-about-contributor"),
            t.fileName && o.isCurrentMember) {
                const e = d.default.getImagePath(`static/image/ui/menu/devs/${t.fileName}`, void 0, "gif", !0);
                this.style.setProperty("--dev-icon", e)
            }
            this.append(new s.Heading(this.api).setText(()=>n.default.ui(i.default.MenuAboutTeamMemberName).get(t.firstName, t.lastName ? t.lastName : "", t.nickname ? n.default.ui(i.default.MenuAboutTeamMemberNickname).get(t.nickname) : "")), o.responsibilities ? new s.default(this.api).setText(()=>o.responsibilities.values().map(e=>new n.default(a.Dictionary.TeamMemberResponsibility,e)).collect(n.default.formatList)) : void 0)
        }
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Trello", ["require", "exports", "utilities/enum/Enums", "utilities/Files", "utilities/iterable/Collectors", "utilities/Log", "utilities/Version"], function(e, t, a, i, n, o, r) {
    var s;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.New = "New",
        e.Improvement = "Improvement",
        e.Bug = "Bug",
        e.Balance = "Balance",
        e.Modding = "Modding",
        e.Mod = "Mod",
        e.Technical = "Technical"
    }(s = t.ChangelogSection || (t.ChangelogSection = {}));
    const l = /^\s*(Beta|Release)\s+(\d+)\.(\d+)(?:\.(\d+))?(?:\s+"(.*?)")?(\s+\((January|February|March|April|May|June|July|August|September|October|November|December) (\d+(?:st|nd|rd|th)), (\d+)\))?\s*$/
      , u = "PWX1Hpjn";
    var d;
    function p(e, t, a=!1) {
        let i = d[e.stage] - d[t.stage];
        return 0 === i && 0 === (i = e.major - t.major) && 0 === (i = e.minor - t.minor) && (i = e.patch - t.patch),
        a ? -1 * i : i
    }
    !function(e) {
        e[e.beta = 0] = "beta",
        e[e.release = 1] = "release"
    }(d || (d = {}));
    class c {
        async getChangelog(e) {
            try {
                const t = await this.findChangelogList(e);
                if (t)
                    return t.list = await this.getCards(t.list),
                    this.parseChangelog(t)
            } catch (t) {
                o.default.error(o.LogSource.Trello)("Failed to get changelog", e, t)
            }
        }
        async getVersions(e, t) {
            const a = [];
            try {
                if (t) {
                    if (t.lists)
                        for (const e of t.lists) {
                            const t = this.getListVersionInfo(e);
                            t && a.push(t)
                        }
                } else
                    (t = await this.getBoard(u)) && (a.push(...await this.getVersions(void 0, t)),
                    t = await this.getBoard(u,!0),
                    a.push(...await this.getVersions(void 0, t)));
                if (a.sort((e,t)=>p(e, t, !0)),
                e)
                    for (; p(a[0], e) > 0; )
                        a.shift()
            } catch (a) {
                o.default.error(o.LogSource.Trello)("Failed to get versions", e, t, a)
            }
            return a
        }
        async getCards(e) {
            return i.default.getJson(`https://api.trello.com/1/lists/${e.id}?cards=open&fields=name&card_fields=name,labels,pos`)
        }
        async getBoard(e, t=!1) {
            return i.default.getJson(`https://api.trello.com/1/boards/${e}?lists=${t ? "closed" : "open"}&list_fields=name&fields=name,desc`)
        }
        getListVersionInfo(e) {
            const t = e.name.match(l);
            if (!t)
                return;
            const a = {
                str: "",
                stage: t[1].toLowerCase(),
                major: parseInt(t[2], 10),
                minor: parseInt(t[3], 10),
                patch: t[4] ? parseInt(t[4], 10) : 0
            };
            return a.str = `${a.stage}${a.major}.${a.minor}.${a.patch}`,
            t[5] && (a.name = t[5]),
            t[6] && (a.date = new Date(`${t[7]} ${parseInt(t[8], 10)}, ${t[9]}`)),
            a
        }
        async findChangelogList(e, t) {
            if (t) {
                if (t.lists)
                    for (const a of t.lists) {
                        const t = this.getListVersionInfo(a);
                        if (t && r.default.isSameVersion(t, e))
                            return {
                                version: t,
                                list: await this.getCards(a)
                            }
                    }
            } else if (t = await this.getBoard(u)) {
                let a = await this.findChangelogList(e,t);
                if (a)
                    return a;
                if (t = await this.getBoard(u,!0),
                a = await this.findChangelogList(e,t))
                    return a
            }
        }
        parseChangelog(e) {
            const t = {
                version: e.version,
                sections: {},
                changeCount: 0
            }
              , i = e.list;
            if (i.cards) {
                t.changeCount = i.cards.length;
                for (const e of i.cards) {
                    const i = e.labels
                      , r = a.default.values(s).filter(e=>i.some(t=>t.name === e)).collect(n.default.first());
                    if (void 0 === r) {
                        o.default.warn(o.LogSource.Trello)(`Missing section id for ${e.name}`, e);
                        continue
                    }
                    e.important = i.some(e=>"Important" === e.name);
                    let l = t.sections[r];
                    l || (l = t.sections[r] = []),
                    l.push(e)
                }
            }
            for (const e of a.default.values(s)) {
                const a = t.sections[e];
                a && (t.sections[e] = a.sort((e,t)=>t.pos - e.pos))
            }
            return t
        }
    }
    t.default = c,
    t.trello = new c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/main/ChangelogMenu", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Block", "newui/component/Button", "newui/component/Component", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "utilities/enum/Enums", "utilities/Log", "utilities/Objects", "utilities/string/Strings", "utilities/Trello", "utilities/Version"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class g extends u.default {
        constructor(e) {
            super(e, "changelog"),
            this.setTitle(e=>e.setText(i.default.MenuChangelogTitle)),
            this.setDescription(e=>e.setText(i.default.MenuChangelogDescription)),
            new o.Block(e).append(this.headingVersionName = new l.Heading(e), this.labelChangeCount = new l.default(e).classes.add("menu-changelog-changecount"), this.changesContainer = new s.default(e)).appendTo(this.content)
        }
        async onBeforeShow() {
            return this.api.interrupt(i.default.MenuMainInterruptLoadingChangelog).withDescription(i.default.MenuMainInterruptLoadingChangelogDescription).withLoading(this.refresh)
        }
        async refresh() {
            this.tabContainer && this.tabContainer.dump(),
            (await h.trello.getVersions(y.default .getVersionInfo(gameVersion))).values().map(e=>new u.Tab(this.api,void 0).setText(n.default.generator(y.default.getVersionDisplayString(e))).on(r.ButtonEvent.Activate, async()=>{
                await this.showVersion(e),
                await this.api.hideLoadingInterrupt()
            }
            )).collect(this.addTabs),
            await this.showVersion(void 0,!1)
        }
        async showVersion(e, t=!0) {
            if (this.scrollToTop(),
            e || (e = gameVersion),
            "string" == typeof e && (e = y.default.getVersionInfo(e)),
            this.lastVersion !== e.str) {
                this.lastVersion = e.str;
                try {
                    t && await this.api.interrupt(i.default .MenuChangelogInterruptLoadingChangelog).withDescription(i.default .MenuChangelogInterruptLoadingChangelogDescription).withLoading();
                    const a = await h.trello.getChangelog(e);
                    if (a) {
                        this.changesContainer.dump(),
                        e = a.version;
                        let t = y.default.getVersionDisplayString(e);
                        e.name && (t += ` "${e.name}"`),
                        this.headingVersionName.setText(n.default.generator(t)),
                        this.labelChangeCount.setText(()=>n.default.ui(i.default.MenuChangelogHeadingChangeCount).get(a.changeCount));
                        for (const e of d.default.values(h.ChangelogSection))
                            this.appendChangelog(e, a.sections[e]);
                        return
                    }
                } catch (e) {
                    p.default.warn(p.LogSource.NewUi)("Changelog error: ", e)
                }
                p.default.warn(p.LogSource.NewUi)("Failed to load changelog"),
                this.changesContainer.dump(),
                this.headingVersionName.setText(()=>n.default.ui(i.default.MenuChangelogHeadingFailedLoad).get(y.default.getVersionDisplayString(e)))
            }
        }
        appendChangelog(e, t) {
            if (!t || 0 === t.length)
                return;
            let o;
            if (e === h.ChangelogSection.Mod) {
                o = new s.default(this.api);
                const e = {};
                t.sort((e,t)=>(t.important ? 1e4 : 1) * (t.pos + 1) - (e.important ? 1e4 : 1) * (e.pos + 1));
                for (const a of t) {
                    const t = a.name.match(/^\s*\[(.*?)\]\s*(.*)$/);
                    let i = o;
                    t && (e[t[1]] || o.append([new s.default(this.api).classes.add("menu-changelog-section-mod").append(e[t[1]] = [new l.Heading(this.api).append(new l.default(this.api).listen("click", ()=>{
                        let e = g.modLinks[t[1]];
                        "number" == typeof e && (e = `https://steamcommunity.com/sharedfiles/filedetails/?id=${e}`),
                        steamworks.openUrl(e)
                    }
                    ).setText(n.default.generator(t[1]))), new l.default(this.api).classes.add("menu-changelog-changecount"), new s.default(this.api,"ul")]).schedule(e=>{
                        e.dataset.sectionId = t[1]
                    }
                    )]),
                    i = e[t[1]][2]),
                    new l.default(this.api,"li").classes.add("menu-changelog-change").classes.toggle(a.important, "important").setContents(m.default.parseMarkup(t ? t[2] : a.name)).appendTo(i)
                }
                for (const t in e)
                    e[t][1].setText(()=>n.default.ui(i.default.MenuChangelogHeadingChangeCount).get(e[t][2].childCount))
            } else
                o = new s.default(this.api,"ul").append(t.sort(this.sortCards).map(e=>new l.default(this.api,"li").classes.add("menu-changelog-change").classes.toggle(e.important, "important").setContents(m.default.parseMarkup(e.name))));
            if (0 === o.childCount)
                return;
            const r = new s.default(this.api).classes.add("menu-changelog-section").append(new l.Heading(this.api).setText(new n.default(a.Dictionary.ChangelogSection,e)), new l.default(this.api).classes.add("menu-changelog-changecount").setText(()=>n.default.ui(i.default.MenuChangelogHeadingChangeCount).get(t.length)), o).appendTo(this.changesContainer);
            r.dataset.sectionId = e
        }
        getChangelogText(e=!1) {
            function t(t, a, i=!1) {
                return e ? `<${t}>${a}</${t}>` : i ? `- ${a}` : a
            }
            let a = "";
            const i = this.element.querySelector(".menu-content > .menu-block");
            function n(e) {
                const t = e ? e.querySelectorAll("[data-text]") : [];
                let a = "";
                for (const e of t)
                    a += e.getAttribute("data-text");
                return a
            }
            a += t("h1", n(i.querySelector(":scope > .heading"))),
            e || (a += ` ${n(i.querySelector(":scope > .menu-changelog-changecount"))}`),
            a += "\n\n\n\n";
            for (const o of i.querySelectorAll(".menu-changelog-section")) {
                a += t("h2", n(o.querySelector(":scope > .heading"))),
                e || (a += ` ${n(o.querySelector(":scope > .menu-changelog-changecount"))}`),
                a += "\n\n";
                const i = o.querySelectorAll(":scope > ul > .menu-changelog-change");
                i.length && (a += t("ul", (()=>{
                    let e = "\n";
                    for (const a of i)
                        e += `\t${t("li", `${a.textContent}`, !0)}\n`;
                    return e
                }
                )()));
                for (const i of o.querySelectorAll(".menu-changelog-section-mod")) {
                    const o = n(i.querySelector(":scope > .heading"));
                    let r = g.modLinks[o];
                    "number" == typeof r && (r = `https://steamcommunity.com/sharedfiles/filedetails/?id=${r}`),
                    a += t("h3", `<a href="${r}" target="_blank">${o}</a>`),
                    e || (a += ` ${n(i.querySelector(":scope > .menu-changelog-changecount"))}`),
                    a += "\n";
                    const s = i.querySelectorAll(":scope > ul > .menu-changelog-change");
                    a += t("ul", (()=>{
                        let e = "\n";
                        for (const a of s)
                            e += `\t${t("li", `${a.textContent}`, !0)}\n`;
                        return e
                    }
                    )()),
                    a += "\n\n"
                }
                a += "\n\n\n"
            }
            console.log(a)
        }
        sortCards(e, t) {
            return (t.important ? 1e7 : 1) * ((e.pos + 1) / 1e4) - (e.important ? 1e7 : 1) * ((t.pos + 1) / 1e4)
        }
    }
    g.modLinks = {
        Reincarnate: 677681194,
        "Debug Tools": 474819610,
        "Developer Tools": 474819610,
        Argus: 474819457,
        "Ridiculous Hairdos": 879852137,
        "Balancing Tools": 474819583,
        TARS: 1218286592,
        "Pirate Language": 631428133,
        "Alpha Tracks": 1345211328,
        Troposphere: 474819705,
        "OwO Whats This": 1628751642,
        "Challenge Server": "https://github.com/waywardgame/challengeserver"
    },
    __decorate([Override], g.prototype, "onBeforeShow", null),
    __decorate([c.Bound], g.prototype, "refresh", null),
    t.default = g
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/main/NewsMenu", ["require", "exports", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Block", "newui/component/Button", "newui/component/Component", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/main/component/SocialRow", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class c extends l.default {
        constructor(e) {
            super(e, "News"),
            this.setTitle(e=>e.setText(a.default.MenuNewsTitle)),
            this.setDescription(e=>e.setText(a.default.MenuNewsDescription)),
            this.content.append(new u.default(this.api), this.newsContainer = new r.default(this.api), new o.default(this.api).setText(a.default.MenuNewsButtonAllNews).on(o.ButtonEvent.Activate, ()=>{
                steamworks.openUrl("http://store.steampowered.com/news/?appids=379210&appgroupname=Wayward")
            }
            ))
        }
        async onBeforeShow() {
            return this.api.interrupt(a.default.MenuMainInterruptLoadingNews).withDescription(a.default.MenuMainInterruptLoadingNewsDescription).withLoading(this.refreshNews)
        }
        async refreshNews() {
            let[,e] = await Promise.all([this.newsContainer.dump(),this.getNews()]);
            if (e) {
                e = e.slice(0, 5);
                for (const t of e) {
                    let e;
                    new n.Block(this.api).append(new s.Heading(this.api).setText(i.default.generator(t.title)), e = new s.Paragraph(this.api).setContents(t.body, !0), new s.default(this.api).setText(i.default.generator(t.date.toLocaleString()))).appendTo(this.newsContainer);
                    const a = e.findDescendants(".bb_link");
                    for (const e of a) {
                        const t = e.getAttribute("href");
                        e.setAttribute("href", t.replace(/^https:\/\/steamcommunity\.com\/linkfilter\/\?url=/, ""))
                    }
                    const o = e.findDescendants(".bb_h1");
                    for (const e of o)
                        "Changelog" === e.textContent && e.classList.add("changelog")
                }
            } else
                new s.Heading(this.api).setText(a.default.MenuNewsHeadingUnableToLoad).appendTo(this.newsContainer)
        }
        async getNews() {
            return new Promise((e,t)=>{
                const a = []
                  , i = new XMLHttpRequest;
                i.onloadend = (()=>{
                    const t = i.responseXML;
                    if (!t)
                        return d.default.warn(d.LogSource.NewUi)("Unable to load news"),
                        void e(void 0);
                    const n = t.getElementsByTagName("item");
                    for (let e = 0; e < n.length; e++)
                        a.push(this.parseArticle(n[e]));
                    e(a)
                }
                ),
                i.open("GET", "http://steamcommunity.com/games/Wayward/rss/"),
                i.responseType = "document",
                i.send()
            }
            )
        }
        parseArticle(e) {
            const t = e.querySelector("title")
              , a = e.querySelector("description")
              , i = e.querySelector("link")
              , n = e.querySelector("pubDate");
            return {
                title: t.textContent,
                body: a.innerHTML,
                link: i.childNodes[0].data,
                date: new Date(n.textContent)
            }
        }
    }
    __decorate([Override], c.prototype, "onBeforeShow", null),
    __decorate([p.Bound], c.prototype, "refreshNews", null),
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/MainMenu", ["require", "exports", "language/dictionary/InterruptChoice", "language/dictionary/UiTranslation", "language/Translation", "newui/component/BlockRow", "newui/component/Button", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/screen/screens/menu/menus/main/AboutMenu", "newui/screen/screens/menu/menus/main/ChangelogMenu", "newui/screen/screens/menu/menus/main/NewsMenu", "newui/util/Misc", "utilities/Objects", "utilities/Version"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class g extends l.default {
        constructor(e) {
            super(e, s.MenuId.Main),
            this.create(),
            this.checkAndShowGameInterrupts()
        }
        async onBeforeShow() {
            this.wentBackTo() || this.classes.until(900).add("insta-animation-in");
            const e = await saveManager.getSaveCount();
            0 === e ? (this.playRow1.append(this.newGameButton, this.loadGameButton),
            this.playRow2.append(this.multiplayerButton),
            this.continueGameButton.store()) : (this.playRow1.append(this.continueGameButton, this.loadGameButton),
            this.playRow2.append(this.multiplayerButton, this.newGameButton))
        }
        create() {
            const e = steamworks.isDedicatedServer();
            let t = !1;
            this.content.append(this.newGameButton = new r.default(this.api).setText(i.default.MenuMainButtonNewGame).on(r.ButtonEvent.Activate, m.menuSwitcher(s.MenuId.NewGame)), this.loadGameButton = new r.default(this.api).setText(i.default.MenuMainButtonLoadGame).on(r.ButtonEvent.Activate, m.menuSwitcher(s.MenuId.LoadGame)), this.multiplayerButton = !e && new r.default(this.api).setText(i.default.MenuMainButtonMultiplayer).on(r.ButtonEvent.Activate, m.menuSwitcher(s.MenuId.Multiplayer)), this.continueGameButton = new r.default(this.api).setText(i.default.MenuMainButtonContinueGame).on(r.ButtonEvent.Activate, async()=>{
                if (!t) {
                    t = !0;
                    try {
                        await game.requestPlay({slot:await saveManager.getMostRecentSlot()})
                    } finally {
                        t = !1
                    }
                }
            }
            ), this.playRow1 = new o.BlockRow(this.api), this.playRow2 = new o.BlockRow(this.api), new u.default(this.api), !e && new r.default(this.api).setText(i.default.MenuMainButtonHighscores).on(r.ButtonEvent.Activate, m.menuSwitcher(s.MenuId.Highscores)), new o.BlockRow(this.api).append(new r.default(this.api).setText(i.default.MenuMainButtonOptions).on(r.ButtonEvent.Activate, m.menuSwitcher(s.MenuId.Options)), new r.default(this.api).setText(i.default.MenuMainButtonMods).on(r.ButtonEvent.Activate, m.menuSwitcher(s.MenuId.Mods))), !e && new u.default(this.api), !e && new o.BlockRow(this.api).append(new r.default(this.api).setText(i.default.MenuMainButtonNews).on(r.ButtonEvent.Activate, m.menuSwitcher(this.getNewsMenu)), new r.default(this.api).setText(i.default.MenuMainButtonChangelog).on(r.ButtonEvent.Activate, m.menuSwitcher(this.getChangelogMenu))), !e && new r.default(this.api).setText(i.default.MenuMainButtonAbout).on(r.ButtonEvent.Activate, m.menuSwitcher(this.getAboutMenu)), new u.default(this.api), new r.default(this.api).setText(i.default.MenuMainButtonQuitGame).on(r.ButtonEvent.Activate, ()=>{
                window.close()
            }
            ))
        }
        checkAndShowGameInterrupts() {
            const e = y.default.getVersionInfo(gameVersion)
              , t = saveDataGlobal.gameLastPlayedVersion ? y.default.getVersionInfo(saveDataGlobal.gameLastPlayedVersion) : void 0;
            saveDataGlobal.gameLastPlayedVersion = gameVersion,
            t && (t.minor < e.minor ? this.api.interrupt(()=>n.default.ui(i.default.MenuMainInterruptWelcomeToVersion).get(y.default.getVersionDisplayString())).withDescription(i.default.MenuMainInterruptWelcomeToVersionDescription).withInfo() : (e.major < t.major || e.minor < t.minor || e.patch < t.patch) && this.api.interrupt(i.default.MenuMainInterruptOldVersionWarning).withDescription(()=>n.default.ui(i.default.MenuMainInterruptOldVersionWarningDescription).get(y.default.getVersionDisplayString(t), y.default.getVersionDisplayString())).withChoice(a.default.ContinueAnyway, a.default.OpenSaveFolderAndQuit).then(e=>{
                e === a.default.OpenSaveFolderAndQuit && (steamworks.openSaveFolder(),
                window.close())
            }
            ))
        }
        getAboutMenu() {
            return this.aboutMenu = this.aboutMenu || new d.default(this.api)
        }
        getChangelogMenu() {
            return this.changelogMenu = this.changelogMenu || new p.default(this.api)
        }
        getNewsMenu() {
            return this.newsMenu = this.newsMenu || new c.default(this.api)
        }
    }
    __decorate([Override], g.prototype, "onBeforeShow", null),
    __decorate([h.Bound], g.prototype, "getAboutMenu", null),
    __decorate([h.Bound], g.prototype, "getChangelogMenu", null),
    __decorate([h.Bound], g.prototype, "getNewsMenu", null),
    t.default = g
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/mods/EditInternalModsMenu", ["require", "exports", "language/dictionary/UiTranslation", "newui/component/Input", "newui/screen/screens/menu/component/Menu", "utilities/iterable/Collectors", "utilities/Objects"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class s extends n.default {
        constructor(e) {
            super(e, "world"),
            this.setTitle(e=>e.setText(a.default.MenuModsSubmenuEditInternalModsTitle)),
            this.setDescription(e=>e.setText(a.default.MenuModsSubmenuEditInternalModsDescription));
            const t = (localStorage.getItem("wayward.mods") || "").split(",");
            this.inputAddNewInternalMod = new i.default(this.api).setPlaceholder(a.default.MenuModsSubmenuEditInternalModsPlaceholderAddNewInternalMod).on(i.InputEvent.Change, (e,t)=>{
                t && (this.inputAddNewInternalMod.clear(),
                this.addInternalMod(t).focus())
            }
            ).appendTo(this.content),
            t.forEach(this.addInternalMod),
            this.on(n.MenuEvent.GoBackFrom, this.goBackFrom)
        }
        async goBackFrom() {
            const e = this.content.getChildren().map(e=>e.text).filter(e=>e).collect(o.default.toString(","));
            localStorage.setItem("wayward.mods", e);
            const t = await this.api.interrupt(a.default .MenuModsSubmenuEditInternalModsInterruptModsListChangeReload).withDescription(a.default .MenuModsSubmenuEditInternalModsInterruptModsListChangeReloadDescription).withConfirmation();
            t && steamworks.reload()
        }
        addInternalMod(e) {
            const t = new i.default(this.api).setDefault(()=>e).clear().setClearTo(()=>t.remove() && "").appendTo(this.content, {
                before: this.inputAddNewInternalMod
            });
            return t
        }
    }
    __decorate([r.Bound], s.prototype, "goBackFrom", null),
    __decorate([r.Bound], s.prototype, "addInternalMod", null),
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/mods/IModsMenu", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Name = 0] = "Name",
        e[e.CreatedDate = 1] = "CreatedDate",
        e[e.InstallDate = 2] = "InstallDate",
        e[e.Author = 3] = "Author",
        e[e.LastUpdated = 4] = "LastUpdated"
    }(a = t.ModSort || (t.ModSort = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/HookCallFactory", ["require", "exports", "mod/IModInfo", "utilities/Log", "utilities/Objects", "utilities/Random"], function(e, t, a, i, n, o) {
    var r;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Reduce = 0] = "Reduce",
        e[e.First = 1] = "First",
        e[e.Last = 2] = "Last",
        e[e.All = 3] = "All"
    }(r = t.ReduceStrategy || (t.ReduceStrategy = {}));
    class s {
        constructor(e, t) {
            this.reduceStrategy = r.Last,
            this.hook = e,
            this.call = this._call.bind(this),
            this.defaultValue = t
        }
        setExpectedResult(e) {
            return this.resultPredicate = e,
            this
        }
        setReduceStrategy(e, t) {
            return this.reduceStrategy = e,
            this.shouldPassCurrentResultToMods = t,
            this
        }
        setDefault(e) {
            return this.defaultValue = e,
            this
        }
        _call(...e) {
            this.args = e,
            this.currentResultValue = this.reduceStrategy === r.All ? [...this.defaultValue?[this.defaultValue]:[]] : this.defaultValue;
            const t = hookManager.getCachedHook(this.hook);
            if (!t)
                return this.currentResultValue;
            for (const e of t.priorities)
                for (const a of t[e]) {
                    const e = this.callHookOnHost(a);
                    if (this.filterHookResult(e)) {
                        if (this.reduceStrategy === r.First)
                            return e;
                        this.reduceStrategy === r.Reduce || this.reduceStrategy === r.Last ? this.currentResultValue = e : this.reduceStrategy === r.All && this.currentResultValue.push(e)
                    }
                }
            return this.currentResultValue
        }
        filterHookResult(e) {
            let t;
            return void 0 === this.resultPredicate ? void 0 !== e : ((t = "number" == typeof this.resultPredicate ? this.validateResultByType(e) : this.resultPredicate(e)) || void 0 === e || i.default.warn(i.LogSource.Mods)(`${this.baseErrorMessage}. The hook method returned the incorrect type! Got ${typeof e}, expected ${this.resultPredicate}`),
            t)
        }
        validateResultByType(e) {
            const t = this.resultPredicate;
            switch (typeof e) {
            case "undefined":
                return Boolean(t & a.TypeFlag.Undefined);
            case "string":
                return Boolean(t & a.TypeFlag.String);
            case "number":
                return Boolean(t & a.TypeFlag.Number);
            case "boolean":
                return Boolean(t & a.TypeFlag.Boolean) || Boolean(!0 === e && t & a.TypeFlag.True) || Boolean(!1 === e && t & a.TypeFlag.False);
            case "function":
                return Boolean(t & a.TypeFlag.Function);
            case "object":
                return null === e ? Boolean(t & a.TypeFlag.Null) : !!(t & a.TypeFlag.Object) || Array.isArray(e) && Boolean(t & a.TypeFlag.Array)
            }
            return !1
        }
        callHookOnHost(e) {
            if (this.baseErrorMessage = `Error calling hook ${this.hook}`,
            !e[this.hook])
                return;
            const t = !game.playing;
            let a;
            t && o.default.generator.pushSeed();
            try {
                this.shouldPassCurrentResultToMods && (this.args[0] = this.currentResultValue),
                a = e[this.hook](...this.args)
            } catch (e) {
                i.default.warn(i.LogSource.Mods)(this.baseErrorMessage, e)
            }
            return t && o.default.generator.popSeed(),
            a
        }
    }
    __decorate([n.Bound], s.prototype, "filterHookResult", null),
    __decorate([n.Bound], s.prototype, "callHookOnHost", null),
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/IModManager", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Loadable = 0] = "Loadable",
        e[e.Disabled = 1] = "Disabled",
        e[e.ModLoadError = 2] = "ModLoadError",
        e[e.DependencyIssue = 3] = "DependencyIssue",
        e[e.ModRequiresItself = 4] = "ModRequiresItself",
        e[e.MissingRequiredMod = 5] = "MissingRequiredMod",
        e[e.CannotLoadRequiredMod = 6] = "CannotLoadRequiredMod",
        e[e.ReqiredModNotLoaded = 7] = "ReqiredModNotLoaded",
        e[e.LocalModPrecedence = 8] = "LocalModPrecedence",
        e[e.IncompatibleVersion = 9] = "IncompatibleVersion",
        e[e.DisabledInMultiplayer = 10] = "DisabledInMultiplayer"
    }(a = t.CanLoadState || (t.CanLoadState = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/IOptionsTabs", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.General = 0] = "General",
        e[e.Audio = 1] = "Audio",
        e[e.Video = 2] = "Video",
        e[e.Gameplay = 3] = "Gameplay",
        e[e.Mods = 4] = "Mods",
        e[e.Controls = 5] = "Controls",
        e[e.SaveData = 6] = "SaveData",
        e[e.Developer = 7] = "Developer"
    }(a = t.OptionsTab || (t.OptionsTab = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Graceful", ["require", "exports", "utilities/Log"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i {
        constructor(...e) {
            this.errorMessage = "Gracefully caught an error",
            this.sources = e.length ? e : ["Graceful"]
        }
        setFailureReturn(e) {
            return this.ifFailReturn = e,
            this
        }
        setErrorMessage(e) {
            return this.errorMessage = e,
            this
        }
        setSources(...e) {
            return this.sources = e,
            this
        }
        execute(e) {
            return (...t)=>{
                try {
                    return e(...t)
                } catch (e) {
                    a.default.error(...this.sources)(this.errorMessage, e)
                }
                return this.ifFailReturn
            }
        }
    }
    t.Graceful = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/TabMods", ["require", "exports", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Component", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/options/IOptionsTabs", "utilities/Graceful", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class d extends o.Tab {
        constructor(e) {
            super(e, r.OptionsTab.Mods),
            this.setText(a.default.MenuOptionsTabMods),
            new o.MenuSection(this.api).setTitle(e=>e.setText(a.default.MenuOptionsHeadingModOptions)).schedule(this.setSection),
            this.refresh()
        }
        static registerModOptions(e, t) {
            d.modOptions[e] = t
        }
        static deleteModOptions(e) {
            delete d.modOptions[e]
        }
        static modHasOptions(e) {
            return !!d.modOptions[e]
        }
        refresh() {
            for (const e of this.subtabs)
                e.section && e.section.remove(),
                e.remove();
            this.subtabs.splice(0, 1 / 0),
            u.default.entries(d.modOptions).map(([e,t])=>l.tuple(modManager.getName(+e), t)).map(([e,t])=>new o.Tab(this.api,e).setSection(new o.MenuSection(this.api).addContent(new n.default(this.api).schedule(new s.Graceful(e).setErrorMessage("Unable to initialize options section").execute(e=>t(this.api, e)))).setTitle(t=>t.setText(i.default.generator(e)))).setText(i.default.generator(e))).collect(this.setSubTabs);
            const e = !!this.subtabs.length;
            return this.section.toggle(e).classes.toggle(!e, "hide-next-separator"),
            this.toggle(e),
            this
        }
    }
    d.modOptions = {},
    t.default = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/TabAudio", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Button", "newui/component/CheckButton", "newui/component/CheckButtonRange", "newui/component/Dropdown", "newui/component/IComponent", "newui/component/LabelledRow", "newui/component/RangeInput", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/options/IOptionsTabs", "save/data/ISaveDataGlobal", "utilities/enum/Enums", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class f extends c.Tab {
        constructor(e) {
            super(e, m.OptionsTab.Audio),
            this.setText(i.default.MenuOptionsTabAudio),
            new c.MenuSection(this.api).setTitle(e=>e.setText(i.default.MenuOptionsHeadingAudio)).addContent(this.volumeEffects = new s.default(this.api).classes.add("menu-volume-row").setText(i.default.MenuOptionsLabelVolumeEffects).setRefreshMethod(()=>!saveDataGlobal.options.muteEffects).on(r.CheckButtonEvent.Change, this.onMuteEffects).editRange(e=>e.setRefreshMethod(()=>Math.round(100 * saveDataGlobal.options.volumeEffects)).on(p.RangeInputEvent.Change, this.onEffectVolumeChange).on(p.RangeInputEvent.Finish, this.onEffectVolumeChangeFinish)).setDisplayValue(i.default.MenuOptionsAudioVolumeDisplay)).addContent(this.volumeMusic = new s.default(this.api).classes.add("menu-volume-row").setText(i.default.MenuOptionsLabelVolumeMusic).setRefreshMethod(()=>!saveDataGlobal.options.muteMusic).on(r.CheckButtonEvent.Change, this.onMuteMusic).editRange(e=>e.setRefreshMethod(()=>Math.round(100 * saveDataGlobal.options.volumeMusic)).on(p.RangeInputEvent.Change, this.onMusicVolumeChange)).setDisplayValue(i.default.MenuOptionsAudioVolumeDisplay).addButton(e=>e.classes.add("button-next", "has-icon-before", "icon-center").setTooltip(e=>e.addHeading(e=>e.setText(i.default.MenuOptionsTooltipMusicNextTrack))).on(o.ButtonEvent.Activate, this.nextTrack))).addContent(new d.LabelledRow(this.api).setLabel(e=>e.setText(i.default.MenuOptionsMusicPlaylist)).append(new l.default(this.api).setRefreshMethod(()=>({
                defaultOption: saveDataGlobal.options.musicPlaylist,
                options: y.default.values(h.MusicPlaylist).map(e=>[e, t=>t.setText(new n.default(a.Dictionary.MusicPlaylist,e)).setTooltip(t=>t.setLocation(u.TooltipLocation.CenterRight).addText(t=>t.setText(new n.default(a.Dictionary.MusicPlaylist,e,1))))])
            })).on(l.DropdownEvent.Selection, (e,t)=>{
                saveDataGlobal.options.musicPlaylist = t
            }
            ))).schedule(this.setSection)
        }
        refresh() {
            return this.volumeEffects.refresh(),
            this.volumeMusic.refresh(),
            this
        }
        onMuteEffects(e, t) {
            saveDataGlobal.options.muteEffects = !t,
            audio.updateVolume()
        }
        onEffectVolumeChange(e, t) {
            saveDataGlobal.options.volumeEffects = t / 100,
            audio.updateVolume()
        }
        onEffectVolumeChangeFinish(e, t) {
            this.api.playActivateSound()
        }
        onMuteMusic(e, t) {
            saveDataGlobal.options.muteMusic = !t,
            audio.updateVolume(),
            saveDataGlobal.options.muteMusic ? audio.stopMusic() : audio.playMusic()
        }
        onMusicVolumeChange(e, t) {
            saveDataGlobal.options.volumeMusic = t / 100,
            audio.updateVolume()
        }
        nextTrack() {
            audio.getMusicHandler().next()
        }
    }
    __decorate([g.Bound], f.prototype, "onMuteEffects", null),
    __decorate([g.Bound], f.prototype, "onEffectVolumeChange", null),
    __decorate([g.Bound], f.prototype, "onEffectVolumeChangeFinish", null),
    __decorate([g.Bound], f.prototype, "onMuteMusic", null),
    __decorate([g.Bound], f.prototype, "onMusicVolumeChange", null),
    __decorate([g.Bound], f.prototype, "nextTrack", null),
    t.default = f
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/BindRow", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/BindingManager", "newui/component/Button", "newui/component/Component", "newui/component/IComponent", "newui/component/Text", "utilities/Async", "utilities/enum/Enums", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class h extends s.default {
        constructor(e, t, i) {
            super(e),
            this.classes.add("menu-bind-button"),
            this.on(s.ButtonEvent.Activate, this.onActivate),
            this.bind = t,
            this.bindCatcher = i,
            this.addButton(e=>e.classes.add("button-reset").setTooltip(e=>e.addHeading(e=>e.setText(n.default.MenuOptionsBindButtonResetTooltip)).setLocation(u.TooltipLocation.Mouse)).on(s.ButtonEvent.Activate, ()=>{
                r.bindingManager.resetBinding(this.bind),
                this.refresh()
            }
            )),
            this.addButton(e=>e.classes.add("button-delete").setTooltip(e=>e.addHeading(e=>e.setText(n.default.MenuOptionsBindButtonDeleteTooltip)).setLocation(u.TooltipLocation.Mouse)).on(s.ButtonEvent.Activate, ()=>{
                r.bindingManager.deleteBinding(this.bind),
                this.refresh()
            }
            )),
            this.addButton(e=>e.classes.add("button-add").setTooltip(e=>e.addHeading(e=>e.setText(n.default.MenuOptionsBindButtonAddTooltip)).setLocation(u.TooltipLocation.Mouse)).on(s.ButtonEvent.Activate, async()=>{
                const e = await this.getBind(n.default .MenuOptionsBindChooseAdd);
                r.bindingManager.addBinding(this.bind, e),
                this.refresh()
            }
            )),
            this.currentBinds = new d.Paragraph(e).classes.add("button-text", "menu-bind-current").appendTo(this);
            const l = r.bindingManager.getBindableType(t);
            l === a.BindableType.Mod && (this.modName = c.default.getMod(a.Bindable, a.Bindable[t], !0).config.name,
            new d.default(e).classes.add("menu-bind-mod").setText(o.default.generator(this.modName)).appendTo(this)),
            this.refresh()
        }
        refresh() {
            this.setText(this.getBindableName),
            this.currentBinds.dump();
            const e = this.getBindTranslations();
            if (e.length > 0) {
                this.currentBinds.setText();
                for (let t = 0; t < e.length; t++)
                    new d.default(this.api).setText(()=>[{
                        content: this.getBindTranslations()[t]
                    }]).appendTo(this.currentBinds)
            } else
                this.currentBinds.setText(n.default.MiscBindableNoBindings);
            return this.dataset.allText = `${this.getBindableName().getString()} ${this.getBindTranslations().join(" ")} ${this.modName ? this.modName : ""}`,
            this
        }
        getBindableName() {
            return new o.default(i.Dictionary.Bindable,this.bind)
        }
        getBindTranslations() {
            return r.bindingManager.getBindingsTranslation(this.bind, !0)
        }
        async getBind(e) {
            this.classes.add("changing"),
            this.bindCatcher.setText(e);
            const t = await this.bindCatcher.getBind();
            return this.classes.remove("changing"),
            t
        }
        async onActivate() {
            const e = await this.getBind(n.default .MenuOptionsBindChoose);
            r.bindingManager.setBinding(this.bind, e),
            this.refresh()
        }
    }
    __decorate([m.Bound], h.prototype, "getBindableName", null),
    __decorate([m.Bound], h.prototype, "onActivate", null),
    t.BindRow = h;
    class y extends l.default {
        constructor(e) {
            super(e),
            this.classes.add("menu-bind-catcher", "no-offset-parent", "hidden"),
            this.attributes.set("tabindex", "-1"),
            this.bindText = new d.Heading(e).appendTo(this)
        }
        async getBind() {
            this.show(),
            this.element.focus();
            const e = e=>this.onInput(e)
              , t = e=>(e.stopImmediatePropagation(),
            e.preventDefault(),
            !1);
            return new Promise((a,i)=>{
                this.resolve = (i=>{
                    this.element.removeEventListener("keyup", e),
                    this.element.removeEventListener("mouseup", e),
                    this.element.removeEventListener("wheel", e),
                    this.element.removeEventListener("keypress", t),
                    this.element.removeEventListener("keydown", t),
                    a(i)
                }
                ),
                this.element.addEventListener("keyup", e),
                this.element.addEventListener("mouseup", e),
                this.element.addEventListener("wheel", e),
                this.element.addEventListener("keypress", t),
                this.element.addEventListener("keydown", t)
            }
            )
        }
        setText(e) {
            this.bindText.setText(e)
        }
        onInput(e) {
            return p.sleep(10).then(()=>{
                this.element.blur(),
                this.hide(),
                this.api.getVisibleScreen().element.focus();
                const t = [];
                e.shiftKey && t.push(r.KeyModifier.Shift),
                e.altKey && t.push(r.KeyModifier.Alt),
                e.ctrlKey && t.push(r.KeyModifier.Control);
                const a = {
                    modifiers: t
                };
                e instanceof KeyboardEvent ? a.key = e.code || e.key : e instanceof WheelEvent ? a.mouseButton = e.deltaY < 0 ? "Up" : "Down" : e instanceof MouseEvent && (a.mouseButton = e.button),
                this.resolve(a)
            }
            ),
            e.preventDefault(),
            e.stopImmediatePropagation(),
            !1
        }
    }
    t.BindCatcher = y
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/BindingsMenu", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/BindingManager", "newui/component/IComponent", "newui/component/Input", "newui/component/LabelledRow", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/options/BindRow", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class g extends d.default {
        constructor(e) {
            super(e, "bindings"),
            this.bindSections = {},
            this.setTitle(e=>e.setText(n.default.MenuBindings)),
            this.setDescription(e=>e.setText(n.default.MenuBindingsDescription)),
            new u.LabelledRow(this.api).classes.add("bindings-filter").setLabel(e=>e.setText(n.default.MiscFilter)).append(new l.default(this.api).on(l.InputEvent.Change, this.filterBindRows)).setTooltip(e=>e.addParagraph(e=>e.setText(n.default.MenuOptionsTooltipControlsFilter)).setLocation(s.TooltipLocation.CenterRight)).appendTo(this),
            this.bindCatcher = new p.BindCatcher(this.api).appendTo(document.body),
            this.on("Remove", this.bindCatcher.remove);
            const t = {};
            for (const e of c.default.keys(a.Bindable)) {
                const i = a.Bindable[e];
                if (i === a.Bindable.None)
                    continue;
                const n = r.bindingManager.getBindableType(i);
                if (void 0 === n) {
                    h.default.warn(h.LogSource.NewUi)(`Bindable ${e} is invalid. Names must start with the name of a valid BindableType`);
                    continue
                }
                t[n] || (t[n] = []);
                const o = new p.BindRow(this.api,i,this.bindCatcher);
                t[n].push(o)
            }
            c.default.entries(a.BindableType).map(([e,a])=>new d.Tab(this.api,e).data.set("bindableType", e).setText(new o.default(i.Dictionary.BindableType,a)).setSection(this.bindSections[a] = new d.MenuSection(this.api).classes.add("menu-bind-section").setTitle(e=>e.setText(new o.default(i.Dictionary.BindableType,a))).addContent(...t[a]||[]))).collect(this.addTabs),
            this.modBindingsTab = this.getTabs().filter(e=>e.data.get("bindableType") === a.BindableType[a.BindableType.Mod]).collect(m.default.first()),
            this.on("Show", this.onShow)
        }
        onShow() {
            const e = [];
            for (const t of c.default.keys(a.Bindable)) {
                const i = a.Bindable[t];
                if (i === a.Bindable.None)
                    continue;
                const n = r.bindingManager.getBindableType(i);
                if (n !== a.BindableType.Mod)
                    continue;
                const o = new p.BindRow(this.api,i,this.bindCatcher);
                e.push(o)
            }
            this.bindSections[a.BindableType.Mod].content.dump(),
            e.length && this.bindSections[a.BindableType.Mod].content.append(e);
            const t = this.bindSections[a.BindableType.Mod].content.childCount > 0;
            return this.modBindingsTab.toggle(t),
            this.modBindingsTab.setDisabled(!t),
            this.bindSections[a.BindableType.Mod].toggle(t),
            this
        }
        filterBindRows(e, t) {
            const a = this.getSelector(t);
            for (const e of document.getElementsByClassName("menu-bind-button"))
                e.classList.toggle("hidden", !!a && !e.matches(a));
            for (const e of document.querySelectorAll(".menu-bind-section > .menu-section-content")) {
                const t = 0 !== e.querySelectorAll(":scope > :not(.hidden)").length;
                e.parentElement.classList.toggle("hidden", !t)
            }
        }
        getSelector(e) {
            const t = [];
            let a = "";
            for (let i of e.split(","))
                (i = i.trim()).startsWith("!") ? (i = i.slice(1),
                a += `:not([data-all-text^="${i}"i]):not([data-all-text*=" ${i}"i])`) : t.push(`[data-all-text^="${i}"i]`, `[data-all-text*=" ${i}"i]`);
            return 0 === t.length ? a : t.map(e=>`${e}${a}`).join(",")
        }
    }
    __decorate([y.Bound], g.prototype, "onShow", null),
    __decorate([y.Bound], g.prototype, "filterBindRows", null),
    t.default = g
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/TabControls", ["require", "exports", "game/IGame", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Button", "newui/component/CheckButton", "newui/component/IComponent", "newui/component/RangeInput", "newui/component/RangeRow", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/options/BindingsMenu", "newui/screen/screens/menu/menus/options/IOptionsTabs", "newui/util/Misc", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class y extends d.Tab {
        constructor(e) {
            super(e, c.OptionsTab.Controls),
            this.refreshables = [],
            this.setText(i.default.MenuOptionsTabControls),
            new d.MenuSection(e).setTitle(e=>e.setText(i.default.MenuOptionsHeadingControls)).addContent(new o.default(e).classes.add("has-icon-before", "button-edit").setText(i.default.MenuOptionsButtonConfigureBindings).on(o.ButtonEvent.Activate, m.menuSwitcher(()=>new p.default(e)))).addContent(new u.RangeRow(e).setLabel(e=>e.setText(i.default.MenuOptionsLabelDirectionTurnDelay)).editRange(e=>e.setMin(0).setMax(a.maximumTurnDelay * a.interval).setRefreshMethod(()=>Math.round(saveDataGlobal.options.directionTurnDelay * a.interval)).schedule(this.addRefreshable)).addDefaultButton(()=>Math.round(a.defaultTurnDelay * a.interval)).setDisplayValue(n.default.ui(i.default.MenuSharedValueTickSpeed).get).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsTooltipTurnDelay))).on(l.RangeInputEvent.Finish, (e,t)=>{
                saveDataGlobal.options.directionTurnDelay = Math.round(t / a.interval)
            }
            )).addContent(new u.RangeRow(e).setLabel(e=>e.setText(i.default.MenuOptionsLabelMouseTurnDelay)).editRange(e=>e.setMin(0).setMax(a.maximumTurnDelay * a.interval).setRefreshMethod(()=>Math.round(saveDataGlobal.options.mouseTurnDelay * a.interval)).schedule(this.addRefreshable)).addDefaultButton(()=>Math.round(a.defaultTurnDelay * a.interval)).setDisplayValue(n.default.ui(i.default.MenuSharedValueTickSpeed).get).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsTooltipMouseTurnDelay))).on(l.RangeInputEvent.Finish, (e,t)=>{
                saveDataGlobal.options.mouseTurnDelay = Math.round(t / a.interval)
            }
            )).addContent(new r.CheckButton(e).setText(i.default.MenuOptionsButtonAlternatingDirectionMovement).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonAllowAlternatingDirectionMovementTooltip))).setRefreshMethod(()=>saveDataGlobal.options.alternatingDirectionMovement).schedule(this.addRefreshable).on(r.CheckButtonEvent.Change, (e,t)=>{
                saveDataGlobal.options.alternatingDirectionMovement = t
            }
            )).schedule(this.setSection)
        }
        refresh() {
            for (const e of this.refreshables)
                e.refresh();
            return this
        }
        addRefreshable(e) {
            this.refreshables.push(e)
        }
    }
    __decorate([h.Bound], y.prototype, "addRefreshable", null),
    t.default = y
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/TabDeveloper", ["require", "exports", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Block", "newui/component/Button", "newui/component/CheckButton", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/options/IOptionsTabs", "utilities/enum/Enums", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class m extends l.Tab {
        constructor(e) {
            super(e, u.OptionsTab.Developer),
            this.refreshables = [],
            this.setText(a.default.MenuOptionsTabDeveloper),
            new l.MenuSection(this.api).setTitle(e=>e.setText(a.default.MenuOptionsHeadingDeveloper)).addContent(new r.CheckButton(this.api).setText(a.default.MenuOptionsButtonDeveloperMode).on(r.CheckButtonEvent.Change, this.toggleDeveloperMode).setRefreshMethod(()=>saveDataGlobal.options.developerMode).schedule(this.addRefreshable)).addContent(new r.CheckButton(this.api).classes.add("requires-developer-mode").setText(a.default.MenuOptionsButtonDeveloperModeContextMenu).on(r.CheckButtonEvent.Change, (e,t)=>{
                saveDataGlobal.options.developerModeContextMenu = t
            }
            ).setRefreshMethod(()=>saveDataGlobal.options.developerModeContextMenu).schedule(this.addRefreshable)).addContent(steamworks.isElectron() ? new o.default(this.api).setText(a.default.MenuOptionsButtonOpenLogsFolder).on(o.ButtonEvent.Activate, this.openLogsFolder) : void 0).addContent(steamworks.isElectron() ? new o.default(this.api).setText(a.default.MenuOptionsButtonToggleDevTools).on(o.ButtonEvent.Activate, this.toggleDeveloperTools) : void 0).addContent(new o.default(this.api).classes.add("warning").setText(a.default.MenuOptionsButtonReloadGame).on(o.ButtonEvent.Activate, this.reloadGame)).addContent(new n.Block(this.api).classes.add("requires-developer-mode").append(new s.Heading(this.api).setText(a.default.MenuOptionsDeveloperLogSourceFilterHeading)).append(...d.default .values(p.LogSource).map(e=>new r.CheckButton(this.api).classes.add("menu-clearbg").setText(i.default .generator(p.LogSource[e])).on(r.CheckButtonEvent.Change, this.toggleLogSource.bind(this, e)).setRefreshMethod(()=>!saveDataGlobal.options.consoleLogSourceFilter.disabledSources.includes(p.LogSource[e])).schedule(this.addRefreshable)))).schedule(this.setSection)
        }
        refresh() {
            for (const e of this.refreshables)
                e.refresh();
            return this
        }
        addRefreshable(e) {
            this.refreshables.push(e)
        }
        toggleLogSource(e, t, a) {
            const i = saveDataGlobal.options.consoleLogSourceFilter.disabledSources
              , n = p.LogSource[e];
            if (a) {
                const e = i.indexOf(n);
                e >= 0 && i.splice(e, 1)
            } else
                i.includes(n) || i.push(n);
            p.default.refresh()
        }
        toggleDeveloperTools() {
            steamworks.toggleDeveloperTools()
        }
        openLogsFolder() {
            steamworks.openLogsFolder()
        }
        toggleDeveloperMode(e, t) {
            saveDataGlobal.options.developerMode = t,
            document.documentElement.classList.toggle("developer-mode", t),
            p.default.refresh()
        }
        async reloadGame() {
            const e = await this.api.interrupt(a.default .MenuOptionsInterruptReloadGame).withConfirmation();
            e && steamworks.reload()
        }
    }
    __decorate([c.Bound], m.prototype, "addRefreshable", null),
    __decorate([c.Bound], m.prototype, "toggleDeveloperTools", null),
    __decorate([c.Bound], m.prototype, "openLogsFolder", null),
    __decorate([c.Bound], m.prototype, "toggleDeveloperMode", null),
    __decorate([c.Bound], m.prototype, "reloadGame", null),
    t.default = m
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/TabGameplay", ["require", "exports", "Enums", "language/dictionary/UiTranslation", "newui/component/Block", "newui/component/CheckButton", "newui/component/ChoiceList", "newui/component/IComponent", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/options/IOptionsTabs", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class c extends u.Tab {
        constructor(e) {
            super(e, d.OptionsTab.Gameplay),
            this.refreshables = [],
            this.setText(i.default.MenuOptionsTabGameplay),
            new u.MenuSection(this.api).setTitle(e=>e.setText(i.default.MenuOptionsHeadingGameplayOptions)).addContent(new o.CheckButton(this.api).setText(i.default.MenuOptionsButtonAutoGatherHarvest).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonAutoGatherHarvestTooltip))).setRefreshMethod(()=>saveDataGlobal.options.autoGatherHarvest).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "autoGatherHarvest", t)
            }
            )).addContent(new o.CheckButton(this.api).setText(i.default.MenuOptionsButtonDropOnGatherHarvest).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonDropOnGatherHarvestTooltip))).setRefreshMethod(()=>saveDataGlobal.options.dropOnGatherHarvest).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "dropOnGatherHarvest", t)
            }
            )).addContent(new o.CheckButton(this.api).setText(i.default.MenuOptionsButtonAutoPickup).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonAutoPickupTooltip))).setRefreshMethod(()=>saveDataGlobal.options.autoPickup).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "autoPickup", t)
            }
            )).addContent(new r.default(this.api).setChoices(new r.Choice(this.api,a.DropLocation.Facing).setText(i.default.MenuOptionsButtonDropLocationFacing), new r.Choice(this.api,a.DropLocation.Feet).setText(i.default.MenuOptionsButtonDropLocationFeet), new r.Choice(this.api,a.DropLocation.FeetWhenFacingBlocked).setText(i.default.MenuOptionsButtonDropLocationFeetWhenFacingBlocked)).setRefreshMethod(e=>e.findChoice(e=>e.id === saveDataGlobal.options.dropLocation)).schedule(this.addRefreshable).on(r.ChoiceListEvent.Choose, (e,t)=>{
                game.updateOption(localPlayer, "dropLocation", t.id)
            }
            )).addContent(new o.CheckButton(this.api).setText(i.default.MenuOptionsButtonWarnOnDangerousActions).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonWarnOnDangerousActionsTooltip))).setRefreshMethod(()=>saveDataGlobal.options.warnOnDangerousActions).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "warnOnDangerousActions", t)
            }
            )).addContent(new n.Block(this.api).append(new l.Heading(this.api).setText(i.default.MenuOptionsHeadingWarnWhenBreakingItems)).append(new o.CheckButton(this.api).classes.add("menu-clearbg").setText(i.default.MenuOptionsButtonWarnWhenBreakingItemsOnUse).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonWarnWhenBreakingItemsOnUseTooltip))).setRefreshMethod(()=>saveDataGlobal.options.warnWhenBreakingItems).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                saveDataGlobal.options.warnWhenBreakingItems = t
            }
            )).append(new o.CheckButton(this.api).classes.add("menu-clearbg").setText(i.default.MenuOptionsButtonWarnWhenBreakingItemsOnCraft).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonWarnWhenBreakingItemsOnCraftTooltip))).setRefreshMethod(()=>saveDataGlobal.options.warnWhenBreakingItemsOnCraft).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                saveDataGlobal.options.warnWhenBreakingItemsOnCraft = t
            }
            ))).addContent(new o.CheckButton(this.api).setText(i.default.MenuOptionsButtonKeepSortActive).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonKeepSortActiveTooltip))).setRefreshMethod(()=>saveDataGlobal.options.keepSortActive).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                saveDataGlobal.options.keepSortActive = t
            }
            )).addContent(new o.CheckButton(this.api).setText(i.default.MenuOptionsButtonProtectCraftingItemsInInventory).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonProtectCraftingItemsInInventoryTooltip))).setRefreshMethod(()=>saveDataGlobal.options.protectedCraftingItems).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "protectedCraftingItems", t)
            }
            )).addContent(new o.CheckButton(this.api).setText(i.default.MenuOptionsButtonProtectCraftingItemContainers).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonProtectCraftingItemsContainersTooltip))).setRefreshMethod(()=>saveDataGlobal.options.protectedCraftingItemContainers).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "protectedCraftingItemContainers", t)
            }
            )).addContent(new o.CheckButton(this.api).setText(i.default.MenuOptionsButtonUseAdjacentContainers).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonUseAdjacentContainersTooltip))).setRefreshMethod(()=>saveDataGlobal.options.useAdjacentContainers).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "useAdjacentContainers", t)
            }
            )).addContent(new o.CheckButton(this.api).setText(i.default.MenuOptionsButtonHideEquippedHeadgear).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonHideEquippedHeadgearTooltip))).setRefreshMethod(()=>saveDataGlobal.options.hideEquippedHeadgear).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "hideEquippedHeadgear", t)
            }
            )).addContent(new o.CheckButton(this.api).setText(i.default.MenuOptionsButtonEnableAutoSave).setTooltip(e=>e.setLocation(s.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(i.default.MenuOptionsButtonEnableAutoSaveTooltip))).setRefreshMethod(()=>saveDataGlobal.options.enableAutoSave).schedule(this.addRefreshable).on(o.CheckButtonEvent.Change, (e,t)=>{
                game.updateOption(localPlayer, "enableAutoSave", t)
            }
            )).schedule(this.setSection)
        }
        refresh() {
            for (const e of this.refreshables)
                e.refresh();
            return this
        }
        addRefreshable(e) {
            this.refreshables.push(e)
        }
    }
    __decorate([p.Bound], c.prototype, "addRefreshable", null),
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/creature/Corpses", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.CreatureType.Blood]: ["blood"],
        [a.CreatureType.FireElemental]: ["pile of embers"],
        [a.CreatureType.WaterBlood]: ["blood in water"]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/creature/Creatures", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.CreatureType.AcidSpitterDemon]: ["acid spitter demon", "A small, but fierce demonic-looking creature with sharp claws. Appears to spit an acidic fluid."],
        [a.CreatureType.AntelopeJackrabbit]: ["antelope jackrabbit", "A hare with formidable speed and agility. It is visually striking with its pointed ears and long muscular frame."],
        [a.CreatureType.Bear]: ["bear", "A hulking carnivorous mammal attracted to your scent. A deadly foe without protection."],
        [a.CreatureType.Blindfish]: ["blindfish", "A cave-dwelling, sightless fish. Hard to see in detail within the murky depths."],
        [a.CreatureType.Bogling]: ["bogling", "A foul, sulphurous-smelling writhing mass of vegetation, seemingly animated and alive."],
        [a.CreatureType.Chicken]: ["chicken", "A flightless fowl that seems fearful of your presence. Produces feathers, eggs, meat, and more."],
        [a.CreatureType.ClawWorm]: ["claw worm", "A wriggling creature with a massive claw-mouth, spawned forth from the ground due to vibrations caused by your gathering."],
        [a.CreatureType.Cod]: ["cod", "A common ocean fish, known for its nutritionally-dense, flaky white flesh."],
        [a.CreatureType.Drake]: ["drake", "A massive flightless lizard-dragon with large scales and the ability to breath fire. A fearsome foe."],
        [a.CreatureType.FireElemental]: ["fire elemental", "A creature that is seemingly composed of only fire. Appears to spread fire and destruction in its wake."],
        [a.CreatureType.GiantRat]: ["giant rat", "A rat of unusual size with sharp claws and piercing teeth. Keep at a distance without equipment."],
        [a.CreatureType.GiantSpider]: ["giant spider", "A gangly, frightful arachnid with the ability to poison you."],
        [a.CreatureType.Goat]: ["goat", "A hardy ruminant animal that has horns. A frisky, lively creature, but dangerous when provoked, ramming at its target with much force."],
        [a.CreatureType.GreyWolf]: ["grey wolf", "A tall canid animal. Able to tear into flesh with vicious abandon."],
        [a.CreatureType.Harpy]: ["harpy", "A large and unusual avian creature. Hostile to your presence."],
        [a.CreatureType.Hobgoblin]: ["hobgoblin", "An odd-looking humanoid. Dislikes your presence and appears to know how to use traps."],
        [a.CreatureType.Imp]: ["imp", "An odd hovering creature with thick wrinkled skin and sharp claws."],
        [a.CreatureType.JellyCube]: ["jelly cube", "An animated cube of gelatin. Its body jiggles to-and-fro as it moves towards you with hostile intent."],
        [a.CreatureType.Kraken]: ["kraken", "A wiry mass of thick tentacles, this lumbering sea-giant is angered by your existence."],
        [a.CreatureType.LavaBeetle]: ["lava beetle", "A horned beetle with a large abdomen, filled with liquid magma."],
        [a.CreatureType.LivingMushroom]: ["living mushroom", "A living mycological abomination. It appears to have a vengeful attitude towards you."],
        [a.CreatureType.LivingRock]: ["living rock", "A massive pile of rocks and minerals that appears to be alive, or semi-aware at least."],
        [a.CreatureType.Mudskipper]: ["mudskipper", "A slippery fish that appears to come to land for feeding. Its bulgy eyes and a large gaping mouth make it quite the sight."],
        [a.CreatureType.PirateGhost]: ["pirate ghost", "A glowing, ethereal visage of a pirate. It appears to be able to manifest a physical weapon to attack you."],
        [a.CreatureType.Rabbit]: ["rabbit", "A fast moving, peaceful herbivorous mammal. Useful for a good meal or as a pet."],
        [a.CreatureType.Rat]: ["rat", "A small and scurrying rodent. Afraid of predators, it will try to escape your grasp."],
        [a.CreatureType.Rattlesnake]: ["rattlesnake", "A dangerous rattling predator of the desert. The rattlesnake warns you with its vibrating tail as you pass by it."],
        [a.CreatureType.Sandcat]: ["sandcat", "A small, but ferocious feline that lives exclusively in desert areas."],
        [a.CreatureType.Scorpion]: ["scorpion", "A predatory arachnid, known for its tall segmented tail and ominous stinger."],
        [a.CreatureType.Shark]: ["shark", "A large blood-thirsty cartilaginous sea creature. Its fin juts from the waters, taunting you."],
        [a.CreatureType.SkeletalMage]: ["skeletal mage", "A robed, magic-casting skeletal humanoid. It appears to hold a wand; flicking it to cast its spells."],
        [a.CreatureType.Skeleton]: ["skeleton", "An animated pile of human, or human-like bones."],
        [a.CreatureType.Slime]: ["slime", "A bouncing globule of animated gelatin. It is not aware of your stirring."],
        [a.CreatureType.SlitherSucker]: ["slither sucker", "A wriggling foreign-looking worm-like creature. Its mouth is wide and is filled with suction modules and razor sharp teeth."],
        [a.CreatureType.Snake]: ["snake", "A slithering, poisonous reptile. Appears ambivalent to your encroachment."],
        [a.CreatureType.TimeSkitter]: ["time skitter", "An unusual spider-like creature that appears to be able to move through solid objects and move at incredible speeds."],
        [a.CreatureType.TrapdoorSpider]: ["trapdoor spider", "A large spider that appeared from an underground dwelling as you stumbled over it."],
        [a.CreatureType.VampireBat]: ["vampire bat", "A flying mammal with large rubbery wings. Appears to have a penchant for human blood."],
        [a.CreatureType.Zombie]: ["zombie", "A slow, but strong foul-smelling undead or diseased human. Appears to dislike the sun."]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/DamageTypes", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.DamageType.Blunt]: "blunt",
        [a.DamageType.Fire]: "fire",
        [a.DamageType.Piercing]: "piercing",
        [a.DamageType.Slashing]: "slashing",
        [a.DamageType.True]: "true"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/doodad/DoodadGroups", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.DoodadTypeGroup.Anvil]: ["anvil"],
        [a.DoodadTypeGroup.LitCampfire]: ["lit campfire"],
        [a.DoodadTypeGroup.LitFurnace]: ["lit furnace"],
        [a.DoodadTypeGroup.LitKiln]: ["lit kiln"],
        [a.DoodadTypeGroup.LitWaterStill]: ["lit water still"]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/doodad/DoodadItems", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = void 0
      , n = {
        [a.ItemType.ClayBrickWell]: [void 0, "A constructed well made of clay bricks, used to collect water."],
        [a.ItemType.CottonBedroll]: [void 0, "A soft sleeping mattress, sprawled out on the ground. Can be used to sleep or rest very comfortably."],
        [a.ItemType.FeatherBedroll]: [void 0, "A bedroll made with feathers and wrapped in fabric. Used for resting and sleeping in comfort on the ground."],
        [a.ItemType.Hammock]: [void 0, "A comfortable place to sleep, although not too sturdy. Crafted by bound cordage and hung off the ground."],
        [a.ItemType.HitchingPost]: [void 0, "A sturdy wooden post fastened with a rope. Creatures and animals can be tied to it to restrict their movement."],
        [a.ItemType.LeafBedroll]: [void 0, "A placed provisional bed with poor insulation and scratchy leaves, used for sleeping or resting."],
        [a.ItemType.SandstoneWell]: [void 0, "A round enclosure made of sandstone, built and extended deep into the ground to collect water."],
        [a.ItemType.StoneWell]: [void 0, "A stone-built enclosure used to trap and collect groundwater."]
    };
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/doodad/Doodads", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.DoodadType.Acid]: ["acid", "A neon-green ooze; boiling and bubbling into the ground."],
        [a.DoodadType.AloeVera]: ["aloe vera", "A succulent evergreen plant, known for its medicinal and antiseptic properties and its sharpened thick leaves."],
        [a.DoodadType.AnimalFatTorchStand]: ["animal fat torch stand", "An animal fat torch planted in the ground. Can be lit on fire for illumination."],
        [a.DoodadType.AppleTree]: ["apple tree", "A deciduous tree known for its sweet, pomaceous fruit; the apple."],
        [a.DoodadType.Badderlocks]: ["badderlocks", "A gathering of long seaweed, useful for eating or cordage."],
        [a.DoodadType.BarkTorchStand]: ["bark torch stand", "A bark torch placed in the ground, ready to be lit on fire when needed."],
        [a.DoodadType.Beggarticks]: ["beggarticks", "A grouping of bright yellow medicinal flowers."],
        [a.DoodadType.ButtonMushrooms]: ["button mushrooms", "A few possibly edible common-looking white mushrooms."],
        [a.DoodadType.Carrots]: ["carrots", "A grouping of green stalky leaves poking out of the ground, revealing just the tips of their root vegetable below ground."],
        [a.DoodadType.CaveEntrance]: ["cave entrance", "An entrance into the the dark caverns below."],
        [a.DoodadType.Chives]: ["chives", "A bunch of bright green chives planted in to the ground."],
        [a.DoodadType.ClayBrickWall]: ["clay brick wall", "A wall made from fired clay bricks."],
        [a.DoodadType.ClayCampfire]: ["clay campfire", "An organized circle of clay bricks, used to contain a fire."],
        [a.DoodadType.ClayFurnace]: ["clay furnace", "A clay furnace for creating an enclosed high-temperature fire."],
        [a.DoodadType.ClayKiln]: ["clay kiln", "A high-temperature fire enclosure made from clay."],
        [a.DoodadType.ClayWaterStill]: ["clay water still", "A clay water still, ready to be lit to desalinate water."],
        [a.DoodadType.Clematis]: ["clematis", "A wiry tangle of thin vines with leaves."],
        [a.DoodadType.CoconutTree]: ["coconut tree", "A tall palm tree, able to produce life-sustaining coconut fruit when mature."],
        [a.DoodadType.CopperAnvil]: ["copper anvil", "A copper anvil used for blacksmithy. Typically used in addition with a fire source."],
        [a.DoodadType.CopperChest]: ["copper chest", "A storage chest made from copper, used to deposit food items for reduced decay, among other uses."],
        [a.DoodadType.CornStalks]: ["corn stalks", "The tall stalks of maize, producing ears of edible sweet kernels."],
        [a.DoodadType.Cotton]: ["cotton", "A white and fluffy cotton plant, an indispensable plant for fiber."],
        [a.DoodadType.CreatureIdol]: ["creature idol", "An odd mass of organs. A hum emanates from it, seemingly attracting creatures."],
        [a.DoodadType.CucumberPlant]: ["cucumber plant", "A creeping cucumber vine, known for producing soft, water-rich gourds."],
        [a.DoodadType.CypressTree]: ["cypress tree", "A tall and gangly conifer tree. Although sparse in foliage, it makes up for it with healthy supply of hardwood."],
        [a.DoodadType.FlyAmanita]: ["fly amanita", "A menacing red spotted mushroom."],
        [a.DoodadType.Grass]: ["grass", "A small mound of growing grass."],
        [a.DoodadType.IronAnvil]: ["iron anvil", "An iron anvil used for metalworking. Used in addition with a fire source."],
        [a.DoodadType.IronChest]: ["iron chest", "An iron container for storing items and reducing food decay."],
        [a.DoodadType.JoshuaTree]: ["joshua tree", "A desert tree with a distinctive look that produces leaves suitable for cordage and nutritious fruit."],
        [a.DoodadType.Lettuce]: ["lettuce", "An edible leafy plant that could almost be mistaken for a weed when growing."],
        [a.DoodadType.LitAnimalFatTorchStand]: ["lit animal fat torch stand", "A lit animal fat torch lodged in the ground, providing light and heat."],
        [a.DoodadType.LitBarkTorchStand]: ["lit bark torch stand", "A bark torch stuck in the ground and lit on fire, providing illumination."],
        [a.DoodadType.LitClayCampfire]: ["lit clay campfire", "A lit fire inside an enclosure of clay bricks."],
        [a.DoodadType.LitClayFurnace]: ["lit clay furnace", "A lit clay furnance, ready to be used in production."],
        [a.DoodadType.LitClayKiln]: ["lit clay kiln", "A lit clay kiln, ready for firing items."],
        [a.DoodadType.LitClayWaterStill]: ["lit clay water still", "A lit clay water still, desalinating water through evaporation."],
        [a.DoodadType.LitPoleTorchStand]: ["lit pole torch stand", "A wooden pole stuck in the ground and lit on fire."],
        [a.DoodadType.LitSandstoneCampfire]: ["lit sandstone campfire", "A lit fire inside an enclosure of sandstone."],
        [a.DoodadType.LitSandstoneFurnace]: ["lit sandstone furnace", "A lit sandstone furnance, ready to be used in production."],
        [a.DoodadType.LitSandstoneKiln]: ["lit sandstone kiln", "A lit sandstone kiln, ready for firing items."],
        [a.DoodadType.LitSandstoneWaterStill]: ["lit sandstone water still", "A lit sandstone water still, desalinating water through evaporation."],
        [a.DoodadType.LitStoneCampfire]: ["lit stone campfire", "A lit fire inside an enclosure of rocks."],
        [a.DoodadType.LitStoneFurnace]: ["lit stone furnace", "A lit stone furnance, ready to be used in production."],
        [a.DoodadType.LitStoneKiln]: ["lit stone kiln", "A lit stone kiln, ready for firing items."],
        [a.DoodadType.LitStoneWaterStill]: ["lit stone water still", "A lit stone water still, desalinating water through evaporation."],
        [a.DoodadType.LockedWoodenChest]: ["locked wooden chest", "A locked chest, too heavy to move. Able to be broken or lockpicked."],
        [a.DoodadType.MapleTree]: ["maple tree", "A common maple tree, known for its distinctive leaf and seed shape."],
        [a.DoodadType.MilkThistles]: ["milk thistles", "A couple milk thistles, known for their medicinal properties."],
        [a.DoodadType.OrnateWoodenChest]: ["ornate wooden chest", "A decorative chest used for storing items and preserving perishables."],
        [a.DoodadType.PileOfRocks]: ["pile of rocks", "A mass of rocks, stuck into the ground."],
        [a.DoodadType.Pineapple]: ["pineapple", "A large spikey plant, with a ripened pineapple fruit contained inside when mature."],
        [a.DoodadType.PoisonIvy]: ["poison ivy", "A creeping plant with leaves of three."],
        [a.DoodadType.PoleTorchStand]: ["pole torch stand", "A wooden pole stuck in the ground, ready for being lit to provide illumination."],
        [a.DoodadType.PotatoPlant]: ["potato plant", "Unassuming leaves poking out of the ground, revealing just the tips of edible tubers underneath."],
        [a.DoodadType.PricklyPears]: ["prickly pears", "Spined cacti, known for its edible fruit and pads with their pointy needles."],
        [a.DoodadType.Pumpkin]: ["pumpkin", "A heavy orange squash, filled with edible fibrous pulp and seeds."],
        [a.DoodadType.RaspberryBush]: ["raspberry bush", "A small bush, bearing small amounts of raspberries."],
        [a.DoodadType.SaguaroCactus]: ["saguaro cactus", "A tall and hefty cactus plant, known for growing in arid desert regions."],
        [a.DoodadType.SandstoneCampfire]: ["sandstone campfire", "An organized circle of sandstone, used to contain a fire."],
        [a.DoodadType.SandstoneFurnace]: ["sandstone furnace", "A sandstone furnace for creating an enclosed high-temperature fire."],
        [a.DoodadType.SandstoneKiln]: ["sandstone kiln", "A high-temperature fire enclosure made from sandstone."],
        [a.DoodadType.SandstoneWall]: ["sandstone wall", "A robust wall created from sandstone."],
        [a.DoodadType.SandstoneWaterStill]: ["sandstone water still", "A sandstone water still, ready to be lit to desalinate water."],
        [a.DoodadType.SetDeadfall]: ["set deadfall", "A constructed deadfall, ready to fall and crush a creature."],
        [a.DoodadType.SetExplosiveTrap]: ["set explosive trap", "An elaborate trap, ready to be triggered and exploded by touch."],
        [a.DoodadType.SetHobgoblinSnare]: ["set hobgoblin snare", "A hobgoblin constructed snare, ready to catch your feet or an unsuspecting creature."],
        [a.DoodadType.SetSnare]: ["set snare", "A constructed snare, ready to trap a creature's appendage."],
        [a.DoodadType.SkeletalRemains]: ["skeletal remains", "A pile of bones that appear to be stirring."],
        [a.DoodadType.SolarStill]: ["solar still", "A constructed solar still, desalinating water through evaporation."],
        [a.DoodadType.SpruceTree]: ["spruce tree", "A large and robust spruce tree. Known for its whorled branches and conical form."],
        [a.DoodadType.StoneAnvil]: ["stone anvil", "A stone anvil used primarily for metalworking and used in conjunction with a fire source."],
        [a.DoodadType.StoneCampfire]: ["stone campfire", "An organized circle of rocks, used to contain a fire."],
        [a.DoodadType.StoneFurnace]: ["stone furnace", "A rock furnace for creating an enclosed high-temperature fire."],
        [a.DoodadType.StoneKiln]: ["stone kiln", "A high-temperature fire enclosure made from stone."],
        [a.DoodadType.StoneWall]: ["stone wall", "A hardy wall built from rocks."],
        [a.DoodadType.StoneWaterStill]: ["stone water still", "A stone water still, ready to be lit to desalinate water."],
        [a.DoodadType.SugarCaneStalks]: ["sugar cane stalks", "Tall, hardy stalks of sugar cane. Can be gathered for chewing or refining into sugar."],
        [a.DoodadType.Switchgrass]: ["switchgrass", "A collection of long grass, suitable for cordage."],
        [a.DoodadType.TomatoPlant]: ["tomato plant", "Nightshade plants that produce large, edible fruit that turn red when ripe."],
        [a.DoodadType.Tumbleweed]: ["tumbleweed", "A common weed, notorious for becoming dry and brittle after its maturity, breaking free from its roots and traveling in high winds, spreading its seeds."],
        [a.DoodadType.Wheat]: ["wheat", "A long grass, cultivated for its protein-rich cereal grain when dried."],
        [a.DoodadType.WoodenChest]: ["wooden chest", "A chest used for stockpiling items and preserving food."],
        [a.DoodadType.WoodenDoor]: ["wooden door", "A sturdy door, used to keep unwanted creatures out."],
        [a.DoodadType.WoodenDoorOpen]: ["open wooden door", "An open door, allowing anything to enter."],
        [a.DoodadType.WoodenFence]: ["wooden fence", "A set of panels, usually used to keep creatures inside."],
        [a.DoodadType.WoodenGate]: ["wooden gate", "A gate, used as a passage through connected fences."],
        [a.DoodadType.WoodenGateOpen]: ["open wooden gate", "An opened gate, allowing anything to escape or enter."],
        [a.DoodadType.WoodenWall]: ["wooden wall", "A wall crafted by connecting wooden logs together."],
        [a.DoodadType.WroughtIronAnvil]: ["wrought iron anvil", "A wrought iron anvil, used for blacksmithing with a fire source."],
        [a.DoodadType.WroughtIronChest]: ["wrought iron chest", "A large chest, used for storage and keeping edibles fresher."]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/doodad/Growth", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.GrowingStage.Germinating]: "germinating",
        [a.GrowingStage.Seedling]: "seedling",
        [a.GrowingStage.Vegetative]: "vegetative",
        [a.GrowingStage.Budding]: "budding",
        [a.GrowingStage.Flowering]: "flowering",
        [a.GrowingStage.Ripening]: "ripening",
        [a.GrowingStage.Dead]: "dead"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/doodad/GrowthFungus", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.GrowingStage.Germinating]: "germinating",
        [a.GrowingStage.Seedling]: "spreading",
        [a.GrowingStage.Vegetative]: "forming",
        [a.GrowingStage.Budding]: "young",
        [a.GrowingStage.Flowering]: "fruiting",
        [a.GrowingStage.Ripening]: "full",
        [a.GrowingStage.Dead]: "dead"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/game/Actions", ["require", "exports", "action/IAction"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.ActionType.AddFuel]: ["Add Fuel", ""],
        [a.ActionType.Apply]: ["Apply", "Consumed on use. Used to apply to your skin to provide protection or treatment to injuries or ailments."],
        [a.ActionType.Attack]: ["Attack", ""],
        [a.ActionType.Build]: ["Build", "Attempt to construct or assemble the item on the tile you are facing towards."],
        [a.ActionType.Carve]: ["Carve", "Used to carve creature corpses or to remove objects attached to the ground."],
        [a.ActionType.Cast]: ["Cast", "Find a fish in a body of water and attempt to cast your line or net to catch it."],
        [a.ActionType.CloseContainer]: ["Close Container", ""],
        [a.ActionType.CloseDoor]: ["Close Door", ""],
        [a.ActionType.Craft]: ["Craft", ""],
        [a.ActionType.Decode]: ["Decode", "Used for attempting to read the map. Use by the treasure location to reveal how far or close you are."],
        [a.ActionType.Dig]: ["Dig", "Used to dig up resources and items from the ground."],
        [a.ActionType.Disassemble]: ["Disassemble", ""],
        [a.ActionType.Dismantle]: ["Dismantle", ""],
        [a.ActionType.DrawMap]: ["Draw Map", "Draw a map using your skill in cartography of the surrounding area."],
        [a.ActionType.DrinkCure]: ["Drink Cure", "Consumed on use. Used to cure poisoning while sometimes providing other health benefits."],
        [a.ActionType.DrinkInFront]: ["Drink in Front", ""],
        [a.ActionType.DrinkItem]: ["Drink", "Consumed on use. Will reduce your thirst; however, will provide negative effects when drinking sea/unpurified water."],
        [a.ActionType.Drop]: ["Drop", ""],
        [a.ActionType.Eat]: ["Eat", "Consumed on use. May provide benefits to hunger, thirst, health and stamina; however, may reduce them as well depending on the food."],
        [a.ActionType.Equip]: ["Equip", ""],
        [a.ActionType.Extinguish]: ["Extinguish", "Douse the torch, extinguishing the flame."],
        [a.ActionType.Fire]: ["Fire", "Using a mixture of black powder along with a bullet, you may fire this weapon."],
        [a.ActionType.Gather]: ["Gather", "Can be used directly to gather from an adjacent resource tile/object. Gathering will attempt to gather everything, destroying the plant or mushroom in the process."],
        [a.ActionType.GatherMilk]: ["Gather Milk", "Attempt to gather milk from a creature you are facing."],
        [a.ActionType.GatherTreasure]: ["Gather Treasure", "Attempt to gather a treasure in the vicinity of use based on a decoded treasure map. Range of gather is dependent on your mining skill."],
        [a.ActionType.GatherWater]: ["Gather Water", "Used to gather water into the item."],
        [a.ActionType.Grasp]: ["Grasp", "Used to pick-up items using another item for safety reasons such as grasping items in a fire."],
        [a.ActionType.Harvest]: ["Harvest", "Can be used to harvest an adjacent plant or mushroom without destroying the plant itself, harvesting just the produce."],
        [a.ActionType.Heal]: ["Heal", "Consumed on use. Used to restore a varied amount of health."],
        [a.ActionType.HealOther]: ["Heal Other", "Consumed on use. Used to restore a varied amount of health to a creature or human entity."],
        [a.ActionType.Hitch]: ["Hitch", "Used when facing a creature that is adjacent to a hitching post to force the creature to stay put."],
        [a.ActionType.Idle]: ["Idle", ""],
        [a.ActionType.Ignite]: ["Ignite", "Use this item on a fire source to start it on fire."],
        [a.ActionType.Jump]: ["Jump", ""],
        [a.ActionType.Learn]: ["Learn", "Consumed on use. Reading usually provides useful knowledge."],
        [a.ActionType.LockPick]: ["Lock Pick", "Used to unlock locked objects."],
        [a.ActionType.Move]: ["Move", ""],
        [a.ActionType.MoveItem]: ["Move Item", ""],
        [a.ActionType.MoveTo]: ["Move To", ""],
        [a.ActionType.Offer]: ["Offer", ""],
        [a.ActionType.OpenBottle]: ["Open Bottle", "Consumed on use. Using this will open it, providing new and unknown items."],
        [a.ActionType.OpenContainer]: ["Open Container", "Using this will open it where you may drag and drop items to and from. Weight reduction and decay reduction bonuses may apply to items inside."],
        [a.ActionType.OpenDoor]: ["Open Door", ""],
        [a.ActionType.Paddle]: ["Paddle", "Used to travel over water without getting your feet wet. Your speed is not reduced in water while paddling."],
        [a.ActionType.Pet]: ["Pet", ""],
        [a.ActionType.Pickup]: ["Pick-up", ""],
        [a.ActionType.PickupAllItems]: ["Pickup All Items", ""],
        [a.ActionType.PickupItem]: ["Pickup Item", ""],
        [a.ActionType.PlaceDown]: ["Place Down", "Place the item down to the adjacent tile so it can be used on the ground instead of directly from your inventory."],
        [a.ActionType.Plant]: ["Plant", "Attempts to plant the item on the tile you are facing towards. Some plants may require certain ground types or conditions to be planted."],
        [a.ActionType.Pour]: ["Pour", "Pour on fire to extinguish the flames, pour inside a water still to begin water filtration, pour on a suitable plant to increase its health, or just simply empty out."],
        [a.ActionType.PourOnYourself]: ["Pour on Yourself", "Liquid is consumed on use. Used to sooth burn injuries."],
        [a.ActionType.Preserve]: ["Preserve", "Used with food items to extend their life and decay rate."],
        [a.ActionType.Read]: ["Read", "Open the book and read the contents."],
        [a.ActionType.Reinforce]: ["Reinforce", "Consumed on use. Use while facing a damaged item to attempt to increase the overall maximum and minimum durability. Success based on skill used to make the item."],
        [a.ActionType.Release]: ["Release", ""],
        [a.ActionType.Rename]: ["Rename", ""],
        [a.ActionType.Repair]: ["Repair", "Use while facing a damaged item to attempt to repair it. Success based on skill used to make the item."],
        [a.ActionType.Rest]: ["Rest", "Used to rest for a period of time to regain health and stamina. You will stop resting when reaching full stamina."],
        [a.ActionType.RubClockwise]: ["Rub Clockwise", "Rubbing this item manifests its effects to the holder."],
        [a.ActionType.RubCounterclockwise]: ["Rub Counterclockwise", "Rubbing this item manifests its effects to the holder."],
        [a.ActionType.SailToCivilization]: ["Sail To Civilization", "After collecting all the pieces of treasure, you can return to civilization and bask in the glory of your riches and fame. You can always return back to these lands afterwards."],
        [a.ActionType.SetDown]: ["Set Down", "Using this item will place it on top of whatever tile is present in your facing direction. This is different than just dropping the item."],
        [a.ActionType.Shoot]: ["Shoot", "You can shoot arrows with this item."],
        [a.ActionType.Sleep]: ["Sleep", "Used to sleep for a period of time to regain health and stamina. Duration is based on camping skill and time of day. A bonus to all effects (including length) will be granted if facing a fire or lit object. Hunger and dehydration increase slower while sleeping."],
        [a.ActionType.Sling]: ["Sling", "You can sling bullets with this item."],
        [a.ActionType.SmotherFire]: ["Smother Fire", "Using this will extinguish fires as well as cover the facing tile with this item."],
        [a.ActionType.Squeeze]: ["Squeeze", "Consumed on use. Spews a stream of fire in your facing direction."],
        [a.ActionType.StartFire]: ["Start Fire", "Used to start a fire. Use on campfires, furnaces, etc. to light them or on an empty tile. Using this action may require kindling, tinder and a fuel item in your inventory depending on the circumstance."],
        [a.ActionType.StokeFire]: ["Stoke Fire", "Used on a fire source to increase the strength of the flame."],
        [a.ActionType.Tame]: ["Tame", ""],
        [a.ActionType.Teleport]: ["Teleport", "With a flick of the wand, teleport to a location in front of where you are facing."],
        [a.ActionType.TellTime]: ["Tell Time", "Used to measure the time of day or night."],
        [a.ActionType.Throw]: ["Throw", ""],
        [a.ActionType.Till]: ["Till", "Use while facing a tile you wish to till, granting it properties for better plant growth."],
        [a.ActionType.Trade]: ["Trade", ""],
        [a.ActionType.Transmogrify]: ["Transmogrify", "Use while facing an equippable item to attempt to infuse with magical properties."],
        [a.ActionType.TraverseTheSea]: ["Traverse the Sea", "Used to travel to new, unexplored lands, leaving behind your current surroundings."],
        [a.ActionType.Unequip]: ["Unequip", ""],
        [a.ActionType.Unhitch]: ["Unhitch", "Used when facing a creature that is hitched to free them."],
        [a.ActionType.UpdateDirection]: ["Update Direction", ""],
        [a.ActionType.UseItem]: ["Use Item", ""]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/game/Difficulties", ["require", "exports", "game/Difficulty"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.Difficulty.Hardcore]: ["Hardcore", "The default and definitive way to play. Death is permanent."],
        [a.Difficulty.Casual]: ["Casual", "Dying will respawn you in the last place you rested or slept, with your items dropped at the location of your demise. Most creatures are neutral/peaceful unless attacked."],
        [a.Difficulty.Challenge]: ["Challenge", 'Randomized difficulty modifiers and a unique set of quests, intended for quick play sessions. Saving is disabled in this mode. Choose the "Daily" option to compete with others or yourself for highscores.'],
        [a.Difficulty.Custom]: ["Custom", "Customize your game, choosing from a large set of difficulty modifiers."]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/game/Messages", ["require", "exports", "language/dictionary/Message"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.default.None]: "",
        [a.default.Aberrant]: "{0?aberrant }{1}",
        [a.default.AboutHours]: "It appears you have {0} for about {1} {2}.",
        [a.default.AddedFuelToFire]: "You added the fuel to the fire! The fire grows stronger.",
        [a.default.AddedFuelToTorch]: "You added the fuel to the torch.",
        [a.default.AddFuel]: "Add Fuel",
        [a.default.AddToQuickslot]: "Add to Quickslot",
        [a.default.Advanced]: "Advanced",
        [a.default.All]: "all",
        [a.default.AllEquipmentUnEquipped]: "All equipment has been unequipped.",
        [a.default.AlreadyDesalinatedWaterInStill]: "There is already desalinated water in this still!",
        [a.default.AlreadyFullyRepaired]: "{0} is already fully repaired.",
        [a.default.AlreadyPreserved]: "{0} is already well preserved.",
        [a.default.AlreadyWaterInStill]: "There is already water in this still!",
        [a.default.AnUnknownItem]: "an unknown item",
        [a.default.AppearedNotEffectiveForGathering]: "{0} did not appear to be the most effective for gathering this resource.",
        [a.default.AppearsToBeAberrant]: "{0} seems abnormally territorial and aggressive. It may be particularly vicious.",
        [a.default.ArmorAppeared]: "Your armor appeared to be {0} to the attack.",
        [a.default.ArmorProtectedFromInjuryAgainst]: "Your armor protected you from injury against the {0}.",
        [a.default.Attack]: "Attack",
        [a.default.AttemptedToDropAllIntoFire]: "You attempted to drop {0} into the fire.",
        [a.default.AttemptedToPlaceAllOnGround]: "You attempted to place {0} on the ground.",
        [a.default.AttemptToTill]: "You attempt to {0} the {1}, but do not produce any results yet.",
        [a.default.Back]: "Back",
        [a.default.BadlyBurnedLostHealth]: "You have been badly burned! You have lost {0} health!",
        [a.default.BarteringSkillsProvided]: "Your bartering skills have provided you with an extra {0} barter credit.",
        [a.default.BasedOnItSeems]: "based on {0}, it seems",
        [a.default.BeenPoisoned]: "You have been poisoned!",
        [a.default.BeginSleeping]: "You begin sleeping...",
        [a.default.BeginUsingRaft]: "You begin using a raft.",
        [a.default.Belt]: "Belt",
        [a.default.Best]: "Best",
        [a.default.BleedingHasStopped]: "The bleeding has stopped!",
        [a.default.BleedingProfusely]: "You start bleeding profusely!",
        [a.default.BleedingToDeathLostHealth]: "You are bleeding to death! You have lost {0} health!",
        [a.default.Blunt]: "Blunt",
        [a.default.BookBlank]: "The rest of the book was blank.",
        [a.default.BookContains]: "Upon opening the {0}, {1} {2} fell from it. {3}",
        [a.default.BookCrumbles]: "Upon opening the {0}, it strangely crumbles to dust and small pieces.",
        [a.default.BookDiagrams]: "The rest of the book contained strange diagrams.",
        [a.default.BookEmpty]: "You open the {0} to reveal that it is completely empty.",
        [a.default.BookNothing]: "The {0} contained nothing of note.",
        [a.default.BookOpen]: 'You open the {0}, "{1}".',
        [a.default.BookScribbles]: "The rest of the book contained incomprehensible scribbles and notes.",
        [a.default.BothEffectiveIneffective]: "both effective and ineffective",
        [a.default.BothHands]: "hands",
        [a.default.BrokeIntoPieces]: "{0} could no longer be repaired and broke into pieces.",
        [a.default.BrokenOnImpact]: "{0} has broken on impact!",
        [a.default.BrokenWhileFiring]: "{0} has broken while firing!",
        [a.default.Build]: "build",
        [a.default.Burned]: "burned",
        [a.default.CannotAddAnyMoreFuel]: "You cannot add any more fuel to {0}.",
        [a.default.CannotBePerformedOverWater]: "This action cannot be performed over water.",
        [a.default.CannotBePreserved]: "{0} cannot be preserved.",
        [a.default.CannotBeReinforced]: "{0} cannot be reinforced.",
        [a.default.CannotBeRepaired]: "{0} cannot be repaired.",
        [a.default.CannotBeTamed]: "{0} cannot be tamed.",
        [a.default.CannotBuildHere]: "You cannot build {0} here!",
        [a.default.CannotDoThatHere]: "You cannot {0} here!",
        [a.default.CannotDropHere]: "You cannot drop {0} here!",
        [a.default.CannotEquipThatThere]: "You cannot equip {0} there!",
        [a.default.CannotFishFor]: "You cannot fish for {0}.",
        [a.default.CannotHere]: "You cannot {0} anything here.",
        [a.default.CannotInWater]: "You cannot {0} items in water.",
        [a.default.CannotLeave]: "You cannot leave your friends and foes behind.",
        [a.default.CannotPickupWhenFull]: "You cannot pick {0} up while it is full of water.",
        [a.default.CannotPickUpWhileLit]: "You cannot pick {0} up while it is lit.",
        [a.default.CannotPickUpWithItemsInside]: "You cannot pick {0} up with items inside!",
        [a.default.CannotPlaceContainerInItself]: "You cannot place a container inside itself.",
        [a.default.CannotPlaceHere]: "You cannot place {0} here!",
        [a.default.CannotPlaceThatFromHere]: "You cannot place {0} from here.",
        [a.default.CannotPlaceThatHere]: "You cannot place {0} here.",
        [a.default.CannotPlantHereTilled]: "You cannot plant {0} here with the {1} untilled.",
        [a.default.CannotRepairWhileLit]: "You cannot repair {0} while it is lit!",
        [a.default.CannotRestHere]: "You cannot rest here.",
        [a.default.CannotSeeHere]: "You cannot see anything here.",
        [a.default.CannotSleepHere]: "You cannot sleep here.",
        [a.default.CannotStartFireHere]: "You cannot start a fire here!",
        [a.default.CannotToTellTime]: "You cannot tell time from here!",
        [a.default.CarryingTooMuchWeight]: "You are carrying too much weight!",
        [a.default.CartographyDirection]: "You believe the treasure is to the {0}.",
        [a.default.CartographyDirectionUnsure]: "You are unsure of which direction this treasure is in.",
        [a.default.CartographyDistanceHighSkillExactDistance]: "The treasure should be {0?around {num(as words):{0}} {reformat({0},false):step} away:here}.",
        [a.default.CartographyDistanceHighSkillFarAway]: "The treasure is very far away.",
        [a.default.CartographyDistanceHighSkillInRegion]: "The treasure is likely in this region.",
        [a.default.CartographyDistanceHighSkillNearby]: "The treasure is near.",
        [a.default.CartographyDistanceLowSkillNearby]: "You believe you could be getting closer to the treasure.",
        [a.default.CartographyDistanceLowSkillUnsure]: "You are unsure of where the treasure could be.",
        [a.default.CartographyDistanceMedSkillFarAway]: "You believe the treasure is far away.",
        [a.default.CartographyDistanceMedSkillNearby]: "You believe the treasure might be near.",
        [a.default.CartographyDistanceMedSkillVeryClose]: "You believe the treasure is very close.",
        [a.default.CarvedUpCorpse]: "You carved and hacked up the corpse.",
        [a.default.CarveWithTool]: "Carve With Tool",
        [a.default.Carving]: "carving",
        [a.default.CastYourLine]: "You cast your line out {0} spaces.",
        [a.default.Category]: "Category",
        [a.default.CaughtFish]: "You caught {0}!",
        [a.default.ChatBanCommand]: "'{0}' has been banned.",
        [a.default.ChatBannedCommand]: "Banned players: {0}",
        [a.default.ChatCommandsCommand]: "Chat commands: {0}",
        [a.default.ChatPingCommand]: "Your ping is {0}ms.",
        [a.default.ChatPlayerMessage]: "{#--text-color-player:{0}}: {1}",
        [a.default.ChatPlayersCommand]: "{0} players connected: {1}",
        [a.default.ChatServerMessage]: "{#--text-color-server:Server}: {1}",
        [a.default.ChatUnbanCommand]: "'{0}' has been unbanned.",
        [a.default.ChatUnknownCommand]: '"{0}" is an unknown command.',
        [a.default.Chest]: "Chest",
        [a.default.ClearMessages]: "Clear Messages",
        [a.default.Clockwise]: "clockwise",
        [a.default.CloseContainer]: "Close Container",
        [a.default.CloseDoor]: "Close Door",
        [a.default.CloseToBeingDestroyed]: "{0} is close to being destroyed.",
        [a.default.CollectObjectWithHands]: "Collect Object With Hands",
        [a.default.Consumed]: "Consumed",
        [a.default.Container]: "Container",
        [a.default.Cook]: "cook",
        [a.default.Cooked]: "cooked",
        [a.default.CopySelectedText]: "Copy Selected Text",
        [a.default.CorpseOf]: "{0} corpse",
        [a.default.CorpseOfNamed]: "the corpse of {0}",
        [a.default.CouldNotDecipher]: "You could not decipher the map.",
        [a.default.Counterclockwise]: "counterclockwise",
        [a.default.Craft]: "craft",
        [a.default.Crafted]: "crafted",
        [a.default.Crafts]: "Crafts",
        [a.default.CreatureAngered]: "angered",
        [a.default.CreatureAppears]: "{0} appears!",
        [a.default.CreatureAppeased]: "appeased",
        [a.default.CreatureIdolAttractedCreature]: "The creature idol attracted another creature.",
        [a.default.CreatureUntamed]: "{0} has become untamed.",
        [a.default.CuredYourPoison]: "You have cured your poison!",
        [a.default.Cut]: "cut",
        [a.default.DamageAppeared]: "{0} damage appeared to be {1}.",
        [a.default.DamagedByPouring]: "You damaged {0} by pouring out the {1}.",
        [a.default.DayQuarter1]: "It is currently in the first quarter of the day.",
        [a.default.DayQuarter2]: "It is currently in the second quarter of the day.",
        [a.default.DayQuarter3]: "It is currently in the third quarter of the day.",
        [a.default.DayQuarter4]: "It is currently in the fourth quarter of the day.",
        [a.default.DealtNoDamageToYou]: "{0} has dealt no damage to you.",
        [a.default.DeathBy]: "by {0}",
        [a.default.DeathByBleeding]: "by bleeding out",
        [a.default.DeathByBurning]: "of burn injuries",
        [a.default.DeathByChallengeWinner]: "by natural selection",
        [a.default.DeathByConsumption]: "by consuming {0}",
        [a.default.DeathByDrowning]: "of drowning",
        [a.default.DeathByExhaustion]: "of exhaustion",
        [a.default.DeathByFistByPlayer]: "by the fist of {0}",
        [a.default.DeathByPoison]: "by poisoning",
        [a.default.DeathBySteppingOn]: "by stepping on a {0}",
        [a.default.DeathByTrap]: "by stepping on a trap",
        [a.default.DeathByWeaponByPlayer]: "by {0} wielded by {1}",
        [a.default.Decay]: "Decay",
        [a.default.DestroyedFromUse]: "{0} has been destroyed from use.",
        [a.default.Dexterity]: "Dexterity",
        [a.default.DexterityIncreasing]: "You felt your dexterity increasing!",
        [a.default.DidNotSeemToBeHurting]: "{0} did not seem to be hurting {1}.",
        [a.default.Dig]: "dig",
        [a.default.DigAway]: "dig away",
        [a.default.Digging]: "digging",
        [a.default.DigWithHands]: "Dig With Hands",
        [a.default.Disabled]: "disabled",
        [a.default.Disassemble]: "disassemble",
        [a.default.DisassembleAction]: "Disassemble",
        [a.default.Disassembling]: "disassembling",
        [a.default.DiscoveredCaveEntrance]: "You have discovered a cave entrance!",
        [a.default.DiscoveredInTheBottle]: "You have discovered {0} in the bottle!",
        [a.default.DiscoveredLavaPassage]: "You have discovered a passage of lava!",
        [a.default.Dismantle]: "dismantle",
        [a.default.DismantleAction]: "Dismantle",
        [a.default.DismantleLabel]: "Dismantle: ",
        [a.default.Dismantling]: "dismantling",
        [a.default.DismantlingRequires]: "Dismantling {0} requires {1}.",
        [a.default.DoNotHaveTreasureMaps]: "You do not have any treasure maps!",
        [a.default.DoNotProduceAnyResources]: "You {0} at the {1}, but do not produce any resources yet.",
        [a.default.DoodadAppearsDamaged]: "{0} appears to have suffered a {#--text-color:great deal of damage}.",
        [a.default.DoodadAppearsOnVergeOfBreaking]: "{0} is on the {#--text-color:verge of breaking}.",
        [a.default.DoodadAppearsUnscathed]: "{0} appears to be {#--text-color:unscathed}.",
        [a.default.DoodadCauseStatus]: "{0} has {1} you. You have lost {2} health!",
        [a.default.DoodadShowsSignsOfWear]: "{0} shows {#--text-color:signs of wear}.",
        [a.default.DrewSurroundings]: "You drew your surroundings.",
        [a.default.Drink]: "Drink",
        [a.default.Drop]: "Drop",
        [a.default.DropAll]: "Drop All",
        [a.default.DropAllOfSameQuality]: "Drop All of the Same Quality",
        [a.default.DroppedIntoDepths]: "You dropped {0} into the depths below.",
        [a.default.DroppedIntoFire]: "You dropped {0} into the fire.",
        [a.default.DueToDehydration]: "due to dehydration",
        [a.default.DueToStarvation]: "due to starvation",
        [a.default.DugTreasureOut]: "You dug the treasure out.",
        [a.default.DumpContentsOfContainerInInventory]: "You dump the contents of the container into your inventory!",
        [a.default.Durability]: "Durability",
        [a.default.DyingOfDehydration]: "You are dying of dehydration!",
        [a.default.EarnedMilestone]: "You have earned the milestone '{Milestone:{0}}', {Milestone:{0}:1}",
        [a.default.East]: "east",
        [a.default.EastNortheast]: "east-northeast",
        [a.default.EastSoutheast]: "east-southeast",
        [a.default.Effective]: "effective",
        [a.default.Enabled]: "enabled",
        [a.default.EquipmentPreventedStatusEffects]: "Your equipment has protected you against a harmful status effect from {0}.",
        [a.default.EquipTo]: "Equip to ",
        [a.default.ErrorHasOccured]: "An error has occurred!",
        [a.default.Expert]: "Expert",
        [a.default.ExtinguishedFire]: "You extinguished the fire.",
        [a.default.ExtinguishedTorch]: "You extinguished the torch.",
        [a.default.FailedToAddFuelToTorch]: "You failed to add the fuel to the torch properly.",
        [a.default.FailedToCatchFish]: "You failed to catch the fish!",
        [a.default.FailedToCauseDamage]: "You failed to cause any damage to {0} with {1}! {2}",
        [a.default.FailedToCauseYouDamage]: "{0} failed to cause you any damage with {1}! {2}",
        [a.default.FailedToDrawMap]: "You failed to draw the map.",
        [a.default.FailedToIgniteTorch]: "You failed to ignite {0}!",
        [a.default.FailedToPickLock]: "You failed to pick the lock.",
        [a.default.FailedToPlant]: "You failed to plant {0} in the ground.",
        [a.default.FailedToPreserve]: "You failed to preserve the food.",
        [a.default.FailedToReinforce]: "You failed to reinforce {0}.",
        [a.default.FailedToRepair]: "You failed to repair {0}.",
        [a.default.FailedToStartFire]: "You failed to start a fire!",
        [a.default.FailedToTame]: "You have failed to tame {0}.",
        [a.default.FailedToTransmogrify]: "You failed to transmogrify {0}.",
        [a.default.Feet]: "Feet",
        [a.default.FeltBurningPainLostHealth]: "You felt burning pain! You have lost {0} health!",
        [a.default.FewMinutes]: "It appears you {0} for a few minutes.",
        [a.default.Filled]: "You filled {0}.",
        [a.default.FilledFrom]: "You filled {0} from {1}.",
        [a.default.Fire]: "Fire",
        [a.default.FireAlmostExtinguished]: "The fire is almost extinguished.",
        [a.default.FireAroundYouIsWarm]: "The fire around you is warm and comforting.",
        [a.default.FiredIntoObstacle]: "You fired {0} into an obstacle.",
        [a.default.FireIsHealthy]: "The fire is very healthy.",
        [a.default.FireIsRaging]: "The fire is raging!",
        [a.default.FireIsStruggling]: "The fire is struggling.",
        [a.default.FireOverflowed]: "The fire has overflowed and spread unexpectedly.",
        [a.default.FireReducedToEmbers]: "The fire has reduced to embers.",
        [a.default.FireSource]: "A Fire Source",
        [a.default.FishingWithNoBait]: "You attempt to catch the fish without any bait, but it appears uninterested.",
        [a.default.FullyDecodedMap]: "You fully decoded the map!",
        [a.default.GainedHealth]: "You have regained {0} health.",
        [a.default.GainedHunger]: "You have gained {0} hunger.",
        [a.default.GainedStamina]: "You have regained {0} stamina.",
        [a.default.GainedThirst]: "You have gained {0} thirst.",
        [a.default.GameHasBeenSavedIsTakingUpMB]: "Your game has been saved! Your save is using {0}MB.",
        [a.default.Gather]: "gather",
        [a.default.GatherDestroy]: "You gather {0} and destroy it in the process.",
        [a.default.Gathering]: "gathering",
        [a.default.GatherWithHands]: "Gather With Hands",
        [a.default.GhostNoActions]: "You cannot do that as a ghost!",
        [a.default.GhostOf]: "Ghost of {0}",
        [a.default.GoatHasNoMilk]: "The goat is not producing milk yet.",
        [a.default.GrabAll]: "Grab All",
        [a.default.Group]: "Group",
        [a.default.HackAway]: "hack away",
        [a.default.HandProtectionPreventedInjury]: "Your hand protection has prevented injury to your hands.",
        [a.default.Hands]: "Hands",
        [a.default.HandsNotEffectiveForDigging]: "Your hands did not appear to be the most effective for digging.",
        [a.default.Harvest]: "harvest",
        [a.default.Harvesting]: "harvesting",
        [a.default.HarvestWithHands]: "Harvest With Hands",
        [a.default.HasBeenHurtByATrap]: "{0} has been hurt by a trap, causing {1} damage!",
        [a.default.HasDecayed]: "Your {0} has decayed.",
        [a.default.HasHitYouForDamage]: "{0} has hit you for {1} damage! {2}",
        [a.default.HasNoEffect]: "The {0} has no effect on {1}.",
        [a.default.HasSetTrapOffNoDamage]: "{0} has set the trap off, but it caused no damage!",
        [a.default.HasSplit]: "{0} has split.",
        [a.default.Head]: "Head",
        [a.default.Held]: "Held",
        [a.default.Help]: "Help",
        [a.default.HelpGrow]: "You used the {0} to help {1} grow.",
        [a.default.Here]: "here",
        [a.default.Hints]: "Hints",
        [a.default.HintsDisabled]: "Hints disabled.",
        [a.default.HintsEnabled]: "Hints enabled.",
        [a.default.Hitch]: "Hitch",
        [a.default.HitchAttempt]: "You attempt to hitch {0}, but it fights you and escapes your grasp.",
        [a.default.HitchCreature]: "You have hitched {0}!",
        [a.default.HitchDisabled]: "You cannot fathom a way to hitch {0}.",
        [a.default.HitchInUse]: "This hitching post is already in use.",
        [a.default.HitForDamage]: "You hit {0} for {1} damage with {2}! {3}",
        [a.default.HitYouForDamage]: "{0} hit you for {1} damage with {2}! {3}",
        [a.default.Hour]: "hour",
        [a.default.Hours]: "hours",
        [a.default.HurtHandsHittingWithoutWeapons]: "You hurt your hands hitting {0} without any weapons!",
        [a.default.HurtHandsWithNoTool]: "You hurt your {0} by {1} with no tool.",
        [a.default.Ignite]: "Ignite",
        [a.default.IgnitedTorch]: "You have ignited {0}!",
        [a.default.Ineffective]: "ineffective",
        [a.default.InjuredFromTrap]: "You have been injured from a trap, causing {0} damage!",
        [a.default.InNeedOfRepair]: "{0} is in need of repair.",
        [a.default.Intermediate]: "Intermediate",
        [a.default.Inventory]: "Inventory",
        [a.default.IsInTheWayOfPickingUp]: "{0} is in the way of picking up {1}.",
        [a.default.It]: "it",
        [a.default.ItAlsoReveals]: "it also reveals",
        [a.default.ItAlsoSeems]: "it also seems",
        [a.default.ItContains]: "It contains {0}.",
        [a.default.ItsWeightCapacity]: "Its weight capacity is {0} / {1}.",
        [a.default.JoinedAServer]: "You have joined a server with {0} other {reformat({0},false):player} connected.",
        [a.default.Jump]: "Jump",
        [a.default.Killed]: "Killed {0}!",
        [a.default.KnowledgeHasIncreased]: "Your knowledge in {0} has increased.",
        [a.default.LabelAdditionalRequirements]: "Additional Requirements: ",
        [a.default.LabelAttackFromTactics]: "Attack From Tactics:",
        [a.default.LabelBase]: "Base: ",
        [a.default.LabelCanIncrease]: "Can Increase: ",
        [a.default.LabelCraftingReputation]: "Crafting Reputation: ",
        [a.default.LabelCraftingSkillReputation]: "{0} From {1}",
        [a.default.LabelDecay]: "Decay: ",
        [a.default.LabelDefense]: "Defense:",
        [a.default.LabelDurability]: "Durability: ",
        [a.default.LabelEquip]: "Equip:",
        [a.default.LabelGrouping]: "Grouping: ",
        [a.default.LabelHave]: "Have: ",
        [a.default.LabelLeftHandAttack]: "Left Hand Attack:",
        [a.default.LabelLevel]: "Level: ",
        [a.default.LabelLightSourceWhenLit]: "Light Source When Lit: ",
        [a.default.LabelOnCure]: "On Cure: ",
        [a.default.LabelOnDrink]: "On Drink: ",
        [a.default.LabelOnEat]: "On Eat: ",
        [a.default.LabelOnEquip]: "On Equip: ",
        [a.default.LabelOnHeal]: "On Heal: ",
        [a.default.LabelOnOtherHeal]: "On Heal Other: ",
        [a.default.LabelProtected]: "Protected",
        [a.default.LabelRange]: "Range: ",
        [a.default.LabelRanged]: "Ranged: ",
        [a.default.LabelRangedAttack]: "Ranged Attack: ",
        [a.default.LabelRangedDamage]: "Ranged Damage:",
        [a.default.LabelReputationImpact]: "Reputation Impact: ",
        [a.default.LabelRequires]: "Requires: ",
        [a.default.LabelResists]: "Resists: ",
        [a.default.LabelRightHandAttack]: "Right Hand Attack:",
        [a.default.LabelSkill]: "Skill: ",
        [a.default.LabelStokeFireStrength]: "Stoke Fire Strength: ",
        [a.default.LabelThrowDamageType]: "Throw Damage Type: ",
        [a.default.LabelTrapDamage]: "Trap Damage:",
        [a.default.LabelUse]: "Use: ",
        [a.default.LabelUses]: "Uses: ",
        [a.default.LabelVulnerabilities]: "Vulnerabilities: ",
        [a.default.LabelWeight]: "Weight: ",
        [a.default.LabelWeightCapacity]: "Weight Capacity: ",
        [a.default.LabelWeightReduction]: "Weight Reduction: ",
        [a.default.LabelWorth]: "Worth: ",
        [a.default.LastPlaceYouLeftOff]: "You awake to discover yourself in the last place you left off...",
        [a.default.LearnedHowToCreate]: "You have learned how to create {0}!",
        [a.default.LeftHand]: "left hand",
        [a.default.LeftHandEquip]: "Left Hand (Held)",
        [a.default.Legs]: "Legs",
        [a.default.LikelyFailures]: " It is likely you will not be able to craft {0} without many failures.",
        [a.default.LostHealth]: "You have lost {0} health.",
        [a.default.LostHunger]: "You have sated {0} hunger.",
        [a.default.LostStamina]: "You have lost {0} stamina.",
        [a.default.LostThirst]: "You have quenched {0} thirst.",
        [a.default.MapNotOfThisArea]: "This map is not of this area.",
        [a.default.MaterialsDestroyed]: "{0} materials have been destroyed from {1}.",
        [a.default.Metabolism]: "Metabolism (Hunger/Thirst)",
        [a.default.MetabolismSlowed]: "Your metabolism has slowed. You will require less food and water.",
        [a.default.Milk]: "milk",
        [a.default.Milking]: "milking",
        [a.default.MissedWith]: "You missed {0} with {1}!",
        [a.default.MissedYouWith]: "{0} missed you with {1}!",
        [a.default.MoreInformation]: "Press {0} to display more information.",
        [a.default.MoveAllOfSameQualityToFacingContainer]: "Move All of Same Quality to Facing Container",
        [a.default.MoveAllOfSameQualityToInventory]: "Move All of Same Quality to Inventory",
        [a.default.MoveAllOfSameQualityToLastOpenedContainer]: "Move All of Same Quality to Last Opened Container",
        [a.default.MoveAllOfSameQualityToOpenedContainer]: "Move All of Same Quality to Opened Container",
        [a.default.MoveAllToFacingContainer]: "Move All to Facing Container",
        [a.default.MoveAllToInventory]: "Move All to Inventory",
        [a.default.MoveAllToLastOpenedContainer]: "Move All to Last Opened Container",
        [a.default.MoveAllToOpenedContainer]: "Move All to Opened Container",
        [a.default.MovedItem]: "You moved {0} into {1}.",
        [a.default.MoveOverTrapButDoNotSetOff]: "You move over the trap, but do not set it off.",
        [a.default.MoveToFacingContainer]: "Move to Facing Container",
        [a.default.MoveToInventory]: "Move to Inventory",
        [a.default.MoveToLastOpenedContainer]: "Move to Last Opened Container",
        [a.default.MoveToOpenedContainer]: "Move to Opened Container",
        [a.default.MultiplayerGamePaused]: "The game has been paused.",
        [a.default.MultiplayerGameResumed]: "The game has been resumed.",
        [a.default.MultiplayerPlayerConnected]: "{0} is connecting.",
        [a.default.MultiplayerPlayerDied]: "{0} died {1}!",
        [a.default.MultiplayerPlayerDisconnected]: "{0} has disconnected.",
        [a.default.MultiplayerPlayerJoined]: "{0} has joined.",
        [a.default.MustBeEquippedToIgnite]: "{0} must be equipped to ignite it.",
        [a.default.MustCastIntoWater]: "You must cast into water to catch anything.",
        [a.default.Mysteriously]: "mysteriously",
        [a.default.Name]: "Name",
        [a.default.NearlyBurnedEquipmentProtectedYou]: "You were nearly burned, but your equipment protected you.",
        [a.default.Neck]: "Neck",
        [a.default.NeedAShovelToDigTreasure]: "You need a shovel to be able to dig up this treasure.",
        [a.default.NeedFishingNetForTreasure]: "You need a fishing net to be able to get this treasure.",
        [a.default.NeedFreeHandToShoot]: "You need a free hand to shoot {0}!",
        [a.default.NeedToEquipToShoot]: "You need to equip {0} to shoot from it!",
        [a.default.NeedToStartTravelsOutside]: "You need to start your travels outside.",
        [a.default.NeedWaterForRaft]: "You need to be facing or in water to use a raft.",
        [a.default.Negatively]: "negatively",
        [a.default.NightQuarter1]: "It is currently in the first quarter of the night.",
        [a.default.NightQuarter2]: "It is currently in the second quarter of the night.",
        [a.default.NightQuarter3]: "It is currently in the third quarter of the night.",
        [a.default.NightQuarter4]: "It is currently in the fourth quarter of the night.",
        [a.default.NoAmmunitionForThatWeapon]: "You do not have any ammunition for {0} in your inventory!",
        [a.default.NoBlackPowderToFireWeapon]: "You do not have any black powder to fire {0}.",
        [a.default.NoFireToStokeWith]: "There is no fire to stoke with {0} here!",
        [a.default.NoFishAtLocation]: "There are no fish at this location!",
        [a.default.NoGroundWater]: "The well is constructed in a location that does not contain any groundwater.",
        [a.default.NoInkToDrawMap]: "You do not have any ink to draw a map with!",
        [a.default.NoKindlingOrFuelItemsToStartFire]: "You do not have any kindling or fuel to start the fire with.",
        [a.default.NoKindlingToStartFire]: "You do not have any kindling to start the fire.",
        [a.default.NoLongerFeelPainOfBeingBurned]: "You no longer feel the pain of being burned!",
        [a.default.NoLongerHostile]: "{0} is no longer hostile towards you.",
        [a.default.NoMoreRoomInContainer]: "There is no more room in this container for {0}.",
        [a.default.NoNeedToStokeFire]: "There is no need to stoke this fire.",
        [a.default.NoReturnWithoutCompletingChallenges]: "An unknown force prevents you from leaving without completing your challenges.",
        [a.default.NoRoomForImprovement]: "{0} has no room for improvement!",
        [a.default.NoRoomToDrop]: "There is no room to drop {0} here!",
        [a.default.North]: "north",
        [a.default.Northeast]: "northeast",
        [a.default.NorthNortheast]: "north-northeast",
        [a.default.NorthNorthwest]: "north-northwest",
        [a.default.Northwest]: "northwest",
        [a.default.NotAvailable]: "N/A",
        [a.default.NotEnoughPurifiedWaterYet]: "There is not enough purified water available in the still yet.",
        [a.default.NotEnoughTreasureToReturn]: "An unknown force prevents you from leaving without all the pieces of treasure.",
        [a.default.NotFacingCreatureToOfferThisTo]: "You are not facing a creature to offer this to.",
        [a.default.NotFacingLockedObject]: "You are not facing a locked object.",
        [a.default.NotFacingOtherToHeal]: "You are not facing anything that can be healed.",
        [a.default.NotFacingValidItem]: "You are not facing a valid item for {0}.",
        [a.default.NothingHereToCarve]: "There is nothing here to carve!",
        [a.default.NothingHereToFill]: "There is nothing here to fill {0}.",
        [a.default.NothingHereToGrasp]: "There is nothing here to grasp!",
        [a.default.NothingToGetFromThis]: "There is nothing to {0} from {1}!",
        [a.default.NothingToHarvestFromThisGather]: "There is nothing to harvest from {0}; however, you can gather from it.",
        [a.default.NothingToSmother]: "There is nothing to smother here!",
        [a.default.NothingUsefulToHarvestYet]: "There is nothing useful to harvest from {0} yet!",
        [a.default.NoTinderToStartFire]: "You do not have any tinder to start the fire.",
        [a.default.NotInRangeOfTreasure]: "You are not in the range of any buried treasure!",
        [a.default.NotSuitableToPlant]: "{0} are not suitable to plant in {1}.",
        [a.default.NoWaterInStill]: "There is no water in this still.",
        [a.default.NPCStartingDialog1]: "Well, hello there! It is nice to see another face around these parts. Let us see if we can exchange goods and help each other out.",
        [a.default.NPCStartingDialog2]: "Good day! Our odds of survival might be better if we can trade some items with each other.",
        [a.default.NPCStartingDialog3]: "Wow! You startled me! I never expected to find another lost soul out here. Do you wish to trade items?",
        [a.default.NPCStartingDialog4]: "Hello there! I noticed you from afar. I have been trying to keep my distance as I was unware of your intentions. Would you like to trade items, or were my suspicions correct?",
        [a.default.NPCWelcome]: "Welcome back!",
        [a.default.NPCWelcomeCredit]: "Welcome back! Ready to use some of that credit?",
        [a.default.NumberEight]: "eight",
        [a.default.NumberFive]: "five",
        [a.default.NumberFour]: "four",
        [a.default.NumberNine]: "nine",
        [a.default.NumberOne]: "one",
        [a.default.NumberSeven]: "seven",
        [a.default.NumberSix]: "six",
        [a.default.NumberTen]: "ten",
        [a.default.NumberThree]: "three",
        [a.default.NumberTwo]: "two",
        [a.default.ObjectIsLocked]: "The object is locked.",
        [a.default.ObjectIsLockedAttemptToBreakIt]: "The object is locked, you attempt to break it open.",
        [a.default.Offer]: "Offer",
        [a.default.OfferAberrantFail]: "{0} took your offering, but failed to accept you as its owner.",
        [a.default.OfferAberrantFailButTamed]: "{0} took your offering, but failed to gain any favor with its owner.",
        [a.default.OpenDoor]: "Open Door",
        [a.default.OverEatingLostStamina]: "You are over-eating! You have lost {0} stamina.",
        [a.default.OverHydratingLostStamina]: "You are over-hydrating! You have lost {0} stamina.",
        [a.default.Pack]: "pack",
        [a.default.PaperTurnedToMush]: "The wet piece of paper turned to mush as it was released from the bottle.",
        [a.default.PartiallyDecodedMap]: "You partially decoded the map.",
        [a.default.PastExperiencesProvideBenefits]: "Your past experiences provide you benefits for survival.",
        [a.default.PenultimateAnd]: "and",
        [a.default.PetCreature]: "You pet {0}. It appears to enjoy it.",
        [a.default.PickAway]: "pick away",
        [a.default.PickupAllItems]: "Pick-up All Items",
        [a.default.PickupItem]: "Pick-up Item",
        [a.default.Piercing]: "Piercing",
        [a.default.Place]: "place",
        [a.default.PlacedOnGround]: "You placed {0} on the ground!",
        [a.default.Plant]: "plant",
        [a.default.PlantCouldBeHarvested]: "{0} is {#--text-color:ready to be harvested} for its seeds, but its main resource must be gathered, destroying the plant.",
        [a.default.PlantedInGround]: "You planted {0} in the ground.",
        [a.default.PlantGatheringWillDestroy]: "Gathering resources from {0} will destroy it.",
        [a.default.PlantHasResourcesToGather]: "{0} has some resources left to gather.",
        [a.default.PlantHasResourcesToHarvest]: "{0} has some resources left to harvest.",
        [a.default.PlantHighlyFertile]: "{0} is highly fertile and may spread in its vicinity.",
        [a.default.Planting]: "planting",
        [a.default.PlantIsDead]: "{0} is {#--text-color:{1}}.",
        [a.default.PlantIsFertile]: "{0} is fertile and may spread in its vicinity.",
        [a.default.PlantIsInStage]: "{0} is in its {#--text-color:{1}} stage of growth.",
        [a.default.PlantIsNotFertile]: "{0} is not fertile and will not spread.",
        [a.default.PlantNotReadyToHarvest]: "{0} does {#--text-color:not yet have resources} to harvest.",
        [a.default.PlantReadyToGather]: "{0} is {#--text-color:ready to gather}.",
        [a.default.PlantReadyToGatherNotMaximal]: "{0} could be gathered from but will {#--text-color:not yet provide the maximal yield}.",
        [a.default.PlantReadyToHarvest]: "{0} is {#--text-color:ready to harvest}.",
        [a.default.PlantReadyToHarvestNotMaximal]: "{0} could be harvested but will {#--text-color:not yet provide the maximal yield}.",
        [a.default.Player]: "player",
        [a.default.PlayerHasCompletedChallengeRequirement]: '{0?{0} has:You have} completed the requirement "{1}". Only {num(as words):{2}} {reformat({2}, false):requirement} left!',
        [a.default.PlayerHasWonChallenge]: "The challenge has been won by {0}. Better luck next time!",
        [a.default.Poisoned]: "poisoned",
        [a.default.PoisonedLostHealth]: "You are poisoned! You have lost {0} health!",
        [a.default.PoisonWorkedItsCourse]: "The poison has worked its course!",
        [a.default.Positively]: "positively",
        [a.default.PouredOut]: "You poured out the {0}.",
        [a.default.PouredOutOnYourself]: "You poured out the {0} on yourself.",
        [a.default.PouredWaterIntoStill]: "You poured the water into the still.",
        [a.default.PourHarmedPlant]: "Pouring out {0} on {1} has harmed it.",
        [a.default.PourHealedPlant]: "{0} has been healed {1} by pouring {2} on it.",
        [a.default.PourHealedPlantFully]: "fully",
        [a.default.PourHealedPlantPartially]: "partially",
        [a.default.PourIncreasedFertility]: "The fertility of {0} has increased from the poured {1}.",
        [a.default.Preservation]: "preservation",
        [a.default.Preserve]: "Preserve",
        [a.default.PreservedFood]: "You preserved the food.",
        [a.default.PurifiedWaterInStill]: "There is purified water in the still.",
        [a.default.Quality]: "Quality",
        [a.default.Recent]: "Recent",
        [a.default.ReduceLength]: "{0} on {1} has reduced the length of your {2}.",
        [a.default.RefusedToBeTamed]: "{0} refuses to be tamed so quickly after being released.",
        [a.default.Reinforce]: "You reinforce {0}.",
        [a.default.Reinforcement]: "reinforcement",
        [a.default.Release]: "Release",
        [a.default.RemovedBlood]: "You removed the blood.",
        [a.default.RemoveFromQuickslot]: "Remove from Quickslot",
        [a.default.Repair]: "repair",
        [a.default.RequiredForDisassembleLabel]: "Required for Disassembly: ",
        [a.default.RequiredForDisassembly]: "{0} is required for disassembly of {1}!",
        [a.default.RequiresFireToBeLit]: "This still requires a fire to be lit underneath it to begin purifying water.",
        [a.default.RequiresYouFacingFireSource]: "{0} requires you to be facing a fire source in order to light it.",
        [a.default.RequiresYouToBeAround]: "{0} requires you to be around {1} in order to {2} it.",
        [a.default.Resistant]: "resistant",
        [a.default.ResistOrVuln]: "{0} {1}",
        [a.default.ResistOrVulnAll]: "all {1}",
        [a.default.Rest]: "rest",
        [a.default.Rested]: "rested",
        [a.default.Resting]: "Resting",
        [a.default.RestingOnGroundNotEffective]: "Resting on the ground did not appear to be the most effective.",
        [a.default.RestInterrupted]: "Your {0} has been interrupted {1}",
        [a.default.RestInterruptedDamage]: "by something hurting you.",
        [a.default.RestInterruptedLoudNoise]: "by a loud, crashing noise.",
        [a.default.RestInterruptedPain]: "by your persisting pain.",
        [a.default.RestInterruptedStirring]: "by something stirring around you.",
        [a.default.RestLongTime]: "long time",
        [a.default.RestModerateTime]: "moderate amount of time",
        [a.default.RestOnGround]: "Rest on Ground",
        [a.default.RestShortTime]: "short time",
        [a.default.RestTime]: "It appears you have {0} for a {1}.",
        [a.default.ReturnedToCivilization]: "Returned to civilization!",
        [a.default.ReturningToCivilizationSetOffAgain]: "After returning the treasure back to civilization, you set off again...",
        [a.default.ReturnsToLife]: "{0} returns to life!",
        [a.default.Reveals]: "{0} reveals",
        [a.default.RevealsEntityAppearsHurt]: "{0} that {1} appears {#--text-color:hurt}.",
        [a.default.RevealsEntityAppearsUnharmed]: "{0} that {1} appears {#--text-color:unharmed}.",
        [a.default.RevealsEntityAppearsVeryHurt]: "{0} that {1} appears {#--text-color:quite injured}.",
        [a.default.RevealsEntityIsAtPercentHealth]: "{0} that {1} is at {#--text-color:{2}% health}.",
        [a.default.RevealsEntityIsInjured]: "{0} that {1} is {#--text-color:injured}.",
        [a.default.RevealsEntityIsMostlyUninjured]: "{0} that {1} is {#--text-color:mostly uninjured}.",
        [a.default.RevealsEntityIsOnTheVergeOfDeath]: "{0} that {1} is on the {#--text-color:verge of death}.",
        [a.default.RevealsEntityIsSeverelyInjured]: "{0} that {1} is {#--text-color:severely injured}.",
        [a.default.RevealsEntitySeemsInjured]: "{0} that {1} is {#--text-color:injured}",
        [a.default.RevealsEntitySeemsUninjured]: "{0} that {1} is {#--text-color:uninjured}.",
        [a.default.RevealsNumberOfResistancesAndVulnerabilities]: "{0} that {1} is {#--text-color:resistant to {2?{2}:no} damage types} and is {#--text-color:vulnerable to {3?{3}:no} damage types}.",
        [a.default.RevealsResistancesAndVulnerabilities]: "{0} that {1} {#--text-color:resists {2?{2}:no} damage} and is {#--text-color:vulnerable towards {3?{3}:no} damage}.",
        [a.default.RevealsSomeResistancesAndVulnerabilities]: "{0} that {1} has {#--text-color:{2?some:no} resistances} and {#--text-color:{3?some:no} vulnerabilties}.",
        [a.default.RightHand]: "right hand",
        [a.default.RightHandEquip]: "Right Hand (Held)",
        [a.default.ScrollMaster]: "You are truly a master of all {0}.",
        [a.default.ScrollProvidedNoUsefulInsight]: "The scroll provided no useful insight for you.",
        [a.default.SeaweedFromWater]: "You dragged a slimy mass of seaweed up out of the water!",
        [a.default.SeemsToHaveDrawnEnergy]: "{0} seems to have drawn energy from {1}!",
        [a.default.SetTrapOffButNoDamage]: "You set the trap off, but it does no damage to you.",
        [a.default.SetUp]: "You have set up {0}.",
        [a.default.ShadowInTheWater]: "You see a shadow in the water.",
        [a.default.Simple]: "Simple",
        [a.default.Skill]: "Skill",
        [a.default.SkillHasRaised]: "Your skill in {0} has raised to {1}%!",
        [a.default.Skills]: "skills",
        [a.default.Slashing]: "Slashing",
        [a.default.Sleep]: "sleep",
        [a.default.Sleeping]: "Sleeping",
        [a.default.Slept]: "slept",
        [a.default.SlitherSuckerConstricts]: "{0} constricts and moves on your head, causing its teeth to pierce you as it writhes.",
        [a.default.SlitherSuckerJumpedOnHead]: "{0} jumps on top of you, suctioning and constricting itself on top of your head.",
        [a.default.Some]: "some",
        [a.default.SomethingInTheWayOf]: "There is something in the way of your {0}!",
        [a.default.SomethingInTheWayOfCarveFirst]: "There is something in the way of your {0}. This must be carved.",
        [a.default.SomethingInTheWayOfFire]: "There is something in the way of stoking the fire!",
        [a.default.SomethingInTheWayOfFishing]: "There is something in the way. You cannot fish past that!",
        [a.default.SomethingInTheWayOfPerforming]: "There is something in the way of performing this action.",
        [a.default.SomethingInTheWayOfPlacing]: "There is something in the way of placing {0}.",
        [a.default.SomethingInTheWayOfPlanting]: "There is something in the way of planting {0} here!",
        [a.default.SomethingInWayOfClosingDoor]: "There is something in the way of closing that door!",
        [a.default.SoothedTheirBurnInjuries]: "You have soothed their burn injuries!",
        [a.default.SoothedYourBurnInjuries]: "You have soothed your burn injuries!",
        [a.default.Sort]: "Sort",
        [a.default.SortedByBest]: "{0} sorted by best.",
        [a.default.SortedByCategory]: "{0} sorted by category.",
        [a.default.SortedByDecay]: "{0} sorted by decay.",
        [a.default.SortedByDurability]: "{0} sorted by durability.",
        [a.default.SortedByGroup]: "{0} sorted by group.",
        [a.default.SortedByName]: "{0} sorted by name.",
        [a.default.SortedByQuality]: "{0} sorted by quality.",
        [a.default.SortedByRecent]: "{0} sorted by recent.",
        [a.default.SortedBySkill]: "{0} sorted by skill.",
        [a.default.SortedByUnlockedTime]: "{0} sorted by discovered time.",
        [a.default.SortedByWeight]: "{0} sorted by weight.",
        [a.default.South]: "south",
        [a.default.Southeast]: "southeast",
        [a.default.SouthSoutheast]: "south-southeast",
        [a.default.SouthSouthwest]: "south-southwest",
        [a.default.Southwest]: "southwest",
        [a.default.StaminaIsFull]: "Your stamina is full, you do not need to rest anymore.",
        [a.default.StartedFire]: "You have started a fire!",
        [a.default.StartTravelInWater]: "You need to start your travels while in ocean water.",
        [a.default.StarvingToDeath]: "You are starving to death!",
        [a.default.SteppingOnHasInjuredYouForDamage]: "Stepping on the {0} has injured you for {1} damage!",
        [a.default.StillHasNoWaterToPurify]: "This still has no water to purify!",
        [a.default.StirredUpClawWorm]: "You stirred up a claw worm from underground!",
        [a.default.StirredUpCreature]: "You stirred up a creature from the depths!",
        [a.default.StoppedYourBleeding]: "You have stopped your bleeding!",
        [a.default.StopUsingRaft]: "You stop using the raft.",
        [a.default.Strength]: "Strength",
        [a.default.StrengthIncreasing]: "You felt your strength increasing!",
        [a.default.SummonedGuardiansByDiggingTreasure]: "You have summoned the guardians by digging up the treasure.",
        [a.default.SunNotBrightEnoughToStartFire]: "The sun is not bright enough to start a fire with {0}!",
        [a.default.TakenFromGroundBecomeTamed]: "{0} has taken {1} from the ground and has become tamed.",
        [a.default.Tame]: "Tame",
        [a.default.TamedAppearsAngered]: "angered",
        [a.default.TamedAppearsContended]: "contented",
        [a.default.TamedAppearsHappy]: "happy",
        [a.default.TamedAppearsUpset]: "upset",
        [a.default.TamedCreature]: "This creature is tamed and appears {0}.",
        [a.default.TeleportBlocked]: "Your teleport destination was blocked.",
        [a.default.Teleported]: "You have teleported.",
        [a.default.ThanksBuying]: "Thanks! I will take {0} credit for {1}.",
        [a.default.ThanksSelling]: "Thanks for trading in {0} for {1} credit.",
        [a.default.The]: "the {0}",
        [a.default.TheCreature]: "the {0?{0}:creature}",
        [a.default.TheirFist]: "their fist",
        [a.default.ThePlant]: "the plant",
        [a.default.ThereIsNoSunToStartFire]: "There is no sun in here to start a fire with.",
        [a.default.ThereIsNothingToMilk]: "There is nothing to milk here.",
        [a.default.ThisCannotBeMilked]: "This creature cannot be milked.",
        [a.default.Throw]: "Throw",
        [a.default.ThrownIntoDepths]: "You have thrown {0} into the depths below.",
        [a.default.ThrownIntoObstacle]: "You have thrown {0} into an obstacle.",
        [a.default.Till]: "till",
        [a.default.Tilling]: "tilling",
        [a.default.TimeIs]: "It appears to be around {1} o'clock.",
        [a.default.TimeIsDawn]: "It is dawn.",
        [a.default.TimeIsDaytime]: "It is daytime.",
        [a.default.TimeIsDusk]: "It is dusk.",
        [a.default.TimeIsNighttime]: "It is nighttime.",
        [a.default.TimeIsSunrise]: "The sun is rising.",
        [a.default.TimeIsSunset]: "The sun is setting.",
        [a.default.ToDamageAChest]: "to damage a chest",
        [a.default.ToFight]: "to fight",
        [a.default.TooDamaged]: "{0} is too damaged to attempt to {1}.",
        [a.default.TooExhaustedToJump]: "You are too exhausted and overburdened to make this jump.",
        [a.default.TradeBarterCreditForItem]: "Trade Barter Credit for Item",
        [a.default.TradeItemForBarterCredit]: "Trade Item for Barter Credit",
        [a.default.TradingWith]: "Trading with {0}",
        [a.default.TrampledFire]: "You trampled the fire, putting it out!",
        [a.default.TrampledIntoGround]: "{0} trampled {1} into the ground.",
        [a.default.TrampleIntoGround]: "You trampled {0} into the ground.",
        [a.default.Trampling]: "You are trampling {0}.",
        [a.default.Transmogrification]: "transmogrification",
        [a.default.Transmogrified]: "You have transmogrified {0}.",
        [a.default.TrapMissed]: "{0} has narrowly missed the trap while moving over it.",
        [a.default.TrapStoppedYou]: "The trap has stopped you in your tracks.",
        [a.default.TravelToFarOffLands]: "You travel to far off lands...",
        [a.default.TreasureIsBlocked]: "You find the spot where the treasure is buried, but it is blocked.",
        [a.default.True]: "True",
        [a.default.UnEquip]: "Unequip",
        [a.default.UnEquipAll]: "Unequip All",
        [a.default.Unhitch]: "Unhitch",
        [a.default.UnhitchCreature]: "You have unhitched {0}!",
        [a.default.Unknown]: "unknown",
        [a.default.UnknownItem]: "unknown item",
        [a.default.UnlockedChest]: "You unlocked the wooden chest and viewed its contents.",
        [a.default.UnlockedTime]: "Discovered Time",
        [a.default.UnpurifiedFreshWater]: "unpurified fresh water",
        [a.default.UnpurifiedWaterInStill]: "There is unpurified water in the still.",
        [a.default.UsingBareHands]: "using bare hands to {0}",
        [a.default.Vulnerable]: "vulnerable",
        [a.default.WaitUntilFireCooledToGetWater]: "You must wait until the fire has cooled off to get the purified water.",
        [a.default.Water]: "water",
        [a.default.WaterGathering]: "water gathering",
        [a.default.WaterPutOutFire]: "The water has put out the fire.",
        [a.default.Weight]: "Weight",
        [a.default.WeightCapacity]: "Weight Capacity: {0} / {1}",
        [a.default.WellIsDry]: "The well is completely dry! It may take some time to refill.",
        [a.default.WellIsFull]: "You cannot pour that into the well because it is full!",
        [a.default.West]: "west",
        [a.default.WestNorthwest]: "west-northwest",
        [a.default.WestSouthwest]: "west-southwest",
        [a.default.WildGoatRefusedToBeMilked]: "The wild goat refuses to be milked!",
        [a.default.WillNotTrade]: "Do you take me for a fool? I will not trade for {0}!",
        [a.default.With]: "with",
        [a.default.WithYouSee]: "with {0}, you see",
        [a.default.WorkingYourselfIntoExhaustion]: "You are working yourself into exhaustion!",
        [a.default.WorkingYourselfIntoExhaustionAndDrowning]: "You are working yourself into exhaustion and drowning!",
        [a.default.YouApplied]: "You applied {0}!",
        [a.default.YouAte]: "You ate {0}!",
        [a.default.YouBeginResting]: "You begin resting...",
        [a.default.YouCannotDoThatYet]: "You cannot do that yet!",
        [a.default.YouCooledLava]: "You cooled the lava.",
        [a.default.YouCrafted]: "You {0} {1}!",
        [a.default.YouDied]: "You died {0}!",
        [a.default.YouDisassembled]: "You disassembled {0}.",
        [a.default.YouDismantled]: "You dismantled {0}.",
        [a.default.YouDrank]: "You drank {0}!",
        [a.default.YouDropTheTorch]: "You drop the torch, causing a fire to break out.",
        [a.default.YouEquip]: "You equipped {0}.",
        [a.default.YouFailedTo]: "You failed to {0} {1} due to lack of skill.{2}",
        [a.default.YouFailedToExtinguishedFireFully]: "You failed to extinguish the fire fully.",
        [a.default.YouFailedToHeal]: "You have failed to heal due to lack of skill in {0}.",
        [a.default.YouFailedToHealOther]: "You have failed to heal {0} due to lack of skill in {1}.",
        [a.default.YouFire]: "You fire {0}.",
        [a.default.YouGathered]: "You gathered {0}!",
        [a.default.YouGatheredAndDropped]: "You gathered and dropped {0}!",
        [a.default.YouHardenedCooledLava]: "You hardened the cooled lava into obsidian.",
        [a.default.YouHarvested]: "You harvested {0}!",
        [a.default.YouHarvestedAndDropped]: "You harvested and dropped {0}!",
        [a.default.YouHaveAlreadyLearned]: "You have already learned all you can from {0}.",
        [a.default.YouHaveDied]: "You have died {0}!",
        [a.default.YouHaveEnabledDisabled]: "You have {0} usage of your {1} for automatic gathering and attacking.",
        [a.default.YouHaveHealedOther]: "You have healed {0}.",
        [a.default.YouHaveKilled]: "You have killed {0}!",
        [a.default.YouHaveReleased]: "You have released {0} into the wild.",
        [a.default.YouHaveTamed]: "You have tamed {0}.",
        [a.default.YouNeedMoreCredit]: "You need {0} more barter credit to trade for that item.",
        [a.default.YouNoticeBecomeEnraged]: "You notice {0} become enraged and increase in strength.",
        [a.default.YouNoticeDying]: "You notice {0} dying.",
        [a.default.YouNoticeFertilityDecreasing]: "You notice the fertility of {0} decreasing.",
        [a.default.YouNoticeFertilityIncreasing]: "You notice the fertility of {0} increasing.",
        [a.default.YouNoticeGrowing]: "You notice {0} growing.",
        [a.default.YouNoticeLavaCooling]: "You notice lava cooling.",
        [a.default.YouNoticeLavaHardening]: "You notice lava hardening.",
        [a.default.YouNoticePerish]: "You notice {0} inexplicably collapse and perish.",
        [a.default.YouNoticeStumbleInjureItself]: "You notice {0} stumble and injure itself.",
        [a.default.YouNoticeTakeFromGround]: "You notice {0} take {1} from the ground but failed to become tamed.",
        [a.default.YouNoticeWoundsClosing]: "You notice the wounds of {0} closing.",
        [a.default.YouNoticeZombieHorde]: "You notice a horde of zombies coming your way.",
        [a.default.YouOfferedToCreature]: "You offered {0} to {1} and it appeared to be {2}.",
        [a.default.YouOpen]: "You open {0}.",
        [a.default.YouPacked]: "You packed the {0}.",
        [a.default.YouPickedUp]: "You picked up {0}.",
        [a.default.YouRepair]: "You repair {0}.",
        [a.default.YourFist]: "your fist",
        [a.default.YourHands]: "Your hands",
        [a.default.YourHighSkill]: "your high {0} skill",
        [a.default.YourInventory]: "your inventory",
        [a.default.YourLowSkill]: "your low {0} skill",
        [a.default.YourModerateSkill]: "your moderate {0} skill",
        [a.default.YourRubbingNoEffect]: "Your rubbing appears to have no effect.",
        [a.default.YouRub]: "You rub {0} {1} as it quickly disintegrates in your grasp. These lands will now act more {2} to your presence.",
        [a.default.YouSalvaged]: "You salvaged {0}.",
        [a.default.YouSee]: "You see {0}.",
        [a.default.YouSeeAnAberrant]: "You see an aberrant {0}.",
        [a.default.YouSeeDrop]: "You see {0} drop from {1}.",
        [a.default.YouSeeEngulfFire]: "You see {0} engulf its surroundings with fire.",
        [a.default.YouSeeHelpingPlant]: "You see {0} tending to {1}.",
        [a.default.YouSeeLay]: "You see {0} lay {1}.",
        [a.default.YouSeeLayingTrap]: "You see {0} laying down a trap.",
        [a.default.YouSeeSpewLava]: "You see {0} spew forth lava in defense.",
        [a.default.YouSeeSpitAcid]: "You see {0} spit acid.",
        [a.default.YouSeeSpringForth]: "You see {0} spring forth!",
        [a.default.YouSeeSummon]: "You see {0} chant and summon {1}.",
        [a.default.YouSeeSwampFlood]: "You see {0} inundate and flood the ground on which it moves.",
        [a.default.YouSeeTrampling]: "You see {0} trampling {1}.",
        [a.default.YouSeparate]: "You separate {0}.",
        [a.default.YouSetTheTrapOff]: "You set the trap off.",
        [a.default.YouThrew]: "You threw {0}!",
        [a.default.YouTilled]: "You tilled the {0}.",
        [a.default.YouUnequip]: "You unequip {0}.",
        [a.default.YouUsed]: "You have used {0}!"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/game/PartsOfDay", ["require", "exports", "game/TimeManager"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.PartOfDay.Dawn]: "Dawn",
        [a.PartOfDay.Sunrise]: "Sunrise",
        [a.PartOfDay.Daytime]: "Daytime",
        [a.PartOfDay.Sunset]: "Sunset",
        [a.PartOfDay.Dusk]: "Dusk",
        [a.PartOfDay.Nighttime]: "Nighttime"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/item/Books", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.BookType.IslandPresence]: ["William J. Andrews", '"This island seems to react to my presence. I often have a weird feeling, like something is watching me, but besides the constant barrage of bloodthirsty creatures at my heels, that feeling never leaves me; it follows me even into my dreams. I\'m not sure how many more sleepless nights I can lead."\n\t\n\t"There it is again. I felled a tree. I hear it."\n\t\n\t"There it is again. I burned a tree. The humming continues."\n\t\n\t"There it is again, the end. I started a forest fire. It\'s too loud!"\n\t\n\tThe next pages have undecipherable scribbles and diagrams.'],
        [a.BookType.Treasure]: ["On Treasures", '"The greed that has driven us to these islands now forces us to stay here. Day after day we search for the treasures that brought us to these lands to begin with. Our group of men have discovered several different types of treasure, some even from slaying the ravenous indigenous creatures that seem to roam these islands and caves. But we cannot seem to leave, we need more. The island demands it."\n\t\n\tThe next pages seem to be ripped out and missing.\n\t\n\t"We have failed. Many have perished. We are missing the final piece. I do not think we can make it much further. We seem to have angered nature itself."'],
        [a.BookType.Deities]: ["Deities", '"The same three strange symbols seem to appear again and again on artifacts, cave walls, and even old long-ago abandoned buildings. Cross referencing other resources and even some older journals we have found references to deities, spirits, and even Gods. Most likely worshiped by the heathens that used to inhabit these lands. They seem connected to these islands somehow."\n\t\n\t"The three names seem to be mentioned again and again, Wry, Da, and Aw."'],
        [a.BookType.PastCivilizations]: ["Past Civilizations", '"We have discovered evidence of many battles here. Not only that, but civilizations, skeletal remains, abandoned houses, and much evidence to support some type of apocalyptic scenario."\n\t\n\t"Not only that, but it seems to happen again and again; the evidence all points to different ages and different points in time. It appears as though no people are able to survive and thrive in these lands, like some force is forbidding human progress."\n\t\n\t"These ravenous, unabating creatures are not helping matters, that\'s for sure."'],
        [a.BookType.SandCasting]: ["Sand Casting", 'The entire book seems to be stained with various chemicals and powders.\n\t\n\t"Throughout my metallurgic experiments, I have found the best way to forge iron based tools, weapons, and ingots was to cast large amounts of material to shape it. The best casting method I have found using resources around me was sand casting."\n\t\n\t"The primary ingredient for creating a sand cast is green sand, a mixture of clay flakes and refined sand. This allows for the malleability of creating the shape of tool and weapon heads, or even forming the ingots in which to work from."\n\t\n\t"Next, we place the green sand in a flask, crafted with wood, sandstone, rock, or raw clay, finishing the build of the sand cast flask. We then set the shape, place down some talc powder so the finished produce can be lifted easier, and pour the molten smelted mixture into the cast to let it set and harden."\n\t\n\tThe book is adorned with crude drawings of each process.\n\t\n\t"I have also found I can use limestone powder as the flux to refine ores and remove impurities in the smelting process. Some carbon powder is also required to get a proper hardness to the finished metal."\n\t\n\tThe bottom of the paged is signed with "James Townsend, the Smithy".'],
        [a.BookType.WanderingMerchants]: ["The Wandering Merchants", '"Throughout my exploration of the island, I have run across other people, much to my surprise. It appears as they were in a similar state as myself; somehow trapped in these lands, struggling for our lives. In the many cases, these folks were not hostile, and we quickly made friendships."\n\n\t"We traded goods and spoke on our situation. One of the folks drove a very hard bargain for some limestone that I needed. If I was a different type of person, given our secluded setting, I may have simply just taken it through "other means"."\n\t\n\t"Although it was always my intent to return to them for trading, try as I might, I could no longer locate them. Either they moved on to other areas or died. Given the circumstances of these harsh lands, I\'m guessing the latter is true."'],
        [a.BookType.TrappersJournal]: ["Trapper's Journal", '"Using techniques and skills my father taught to me in my youth, I was successfully able to ward off the monstrosities using traps. The snare and the deadfall become my most useful weapons."\n\t\n\t"I spent days crafting traps and placing them outside my shelter instead of focusing on traditional weaponry. My combat skills are not so great, and I have not found a meaningful resource to craft armor, so trapping appeared to be my best bet to dispatch these creatures."\n\t\n\t"I think I just heard my deadfall squish another giant spider. I\'ll write more on my improvised spider meat meal. Sadly, cooking is not my forte either."'],
        [a.BookType.TheForce]: ["The Force", '"I\'m not sure if I can properly explain this. Maybe if I ever see you in person again, I can walk you through it. I can show it to you if you have not yet experienced it. I hope that day comes. Sadly, I fear that shall not be the case."\n\t\n\t"There is a presence here. It\'s a force. A force that bends things to its will. It preys on my malevolence. I know I sound mad, but I\'m sure of this."\n\t\n\t"I have dispatched of many helpless creatures here. Not my proudest moments to be sure. That force is the strongest in those times. The times where I push myself over that perilous moral edge and indulge in my very nature. The nature of us all. To fight, to kill, to dominate."\n\t\n\t"And yet, the force wanes as I tend to my crops and as I slay the evil things that roam here."\n\t\n\t"Maybe there is no force, and this is just a manifestation of guilt. My abject want of a rejection of progress and to live a peaceful existence."\n\t\n\t"I hope I can see you again. In this life or the next."\n\t\n\t"Your loving sister, Margaret."'],
        [a.BookType.IslandRiddle]: ["Island Riddle", '"I cultivated the land"\n\t\n\t"And dominated over nature"\n\t\n\t"The destitute I remand"\n\t\n\t"Through heinous legislature"\n\t\n\t"Gaze at my wonderful structures"\n\t\n\t"As I tax the poor"\n\t\n\t"Losing my deep-rooted culture"\n\t\n\t"Sacrificed for the allure"\n\t\n\t"I am destined to rise and destined to fall"\n\t\n\t"With an inevitable destruction to mankind and all"'],
        [a.BookType.Trapped]: ["Trapped!", '"One would assume I would be able to make it back home, or at least a bit further from these islands. But try as I might with this ramshackle raft, I am unable to get very far. I somehow always lose my bearing. The horizon becomes unclear and my surroundings blurry. Next thing you know, I am somehow turned around, looping back to the west as I travel east, or back to south as I travel north."\n\t\n\t"I am unable to explain this."\n\t\n\t"Perhaps a faster and better constructed vessel might be a safer idea for traversing these strange seas."\n\t\n\tThe rest of the book is water damaged and most of the writing is illegible.']
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/item/ItemGroups", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.ItemTypeGroup.Anvil]: ["anvil"],
        [a.ItemTypeGroup.Arrow]: ["arrow"],
        [a.ItemTypeGroup.Bait]: ["bait"],
        [a.ItemTypeGroup.Bedding]: ["bedding", " item"],
        [a.ItemTypeGroup.Bone]: ["bone"],
        [a.ItemTypeGroup.Book]: ["book"],
        [a.ItemTypeGroup.Bullet]: ["bullet"],
        [a.ItemTypeGroup.Campfire]: ["campfire"],
        [a.ItemTypeGroup.Carbon]: ["carbon", " item"],
        [a.ItemTypeGroup.ClayJugOfPotableWater]: ["clay jug of potable water"],
        [a.ItemTypeGroup.CoconutContainerOfPotableWater]: ["coconut container of potable water"],
        [a.ItemTypeGroup.Compost]: ["compost", " item"],
        [a.ItemTypeGroup.Container]: ["container"],
        [a.ItemTypeGroup.ContainerOfDesalinatedWater]: ["container of desalinated water"],
        [a.ItemTypeGroup.ContainerOfMedicinalWater]: ["container of medicinal water"],
        [a.ItemTypeGroup.ContainerOfPurifiedFreshWater]: ["container of purified fresh water"],
        [a.ItemTypeGroup.ContainerOfSeawater]: ["container of seawater"],
        [a.ItemTypeGroup.ContainerOfUnpurifiedFreshWater]: ["container of unpurified fresh water"],
        [a.ItemTypeGroup.CookedMeat]: ["cooked meat", " item"],
        [a.ItemTypeGroup.CookingEquipment]: ["cooking equipment"],
        [a.ItemTypeGroup.Cookware]: ["cookware"],
        [a.ItemTypeGroup.Cordage]: ["cordage", " item"],
        [a.ItemTypeGroup.Equipment]: ["equipment", " item"],
        [a.ItemTypeGroup.Fabric]: ["fabric", " item"],
        [a.ItemTypeGroup.Firemaking]: ["firemaking", " item"],
        [a.ItemTypeGroup.FireStarter]: ["fire starter"],
        [a.ItemTypeGroup.Food]: ["food", " item"],
        [a.ItemTypeGroup.Fruit]: ["fruit"],
        [a.ItemTypeGroup.Fuel]: ["fuel", " item"],
        [a.ItemTypeGroup.Furnace]: ["furnace"],
        [a.ItemTypeGroup.GlassBottleOfPotableWater]: ["glass bottle of potable water"],
        [a.ItemTypeGroup.Glue]: ["glue"],
        [a.ItemTypeGroup.Hammer]: ["hammer"],
        [a.ItemTypeGroup.Health]: ["health", " item"],
        [a.ItemTypeGroup.Heating]: ["heating", " item"],
        [a.ItemTypeGroup.Housing]: ["housing", " item"],
        [a.ItemTypeGroup.Kiln]: ["kiln"],
        [a.ItemTypeGroup.Kindling]: ["kindling", "item"],
        [a.ItemTypeGroup.LightSource]: ["light source"],
        [a.ItemTypeGroup.Liquid]: ["liquid"],
        [a.ItemTypeGroup.LitTorch]: ["lit torch"],
        [a.ItemTypeGroup.Meat]: ["meat", " item"],
        [a.ItemTypeGroup.Medicinal]: ["medicinal", " item"],
        [a.ItemTypeGroup.Milk]: ["milk"],
        [a.ItemTypeGroup.MortarAndPestle]: ["mortar and pestle"],
        [a.ItemTypeGroup.Needle]: ["needle"],
        [a.ItemTypeGroup.Other]: ["other", " item"],
        [a.ItemTypeGroup.Pole]: ["pole"],
        [a.ItemTypeGroup.Powder]: ["powder"],
        [a.ItemTypeGroup.Preservative]: ["preservative"],
        [a.ItemTypeGroup.Pulp]: ["pulp", " item"],
        [a.ItemTypeGroup.RawMeat]: ["raw meat", " item"],
        [a.ItemTypeGroup.Reinforce]: ["reinforce", " item"],
        [a.ItemTypeGroup.Repair]: ["repair", " item"],
        [a.ItemTypeGroup.Rock]: ["rock"],
        [a.ItemTypeGroup.Sand]: ["sand"],
        [a.ItemTypeGroup.SandCastFlask]: ["sand cast flask"],
        [a.ItemTypeGroup.Seed]: ["seed"],
        [a.ItemTypeGroup.Sharpened]: ["sharpened", " item"],
        [a.ItemTypeGroup.SharpenedRock]: ["sharpened rock"],
        [a.ItemTypeGroup.Storage]: ["storage", " item"],
        [a.ItemTypeGroup.Tinder]: ["tinder", " item"],
        [a.ItemTypeGroup.Tongs]: ["tongs"],
        [a.ItemTypeGroup.Tool]: ["tool"],
        [a.ItemTypeGroup.Transmogrify]: ["transmogrify", " item"],
        [a.ItemTypeGroup.Trap]: ["trap"],
        [a.ItemTypeGroup.Travel]: ["travel", " item"],
        [a.ItemTypeGroup.Treasure]: ["treasure"],
        [a.ItemTypeGroup.Untradable]: ["untradable"],
        [a.ItemTypeGroup.Vegetable]: ["vegetable"],
        [a.ItemTypeGroup.WaterskinOfPotableWater]: ["waterskin of potable water"],
        [a.ItemTypeGroup.WaterStill]: ["water still"],
        [a.ItemTypeGroup.Weapon]: ["weapon"]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/item/ItemQualities", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.ItemQuality.None]: "none",
        [a.ItemQuality.Random]: "random",
        [a.ItemQuality.Remarkable]: "remarkable",
        [a.ItemQuality.Exceptional]: "exceptional",
        [a.ItemQuality.Legendary]: "legendary"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/item/Items", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.ItemType.AberrantSlitherSucker]: ["aberrant slither sucker", "A living, writhing aberrant slither sucker, constricting itself to you, causing pain as it sinks its teeth into you."],
        [a.ItemType.AloeVeraLeaves]: ["aloe vera leaves", "Thick succulent plant leaves, sharp to the touch and known for their use as an antiseptic. Their inner flesh can be applied to the skin to reduce burning pain."],
        [a.ItemType.AloeVeraSeeds]: ["aloe vera seeds", "These thin black seeds appear to be that from an aloe vera plant. They can be used to grow aloe vera or eaten in dire circumstances."],
        [a.ItemType.AnimalClaw]: ["animal claw", "A sharp claw from an animal. A perfect animal by-product for using as a needle."],
        [a.ItemType.AnimalFat]: ["animal fat", "A gelatinous shaving of animal fat, slimy to the touch. Useful as a rendered fuel."],
        [a.ItemType.AnimalFatTorch]: ["animal fat torch", "A torch; wrapped in rendered animal fat, producing a long-lasting light source."],
        [a.ItemType.AnimalFur]: ["animal fur", "A large clump of animal fur and hair. Could be used as tinder in a situation where wood is not available."],
        [a.ItemType.AnimalGlue]: ["animal glue", "A natural glue processed from boiling animal bones that can be used to reinforce and secure items."],
        [a.ItemType.AnimalPelt]: ["animal pelt", "The remains of an unlucky skinned animal. Can be used as a makeshift garment or dismantled into the hide and fur separately."],
        [a.ItemType.AnimalSkull]: ["animal skull", "A large hollowed-out, bleached animal skull, suitable for crafting into a provisional helmet."],
        [a.ItemType.Apple]: ["apple", "A juicy, delicious red apple. The fruit contains seeds to grow apple trees."],
        [a.ItemType.AppleSeeds]: ["apple seeds", "Still scented like the apples they come from, these small brown seeds are used for planting to grow into apple trees."],
        [a.ItemType.ArrowShaft]: ["arrow shaft", "A whittled down pole, used for the shaft of a fletched arrow."],
        [a.ItemType.Backpack]: ["backpack", "Crafted with leather, it's suitable for holding many items on your back, reducing overall weight."],
        [a.ItemType.Badderlocks]: ["badderlocks", "A stringy wet mass of seaweed. Can be used as cordage or eating in desperation."],
        [a.ItemType.Bandage]: ["bandage", "A tattered piece of fabric, used to staunch wounds and prevent infection."],
        [a.ItemType.BarkLeggings]: ["bark leggings", "Rudimentary leg armor, crafted from strong tree bark and secured with string."],
        [a.ItemType.BarkShield]: ["bark shield", "A makeshift shield, used to block incoming attacks, made with tree bark and wrapped with string."],
        [a.ItemType.BarkTorch]: ["bark torch", "A torch wrapped and bound by stripped tree bark, providing natural oils to increase the life of the torch."],
        [a.ItemType.BarkTunic]: ["bark tunic", "Tree bark chest armor bound together with string."],
        [a.ItemType.Beggarticks]: ["beggarticks", "The flower and stems of beggarticks. Only useful in creating medicinal tonics, or ingesting directly if food supply is low."],
        [a.ItemType.BeggartickSeeds]: ["beggartick seeds", "Dried beggartick seeds which can be planted to grow flowers."],
        [a.ItemType.BlackplateBoots]: ["blackplate boots", "Almost sharp to the touch, these expertly crafted annealed blackplate iron boots will make for satisfactory foot protection as well as fashion."],
        [a.ItemType.BlackplateBreastplate]: ["blackplate breastplate", "A uniquely designed piece of armor to cover your torso with long sharpened points jutting out from the shoulders. Made from a special annealed form of iron."],
        [a.ItemType.BlackplateGauntlets]: ["blackplate gauntlets", "Crafted from annealed iron, these blackplate gauntlets make for excellent hand guards."],
        [a.ItemType.BlackplateGorget]: ["blackplate gorget", "A neck guard, forged from iron and annealed, giving it a darker appearance."],
        [a.ItemType.BlackplateGreaves]: ["blackplate greaves", "These leggings are crafted from iron and annealed, giving it a darkened hue and widened to make the wearer appear larger."],
        [a.ItemType.BlackplateHelmet]: ["blackplate helmet", "An evil gaze has been forged into the face of this annealed iron helmet, giving the wearer a menacing look upon equipping it. Two sturdy metal horns pierce outwards, mimicking some form of animal."],
        [a.ItemType.BlackPowder]: ["black powder", "A highly combustible powder, made up of a combination of minerals."],
        [a.ItemType.BoatPaddle]: ["boat paddle", "A makeshift boat paddle used with boats and rafts, or combat if in dire need."],
        [a.ItemType.BoiledEgg]: ["boiled egg", "A moist, delicious boiled egg. Great tasting and packed with protein."],
        [a.ItemType.Bone]: ["bone", "A heavy, sun-bleached animal bone, suitable for rudimentary combat, gathering, or crafting into more useful items."],
        [a.ItemType.BoneFragments]: ["bone fragments", "A bundle of bones from a small vertebrate. Some cracked, others shattered. The pieces are quite sharp."],
        [a.ItemType.BoneMeal]: ["bone meal", "A pestled pile of powdered bone remnants."],
        [a.ItemType.BoneNeedle]: ["bone needle", "A thin, hard, sharp needle, carved from bone."],
        [a.ItemType.BonePole]: ["bone pole", "A smooth cudgel crafted from a large bone."],
        [a.ItemType.Bow]: ["bow", "A bent wooden pole with a shorter string tied to both ends. The tension of the string is used to fire arrows."],
        [a.ItemType.BowDrill]: ["bow drill", "An advanced fire starting device. Uses the string on a bow to rotate into the wood, reducing much effort."],
        [a.ItemType.Branch]: ["branch", "A typical tree branch, useful for a variety of crafts or stoking a fire."],
        [a.ItemType.BullBoat]: ["bull boat", "A boat made with leather and framed with curved wooden poles. Used to travel to new, far away lands."],
        [a.ItemType.BundleOfSwitchgrass]: ["bundle of switchgrass", "Bundled up switchgrass stalks, complete with its seeds."],
        [a.ItemType.BushelOfWheat]: ["bushel of wheat", "The clipped remains of the stalk and grains from wheat grass."],
        [a.ItemType.ButtonMushrooms]: ["button mushrooms", "Long lasting common white mushrooms. They appear safe to consume."],
        [a.ItemType.CactusNeedle]: ["cactus needle", "A needle from a cactus plant, useful in crafting smaller, more intricate items."],
        [a.ItemType.CactusSpines]: ["cactus spines", "Thin, long spikes, suitable for crafting into makeshift needles."],
        [a.ItemType.CarbonPowder]: ["carbon powder", "Black, sooty carbonized powder."],
        [a.ItemType.Carrot]: ["carrot", "A healthy looking root vegetable, orange in color and full of nutrients. Both the taproot and leaves are edible."],
        [a.ItemType.CarrotSeeds]: ["carrot seeds", "Seeds for growing carrots, taken from seeding carrot flowers."],
        [a.ItemType.Charcoal]: ["charcoal", "Condensed, carbon-rich burned matter."],
        [a.ItemType.CharcoalBandage]: ["charcoal bandage", "A cloth bandage, coated in charcoal and used for its natural antiseptic and anticoagulant properties."],
        [a.ItemType.Chives]: ["chives", "A strong smelling and tasting plant, packed with nutrients and vitamins."],
        [a.ItemType.ChiveSeeds]: ["chive seeds", "The small black appearance of these seeds suggests they are for growing chives."],
        [a.ItemType.ClayBlowpipe]: ["clay blowpipe", "A sturdy blowpipe used for glassblowing."],
        [a.ItemType.ClayBrick]: ["clay brick", "A hardened clay brick, used in the building of structures such as floors and walls."],
        [a.ItemType.ClayBrickFlooring]: ["clay brick flooring", "Flooring crafted from clay bricks. Could be used as decoration or as part of a building."],
        [a.ItemType.ClayBrickWall]: ["clay brick wall", "A wall made from clay bricks, set into a typical skewed, grid-like fashion to increase durability."],
        [a.ItemType.ClayBrickWell]: ["clay brick well", "A well constructed of clay bricks, used to collect water by digging a shaft into the ground."],
        [a.ItemType.ClayCampfire]: ["clay campfire", "A grouping of clay bricks shaped into a ring to contain a fire."],
        [a.ItemType.ClayFlakes]: ["clay flakes", "Dried shavings of clay. Created by shaving clay and drying over a period of time."],
        [a.ItemType.ClayFurnace]: ["clay furnace", "An enclosed structure made of clay bricks, which traps in the heat to keep a long-lasting, high-temperature fire."],
        [a.ItemType.ClayJug]: ["clay jug", "A fully hardened clay jug with a cork. Used to hold water."],
        [a.ItemType.ClayJugOfDesalinatedWater]: ["clay jug of desalinated water", "Potable, safe-to-drink water. The water in this clay jug has gone through the desalination process."],
        [a.ItemType.ClayJugOfGoatMilk]: ["clay jug of goat milk", "A clay jug full of nutritious raw goat milk."],
        [a.ItemType.ClayJugOfMedicinalWater]: ["clay jug of medicinal water", "A clay jug containing medicinal water, used to cure and soothe certain ailments while also replenishing your thirst."],
        [a.ItemType.ClayJugOfPurifiedFreshWater]: ["clay jug of purified fresh water", "A clay jug filled with fresh, purified water. Can be used to quench your thirst."],
        [a.ItemType.ClayJugOfSeawater]: ["clay jug of seawater", "Unfiltered seawater, held in a clay jug. Unsuitable to drink in its current form but could be desalinated."],
        [a.ItemType.ClayJugOfUnpurifiedFreshWater]: ["clay jug of unpurified fresh water", "A clay jug full of natural, fresh water. Although it is drinkable, further purification is recommended."],
        [a.ItemType.ClayKiln]: ["clay kiln", "Similar to a furnace, but constructed with clay and in a way that allows for proper heat distribution for crafting glass and clay items."],
        [a.ItemType.ClayMortarAndPestle]: ["clay mortar and pestle", "A grinding device made from fired and cured clay."],
        [a.ItemType.ClaySandCastFlask]: ["clay sand cast flask", "A moulded clay flask, used for casting and shaping molten metal using malleable green sand."],
        [a.ItemType.ClayWaterStill]: ["clay water still", "A carved-out clay brick with a lid. It's used to desalinate water by boiling it and then collecting the steam into a separate container."],
        [a.ItemType.ClematisSeeds]: ["clematis seeds", "Seeds to grow clematis. Can be eaten if desperate, but they do not contain any significant nutrition."],
        [a.ItemType.ClematisVine]: ["clematis vine", "A long, winding clematis vine, suitable for cordage."],
        [a.ItemType.Cloak]: ["cloak", "An old, but sturdy hooded cloak garment. It appears to be of high quality from a bygone era."],
        [a.ItemType.Coal]: ["coal", "A black and brittle mineral, staining anything it touches, but useful as fuel."],
        [a.ItemType.CobblestoneFlooring]: ["cobblestone flooring", "Primitive flooring created by placing stones in an organized pattern, filling any gaps."],
        [a.ItemType.Coconut]: ["coconut", "A fibrous and heavy fruit. Difficult to consume, but packed with plenty of caloric-dense coconut meat and milk."],
        [a.ItemType.CoconutContainer]: ["coconut container", "An interim liquid container, crafted by poking a hole into a coconut and sealed using a cork."],
        [a.ItemType.CoconutContainerOfCoconutWater]: ["coconut container of coconut water", "A coconut fruit, affixed with a string and cork to contain its natural juice. The container can be reused for other liquids once consumed."],
        [a.ItemType.CoconutContainerOfDesalinatedWater]: ["coconut container of desalinated water", "A coconut filled with water that has gone through the desalination process."],
        [a.ItemType.CoconutContainerOfGoatMilk]: ["coconut container of goat milk", "This coconut container is filled with goat milk, no doubt giving a unique flavor when consumed."],
        [a.ItemType.CoconutContainerOfMedicinalWater]: ["coconut container of medicinal water", "A coconut containing medicinal water, used for treating certain conditions while also quenching some thirst."],
        [a.ItemType.CoconutContainerOfPurifiedFreshWater]: ["coconut container of purified fresh water", "Potable and purified fresh water, enclosed in a coconut container."],
        [a.ItemType.CoconutContainerOfSeawater]: ["coconut container of seawater", "A coconut container filled with seawater. Not suitable for consuming without first being desalinated to remove all the salt content and other impurities."],
        [a.ItemType.CoconutContainerOfUnpurifiedFreshWater]: ["coconut container of unpurified fresh water", "A container full of unpurified fresh water, contained within a coconut. Purification is recommended before consumption."],
        [a.ItemType.CoconutHusk]: ["coconut husk", "The fibrous outer layer of a coconut. Useful for cordage, pulp, and tinder for starting fires."],
        [a.ItemType.CoconutMeat]: ["coconut meat", "An opened coconut fruit, revealing its fleshy edible coconut meat."],
        [a.ItemType.CompositeBow]: ["composite bow", "An expertly crafted bow, designed for both velocity and force."],
        [a.ItemType.CookedAberrantScorpion]: ["cooked aberrant scorpion", "Even though the aberrant scorpion is larger, and its corpse will provide much more food, the texture will most likely be worse when consuming it."],
        [a.ItemType.CookedBlindfish]: ["cooked blindfish", "While the source of the food is a bit suspect, after being cooked, it appears to be more palatable."],
        [a.ItemType.CookedChicken]: ["cooked chicken", "A well-cooked chicken, ready to consume and sure to satisfy."],
        [a.ItemType.CookedCod]: ["cooked cod", "A seared, well-cooked cod, ready to consume and enjoy."],
        [a.ItemType.CookedCornCob]: ["cooked corn cob", "A well cooked cob of corn. Ready to consume and enjoy."],
        [a.ItemType.CookedFishSteak]: ["cooked fish steak", "A cooked fish fillet, seared on the outside and delicious."],
        [a.ItemType.CookedJoshuaTreeFruit]: ["cooked joshua tree fruit", "Roasted and dried joshua tree fruit. It gives off a delightful aroma and has a sweet taste."],
        [a.ItemType.CookedMeat]: ["cooked meat", "Adequately heated meat, safe and ready for consumption."],
        [a.ItemType.CookedPotato]: ["cooked potato", "A skin-on cooked potato; soft and mushy and packed with calories."],
        [a.ItemType.CookedReptileMeat]: ["cooked reptile meat", "A grilled piece of reptile meat. The look and texture could almost be passed as chicken."],
        [a.ItemType.CookedScorpion]: ["cooked scorpion", "While still a bit nauseating to consume, the cooked scorpion can provide much needed sustenance."],
        [a.ItemType.CookedSpiderMeat]: ["cooked spider meat", "Crispy spider meat. Not the best texture or flavor, but contains the more edible portions of the deceased arachnid."],
        [a.ItemType.CookedTaintedMeat]: ["cooked tainted meat", "A piece of discolored meat, cooked to kill possible toxins, but possibly still unsafe for consumption."],
        [a.ItemType.CookedTentacles]: ["cooked tentacles", "Although, still springy to the touch, this cooked cephalopod appendage can be stomached much easier than if raw."],
        [a.ItemType.CookedWormMeat]: ["cooked worm meat", "A cooked patty of worm meat. Unappetizing to think about, but can provide as a good source of needed nutrition."],
        [a.ItemType.Copal]: ["copal", "Hardened tree resin. Can be melted after grinding to reinforce items."],
        [a.ItemType.CopalResin]: ["copal resin", "Ground-up hardened tree resin. Can be melted with high heat to be used as a reinforcement and binding material."],
        [a.ItemType.CopperAnvil]: ["copper anvil", "A heavy shaped slab of copper perched on a wooden base, used in the production of metal weapons, tools, and armor."],
        [a.ItemType.CopperArrow]: ["copper arrow", "A fletched arrow, made with feathers and a copper arrowhead."],
        [a.ItemType.CopperArrowhead]: ["copper arrowhead", "A sharp pointed arrowhead, formed from copper. Can be used as a carving implement."],
        [a.ItemType.CopperAxe]: ["copper axe", "The perfect tool for tree chopping and gathering. This copper-bladed implement can also be used in carving and crafts that require a sharp tool."],
        [a.ItemType.CopperBakingTray]: ["copper baking tray", "A thin rimmed baking sheet made from copper, primarily used for baking foods."],
        [a.ItemType.CopperBoots]: ["copper boots", "Copper boots, work hardened and crafted to fit closely to your feet size."],
        [a.ItemType.CopperBreastPlate]: ["copper breastplate", "Cold formed in a classic abdominal design, this copper breastplate can protect your torso from damage."],
        [a.ItemType.CopperBullet]: ["copper bullet", "A nearly solid copper bullet. Used as ammunition for slings and other ranged weaponry."],
        [a.ItemType.CopperChest]: ["copper chest", "A roomy copper chest, used for caching items and food storage, reducing spoilage."],
        [a.ItemType.CopperDoubleAxe]: ["copper double axe", "An almost lumbering and unwieldy copper weapon and tool."],
        [a.ItemType.CopperGauntlets]: ["copper gauntlets", "Complex and intricate, but still fairly durable. These copper hand armor pieces are used to block damage to your extremities."],
        [a.ItemType.CopperGorget]: ["copper gorget", "A shiny copper neck protection piece."],
        [a.ItemType.CopperGreaves]: ["copper greaves", "Sturdy copper leggings that can be tied around your legs, shielding them from damage."],
        [a.ItemType.CopperHammer]: ["copper hammer", "Although copper tends to be quite malleable, this copper hammer will do the trick in most cases for repair and other crafts."],
        [a.ItemType.CopperHelmet]: ["copper helmet", "A piece of copper head armor, designed with ancient sensibilities."],
        [a.ItemType.CopperHoe]: ["copper hoe", "A gardening tool used to till ground. This tool is cold worked from copper."],
        [a.ItemType.CopperIngot]: ["copper ingot", "A dense, formed brick of copper. Slag and other impurifies have been removed, making it useful for forging into tools, weapons, and armor."],
        [a.ItemType.CopperLockPick]: ["copper lock pick", "A small and precise device used for picking locks, made with refined copper ore."],
        [a.ItemType.CopperMortarAndPestle]: ["copper mortar and pestle", "Used as a grinding and crushing tool. This mortar and pestle is sharped and work hardened from solid copper."],
        [a.ItemType.CopperOre]: ["copper ore", "Raw copper ore with a tinge of oxidation. Can be smelted into ingot form with a cast."],
        [a.ItemType.CopperPickaxe]: ["copper pickaxe", "A copper pick tool, primarily used for gathering rocks and stones; however, copper may not the best choice for such a tool."],
        [a.ItemType.CopperShield]: ["copper shield", "A rounded copper offhanded armor piece. Copper can be an ideal material for taking a beating with such a design."],
        [a.ItemType.CopperShovel]: ["copper shovel", "A copper digging tool, used for lifting soils or resource gathering."],
        [a.ItemType.CopperSpear]: ["copper spear", "A long piercing weapon with a copper spearhead."],
        [a.ItemType.CopperSword]: ["copper sword", "A sharp and work hardened copper blade, designed for close quarter combat."],
        [a.ItemType.CopperTongs]: ["copper tongs", "Tongs crafted from copper, used to grasp hot objects, protecting your hands and fingers."],
        [a.ItemType.CordedSling]: ["corded sling", "A thick piece of cordage, wrapped and bound with a slot made for a projectile. Used to swing ammunition, increasing throwing range."],
        [a.ItemType.Cork]: ["cork", "A small cork plug. Crafted from rubbery tree bark; it can be used to contain liquids in bottles and other containers."],
        [a.ItemType.CornEar]: ["corn ear", "An ear of corn, wrapped in its husk; ready to be shucked and cooked, or eaten raw."],
        [a.ItemType.CornSeeds]: ["corn seeds", "Dried and aged corn kernels, used for planting and growing corn stalks."],
        [a.ItemType.Cotton]: ["cotton", "A downy bundle of opened cotton seeds, the ideal solution for spinning thread and making fabrics."],
        [a.ItemType.CottonBedroll]: ["cotton bedroll", "A soft and downy sleeping mattress, rolled up for ease of carrying. Can be used to sleep or rest very comfortably."],
        [a.ItemType.CottonFabric]: ["cotton fabric", "A soft piece of cloth spun from cotton."],
        [a.ItemType.CottonSeeds]: ["cotton seeds", "De-fluffed and cleaned off cotton seeds, ready to plant."],
        [a.ItemType.CreatureIdol]: ["creature idol", "A mass of animal organs, crudely shaped into some kind of figure. It smells awful and emits an odd humming noise, and appears to attract creatures."],
        [a.ItemType.Cucumber]: ["cucumber", "A cucumiform gourd fruit, grown from a creeping vine. Full of nutrients and packed with water content."],
        [a.ItemType.CucumberSeeds]: ["cucumber seeds", "Seeds taken from inside the fruit of a cucumber."],
        [a.ItemType.CypressCone]: ["cypress cone", "A rounded cone from a cypress tree, containing seeds."],
        [a.ItemType.CypressLeaves]: ["cypress leaves", "Flat bladed foliage from a cypress tree. Can be used for tinder or compost when dried out."],
        [a.ItemType.CypressSeeds]: ["cypress seeds", "Sharp to the touch, these seeds can be used for growing cypress trees."],
        [a.ItemType.DeadAberrantScorpion]: ["dead aberrant scorpion", "The body of a large aberrant scorpion. It can be cooked over low heat to provide a more palatable eating experience."],
        [a.ItemType.Deadfall]: ["deadfall", "A large, flat rock, propped up with a stick. Once set, anything that triggers it will be crushed or injured from the falling rock."],
        [a.ItemType.DeadScorpion]: ["dead scorpion", "A dispatched scorpion, ready to be skewered and cooked for the brave indifferent eater."],
        [a.ItemType.DeathKnightAxe]: ["death knight axe", "A uniquely forged axe with a gnarled design; the signature of a powerful death knight. The entire weapon is casted, making it very heavy, but powerful."],
        [a.ItemType.Dough]: ["dough", "A simple kneaded dough consisting of wheat flour and water. The consistency leaves a lot to be desired for baked goods, but it may suffice for some recipes."],
        [a.ItemType.DrawnMap]: ["drawn map", "A paper sheet, scrawled with geographical landmarks and features. Used to approximate a location when read."],
        [a.ItemType.Earthworm]: ["earthworm", "A live wriggling worm, effective for bait or eating on its own."],
        [a.ItemType.Ectoplasm]: ["ectoplasm", "A ghostly, weightless fluff of misty goo, strangely self-contained and quickly evaporating."],
        [a.ItemType.Egg]: ["egg", "A brown colored egg, laid by a chicken. Can be eaten as is, or cooked for a tastier meal."],
        [a.ItemType.ExplosiveTrap]: ["explosive trap", "A mound of leaves used to conceal a volatile explosive powder. Stepping on it will trigger a small explosion."],
        [a.ItemType.Feather]: ["feather", "Some bright white plumage from an avian creature."],
        [a.ItemType.FeatherBedroll]: ["feather bedroll", "A bedroll made with soft feathers and wrapped in fabric. Used for resting and sleeping in comfort."],
        [a.ItemType.FertileSoil]: ["fertile soil", "A rich and nutrient-dense soil, suitable for setting down to attempt to grow plants in for maximum fertility."],
        [a.ItemType.Fertilizer]: ["fertilizer", "A rich mixture of organic chemical compounds, suitable for combining with soil to create fertile soil."],
        [a.ItemType.FireBladder]: ["fire bladder", "An oddly shaped organ from a fire-breathing creature. Hot to the touch; it appears to contain a deadly chemical reaction inside."],
        [a.ItemType.FirePlough]: ["fire plough", "A fire making device which uses a stick and groove method to create heat through friction."],
        [a.ItemType.FishingNet]: ["fishing net", "A checkered weave of string with weights on each corner, used to trap and catch fish."],
        [a.ItemType.FishingRod]: ["fishing rod", "A flexible, smooth wooden rod with a string line and sharpened hook. Used for fly fishing."],
        [a.ItemType.Flask]: ["flask", "A glass container which can be heated to use for desalination, a process used to make seawater drinkable."],
        [a.ItemType.FlintlockPistol]: ["flintlock pistol", "A long range, high damage pistol. Requires black powder and bullets to fire."],
        [a.ItemType.Flour]: ["flour", "Wheat ground down into a white powdery form. Used in the process of making dough."],
        [a.ItemType.FlyAmanita]: ["fly amanita", "An odd looking, and even odder smelling red spotted mushroom."],
        [a.ItemType.Fossil]: ["fossil", "A carbonized fossil of a species long since extinct."],
        [a.ItemType.Giblets]: ["giblets", "A batch of cooked animal organs. Considerably repugnant, but nutritious and filling."],
        [a.ItemType.GildedRedBook]: ["gilded red book", "An old, fancy looking book with a red cover, gilded with golden trim."],
        [a.ItemType.GlassBottle]: ["glass bottle", "A transparent vessel with a cork for containment. Used for collecting water."],
        [a.ItemType.GlassBottleOfDesalinatedWater]: ["glass bottle of desalinated water", "A bottle filled with clear seawater that has been processed to remove the salt content."],
        [a.ItemType.GlassBottleOfGoatMilk]: ["glass bottle of goat milk", "A bottled batch of goat milk, filled to the top of this glass bottle."],
        [a.ItemType.GlassBottleOfMedicinalWater]: ["glass bottle of medicinal water", "A bottled concoction of herbs and nutrients. Used to cure thirst, poisons, and other ailments."],
        [a.ItemType.GlassBottleOfPurifiedFreshWater]: ["glass bottle of purified fresh water", "Potable, and safe to hydrate yourself with. The water has been purified reducing any toxins and unsafe bacteria."],
        [a.ItemType.GlassBottleOfSeawater]: ["glass bottle of seawater", "Filled to the top with seawater. While seawater is technically drinkable, it will not reduce your thirst."],
        [a.ItemType.GlassBottleOfUnpurifiedFreshWater]: ["glass bottle of unpurified fresh water", "A bottle containing water that is likely unfit to drink. It will quench your thirst, but may have negative side-effects until it's purified."],
        [a.ItemType.GoldCoins]: ["gold coins", "Shiny, golden coins, from a lost civilization unknown to you."],
        [a.ItemType.GoldenChalice]: ["golden chalice", "A large, ornate, and resplendent chalice."],
        [a.ItemType.GoldenKey]: ["golden key", "A large and decorative key forged from gold."],
        [a.ItemType.GoldenRing]: ["golden ring", "A golden ring, most likely used as a sign of wealth and power."],
        [a.ItemType.GoldenSword]: ["golden sword", "An ornate, but soft sword, forged from solid gold. Not suitable for combat due to its softness."],
        [a.ItemType.GrassSeeds]: ["grass seeds", "Small dried grass seeds. Can be planted to grow grass."],
        [a.ItemType.GreenSand]: ["green sand", "A form of malleable sand made with clay, used to make molds for metal casting."],
        [a.ItemType.Grindstone]: ["grindstone", "A coarse rock useful for sanding, sharpening, and repairing other items."],
        [a.ItemType.Hammock]: ["hammock", "A comfortable place to sleep, although not too sturdy. Crafted by bound cordage and usually hung off of the ground."],
        [a.ItemType.HandDrill]: ["hand drill", "A rudimentary fire making tool which uses a stick and another piece of wood. Both hands are used to twist the stick against wood, making friction to create an ember for the fire."],
        [a.ItemType.Hardtack]: ["hardtack", "A nonperishable biscuit, baked at high temperatures for long periods of time to remove all moisture from it."],
        [a.ItemType.HitchingPost]: ["hitching post", "A sturdy wooden structure fastened with a large rope. It can be used to hitch animals and creatures to restrict their movement."],
        [a.ItemType.HoneyFungus]: ["honey fungus", "A parasitic fungi, grown from a tree and possibly edible."],
        [a.ItemType.Inkstick]: ["inkstick", "A hardened brick of ink, used for drawing and painting."],
        [a.ItemType.IronAnvil]: ["iron anvil", "A sturdy iron anvil. Used in the production of metal armor, weapons, tools, and more."],
        [a.ItemType.IronArrow]: ["iron arrow", "An arrow tipped with a high-quality iron arrowhead. Fletched with feathers to stabilize flight and accuracy."],
        [a.ItemType.IronArrowhead]: ["iron arrowhead", "An expertly forged iron arrowhead, used to create arrows. Alternatively, can be used to carve if necessary."],
        [a.ItemType.IronAxe]: ["iron axe", "An iron-forged axe used in wood chopping. Its sharp end can be used for crafting and carving."],
        [a.ItemType.IronBakingTray]: ["iron baking tray", "A baking sheet crafted from iron and used for baking. It has raised edges to help retain food and shallow liquids."],
        [a.ItemType.IronBoots]: ["iron boots", "Heavy iron plated boots, shielding your feet from damage."],
        [a.ItemType.IronBreastplate]: ["iron breastplate", "Durable, armor worn over the torso. One could take a serious beating while wearing this."],
        [a.ItemType.IronBullet]: ["iron bullet", "A strong, forged iron bullet. Used as sling or firearm ammunition."],
        [a.ItemType.IronChest]: ["iron chest", "A large iron chest that is both roomy and sturdy. Foods contained within will decay at a slower rate."],
        [a.ItemType.IronDoubleAxe]: ["iron double axe", "An axe with a forged, double sided head, ideal for both combat and gathering."],
        [a.ItemType.IronGauntlets]: ["iron gauntlets", "Iron gloves designed to be protective and durable, while maintaining as much flexibility as possible."],
        [a.ItemType.IronGorget]: ["iron gorget", "A round metal brace worn around the neck and over the shoulders."],
        [a.ItemType.IronGreaves]: ["iron greaves", "Iron leggings; to be strapped on and function as leg protection."],
        [a.ItemType.IronHammer]: ["iron hammer", "A strong hammer with an iron head, perfect for shaping and repairing items."],
        [a.ItemType.IronHelmet]: ["iron helmet", "Iron plated headgear designed to withstand heavy blows."],
        [a.ItemType.IronHoe]: ["iron hoe", "A long-handled gardening tool with a blade on the end, forged from iron. Used to till soil for better plant growth."],
        [a.ItemType.IronIngot]: ["iron ingot", "A solid brick of iron, ready to be formed or melted and cast in many ways."],
        [a.ItemType.IronLockPick]: ["iron lock pick", "A pair of iron picks and wrenches, durable enough to pick the most adept of locks."],
        [a.ItemType.IronMortarAndPestle]: ["iron mortar and pestle", "Forged from iron; this device can be used for crushing and grinding other items."],
        [a.ItemType.IronOre]: ["iron ore", "Unprocessed, raw iron ore. Can be smelted into ingots using a cast or worked with in a wrought iron form."],
        [a.ItemType.IronPickaxe]: ["iron pickaxe", "A robust mining implement, with a blade forged from iron."],
        [a.ItemType.IronShield]: ["iron shield", "A large and heavy iron shield, used for blocking projectiles or melee attacks."],
        [a.ItemType.IronShovel]: ["iron shovel", "A heavy iron digging implement, lifting and breaking through even the toughest gravels and soils."],
        [a.ItemType.IronSpear]: ["iron spear", "A polearm with a strong pointed tip forged from iron."],
        [a.ItemType.IronSword]: ["iron sword", "A strong, sharp blade designed for thrusting and slashing."],
        [a.ItemType.IronTongs]: ["iron tongs", "Durable iron tongs used to grab hot items, protecting your hands from damage."],
        [a.ItemType.JoshuaTreeFlowers]: ["joshua tree flowers", "A blossoming batch of flowers gathered from a joshua tree. The flowers are sticky to the touch and smell quite sweet and possibly edible if not a bit bitter."],
        [a.ItemType.JoshuaTreeFruit]: ["joshua tree fruit", "The oval-shaped fruiting body of the joshua tree. It appears to be edible but may be more pleasant cooked."],
        [a.ItemType.JoshuaTreeLeaves]: ["joshua tree leaves", "A bundle of spiny joshua tree leaves which are almost as unique looking as the joshua tree itself. Suitable for usage as cordage or dried out and used as tinder."],
        [a.ItemType.JoshuaTreeSeeds]: ["joshua tree seeds", "Large black seeds extracted from a joshua tree fruit."],
        [a.ItemType.Journal]: ["journal", "A leather-bound soft journal. It appears it has seen a lot of use over time."],
        [a.ItemType.LargeRock]: ["large rock", "A rather large rock, handy for crafting many tools and devices."],
        [a.ItemType.LavaBeetleHelmet]: ["lava beetle helmet", "An extremely hard and fire-resistant helmet, sourced from the carcass of a fallen lava beetle."],
        [a.ItemType.LeafBedroll]: ["leaf bedroll", "A provisional bed with poor insulation and scratchy half-dried leaves, used for sleeping or resting."],
        [a.ItemType.LeatherBelt]: ["leather belt", "Made from tanned animal hide, cut, wrapped, and stitched together to tie around the waist."],
        [a.ItemType.LeatherBoots]: ["leather boots", "Malleable yet tough foot protection, crafted from tanned animal hide."],
        [a.ItemType.LeatherCap]: ["leather cap", "A hat made of leather, double layered for extra sturdiness."],
        [a.ItemType.LeatherGloves]: ["leather gloves", "Leather-bound hand protection, crafted from tanned animal hide."],
        [a.ItemType.LeatherGorget]: ["leather gorget", "A circlet of leather, bound in two, stitched together and used as neck protection."],
        [a.ItemType.LeatherHide]: ["leather hide", "A fresh leather hide, stripped from an animal and de-furred."],
        [a.ItemType.LeatherPants]: ["leather pants", "Basic leather leggings with just enough padding to provide some leg protection."],
        [a.ItemType.LeatherQuiver]: ["leather quiver", "A leather-bound, back-mounted container designed to hold arrows; however, other items will also fit inside as well."],
        [a.ItemType.LeatherSling]: ["leather sling", "A sling crafted from tanned leather. Designed to hold a projectile to be thrown at an increased velocity."],
        [a.ItemType.LeatherTunic]: ["leather tunic", "A leather garment which provides protection for the torso."],
        [a.ItemType.Leaves]: ["leaves", "A handful of foliage used as compost, to stoke a fire, or as tinder when dried."],
        [a.ItemType.Lens]: ["lens", "Glass formed into a partially convex shape. It allows focusing sunlight into a single location, creating enough heat for a fire."],
        [a.ItemType.Lettuce]: ["lettuce", "This leafy green vegetable is rich in vitamins and quite filling when eaten."],
        [a.ItemType.LettuceSeeds]: ["lettuce seeds", "Seeds taken from lettuce that has turned to seed."],
        [a.ItemType.Limestone]: ["limestone", "A mineral-rich rock that can be ground into a powder. Useful for metal and glass production."],
        [a.ItemType.LimestonePowder]: ["limestone powder", "A white, mineral-dense powder used in glass tempering and the purifying of metals."],
        [a.ItemType.LitAnimalFatTorch]: ["lit animal fat torch", "A bright burning, pleasant smelling torch. Made with a pole and long lasting, rendered animal fat."],
        [a.ItemType.LitBarkTorch]: ["lit bark torch", "Provides light to your surroundings when equipped and can also be used to start other fires."],
        [a.ItemType.LitPoleTorch]: ["lit pole torch", "A wooden pole that has been lit on fire. Not suitable for long journeys in the darkness."],
        [a.ItemType.LockPick]: ["lock pick", "An improvised needle and prong that should be strong enough to pick a lock or two."],
        [a.ItemType.Log]: ["log", "A sturdy piece of wood, useful for construction or as a fuel for a fire."],
        [a.ItemType.LongBow]: ["long bow", "Nearly as tall as the average person, this bow is designed for maximum range."],
        [a.ItemType.Macuahuitl]: ["macuahuitl", "A wooden club, adorned with razor-sharp fragments of obsidian. Brittle in combat, but deadly and effective in practice."],
        [a.ItemType.MageRobe]: ["mage robe", "An ancient tattered robe, once owned by a spell casting foe."],
        [a.ItemType.MagicalEssence]: ["magical essence", "An odd transparent powder with organic and ethereal materials. This magical matter may be used on items to affix magical properties on to them."],
        [a.ItemType.MapleSeeds]: ["maple seeds", "Small, winged seeds that seemingly dance and twirl in the air as they fall from a maple tree."],
        [a.ItemType.MeltedCopal]: ["melted copal", "Heated copal resin; used to create a hardened bind when cooled on to another item."],
        [a.ItemType.MessageInABottle]: ["message in a bottle", "An old cloudy bottle with an unidentified object contained inside."],
        [a.ItemType.MilkThistleFlowers]: ["milk thistle flowers", "The flowering bulbs of a milk thistle plant. Filled with a bitter but nutritious milk."],
        [a.ItemType.MilkThistleSeeds]: ["milk thistle seeds", "Small hard seeds, used for growing milk thistle plants."],
        [a.ItemType.MossCoveredBook]: ["moss covered book", "A book that has seen better days. It smells of mold and earth and seems fragile."],
        [a.ItemType.Niter]: ["niter", "A natural mineral, ground up to be used as a preservative or for other chemical applications."],
        [a.ItemType.Nopal]: ["nopal", "A de-spined cactus pad, filled with refreshing liquid and nutrition."],
        [a.ItemType.Obsidian]: ["obsidian", "An extremely sharp and hard shard of obsidian, useful for cutting, but very brittle."],
        [a.ItemType.ObsidianArrow]: ["obsidian arrow", "A fletched arrow using an obsidian arrowhead, delivering substantial piercing potential."],
        [a.ItemType.ObsidianArrowhead]: ["obsidian arrowhead", "A brittle, but razor-sharp arrow tip, to be crafted into an arrow with a shaft and fletching."],
        [a.ItemType.ObsidianAxe]: ["obsidian axe", "An axe with an obsidian blade, known for its slashing prowess, but also brittle in practice."],
        [a.ItemType.ObsidianKnife]: ["obsidian knife", "A shard of obsidian fastened into a handle and bound with string. Can be used as a carving tool or in short-range combat."],
        [a.ItemType.ObsidianShovel]: ["obsidian shovel", "A digging tool with a large piece of obsidian attached to the end. Beautiful to look at, but less effective due to the fragility of the obsidian."],
        [a.ItemType.ObsidianSpear]: ["obsidian spear", "An obsidian-tipped polearm used in melee combat or thrown for added range."],
        [a.ItemType.Offal]: ["offal", "A mound of organs, tissue, and other undesirable portions of an unlucky animal."],
        [a.ItemType.OldEducationalScroll]: ["{0?{0}:old} educational scroll", "An unfurled scroll with a large amount of text explaining some in-depth knowledge on a specific skill."],
        [a.ItemType.OldInstructionalScroll]: ["{0?{0}:old} instructional scroll", "A tattered sheet of paper with some roughly scribbled instructions and diagrams."],
        [a.ItemType.OrbOfInfluence]: ["orb of influence", "A strange spherical orb that gives off a shimmering radiance on your touch. It appears to hum as you hold it."],
        [a.ItemType.OrnateBlueBook]: ["ornate blue book", "An expensive looking book with a blue hard cover. The insides and back have heavy wear on inspection."],
        [a.ItemType.OrnateCape]: ["ornate cape", "A red and gold stitched cape, which drapes the back and fastens at the neck. Worn as a status symbol."],
        [a.ItemType.OrnateWoodenChest]: ["ornate wooden chest", "A decorative wooden container gilded with symbols inlaid into the wood."],
        [a.ItemType.PalmLeaf]: ["palm leaf", "A large leaf from a palm tree. The strong inner fibers of the leaf are perfect for cordage."],
        [a.ItemType.PaperMold]: ["paper mold", "A mold used for making paper. Contains a screen that holds wet recycled fibers to dry and press into flattened, usable paper."],
        [a.ItemType.PaperSheet]: ["paper sheet", "A large piece of paper. It appears to contain many recycled fibers. Suitable for drawing on with ink."],
        [a.ItemType.Peat]: ["peat", "A dried mass of sponge-like plants, great for fire fuel and composting."],
        [a.ItemType.PeatBandage]: ["peat bandage", "A fabric bandage combined with peat as an effective antiseptic."],
        [a.ItemType.PeeledCoconut]: ["peeled coconut", "The remaining coconut fruit after husking the outer layer. Its innards contain thirst-quenching coconut water and protein-rich meat. You may fashion this into a coconut container with string and cork."],
        [a.ItemType.Pemmican]: ["pemmican", "A ball of dried ground meat. With a long shelf life, this is the ultimate survival food. For the best benefits, prepare it with animal fat."],
        [a.ItemType.PileOfAsh]: ["pile of ash", "The powdery remains of burned matter."],
        [a.ItemType.PileOfBeachSand]: ["pile of beach sand", "A large pile of fine beach sand, useful for making glass when refined."],
        [a.ItemType.PileOfCompost]: ["pile of compost", "A mix of decaying organic matter, full of chemical nutrients and great for growing plants when combined with other fertilizer components."],
        [a.ItemType.PileOfDesertSand]: ["pile of desert sand", "A pile of coarse desert sand with an orange hue. Can be refined for use in glass making."],
        [a.ItemType.PileOfGravel]: ["pile of gravel", "A large pile of damp stone and sand."],
        [a.ItemType.PileOfSnow]: ["pile of snow", "A melting snow pile. Useful to drink in desperate need, but be quick!"],
        [a.ItemType.Pineapple]: ["pineapple", "A juicy, ripe pineapple, loaded with vitamins and thirst-quenching attributes."],
        [a.ItemType.PineappleSeeds]: ["pineapple seeds", "Small brown seeds that can be planted to grow into pineapple plants."],
        [a.ItemType.PlantRoots]: ["plant roots", "A tangled mess of roots, with earth still hanging from the tips."],
        [a.ItemType.PoisonIvyLeaves]: ["poison ivy leaves", "Causes irritation to the touch; these leaves of three do not belong on your person."],
        [a.ItemType.PoisonIvySeeds]: ["poison ivy seeds", "Bright green, soft seeds, used to plant to grow into poison ivy."],
        [a.ItemType.Potato]: ["potato", "Starchy edible tubers. Not suitable for consumption without cooking due to toxicity."],
        [a.ItemType.PotatoSeeds]: ["potato seeds", "An alternative way to grow potatoes without using seed potatoes. These will grow into a potato plant seedling."],
        [a.ItemType.PreparedPemmican]: ["prepared pemmican", "A seasoned mound of dried ground meat, fried and cooked with fat for maximum flavor and caloric content."],
        [a.ItemType.PricklyPearFruit]: ["prickly pear fruit", "The fruiting body of a prickly pear cactus. The insides are extremely red and juicy."],
        [a.ItemType.PricklyPearSeeds]: ["prickly pear seeds", "These appear to be prickly pear seeds. Can be planted to grow cacti or eaten."],
        [a.ItemType.Pumpkin]: ["pumpkin", "A heavy orange squash, filled with edible pulp. Contains seeds for growing more."],
        [a.ItemType.PumpkinSeeds]: ["pumpkin seeds", "Large, flat pumpkin seeds. Can be shelled and eaten or planted as is."],
        [a.ItemType.Raft]: ["raft", "A small, simple boat; a quicker alternative to swimming. Effective for traversing large expanses of water."],
        [a.ItemType.Raspberries]: ["raspberries", "Lush, ripe raspberries, plucked from a raspberry bush."],
        [a.ItemType.RaspberrySeeds]: ["raspberry seeds", "Seeds that will grow into a raspberry bush, given enough time and care."],
        [a.ItemType.RawBlindfish]: ["raw blindfish", "An odd-looking fish with no eyes. Very slimy to the touch."],
        [a.ItemType.RawChicken]: ["raw chicken", "A small, plump and de-feathered chicken carcass, ready for cooking."],
        [a.ItemType.RawClay]: ["raw clay", "A soft, formable mud. Suitable for building materials, tool-making, and more."],
        [a.ItemType.RawClayBlowpipe]: ["raw clay blowpipe", "An unfired clay blowpipe used in glassblowing. Unusable until it has been fired."],
        [a.ItemType.RawClayBrick]: ["raw clay brick", "A soft piece of raw clay, molded into a rectangle. Ready to be fired inside a kiln."],
        [a.ItemType.RawClayJug]: ["raw clay jug", "A formed and sculpted jug molded from raw clay. Requires a cork and a kiln to be fired and hardened."],
        [a.ItemType.RawClayMortarAndPestle]: ["raw clay mortar and pestle", "An unfired mortar and pestle, used as a grinding device when hardened."],
        [a.ItemType.RawCod]: ["raw cod", "Slimy to the touch, but healthy and delicious to eat. Can be cooked for a better meal."],
        [a.ItemType.RawFishSteak]: ["raw fish steak", "A raw piece of fish, cut into a fillet. Good to eat as is, but is tastier cooked."],
        [a.ItemType.RawMeat]: ["raw meat", "A raw, bloody chunk of meat. Cooking is recommended before consumption."],
        [a.ItemType.RawReptileMeat]: ["raw reptile meat", "A grainy piece of edible reptile flesh. Generally, not safe to consume without being cooked due to bacteria."],
        [a.ItemType.RawTaintedMeat]: ["raw tainted meat", "A piece of bad-smelling meat, possibly diseased or tainted with parasites. Possible to consume, but could be deadly."],
        [a.ItemType.RefinedSand]: ["refined sand", "A finely ground sand, useful in making glass."],
        [a.ItemType.RollOfRedCarpet]: ["roll of red carpet", "A rolled-up piece of red carpet, suitable for making a comfortable living space or welcoming important guests."],
        [a.ItemType.Rope]: ["rope", "A thick, twisted piece of cordage, useful for heavy-duty binding."],
        [a.ItemType.RottenMeat]: ["rotten meat", "Acrid decomposing animal tissue. You would not want to eat this, but can be used in compost."],
        [a.ItemType.RottingVegetation]: ["rotting vegetation", "A stinking mash of organic plant matter, now usable as compost. Unless you want to risk eating it."],
        [a.ItemType.SaguaroCactusChunk]: ["saguaro cactus chunk", "A hefty chunk of wet, de-spined cacti. There does appear to be quite a bit of liquid contained in the soft flesh, but it smells odd."],
        [a.ItemType.SaguaroCactusFruit]: ["saguaro cactus fruit", "A fleshy pod gathered from a saguaro cactus. It can be cut open to discover its juicy red innards."],
        [a.ItemType.SaguaroCactusSeeds]: ["saguaro cactus seeds", "Oblong black seeds extracted from the fruit of the saguaro cactus."],
        [a.ItemType.Sail]: ["sail", "A large piece of fabric, woven together to be attached to a mast. Used on a sailboat to propel it along the sea."],
        [a.ItemType.Sailboat]: ["sailboat", "A large one-man boat. Used to traverse large expanses of water and for travel back to civilization."],
        [a.ItemType.Saltpeter]: ["saltpeter", "A ground mineral, to be used as a natural food preservative. If combined with other minerals, it can be combustible."],
        [a.ItemType.Sandstone]: ["sandstone", "A soft, malleable rock, useful for construction and tool making."],
        [a.ItemType.SandstoneCampfire]: ["sandstone campfire", "A grouping of sandstone shaped into a ring to contain a fire."],
        [a.ItemType.SandstoneFlooring]: ["sandstone flooring", "A group of sandstone bricks, placed in a grid to be used as flooring."],
        [a.ItemType.SandstoneFurnace]: ["sandstone furnace", "An enclosed structure made of sandstone, which traps in the heat to keep a long-lasting, high-temperature fire."],
        [a.ItemType.SandstoneKiln]: ["sandstone kiln", "Similar to a furnace, but constructed with sandstone and in a way that allows for proper heat distribution for crafting glass and clay items."],
        [a.ItemType.SandstoneMortarAndPestle]: ["sandstone mortar and pestle", "A mortar and pestle carved from sandstone, used to grind up other items."],
        [a.ItemType.SandstoneSandCastFlask]: ["sandstone sand cast flask", "A mold for casting molten metals, made with a green sand mixture and placed into a carved piece of sandstone."],
        [a.ItemType.SandstoneWall]: ["sandstone wall", "A constructed wall built from mined sandstone."],
        [a.ItemType.SandstoneWaterStill]: ["sandstone water still", "A hollowed-out piece of sandstone with a lid. It's used to desalinate water by boiling it and then collecting the steam into a separate container."],
        [a.ItemType.SandstoneWell]: ["sandstone well", "A round empty enclosure made of sandstone, which can be built and extended deep into the ground to collect water."],
        [a.ItemType.Scales]: ["scales", "Dried and hardened scales from a reptilian creature. Can be used as a rudimentary fabric."],
        [a.ItemType.ScorpionStinger]: ["scorpion stinger", "A dangerous item to be held indeed. This scorpion stinger still contains its venom."],
        [a.ItemType.Shale]: ["shale", "A brittle but sharp carving implement."],
        [a.ItemType.SharkFin]: ["shark fin", "Not much more than a trophy, this carved dorsal fin remains slippery and rubbery to the touch."],
        [a.ItemType.SharpenedBone]: ["sharpened bone", "A sharp bone, useful for carving other objects."],
        [a.ItemType.SharpGlass]: ["sharp glass", "A semi-opaque shard of glass, formed after melting sand down."],
        [a.ItemType.SharpRock]: ["sharp rock", "A sharpened rock, useful for crafting, tool making, and carving when required."],
        [a.ItemType.SheafOfHay]: ["sheaf of hay", "Long and almost sharp to the touch. These grass stalks are perfect for string making, animal feed, or tinder when dried."],
        [a.ItemType.SheetOfGlass]: ["sheet of glass", "A cloudy tempered piece of glass. Practical for many optical tools and other simple devices used to harness the sun."],
        [a.ItemType.ShortBow]: ["short bow", "A bow designed for powerful shots at close range."],
        [a.ItemType.ShreddedPaper]: ["shredded paper", "Torn pieces paper assembled into a loose pile. Can be turned into a mash and used as pulp or used as tinder in firemaking."],
        [a.ItemType.Sinew]: ["sinew", "Strong and flexible animal tissue. Commonly used for making bows or simple cordage."],
        [a.ItemType.SkeletalMageWand]: ["skeletal mage wand", "A mysterious, gnarled staff with a twinkling red gemstone attached to the end."],
        [a.ItemType.Skullcap]: ["skullcap", "A hollowed-out animal skull, useful as a provisional helmet."],
        [a.ItemType.SlimeGelatin]: ["slime gelatin", "A lump of slime gelatin which jiggles upon your touch. Can be used to preserve food, or melted down and used as glue."],
        [a.ItemType.SlimeGlue]: ["slime glue", "A glue consisting of boiled slime gelatin that can be used to bind and reinforce items."],
        [a.ItemType.SlitherSucker]: ["slither sucker", "A living, writhing slither sucker, constricting itself to you, causing pain as it sinks its teeth into you."],
        [a.ItemType.SmallBag]: ["small bag", "A leather pouch used for holding a few items, carried at your waist, reducing encumbrance."],
        [a.ItemType.SmoothRock]: ["smooth rock", "A round, smoothed rock, useful for many crafts."],
        [a.ItemType.Snare]: ["snare", "A short pole pushed into the ground with a string attached. Designed to ensnare creatures in its slipknot."],
        [a.ItemType.Soil]: ["soil", "A pile of moist dirt. The heavy smell of earth permeates your nostrils when holding it."],
        [a.ItemType.SolarStill]: ["solar still", "A still that collects condensation and filters it into a hole beneath the glass, desalinating the water and draining it into a container."],
        [a.ItemType.SpiderEggs]: ["spider eggs", "Soft and squishy to the touch. These small silken eggs contain arachnid life inside."],
        [a.ItemType.SpiderMeat]: ["spider meat", "A spider's fleshy innards. It's hard to stomach, even when cooked. Try not to think about what you're eating."],
        [a.ItemType.SpiderSilk]: ["spider silk", "A delicate but strong strand of silk, produced by a spider. Can be used as cordage."],
        [a.ItemType.SpruceCone]: ["spruce cone", "A prickly cone from a spruce tree, filled with seeds contained inside its scales."],
        [a.ItemType.SpruceNeedles]: ["spruce needles", "Dense, needled branches from a spruce tree. Useful for compost or drying out for tinder."],
        [a.ItemType.SpruceSeeds]: ["spruce seeds", "White seeds for growing a spruce tree, ejected from a spruce cone."],
        [a.ItemType.Spyglass]: ["spyglass", "An improvised, short-range telescope, which can be used to see slightly further away in any direction when equipped."],
        [a.ItemType.StoneAnvil]: ["stone anvil", "A solid stone anvil. Used in the production of metal armor, weapons, and tools."],
        [a.ItemType.StoneArrow]: ["stone arrow", "A projectile to be fired from a bow, crafted with an arrowhead and feather to control flight."],
        [a.ItemType.StoneArrowhead]: ["stone arrowhead", "Crafted from stone and to be used in the crafting of arrows. Could also be used as a carving implement."],
        [a.ItemType.StoneAxe]: ["stone axe", "A simple stone axe used for chopping wood or as a carving implement."],
        [a.ItemType.StoneBullet]: ["stone bullet", "A basic stone projectile for slings and firearms. Smooth and more or less spherical in shape."],
        [a.ItemType.StoneCampfire]: ["stone campfire", "A grouping of rocks shaped into a ring to contain a fire."],
        [a.ItemType.StoneFurnace]: ["stone furnace", "An enclosed structure made of stone, which traps in the heat to keep a long-lasting, high-temperature fire."],
        [a.ItemType.StoneHammer]: ["stone hammer", "A rudimentary stone hammer, braced on the end of a pole with string. Used for gathering and repairing."],
        [a.ItemType.StoneHoe]: ["stone hoe", "A rudimentary tilling and gardening tool, used to break up soil for more successful growth of plants."],
        [a.ItemType.StoneKiln]: ["stone kiln", "Similar to a furnace, but constructed with rocks and in a way that allows for proper heat distribution for crafting glass and clay items."],
        [a.ItemType.StoneKnife]: ["stone knife", "A sharpened piece of stone acting as blade and socketed into a carved handle and wrapped with string for support. Can be used as a weapon, gathering tool or to carve."],
        [a.ItemType.StoneMortarAndPestle]: ["stone mortar and pestle", "Used for grinding and crushing, made from smooth stones."],
        [a.ItemType.StonePickaxe]: ["stone pickaxe", "A primitive stone pickaxe used for mining into rock or as a stopgap blunt weapon."],
        [a.ItemType.Stones]: ["stones", "A mass of small rocks. Can be used for throwing or crafting."],
        [a.ItemType.StoneSandCastFlask]: ["stone sand cast flask", "A hallowed out rock with green sand moulding inside. Used for casting metal into any shape."],
        [a.ItemType.StoneShovel]: ["stone shovel", "A digging tool made of stone, used to collect different materials from the ground or to route water."],
        [a.ItemType.StoneSpear]: ["stone spear", "A hunting weapon crafted with a stone head, suitable as a throwing weapon."],
        [a.ItemType.StoneWall]: ["stone wall", "A series of interlaced stones and rocks, shaped into a vertical wall structure. Can be built to keep enemies out."],
        [a.ItemType.StoneWaterStill]: ["stone water still", "A hollowed-out rock with a stone lid. It's used to desalinate water by boiling it and then collecting the steam into a separate container."],
        [a.ItemType.StoneWell]: ["stone well", "A stone-built enclosure used to trap and collect groundwater when constructed."],
        [a.ItemType.StrawHat]: ["straw hat", "A hat made from braids of hay, woven together. What it lacks in protection, it makes up for in its sun-blocking properties and style."],
        [a.ItemType.String]: ["string", "Woven fabric; the cornerstone of all crafting materials, mainly used for binding."],
        [a.ItemType.StrippedBark]: ["stripped bark", "A strong, fibrous shaving from a branch, useful for making cordage."],
        [a.ItemType.StrippedLeather]: ["stripped leather", "Thin strips of cut leather, useful for making strings and rope."],
        [a.ItemType.SugarCaneSeeds]: ["sugar cane seeds", "Seeds for planting and growing crops of sugar cane stalks."],
        [a.ItemType.SugarCaneStalks]: ["sugar cane stalks", "Stout, jointed, fibrous stalks that are rich in the sugar content. They can be quite long and the insides can be chewed on for sustenance."],
        [a.ItemType.Sundial]: ["sundial", "A stone timepiece that uses the location of the sun or moon to show the approximate time of day or night."],
        [a.ItemType.Suture]: ["suture", "A sharp needle tool with an attached thin string, used to sew and close gaping wounds."],
        [a.ItemType.SwitchgrassSeeds]: ["switchgrass seeds", "Long dried grass seeds. Can be planted to grow a longer type of grass."],
        [a.ItemType.TailFeathers]: ["tail feathers", "A fluffy clump of white feathers, removed from an avian creature's backside."],
        [a.ItemType.Talc]: ["talc", "A very chalky mineral, only useful in its powder form."],
        [a.ItemType.TalcumPowder]: ["talcum powder", "Chalky and abundantly absorbent to the touch. An agent required for casting of advanced metals."],
        [a.ItemType.TannedLeather]: ["tanned leather", "A durable, treated piece of leather. Used in crafting armor and other tools."],
        [a.ItemType.Tannin]: ["tannin", "A natural treating agent. To be applied on hides to create tanned leather."],
        [a.ItemType.TatteredMap]: ["{0?completed }tattered map", "An old torn map covered with drawings and scribbles, a bit hard to make sense of on first glance."],
        [a.ItemType.TatteredPants]: ["tattered pants", "Brown colored pants, now reduced to shorts from distress and wear."],
        [a.ItemType.TatteredShirt]: ["tattered shirt", "A once fine piece of a clothing, now torn and tattered."],
        [a.ItemType.Tentacles]: ["tentacles", "A slimy, wriggling appendage from an unlucky cephalopod. Can be eaten, but with some force due to the rubbery unpleasant texture."],
        [a.ItemType.Tomato]: ["tomato", "Red, plump and juicy, this savory fruit can be eaten raw for replenishment of hunger as well as some thirst."],
        [a.ItemType.TomatoSeeds]: ["tomato seeds", "Seeds from a tomato, ready for planting and germination to grow into tomato plants."],
        [a.ItemType.Tourniquet]: ["tourniquet", "A hard stud twisted together with a string. Used to twist around a bleeding wound to stem the flow of blood."],
        [a.ItemType.TreeBark]: ["tree bark", "A tough, dense chunk of bark, broken off from a tree. Can be used for kindling or stripping into cordage."],
        [a.ItemType.TumbleweedSeeds]: ["tumbleweed seeds", "Small and slightly thorny, these seeds are used to plant and grow tumbleweeds, as if you ever wanted to grow weeds."],
        [a.ItemType.Twigs]: ["twigs", "A small pile of sticks and tree limbs. Mostly used for kindling."],
        [a.ItemType.VenomGland]: ["venom gland", "The venom producing gland of a snake, still filled with some immobilizing venom."],
        [a.ItemType.VineWhip]: ["vine whip", "A makeshift weapon made simply with vines wrapped together."],
        [a.ItemType.Waterskin]: ["waterskin", "A portable water container, made from stitched leather."],
        [a.ItemType.WaterskinOfDesalinatedWater]: ["waterskin of desalinated water", "A waterskin full of freshly desalinated seawater."],
        [a.ItemType.WaterskinOfGoatMilk]: ["waterskin of goat milk", "A filled leather waterskin containing the raw milk from a goat."],
        [a.ItemType.WaterskinOfMedicinalWater]: ["waterskin of medicinal water", "A soothing mixture of plants and roots. Used to heal poisons and illnesses."],
        [a.ItemType.WaterskinOfPurifiedFreshWater]: ["waterskin of purified fresh water", "A full waterskin of fresh, safe-to-drink water."],
        [a.ItemType.WaterskinOfSeawater]: ["waterskin of seawater", "A waterskin full of seawater, not suitable for drinking without desalination."],
        [a.ItemType.WaterskinOfUnpurifiedFreshWater]: ["waterskin of unpurified fresh water", "Unpurified and possibly hazardous water. It is recommended you purify the water before drinking."],
        [a.ItemType.Wheat]: ["wheat", "The hulled spikelets from wheat grass, containing the raw grains."],
        [a.ItemType.WoodenArrow]: ["wooden arrow", "A provisional wooden projectile to be fired from a bow. Crafted with a feather to control flight."],
        [a.ItemType.WoodenChest]: ["wooden chest", "A large wooden container that can fit many items while placed on the ground. Foods will decay slower within it."],
        [a.ItemType.WoodenDoor]: ["wooden door", "A door crafted from long wooden planks with large wooden hinges. Can be opened and closed when built."],
        [a.ItemType.WoodenDowels]: ["wooden dowels", "A gathering of small wooden pegs. Used as hinges in woodworking or as kindling in firemaking."],
        [a.ItemType.WoodenFence]: ["wooden fence", "A section of wooden fencing, constructed from two logs and held together with horizontal beams."],
        [a.ItemType.WoodenFlooring]: ["wooden flooring", "Wooden floor boards; planed to equal height and length."],
        [a.ItemType.WoodenGate]: ["wooden gate", "A gate crafted from long wooden planks with small wooden hinges. Can be opened and closed when built."],
        [a.ItemType.WoodenMortarAndPestle]: ["wooden mortar and pestle", "Carved from wood; this makeshift device can be used for crushing up items."],
        [a.ItemType.WoodenPole]: ["wooden pole", "A long piece of wood, carved and shaved down into a smooth rod from a branch or log."],
        [a.ItemType.WoodenSandCastFlask]: ["wooden sand cast flask", "A mold for casting metal into any shape, made with green sand and placed into a carved-out log."],
        [a.ItemType.WoodenShavings]: ["wooden shavings", "A dry bunch of wooden shavings, used to ignite kindling when starting a fire."],
        [a.ItemType.WoodenSpear]: ["wooden spear", "A makeshift, easy to craft hunting weapon. Makes for an ideal ranged weapon."],
        [a.ItemType.WoodenSword]: ["wooden sword", "A sturdy blunt sword, crafted from wood with a sharp piercing point. Most useful for sparring practice."],
        [a.ItemType.WoodenTongs]: ["wooden tongs", "A pair of simple wood tongs, used to pick up hot objects without injury."],
        [a.ItemType.WoodenWall]: ["wooden wall", "A sturdy set of bound logs, forming a protective wall that can be placed."],
        [a.ItemType.WormMeat]: ["worm meat", "Essentially a mash of worm innards, almost ground up into a paste. Definitely not the most appetizing, but can be cooked for better flavor."],
        [a.ItemType.WovenFabric]: ["woven fabric", "A makeshift piece of fibrous tissue, woven together into fabric."],
        [a.ItemType.WroughtIron]: ["wrought iron", "A heavily oxidized and unpurified form of iron, used in the forging of brittle tools, weapons, and armor."],
        [a.ItemType.WroughtIronAnvil]: ["wrought iron anvil", "An anvil made from wrought iron with a wooden base. Useful for metalworking."],
        [a.ItemType.WroughtIronArrow]: ["wrought iron arrow", "An arrow with a wrought iron arrowhead. The shaft of the arrow is long and is fletched with feathers."],
        [a.ItemType.WroughtIronArrowhead]: ["wrought iron arrowhead", "Forged with wrought iron, this arrowhead is used to craft an arrow. In dire need, it could also be used for carving."],
        [a.ItemType.WroughtIronAxe]: ["wrought iron axe", "An axe forged out of wrought iron, primarily used for lumberjacking and carving."],
        [a.ItemType.WroughtIronBakingTray]: ["wrought iron baking tray", "A rigid sheet pan crafted from flattened wrought iron."],
        [a.ItemType.WroughtIronBoots]: ["wrought iron boots", "Wrought iron footwear. Heavy and made specifically for protecting feet and lower legs."],
        [a.ItemType.WroughtIronBreastPlate]: ["wrought iron breastplate", "A large wrought iron chest plate, worn over the torso."],
        [a.ItemType.WroughtIronBullet]: ["wrought iron bullet", "A small ball of wrought iron, used as ammunition for slingshots or firearms."],
        [a.ItemType.WroughtIronChest]: ["wrought iron chest", "A spacious container built from wrought iron that can store many items. Foods will spoil slower inside of it."],
        [a.ItemType.WroughtIronDoubleAxe]: ["wrought iron double axe", "A dual-bladed axe which can provide enough slashing damage for both combat and gathering."],
        [a.ItemType.WroughtIronGauntlets]: ["wrought iron gauntlets", "Intricate and sturdy, these wrought iron gloves fit snugly on your hands."],
        [a.ItemType.WroughtIronGorget]: ["wrought iron gorget", "A molded piece of metal, used to protect the area around the neck and shoulders."],
        [a.ItemType.WroughtIronGreaves]: ["wrought iron greaves", "Wrought iron leggings, strapped and padded around the legs to reduce most damage."],
        [a.ItemType.WroughtIronHammer]: ["wrought iron hammer", "A large mallet crafted from wrought iron. Useful for repairing and sometimes gathering."],
        [a.ItemType.WroughtIronHelmet]: ["wrought iron helmet", "Using a barbute design, this iron helmet shields the head from most kinds of attacks."],
        [a.ItemType.WroughtIronHoe]: ["wrought iron hoe", "A long pole with a wrought iron metal blade attached to the end. Used to till the ground for planting seeds."],
        [a.ItemType.WroughtIronLockPick]: ["wrought iron lock pick", "A set of picks and wrenches made from wrought iron, used for picking and unlocking locked devices."],
        [a.ItemType.WroughtIronMortarAndPestle]: ["wrought iron mortar and pestle", "Used for pulverizing items, forged from wrought iron."],
        [a.ItemType.WroughtIronPickaxe]: ["wrought iron pickaxe", "A dual-headed mining implement. One head is heavy and blunt, the other, spiked to cut through rock with ease."],
        [a.ItemType.WroughtIronShield]: ["wrought iron shield", "A sturdy wrought iron shield, made by bending large sheets of metal into shape."],
        [a.ItemType.WroughtIronShovel]: ["wrought iron shovel", "A shovel with an angled, pointed head, useful for digging and water routing."],
        [a.ItemType.WroughtIronSpear]: ["wrought iron spear", "A polearm with pointed head, crafted from wrought iron. Used in melee or thrown in combat."],
        [a.ItemType.WroughtIronSword]: ["wrought iron sword", "A long, sharpened blade fitted into a solid hilt and forged from wrought iron. A good, strong weapon."],
        [a.ItemType.WroughtIronTongs]: ["wrought iron tongs", "A pair of tongs, forged from wrought iron. Used to lift hot objects without injury."]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/item/LegendaryItems", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.LegendaryType.Attack]: "power",
        [a.LegendaryType.Defense]: "guarding",
        [a.LegendaryType.Illumination]: "illumination",
        [a.LegendaryType.WeightCapacity]: "magnitude",
        [a.LegendaryType.ItemWeight]: "featherweight",
        [a.LegendaryType.Stat]: "{0}",
        [a.LegendaryType.Skill]: "{0}",
        [a.LegendaryType.Benignity]: "benevolence",
        [a.LegendaryType.Malignity]: "malevolence",
        [a.LegendaryType.Range]: "range",
        [a.LegendaryType.UseBenefits]: "potency",
        [a.LegendaryType.Worth]: "worth",
        [a.LegendaryType.TrapDamage]: "trapping",
        [a.LegendaryType.MaxWeight]: "lightening",
        [a.LegendaryType.ContainerWeight]: "storing"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/misc/Commands", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.Command.Ban]: "ban",
        [a.Command.Banned]: "banned",
        [a.Command.Commands]: "commands",
        [a.Command.Kick]: "kick",
        [a.Command.Pause]: "pause",
        [a.Command.Ping]: "ping",
        [a.Command.Players]: "players",
        [a.Command.Save]: "save",
        [a.Command.Unban]: "unban"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/misc/InspectTypes", ["require", "exports", "game/inspection/IInspection"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.InspectType.Corpses]: "Corpses",
        [a.InspectType.Creature]: "Creatures",
        [a.InspectType.NPC]: "NPCs",
        [a.InspectType.Player]: "Players",
        [a.InspectType.Tile]: "Terrain",
        [a.InspectType.TileEvents]: "Tile Events",
        [a.InspectType.Doodad]: "Doodads",
        [a.InspectType.Items]: "Items"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/misc/MiscTranslations", ["require", "exports", "language/dictionary/Misc"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.MiscTranslation.Unknown]: "Unknown",
        [a.MiscTranslation.UnknownCreature]: "Unknown Creature",
        [a.MiscTranslation.UnknownItem]: "unknown item",
        [a.MiscTranslation.UnknownDoodad]: "Unknown Doodad",
        [a.MiscTranslation.UnknownTileEvent]: "Unknown Tile Event",
        [a.MiscTranslation.ReformatSingularNoun]: "{0?{0}:{reformat({1},{2}):{3}}}",
        [a.MiscTranslation.ItemQualityColor]: "{0?{#--item-quality-{0}:{1}}:{1}}",
        [a.MiscTranslation.ItemQuality]: "{0?{ItemQuality:{0}} }{1}",
        [a.MiscTranslation.Thing]: "{0}",
        [a.MiscTranslation.Message]: "{0?{#--message-type-{0}:{1}}:{1}}",
        [a.MiscTranslation.CorpseOf]: "{Corpse:{0}?{Corpse:{0}}:{Message:CorpseOf:({1})}}",
        [a.MiscTranslation.AAndB]: "{0} and {1}",
        [a.MiscTranslation.AOrB]: "{0} or {1}",
        [a.MiscTranslation.ListItemSeparator]: ", ",
        [a.MiscTranslation.AListAndB]: "{0}, and {1}",
        [a.MiscTranslation.AListOrB]: "{0}, or {1}",
        [a.MiscTranslation.CountThing]: "{0} {1}",
        [a.MiscTranslation.Renamed]: '"{0}"',
        [a.MiscTranslation.HumanName]: "{#--text-color-player:{0}}",
        [a.MiscTranslation.Aberrant]: "{#--message-type-bad:{0}}",
        [a.MiscTranslation.ItemLegendary]: "{1} of {0}"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/misc/ModTypes", ["require", "exports", "mod/IModInfo"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.ModType.Internal]: "Internal",
        [a.ModType.Workshop]: "Workshop",
        [a.ModType.Local]: "Local"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/misc/Numbers", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const a = {
        0: "zero",
        1: "one",
        2: "two",
        3: "three",
        4: "four",
        5: "five",
        6: "six",
        7: "seven",
        8: "eight",
        9: "nine",
        10: "ten",
        11: "eleven",
        12: "twelve",
        13: "thirteen",
        14: "fourteen",
        15: "fifteen",
        16: "sixteen",
        17: "seventeen",
        18: "eighteen",
        19: "nineteen",
        ten1: "ten",
        ten2: "twenty",
        ten3: "thirty",
        ten4: "fourty",
        ten5: "fifty",
        ten6: "sixty",
        ten7: "seventy",
        ten8: "eighty",
        ten9: "ninety",
        tens: "{tens}{ones?-{ones}}",
        hundreds: "{hundreds} hundred{and? {and}}",
        thousands: "{thousands} thousand{and? {and}}",
        millions: "{millions} million{and? {and}}",
        billions: "{billions} billion{and? {and}}"
    };
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/misc/Sources", ["require", "exports", "player/IMessageManager"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.Source.All]: "All",
        [a.Source.Action]: "Action",
        [a.Source.Allies]: "Humans and Pets",
        [a.Source.Chat]: "Chat",
        [a.Source.Combat]: "Combat",
        [a.Source.Command]: "Command",
        [a.Source.Creature]: "Creature",
        [a.Source.Equipment]: "Equipment",
        [a.Source.Game]: "Game",
        [a.Source.Item]: "Item",
        [a.Source.Meta]: "Meta",
        [a.Source.Milestone]: "Milestone",
        [a.Source.Multiplayer]: "Multiplayer",
        [a.Source.Resource]: "Resource Collection",
        [a.Source.Skill]: "Skill",
        [a.Source.Wellbeing]: "Well-Being",
        [a.Source.Stat]: "Stat"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/player/Milestones", ["require", "exports", "player/IMilestone"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.MilestoneType.Abnormalizer]: ["Abnormalizer", "Killed 25 aberrant creatures."],
        [a.MilestoneType.Artificer]: ["Artificer", "Transmogrified an item."],
        [a.MilestoneType.Benevolent]: ["Benevolent", "Reached 64,000 benignity."],
        [a.MilestoneType.Boundless]: ["Boundless", "Reach 125% in a single skill."],
        [a.MilestoneType.Chef]: ["Chef", "Cooked 25 food items."],
        [a.MilestoneType.Collector]: ["Collector", "Collected one of every item."],
        [a.MilestoneType.Crafter]: ["Crafter", "Crafted 250 items."],
        [a.MilestoneType.Doctor]: ["Doctor", "Cured each status effect."],
        [a.MilestoneType.DragonSlayer]: ["Dragon Slayer", "Slayed a drake."],
        [a.MilestoneType.Explorer]: ["Explorer", "Stepped on or gathered from every type of tile."],
        [a.MilestoneType.Exterminator]: ["Exterminator", "Killed 1000 creatures."],
        [a.MilestoneType.Friendly]: ["Friendly", "Tamed 25 creatures."],
        [a.MilestoneType.Gardener]: ["Gardener", "Planted 50 plants or mushrooms."],
        [a.MilestoneType.Gatherer]: ["Gatherer", "Gathered 1000 times."],
        [a.MilestoneType.Grandmaster]: ["Grandmaster", "Raised a skill to 100%."],
        [a.MilestoneType.Hunter]: ["Hunter", "Killed 100 creatures."],
        [a.MilestoneType.Huntsman]: ["Huntsman", "Killed one of every creature."],
        [a.MilestoneType.Locksmith]: ["Locksmith", "Lock picked 10 locks."],
        [a.MilestoneType.Malevolent]: ["Malevolent", "Reached 64,000 malignity."],
        [a.MilestoneType.Merchant]: ["Merchant", "Bartered with 100 items."],
        [a.MilestoneType.Navigator]: ["Navigator", "Traversed the seas in search of new lands."],
        [a.MilestoneType.Notekeeper]: ["Notekeeper", "Jotted down a note for each situation."],
        [a.MilestoneType.Operator]: ["Operator", "Used every action available."],
        [a.MilestoneType.Pacifier]: ["Pacifier", "Tamed one of each tamable creature."],
        [a.MilestoneType.Prepared]: ["Prepared", "Equipped something in each equipment slot."],
        [a.MilestoneType.Pulchritudinous]: ["Pulchritudinous", "Equipped a legendary item in each equipment slot."],
        [a.MilestoneType.ReaperOfSouls]: ["Reaper of Souls", "Killed 50 pirate ghosts and harvested their corpses."],
        [a.MilestoneType.Seafarer]: ["Seafarer", "Sailed to civilization and completed the game."],
        [a.MilestoneType.Seasoned]: ["Seasoned", "Survived for 1,000,000 turns."],
        [a.MilestoneType.Survivor]: ["Survivor", "Survived for 10,000 turns."],
        [a.MilestoneType.Talented]: ["Talented", "Reached 1000% in skill percentages across all skills."],
        [a.MilestoneType.Thrower]: ["Thrower", "Thrown 500 items."],
        [a.MilestoneType.Trapper]: ["Trapper", "Injured 10 creatures with traps."],
        [a.MilestoneType.TreasureHunter]: ["Treasure Hunter", "Dug or fished up 10 treasure chests."],
        [a.MilestoneType.Treasurer]: ["Treasurer", "Collected every one of the five types of treasure."],
        [a.MilestoneType.Weathered]: ["Weathered", "Survived for 100,000 turns."]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/player/Names", ["require", "exports", "language/dictionary/HumanName"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.default.Full]: "{HumanName:First:random}{HumanName:Last? {HumanName:Last:random}}",
        [a.default.First]: ["Aann", "Aaron", "Abbell", "Abby", "Abell", "Abendigo", "Abigail", "Abigaile", "Abigaill", "Abigall", "Abigell", "Abraham", "Abrahamt", "Abram", "Abygall", "Acorne", "Adah", "Adam", "Adamo", "Adamson", "Adamus", "Adan", "Adanell", "Adda", "Adde", "Addeline", "Addenel", "Addenell", "Addi", "Addianall", "Addilay", "Addilinah", "Addilyne", "Addin", "Addinall", "Addinel", "Addinell", "Adelin", "Adelina", "Adeline", "Adenel", "Aderline", "Adilene", "Adinal", "Adinell", "Adolina", "Adoline", "Adria", "Adrian", "Adylyne", "Aelcea", "Aelecea", "Agatha", "Agnas", "Agne", "Agnees", "Agnes", "Agness", "Agnet", "Agneta", "Agnete", "Agnetum", "Agnis", "Agnnes", "Agnus", "Ailca", "Ailes", "Ailez", "Ailic", "Ailice", "Ailles", "Aillice", "Ails", "Alacs", "Alas", "Alathea", "Albany", "Albert", "Alc", "Alce", "Alcie", "Aleezes", "Alen", "Ales", "Alesabeth", "Aleson", "Alesonne", "Alexander", "Alexandrius", "Alezes", "Alfred", "Alia", "Alias", "Alic", "Alica", "Alice", "Alicea", "Alices", "Aliceson", "Alicia", "Aliciam", "Alics", "Alie", "Alies", "Alis", "Alise", "Alisia", "Alison", "Alisonn", "Alisonne", "Alithea", "Alixander", "Alixia", "Alizan", "Alizander", "Alizes", "Alizon", "All", "Allam", "Allan", "Allas", "Allce", "Alle", "Allea", "Allen", "Allene", "Allenson", "Alles", "Allese", "Alleson", "Allesonne", "Allexander", "Alley", "Allic", "Allice", "Allicea", "Allicia", "Allicien", "Allicksander", "Allie", "Allies", "Alliner", "Allines", "Allinson", "Allis", "Allisina", "Allisine", "Allison", "Allisone", "Allisonn", "Allisonne", "Allixander", "Alliz", "Allizen", "Alls", "Ally", "Allyce", "Allye", "Allyee", "Allysander", "Allyso", "Allyson", "Alm", "Alma", "Als", "Alyce", "Alys", "Alysand", "Alyse", "Alyson", "Alysone", "Alyxander", "Ambras", "Ambros", "Ambrose", "Ambrosius", "Ambrosse", "Ambus", "Amcoats", "Amelia", "Ames", "Ammeras", "Amorous", "Amos", "Amoz", "Amyell", "Ana", "Anastasia", "Andecus", "Anderson", "Andre", "Andreas", "Andrew", "Andrewe", "Andro", "Ane", "Aneran", "Anerilla", "Anes", "Angas", "Anges", "Angness", "Anias", "Ann", "Anna", "Annae", "Annam", "Annan", "Annas", "Anne", "Annee", "Annes", "Annie", "Annis", "Anns", "Annus", "Antho", "Anthona", "Anthone", "Anthoney", "Anthonia", "Anthonie", "Anthonius", "Anthony", "Anthonyas", "Anthonye", "Anthonyne", "Anthus", "Antoni", "Antonie", "Antonius", "Antony", "Apolin", "Apollina", "Appilby", "Appolina", "Appollina", "Arabaell", "Arch", "Archabald", "Archbad", "Archbald", "Archbold", "Arche", "Archebald", "Archibald", "Archiball", "Arcye", "Aribald", "Arison", "Aristoteles", "Armstrong", "Arnst", "Aron", "Arraell", "Arthro", "Arthur", "Arthura", "Arthure", "Ather", "Atkinson", "Aubone", "Augs", "Augustus", "Auther", "Avarall", "Avarill", "Avary", "Averall", "Averell", "Averilde", "Averill", "Avery", "Avirilla", "Avis", "Awdria", "Ayles", "Aylles", "Ayres", "Aysley", "Babora", "Bailey", "Bainbridge", "Baker", "Bales", "Banbara", "Barba", "Barbaa", "Barbar", "Barbara", "Barbarah", "Barbaraye", "Barbare", "Barbarey", "Barbari", "Barbaria", "Barbarie", "Barbarry", "Barbary", "Barbarye", "Barbay", "Barbere", "Barberey", "Barberie", "Barberre", "Barberry", "Barbery", "Barberye", "Barbiry", "Barbra", "Barbray", "Barbre", "Barholemew", "Barker", "Barnabas", "Barnabie", "Barnaby", "Barnabye", "Barnard", "Barnarde", "Barnatt", "Barnerd", "Barnes", "Barnet", "Barnett", "Barniby", "Bartell", "Barterim", "Barthilmew", "Bartholelmew", "Bartholemeus", "Bartholemew", "Bartholew", "Barthollomewe", "Bartholomew", "Barthram", "Bartill", "Bartle", "Bartlemew", "Barton", "Bartram", "Bartrame", "Bartramus", "Barty", "Bartyllmew", "Bateman", "Batholemew", "Bathsheba", "Bavington", "Beale", "Beata", "Beatrice", "Beatrix", "Beeley", "Beell", "Beitresse", "Belbie", "Bell", "Belle", "Bellow", "Benamy", "Bend", "Beniamin", "Benjam", "Benjamin", "Benjanin", "Benomi", "Benomy", "Benson", "Benton", "Berbarie", "Bernard", "Bertram", "Besse", "Bessie", "Besy", "Bethel", "Bethuel", "Betreccam", "Betris", "Betsy", "Bett", "Bette", "Betteires", "Betteras", "Betteres", "Bettireia", "Bettram", "Bettras", "Bettres", "Bettress", "Bettresse", "Bettrice", "Bettries", "Bettris", "Bettriss", "Betty", "Billhagh", "Birget", "Blackit", "Blanch", "Blanhe", "Blench", "Blythman", "Boniventure", "Bradberry", "Breget", "Brian", "Briand", "Brianus", "Brice", "Bridget", "Bridgett", "Bridgetta", "Bridggett", "Bridgit", "Bridgitt", "Bridjett", "Brien", "Brigeta", "Brigett", "Brigget", "Brigitt", "Brignal", "Brown", "Bryan", "Bryand", "Bryane", "Bryget", "Bryham", "Burnat", "Burnip", "Byle", "Caleb", "Calverley", "Camela", "Camilla", "Cancilla", "Carolina", "Caroline", "Carolus", "Carter", "Cary", "Cassandra", "Catchisid", "Catearan", "Cateran", "Caterian", "Caterine", "Catharen", "Catharin", "Cathe", "Catherain", "Catheran", "Catheren", "Catherin", "Catherina", "Catherine", "Cathering", "Catherne", "Catheron", "Catheryen", "Catheryn", "Catheryne", "Cathran", "Cathren", "Cathrin", "Cathrine", "Catren", "Catteryn", "Cattyrynye", "Caverley", "Cecile", "Cecilia", "Cecill", "Cecilla", "Cecille", "Cecilliam", "Cecily", "Ceuse", "Chambers", "Charilus", "Charite", "Charitee", "Charity", "Charitye", "Charles", "Charlotte", "Charlton", "Charlys", "Charolus", "Charrolus", "Chatarin", "Chatherine", "Chestepher", "Chipchase", "Chispher", "Chivett", "Chonstans", "Chrestepher", "Chrestopher", "Chrestpher", "Chrisephor", "Chrishbell", "Chrisian", "Christabel", "Christabell", "Christable", "Christebell", "Christiah", "Christian", "Christiana", "Christianna", "Christibell", "Christiforth", "Christine", "Christobel", "Christobell", "Christoble", "Christofer", "Christofor", "Christopher", "Christopherus", "Christopheus", "Christophor", "Christophus", "Chrsfor", "Chrystabell", "Chrytoffer", "Churchian", "Chutbert", "Cibell", "Cicel", "Cicela", "Cicele", "Cicelia", "Ciceliam", "Cicelie", "Cicell", "Cicely", "Cicile", "Cicilea", "Cicilee", "Ciciley", "Cicilia", "Ciciliam", "Cicilie", "Cicilla", "Cicille", "Cicilliam", "Cicillie", "Cicilly", "Cicily", "Cicilye", "Ciclye", "Cillium", "Cirstabell", "Cisilie", "Cisily", "Cisilya", "Cisley", "Cisseley", "Cissely", "Cissilla", "Clament", "Clara", "Clare", "Clarinda", "Clark", "Clary", "Claudius", "Clemelt", "Clemens", "Clement", "Clemente", "Coates", "Cockerell", "Codial", "Collet", "Colleta", "Collin", "Comance", "Commissary", "Conand", "Conandus", "Consand", "Constance", "Constancia", "Cooper", "Cordal", "Cordell", "Corn", "Cornelia", "Cornelius", "Cornellis", "Cornelysis", "Cownandus", "Craggs", "Craine", "Cressy", "Crestepher", "Crestopher", "Creswell", "Cristabell", "Crister", "Cristian", "Cristibell", "Cristobella", "Cristofer", "Cristofur", "Cristoper", "Cristopher", "Crooks", "Crosswell", "Crozier", "Crystabell", "Crystybell", "Cubbart", "Cudbart", "Cudbert", "Culbert", "Cumberland", "Curchian", "Curstabell", "Curtley", "Custance", "Custans", "Custantiam", "Custon", "Cutberd", "Cutbert", "Cutch", "Cutchbart", "Cutchbat", "Cutchbert", "Cuthbard", "Cuthbart", "Cuthbartus", "Cuthber", "Cuthbert", "Cuthberte", "Cuthbertus", "Cutheberd", "Cuthert", "Cuttbert", "Damian", "Danel", "Daniel", "Daniell", "Dann", "Danniell", "Darcy", "Dary", "Daved", "David", "Davide", "Davie", "Davison", "Dawson", "Debbora", "Debora", "Deborah", "Debrah", "Delice", "Demes", "Den", "Dena", "Denic", "Denn", "Denne", "Dennis", "Dennys", "Denys", "Denysse", "Detrus", "Diana", "Dianey", "Dickenson", "Dickeson", "Dickinson", "Dickson", "Didnes", "Dilworth", "Dina", "Dinah", "Dinnes", "Dionesius", "Dionise", "Ditham", "Dixon", "Dods", "Dodshon", "Donking", "Donnette", "Dorath", "Dorathe", "Dorathea", "Dorathey", "Dorathie", "Dorathoe", "Dorathy", "Dorathye", "Doratie", "Dorcas", "Dorete", "Dorethia", "Dorethy", "Dorety", "Doreyte", "Doriethie", "Doriety", "Dorite", "Doritee", "Doritey", "Doritha", "Dorithe", "Dorithea", "Doritheam", "Dorithee", "Dorithie", "Dorithy", "Dorithye", "Doriti", "Doritia", "Doritie", "Dority", "Doritye", "Doroothy", "Doroth", "Dorothe", "Dorothea", "Dorotheam", "Dorothee", "Dorothie", "Dorothy", "Dorothye", "Dorotie", "Doroty", "Dorrathy", "Dorraty", "Dorret", "Dorreta", "Dorrete", "Dorrety", "Dorrite", "Dorritee", "Dorrithie", "Dorrithy", "Dorritie", "Dorrity", "Dorritye", "Dorrothie", "Dorrothy", "Dorrythy", "Dorryty", "Dorthithea", "Dorthy", "Dorty", "Dorytey", "Dorythe", "Dorythey", "Dorythie", "Dorythy", "Dorytie", "Doryty", "Dorytye", "Douglas", "Druscilla", "Dtendl", "Dudley", "Dulcibella", "Duncan", "Dyanes", "Dyanis", "Dye", "Dyna", "Dyonise", "Dyonisius", "Dyonnes", "Eales", "Eallis", "Earingshaw", "Easter", "Easther", "Eathar", "Eather", "Ebbaline", "Ebeneezer", "Eccho", "Ector", "Edawrd", "Ede", "Eden", "Edena", "Edeth", "Edin", "Edith", "Edmand", "Edmond", "Edmonde", "Edmonte", "Edmounde", "Edmund", "Edmundas", "Edmunde", "Edmundos", "Ednes", "Edom", "Edrus", "Edvardus", "Edwad", "Edward", "Edwarde", "Edwardus", "Edwerd", "Edwin", "Edy", "Effam", "Effula", "Egedius", "Egress", "Ekin", "Elainor", "Elan", "Elanor", "Elasabath", "Elasabeth", "Elazebeth", "Elbith", "Elces", "Eldaah", "Eldia", "Elean", "Eleana", "Eleanor", "Eleanora", "Eleanour", "Eleazer", "Eleibeth", "Eleinour", "Elen", "Elena", "Elene", "Elener", "Elenere", "Elenner", "Elennor", "Elenor", "Elenora", "Elenoram", "Elenour", "Eleonar", "Eleoner", "Eleonor", "Eleonorum", "Elesabath", "Elesabeth", "Elesbeth", "Elesepeth", "Elezabeth", "Elezbath", "Elezebeth", "Elia", "Elianer", "Eliann", "Elianna", "Elianor", "Elianora", "Elias", "Elie", "Elies", "Elijah", "Elin", "Elina", "Eline", "Elineor", "Eliner", "Elinor", "Elinora", "Elinour", "Elionara", "Elioner", "Elionere", "Elionna", "Elionor", "Elionora", "Elisabeth", "Elisebeth", "Elison", "Elixsander", "Eliza", "Elizabeta", "Elizabeth", "Elizabetha", "Elizabethe", "Ell", "Ellab", "Ellabeth", "Ellan", "Ellanor", "Elleanor", "Ellebeth", "Elleese", "Ellen", "Ellena", "Ellenar", "Ellene", "Ellener", "Ellenna", "Ellennar", "Ellenner", "Ellenor", "Ellenora", "Ellenore", "Ellenour", "Elleonora", "Elleor", "Elles", "Ellesbath", "Ellesebeth", "Ellexarder", "Ellice", "Ellin", "Ellina", "Ellinar", "Elliner", "Elling", "Ellinner", "Ellinnor", "Ellinor", "Ellinora", "Ellinori", "Ellinour", "Ellioner", "Ellis", "Ellisabeth", "Ellisbeth", "Ellise", "Ellisebeth", "Ellisone", "Elliza", "Ellizabeth", "Ellme", "Ellner", "Ellnor", "Ellonor", "Ellons", "Ells", "Ellsabeth", "Ellsbeth", "Ellsebe", "Ellsebeth", "Ellsebeyth", "Ellssebeth", "Ellyce", "Ellyn", "Ellyne", "Ellyner", "Ellyng", "Ellynor", "Ellysabeth", "Ellzebeth", "Ellzibath", "Elnet", "Elnor", "Eloner", "Elonor", "Els", "Elsa", "Elsab", "Elsabet", "Elsabeth", "Elsabetha", "Elsabethe", "Elsapeth", "Elsb", "Elsbeth", "Else", "Elsebeth", "Elsebethe", "Elsebeyth", "Elsebyth", "Elsepath", "Elsepeth", "Elseth", "Elsey", "Elsopeth", "Elspeth", "Elssebeth", "Elteringem", "Elxeth", "Ely", "Elyanor", "Elyce", "Elyn", "Elyner", "Elynor", "Elysabeth", "Elysabethe", "Elyzabeth", "Elyzaibethe", "Elyzaibeyhe", "Elzabe", "Elzabeth", "Elzabethe", "Elzeabeth", "Elzebeth", "Emanuel", "Emanuell", "Emarluel", "Emat", "Emath", "Eme", "Emeet", "Emericke", "Emet", "Emett", "Emiley", "Emily", "Emma", "Emmalay", "Emmanuel", "Emme", "Emmerson", "Emmet", "Emmond", "Emmott", "Emmy", "Emonte", "Emot", "Emote", "Emotte", "Engrum", "Ennett", "Enock", "Epham", "Ephe", "Ephoes", "Ephraim", "Ephriam", "Ephy", "Epilina", "Eppe", "Epphe", "Eppie", "Erasmus", "Ercullus", "Errington", "Esabell", "Esbell", "Esebell", "Esebeyth", "Esotte", "Essabel", "Essabell", "Essebell", "Essebeth", "Essell", "Essybell", "Ester", "Esther", "Estherr", "Esthy", "Eszabell", "Etholbred", "Euphemia", "Evan", "Evans", "Evante", "Expo", "Expofer", "Expoferus", "Expopeus", "Ezabell", "Ezable", "Ezekiel", "Eziabell", "Ezsebell", "Fairbridge", "Faith", "Faithee", "Fanney", "Fanny", "Farbricke", "Fardenando", "Farrow", "Felice", "Fenwick", "Fenwicke", "Ferdinand", "Ferdinanda", "Ferdinando", "Filice", "Filles", "Fillis", "Filos", "Flanders", "Flaunders", "Flawrence", "Flerrin", "Flora", "Florance", "Florence", "Florens", "Florentia", "Forster", "Fortin", "Forton", "Fortun", "Fortune", "Foster", "Fouter", "Fracnis", "Franc", "France", "Frances", "Francesca", "Francese", "Francesse", "Franchis", "Franci", "Francies", "Francis", "Francisa", "Francisca", "Franciscus", "Francise", "Frane", "Franis", "Frank", "Frannces", "Franncis", "Fransis", "Fras", "Frasences", "Fraunces", "Frauncis", "Frederic", "Frederick", "Frilome", "Frinces", "Frnaces", "Fron", "Frqncis", "Fyllese", "Fyllope", "Gabraell", "Gabrell", "Gabriel", "Gabriell", "Gabrill", "Gainforth", "Garmayne", "Garrad", "Garrard", "Gartered", "Garth", "Garthainer", "Garthere", "Gartrett", "Gartrude", "Gary", "Gascin", "Gascoign", "Gascone", "Gaskin", "Gathias", "Gawan", "Gawen", "Gawin", "Gawinus", "Gawmen", "Gawon", "Gawtley", "Gawyne", "Gaye", "Gayle", "Gearvas", "Gelbert", "Gelia", "Gelians", "Gelyan", "Gemmado", "Genat", "Genet", "Gennet", "Geoffrey", "Georg", "George", "Georges", "Georgi", "Georgiana", "Georgius", "Georguis", "Gephray", "Gerald", "Gerard", "Gerardus", "Gerhard", "Gerlick", "Germaine", "German", "Germane", "Geroge", "Gerrard", "Gerrerd", "Gerrett", "Gertrude", "Gibson", "Gideon", "Gilbart", "Gilbarte", "Gilbeart", "Gilberd", "Gilbert", "Gilbertus", "Gilbetus", "Gilbroyt", "Gilean", "Giles", "Gilfray", "Gilian", "Gill", "Gillbert", "Gilliam", "Gillian", "Gillien", "Gilling", "Glenn", "Godfrae", "Godfraie", "Godfray", "Godfree", "Godfrey", "Godfridus", "Goerge", "Goge", "Goldsbrough", "Goodchild", "Goorge", "Gorg", "Gorge", "Gorgs", "Grac", "Grace", "Gracea", "Graci", "Gracia", "Gracie", "Graice", "Grase", "Gratia", "Gray", "Grayce", "Graye", "Greg", "Gregerius", "Gregorie", "Gregorius", "Gregory", "Gregorye", "Griffin", "Grisell", "Grysell", "Guallter", "Gualtenus", "Gualterns", "Guil", "Guilielmus", "Guleilmus", "Gulemius", "Gulfridus", "Gulielemus", "Gulielimus", "Gulielmas", "Gulielmus", "Guliemos", "Guliemus", "Gustavus", "Guy", "Gylbarte", "Gylbert", "Gylbtus", "Gyles", "Gyllan", "Gyrge", "Gyy", "Habell", "Halde", "Hamet", "Hamlett", "Hanah", "Hanary", "Handley", "Hann", "Hanna", "Hannah", "Hannahe", "Hanndro", "Hanno", "Hanwith", "Harper", "Harrie", "Harriet", "Harry", "Harrye", "Hartburn", "Harvey", "Harye", "Haryey", "Haster", "Hauxley", "Hawell", "Haylles", "Hecter", "Hector", "Hedworth", "Helane", "Heleanor", "Helen", "Helena", "Helene", "Helenor", "Helenora", "Helin", "Helina", "Heliner", "Helinor", "Helle", "Hellen", "Hellena", "Hellenor", "Hellenore", "Hellin", "Hellina", "Helline", "Helliner", "Hellinor", "Hellymer", "Hellyn", "Helyn", "Helyna", "Henary", "Hend", "Henderry", "Henderson", "Hendey", "Hendre", "Hendry", "Henerie", "Henerre", "Henerry", "Henery", "Henerye", "Hennary", "Hennery", "Hennry", "Henr", "Henrey", "Henri", "Henric", "Henricum", "Henricus", "Henricy", "Henrie", "Henrietta", "Henrigg", "Henrij", "Henrius", "Henry", "Henrye", "Heppell", "Hercules", "Hericus", "Herioll", "Herison", "Herry", "Heslop", "Hester", "Hestera", "Hesther", "Hestia", "Heth", "Heugh", "Hew", "Hewe", "Hewgh", "Hewghe", "Hewgo", "Heyricke", "Hezekiah", "Hierimas", "Hilda", "Hilday", "Hildred", "Hilton", "Himo", "Hobson", "Hodgson", "Hodshon", "Honer", "Honnor", "Honor", "Honour", "Hoogart", "Hornby", "Howden", "Howe", "Howey", "Howtheam", "Hson", "Hue", "Hugem", "Hugh", "Hughe", "Hugo", "Hugomem", "Hugonem", "Huhge", "Hulda", "Humble", "Humfray", "Humfraye", "Humfrey", "Humfriches", "Humfridus", "Humph", "Humphery", "Humphfraie", "Humphfrey", "Humphidus", "Humphra", "Humphray", "Humphre", "Humphredus", "Humphrey", "Humphry", "Humpray", "Humprey", "Hunter", "Hutchinson", "Hutton", "Hwy", "Hylton", "Iliz", "Illner", "Ilsabeth", "Ilse", "Ingram", "Isaabel", "Isaabell", "Isaac", "Isaack", "Isaacke", "Isaak", "Isab", "Isabe", "Isabeil", "Isabel", "Isabela", "Isabell", "Isabella", "Isabellam", "Isable", "Isacke", "Isaebell", "Isbel", "Isbell", "Isble", "Isebell", "Isobel", "Isobell", "Israel", "Isreal", "Issabel", "Issabell", "Issabella", "Issabill", "Issable", "Issac", "Issbell", "Issebell", "Issell", "Issobell", "Issoble", "Iszabell", "Iszebell", "Izabel", "Izabell", "Izacke", "Izebell", "Jackson", "Jacob", "Jacobi", "Jacobs", "Jacobus", "Jacques", "Jahn", "Jaimes", "Jain", "Jaine", "Jame", "James", "JamesEsq", "Jams", "Jan", "Jana", "Janam", "Janat", "Janate", "Janatt", "Jane", "Janenta", "Janet", "Janeta", "Janett", "Janetta", "Jania", "Janie", "Jann", "Janna", "Jannat", "Jannatt", "Janne", "Jannem", "Jannet", "Janneta", "Jannett", "Jannette", "Jannit", "Janstam", "Janum", "Jarard", "Jararde", "Jarate", "Jared", "Jariad", "Jarmaine", "Jarrad", "Jarrade", "Jarrald", "Jarralde", "Jarrard", "Jarrat", "Jarrate", "Jarratt", "Jarred", "Jarrelde", "Jarret", "Jarrett", "Jarrold", "Jarvace", "Jarvis", "Jason", "Jasper", "Jaymes", "Jayn", "Jayne", "Jaynet", "Jean", "Jeane", "Jeanet", "Jeffaray", "Jeffarde", "Jefferay", "Jefferey", "Jeffery", "Jeffray", "Jeffrey", "Jeffry", "Jefraye", "Jelian", "Jelinger", "Jellian", "Jelliann", "Jellin", "Jelyan", "Jemima", "Jemina", "Jen", "Jenal", "Jenat", "Jenatt", "Jene", "Jenet", "Jeneta", "Jenete", "Jenett", "Jenetta", "Jenit", "Jenite", "Jenken", "Jenkin", "Jennat", "Jennatt", "Jenne", "Jennet", "Jenneta", "Jennett", "Jennetta", "Jennit", "Jennitte", "Jennt", "Jenny", "Jennytte", "Jent", "Jeny", "Jeptha", "Jerard", "Jeremiah", "Jeremie", "Jeremy", "Jerralde", "Jerrard", "Jerrarde", "Jerrona", "Jervas", "Jesbel", "Jesper", "Jess", "Jesse", "Jessie", "Jhoan", "Jhoane", "Jhon", "Jhone", "Jillian", "Jliz", "Joahn", "Joan", "Joana", "Joane", "Joanes", "Joann", "Joanna", "Joannah", "Joanne", "Joannem", "Joannes", "Job", "Jobling", "Joem", "Jofne", "Joh", "Joham", "Johan", "Johana", "Johanan", "Johanes", "Johanis", "Johann", "Johanna", "Johannam", "Johannan", "Johannas", "Johannem", "Johannen", "Johannes", "Johannh", "Johannis", "Johanns", "Johannus", "Johathan", "Johem", "Johes", "Johis", "John", "Johnannam", "Johnannem", "Johnannes", "Johne", "Johnes", "Johnny", "Johnson", "Johon", "Johs", "Joice", "Joiem", "Jokan", "Jon", "Jona", "Jonah", "Jonas", "Jonath", "Jonathan", "Jonathon", "Jone", "Jones", "Jonn", "Jonnanem", "Josef", "Josep", "Josepe", "Joseph", "Josephe", "Josephus", "Joseve", "Joshiah", "Joshua", "Joshuah", "Josiah", "Josian", "Josias", "Jospeh", "Josua", "Josuah", "Jotte", "Jouan", "Joyce", "Juday", "Judd", "Jude", "Judeth", "Judith", "Judithe", "Judyth", "Julia", "Julian", "Juliana", "Juliel", "Julius", "Julliet", "Julyan", "Kactren", "Kane", "Kateren", "Katerin", "Katerina", "Katerne", "Kateron", "Kateryne", "Katharine", "Kathe", "Kather", "Kathera", "Katherain", "Katheraine", "Katheran", "Katherane", "Katherann", "Katheren", "Katherenn", "Katheria", "Katherin", "Katherina", "Katherine", "Kathering", "Katheringe", "Katherne", "Katheron", "Katheryn", "Katheryne", "Kathran", "Kathren", "Kathrin", "Kathrine", "Kathron", "Katren", "Katrin", "Katrine", "Katron", "Katrryng", "Katryne", "Katryng", "Katterina", "Kattre", "Kattren", "Kattrin", "Kay", "Kendal", "Ketherane", "Ketheron", "Kezia", "Kilner", "Kingswood", "Kirby", "Kirchine", "Kirshion", "Kirste", "Kirstebell", "Kirstefor", "Kirtian", "Kirtley", "Kitchen", "Kitty", "Kunance", "Kyrchen", "Kyrchyne", "Kyrcken", "Ladler", "Lainwell", "Lambton", "Lambwell", "Lamerick", "Lamewell", "Lamoriche", "Lancellott", "Lancelot", "Lancelote", "Lancelott", "Lancelotus", "Lanclot", "Lanclote", "Lanclott", "Lansletus", "Lanslote", "Lascelles", "Laurenc", "Laurence", "Laurencius", "Laurentius", "Laurenzius", "Lawerence", "Lawrance", "Lawrence", "Lawrenting", "Lawrentius", "Lawry", "Layburn", "Laynard", "Lazurus", "Leah", "Leanard", "Ledam", "Lenard", "Lenert", "Lenix", "Lennard", "Lennerd", "Leonall", "Leonard", "Leonarde", "Leonardus", "Lesper", "Letitia", "Lettice", "Lewens", "Lewes", "Lewi", "Lewis", "Lews", "Lewse", "Libeus", "Lidday", "Lidia", "Lightfoot", "Lilias", "Lillias", "Lillyn", "Linn", "Linsley", "Lionel", "Lionell", "Lively", "Lodam", "Lodowick", "Lodoyick", "Lodwick", "Lonclot", "Longaveill", "Looke", "Lorrance", "Losilioure", "Louisa", "Louke", "Lourance", "Loving", "Lowenger", "Lowrance", "Lowrans", "Lucam", "Lucas", "Luce", "Lucey", "Lucia", "Luciam", "Lucie", "Luck", "Lucke", "Lucrece", "Lucy", "Lucye", "Ludy", "Luke", "Lumlye", "Lurab", "Lwse", "Lyall", "Lydda", "Lydia", "Lyonall", "Lyonel", "Lyonell", "Maball", "Mabble", "Mabel", "Mabell", "Mabella", "Mable", "Macor", "Madby", "Maddison", "Made", "Madglyne", "Madilon", "Madylyne", "Magalene", "Magaret", "Magareta", "Magdalen", "Magdalena", "Magdalene", "Magdalina", "Magdaline", "Magdallen", "Magdelem", "Magdelena", "Magdelina", "Magdeline", "Magdellan", "Magery", "Magore", "Magrett", "Maibel", "Maibell", "Maira", "Major", "Malachi", "Malcolm", "Malda", "Malde", "Malin", "Malle", "Malley", "Mallie", "Mallye", "Mann", "Marcellus", "Marcus", "Mare", "Maree", "Marey", "Margaert", "Margain", "Margarate", "Margare", "Margaream", "Margareett", "Margarert", "Margaret", "Margareta", "Margarete", "Margarethe", "Margarett", "Margaretta", "Margarget", "Margari", "Margarie", "Margarit", "Margarita", "Margaritam", "Margarite", "Margarrett", "Margartam", "Margartt", "Margary", "Margat", "Margate", "Margatt", "Margayt", "Margeare", "Margere", "Margerea", "Margeret", "Margerey", "Margeri", "Margeria", "Margerie", "Margerium", "Margerre", "Margerret", "Margerrett", "Margert", "Margery", "Margerye", "Marget", "Margett", "Margit", "Margorie", "Margory", "Margot", "Margrat", "Margrate", "Margratt", "Margre", "Margreat", "Margreatt", "Margreet", "Margreett", "Margret", "Margreta", "Margrete", "Margrett", "Margrette", "Margrie", "Margrit", "Margritt", "Margta", "Margyre", "Margyriam", "Mari", "Maria", "Mariam", "Marian", "Mariana", "Marianiam", "Mariann", "Marianne", "Mariaram", "Marie", "Mariella", "Marieria", "Marierie", "Mariery", "Marierye", "Mariey", "Marillam", "Marin", "Marine", "Marion", "Mariona", "Mariorge", "Mariorye", "Marius", "Marjary", "Marjerie", "Marjery", "Marjoria", "Marjorie", "Marjory", "Mark", "Marke", "Marley", "Marmaduck", "Marmaducus", "Marmaduke", "Marmeduke", "Marpitt", "Marrell", "Marriam", "Marrie", "Marriol", "Marry", "Marrye", "Marryon", "Marshall", "Martan", "Martha", "Marthay", "Martiey", "Martin", "Martine", "Marting", "Martinge", "Martinn", "Martinus", "Martyn", "Martyne", "Mary", "Marya", "Maryall", "Maryan", "Marye", "Maryene", "Maryon", "Maryone", "Maryre", "Maryta", "Mase", "Matean", "Matew", "Mathe", "Mather", "Matheus", "Mathew", "Mathewe", "Mathias", "Matho", "Mathocus", "Mathyas", "Matilda", "Matteous", "Matteus", "Mattew", "Mattha", "Matthaeus", "Matther", "Matthew", "Matthewe", "Matthias", "Matthueus", "Mattie", "Maude", "Maudeland", "Maudelin", "Maudlan", "Maudland", "Maudlen", "Maudlin", "Maugham", "Maurice", "Mawd", "Mawde", "Mawdyd", "Max", "Maxwell", "May", "Mayry", "Meall", "Merall", "Mercall", "Mercy", "Merell", "Mergerie", "Mergery", "Merial", "Meriall", "Meriareta", "Meril", "Meriol", "Merioll", "Merral", "Merrell", "Merriall", "Merril", "Merrill", "Merrington", "Meryal", "Meryall", "Metcalfe", "Meynell", "Mgaret", "Mgerie", "Mgerye", "Micah", "Micall", "Michael", "Michaell", "Michaellus", "Michale", "Michall", "Michalle", "Micheall", "Michel", "Michell", "Michiell", "Michill", "Mickell", "Micsell", "Middleton", "Mighall", "Milcah", "Mildred", "Mildreda", "Mile", "Miles", "Miless", "Milisat", "Milisata", "Miller", "Milles", "Millian", "Mirable", "Mirall", "Mireall", "Mirell", "Mirial", "Miriall", "Miriam", "Miriel", "Miroh", "Mirrell", "Mirriall", "Mirriam", "Mirriel", "Mistress", "Mitchel", "Moore", "Moorecocke", "Moorie", "Morley", "Morrel", "Moses", "mother", "Moungeye", "Mouses", "Mtyne", "Muirell", "Muirill", "Mungah", "Munge", "Mungo", "Muriel", "Muril", "Murriall", "Musgrave", "Mychaell", "Mychaill", "Mychall", "Mychell", "Myghell", "Myhell", "Myles", "Myriell", "Myrillam", "Myriol", "Myrrel", "Myrrell", "Myrrill", "Myryell", "Nan", "Nancy", "Nanne", "Naomi", "Nathan", "Nathaniel", "Nathaniell", "Nathanyell", "Nathen", "Necheles", "Necholes", "Nehemiah", "Neil", "Nell", "Ness", "Nevilson", "Newark", "Newby", "Newton", "Nichall", "Nichallars", "Nichol", "Nicholas", "Nicholaus", "Nicholes", "Nicholeus", "Nichollas", "Nicholles", "Nicholson", "Nicholus", "Nickalles", "Nickellass", "Nicklas", "Nickolas", "Nickolass", "Nickolo", "Niclas", "Nicolas", "Nicolaus", "Nicolays", "Nicolum", "Ninan", "Ninian", "Ninion", "Ninivinus", "Noah", "Nocholas", "Noe", "Nycholas", "Nycholase", "Nycholaus", "Nychollas", "Nyckolus", "Nycolas", "Oates", "Oboney", "Odnell", "Oliver", "Oliverus", "Olivia", "Olliuer", "Olyver", "Onnkin", "Osabell", "Osmyn", "Osvould", "Oswald", "Oswalds", "Oswaldus", "Oswan", "Oswen", "Oswin", "Oswine", "Oswold", "Oswoode", "Oswould", "Oswoulde", "Otilwell", "Ottiwell", "Ouswan", "Ouswould", "Owen", "Owenanes", "Owin", "Parcevell", "Parcival", "Parcivale", "Parcivall", "Parcivell", "Parcuell", "Parkin", "Parniell", "Parseuell", "Parseval", "Parsevall", "Parsevel", "Parsevell", "Parswell", "Partus", "Pater", "Patience", "Patreas", "Patriake", "Patricius", "Patrick", "Patricke", "Patrike", "Patteson", "Pattinson", "Pattricke", "Paul", "Pawll", "Pearcivall", "Peart", "Peeter", "Pegge", "Pemberton", "Penelope", "Perceuell", "Percevall", "Percevel", "Percillus", "Percival", "Percivell", "Percivellus", "Percyvelus", "Percywell", "Peregrine", "Persevell", "Persivell", "Peter", "Peterus", "Petronella", "Petronnella", "Petrum", "Petrus", "Petter", "Pexal", "Phatch", "Phebe", "Pheles", "Philas", "Philice", "Philip", "Philipe", "Philipp", "Philippus", "Philis", "Phillas", "Phillese", "Phillice", "Phillip", "Phillipa", "Phillipe", "Phillipus", "Phillis", "Phillise", "Philliss", "Phillop", "Phillope", "Phillupp", "Philop", "Philopeny", "Philotis", "Phineas", "Phoebe", "Phyllis", "Phyllypp", "Pickering", "Plato", "Presela", "Preston", "Price", "Pricilla", "Priscilla", "Proctor", "Proda", "Prudance", "Prudence", "Prudens", "Quintine", "Quintmus", "Quinton", "Quintyne", "Quyntane", "Raafe", "Rabit", "Rachael", "Rachaell", "Rachail", "Racheal", "Rachel", "Rachell", "Rachill", "Rachus", "Rad", "Radbus", "Raddpus", "Raded", "Radess", "Radol", "Radolph", "Radolphham", "Radolphus", "Radul", "Radulph", "Radulpham", "Radulphum", "Radulphus", "Radulus", "Radus", "Rafe", "Raffe", "Rahphe", "Raif", "Raife", "Raiffe", "Railph", "Rainolde", "Raipf", "Raiph", "Raiphe", "Ralf", "Ralfe", "Rallfe", "Rallph", "Ralp", "Ralph", "Ralphe", "Ralulphus", "Ramshaw", "Ranchis", "Rancis", "Randall", "Randell", "Randle", "Randoll", "Raneld", "Ranolde", "Raph", "Raphe", "Ratchell", "Rauf", "Rauff", "Rauffe", "Rawffe", "Rawling", "Rawse", "Raymond", "Raynard", "Raynold", "Rayold", "Rchard", "Rearne", "Rebbeca", "Rebbecca", "Rebecca", "Rebeccah", "Rebeccam", "Rebeccha", "Rebecka", "Rebeckah", "Rebeckay", "Rebeckey", "Rebekah", "Rebekak", "Recca", "Reedheade", "Rees", "Reg", "Reginald", "Reinold", "Relicta", "Renard", "Renee", "Reneld", "Rennald", "Rennolde", "Renold", "Renoldus", "Reonarard", "Reonard", "Rephe", "Reuben", "Rev", "Rey", "Reynald", "Reynddus", "Reyvell", "Rhebecca", "Rhoda", "Rhueben", "Ricardin", "Ricardus", "Riccus", "Richad", "Richar", "Richard", "Richarde", "Richardes", "Richards", "Richardson", "Richardus", "Richart", "Riche", "Richeard", "Richer", "Richerd", "Richmond", "Richus", "Ricus", "Ridley", "Rinion", "Roathe", "Robard", "Robart", "Robarte", "Robartt", "Robartus", "Robbert", "Roberd", "Robert", "Roberta", "Roberte", "Roberts", "Robertt", "Robertus", "Robett", "Robin", "Robinson", "Robson", "Robte", "Robts", "Robtus", "Roddam", "Rodger", "Rodolphus", "Rodrick", "Rogar", "Roger", "Rogerus", "Rogeus", "Rogger", "Rojer", "Roland", "Rolande", "Rolland", "Rollande", "Rosa", "Rosamon", "Rosamond", "Rosamund", "Rosannah", "Rose", "Rosey", "Rosmud", "Rotherforth", "Rouland", "Routlidge", "Roweland", "Rowl", "Rowlance", "Rowland", "Rowlande", "Rowlandus", "Roxby", "Roy", "Rubie", "Rubin", "Rubina", "Ruderforth", "Rudulphus", "Rudulpus", "Rueben", "Russell", "Ruth", "Ruthe", "Rycardus", "Rychard", "Rycharde", "Rychart", "Rycher", "Rycherd", "Rymon", "Sairay", "Samiull", "Sammewell", "Sampson", "Samson", "Samuall", "Samuel", "Samuell", "Samuwell", "Samwell", "Sanctus", "Sanders", "Sanderson", "Sangster", "Sara", "Sarah", "Sarai", "Saram", "Saray", "Saraye", "Sarey", "Sarra", "Sary", "Scythe", "Seath", "Sebell", "Sence", "Septimus", "Sesell", "Sessilay", "Seth", "Sett", "Sharp", "Sharpe", "Shireff", "Shotton", "Sibbea", "Sibbele", "Sibbell", "Sibble", "Sibell", "Sibella", "Sibil", "Sibill", "Sibilla", "Sicela", "Sicely", "Sicile", "Sicilea", "Sicilia", "Sicily", "Silas", "Silvester", "Sim", "Simeon", "Simmonde", "Simon", "Simond", "Simonde", "Simonus", "Simpkin", "Simpson", "Simund", "Singleton", "Sisala", "Siscely", "Siselle", "Sisley", "Sislie", "Sissala", "Sissaly", "Sisselie", "Sissell", "Sissely", "Sissilley", "Sisson", "Sith", "Sitha", "Sithe", "Sithea", "Sjymound", "Skelton", "Smalepaidge", "Smallhop", "Smith", "Solloman", "Solomon", "Sophia", "Sowerby", "Sowlesby", "Sparke", "Spence", "Steaven", "Steeuen", "Stephanus", "Stephen", "Stephenus", "Steven", "Stevene", "Stevenson", "Stewen", "Stiven", "Stokoe", "Stonas", "Strickland", "Stven", "Suckling", "Surtees", "Susan", "Susana", "Susanaye", "Susanna", "Susannah", "Susannay", "Susanne", "Susans", "Susom", "Sussan", "Sussana", "Sussannah", "Suzan", "Suzanna", "Swann", "Swasone", "Swinburne", "Sybell", "Sybill", "Syceley", "Symon", "Symond", "Symone", "Symonns", "Symont", "Symonte", "Sysselly", "Syth", "Sythe", "Sythean", "Tabitha", "Tace", "Talier", "Tamar", "Tamer", "Tayler", "Taylor", "Tedde", "Temple", "Teresa", "Thamar", "Thaymazin", "Theodore", "Theophila", "Theophilus", "Thmas", "Thom", "Thoma", "Thomam", "Thomas", "Thomasin", "Thomasina", "Thomasine", "Thomason", "Thomass", "Thomasson", "Thomazena", "Thomazin", "Thomazina", "Thomazine", "Thomison", "Thomlinson", "Thompso", "Thompson", "Thomson", "Thomtey", "Thomyson", "Thomzye", "Thonas", "Thosas", "Thurstan", "Thursten", "Timosin", "Timothea", "Timotheus", "Timothie", "Timothy", "Tiplady", "Tiseck", "Titus", "Tobia", "Tobias", "Tobie", "Tobit", "Tobius", "Toby", "Tobyam", "Tobyas", "Tobye", "Tobyous", "Todd", "Tomasin", "Tomason", "Tomazin", "Tomeson", "Tomisan", "Tomisine", "Tomison", "Tomlinson", "Tommonson", "Tommoson", "Tomonson", "Tomysen", "Tomyson", "Tomysyne", "Toyson", "Traphoena", "Trestram", "Trinian", "Triny", "Tristaham", "Tristern", "Tristram", "Trollop", "Troth", "Trothy", "Tryphena", "Tunstall", "Turner", "Turpin", "Tymothie", "Tymothy", "Tymothye", "Uasalay", "Uemfrede", "Ullisibell", "Umfray", "Umfrey", "Umfride", "Umphia", "Umphra", "Umphraie", "Umphray", "Umphriam", "Umphry", "Ursala", "Ursella", "Ursellay", "Ursillay", "Ursilley", "Ursula", "Ursulam", "Usabeth", "Usbye", "Useley", "Ussaley", "Ussan", "Usseley", "Ussillie", "Ussula", "Usula", "Uswald", "Uswalde", "Uswand", "Uswenn", "Usworth", "Uswould", "Valantine", "Valentina", "Valentine", "Vasie", "Vaughan", "Vaysee", "Vidua", "Vinca", "Vincent", "Violet", "Violetta", "Volantine", "Volentine", "Voluntine", "Vyctoe", "Wabra", "Wade", "Waide", "Walkenson", "Walker", "Walter", "Walters", "Walterus", "Warington", "Wasetell", "Water", "Wator", "Watson", "Wede", "Wedo", "Wedoo", "Wedow", "Wedowe", "Wenefride", "Wetherell", "Weydefielde", "Whetly", "Whitefield", "Whitfield", "Widow", "Wiggett", "Wigham", "Wilelmus", "Wilfred", "Wilfry", "Wilhelmus", "Wilhemas", "Wiliam", "Wililam", "Wilkinson", "Will", "Willa", "Willaim", "Willam", "Willans", "Willelmus", "Willer", "Willfrey", "Willhemus", "Willi", "Willia", "William", "Williams", "Williamson", "Williamus", "Willielg", "Willieling", "Willielmas", "Willielmus", "Willilam", "Willimus", "Willmas", "Willmus", "Willsam", "Willus", "Willya", "Willyam", "Willye", "Willym", "Wilme", "Wilmus", "Wilson", "Wilsonn", "Wilton", "Wilya", "Wilyam", "Wine", "Winifred", "Winifreda", "Winifrid", "Witherson", "Wny", "Woodifield", "Woodness", "Wormley", "Wyll", "Wyllin", "Wyllm", "Wyllyam", "Wynefryde", "Wyniffryd", "Xdiana", "Xdobell", "Xdofer", "Xdoferus", "Xdopher", "Xopher", "Xpibell", "Xpo", "Xpobel", "Xpobell", "Xpofer", "Xpoferus", "Xpofor", "Xpop", "Xpoper", "Xpopher", "Xpopherus", "Xpterfuth", "Xro", "Xrobell", "Xrofer", "Xroper", "Xrotabell", "Xto", "Xtofer", "Xtopher", "Yidua", "Ysabell", "Yssabell", "Yzabell", "Zacharia", "Zachariah", "Zebulon", "Zecheriah", "Zimri", "Zusana"],
        [a.default.Last]: []
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/player/Notes", ["require", "exports", "language/dictionary/Note"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.default.Bleeding]: ["Bleeding", "{0?{0}:Using my bare hands to {1}} has caused me to begin bleeding. If I do not cease the flow of blood, my situation will quickly become much grimmer. I must stem the flow of blood using a bandage, tourniquet, or suture. I'm starting to feel a bit faint…"],
        [a.default.Burned]: ["Burned", "My seared flesh remains as painful as the moment I burned it. I know that while I am in this constant and unabating pain, my focus and wellbeing will be hampered. It may be wise to attempt to soothe this pain. Perhaps with pouring liquid over the burn, I can stifle the agony. It may be an even wiser idea to take a swim and use the minerals within the water to both sooth and heal the afflicted wound."],
        [a.default.Caving]: ["Caving", "When outside, I hear the chirps and calls of birds and small animals, and I hear the strong winds from the ocean rustle the leaves of trees and other fauna. Every once in a while, in the distance, I hear a loud growl or the sounds of a fevered chase through the underbrush, of a predator and its prey.\n\t\n\tDown here, however, is different story. It is eerily quiet in the depths of the island. And unlike above, the infrequent sounds that I //do// hear send shivers down my spine. A faint tip, tap, as water drips in the distance, a thin whistle as air passes through cracks in the rough stone. An intermittent clicking noise, of what I can only imagine must be the claws of a large arthropod.\n\t\n\tIt would be surprising if these caves didn't have //something// within them. There are other signs of human activity on this island, the caves should be no different. Maybe treasure or other riches. However, I would be lying to myself if I said I wasn't horrified at the thought of continuing deeper."],
        [a.default.Combat]: ["Combat", 'As I engage in combat with {0}, I acknowledge it may not be the best course of actions, given my current situation. The concept of //"fight or flight"// remains lingering in my mind. Perhaps running from {0} could be a consideration in the future. Attempting to tame or offer food to the creature has also crossed my mind.\n\t\n\tIf all else fails, I must protect my life through mortal conflict and dispatch of the creature. I will endeavor to record my findings on the effectiveness of my weapons against certain types of creatures. I note for example, that {0} is seemingly resistant to {1?{1}:no} damage types, and vulnerable to {2?{2}:no} damage types. This also applies to the potential damage the creature inflicts on me against my own armor.\n\t\n\tIn a previous situation, parrying proved to be very valuable, allowing me to block incoming attacks from my sparring partner. As long as I hold two weapons or a shield in my off-hand, I should be able to mitigate some damage from my opponent.'],
        [a.default.Corpse]: ["Corpse", "{corpses} {multiple?lay:lays} there, lifeless. In order to maintain my own life, perhaps it would be beneficial to use a sharp tool or material to carve this corpse and gather the usable remains."],
        [a.default.CreatureTaming]: ["Creature Taming", 'I recall a more innocent time in my life as I witness the deceased {0}. The adage, //"violence is not the answer"// floods my mind as I ponder practicing benevolence against the creatures here.\n\t\n\tI could attempt to tame creatures using my skills; however, perhaps an even better idea would be to offer the creature food it would like to consume. Both options involve getting close to the creature. Perhaps I can simply leave the items on the ground and see if they will act in kindness towards me after accepting my offering as they move towards it. I know I will become more successful with any of these options as my skills grow.'],
        [a.default.Dehydration]: ["Dehydration", "The rhyme echoes in my head, //\"water, water, everywhere, nor any drop to drink\"//. My mind runs cloudy; my mouth bone-dry. I'll require water if I am to last any longer.\n\t\n\tUnfortunately, the largest body of water in my vision is nearly undrinkable in its natural form. I'll need to construct a water still if I am to convert the salinated sea water to potable water. It is quite the endeavor indeed.\n\t\n\tIf I am lucky, I may be able to find fresh water sources inland or in the caves below. It should be drinkable in its natural form, but erring on the side of caution, it may be prudent to boil it for safety."],
        [a.default.Durability]: ["Durability", "My {item} is close to breaking from use. {canRepair?Using my {repairItemName}, I should be able to repair it easily enough:With the right resources, I should be able to fashion myself a hammer to repair it}.\n\t\n\tIf I actively search out high quality materials to craft my tools, armor, and weapons with, I can expect much higher durability on them, especially after my skills have improved. {canGlue?I can also craft glue to:If I ever manage to find out how to concoct a glue, I can} further reinforce my items, providing much higher durability."],
        [a.default.Encumbered]: ["Encumbered", "This confounded burden! My pack is overflowing with heavy items that I will need to purge in order to decrease my encumbrance. Carrying this many items will slow down my movement and heavily impact my stamina.\n\t\n\tSome of the heaviest things in my inventory include {0}, {1}, and {2}."],
        [a.default.FailureInCrafting]: ["Failure In Crafting", "I failed in my attempt to craft {0}, mostly due to my lack of skill and knowledge in {1}. I think with repeated attempts, I'll gain some knowledge to hopefully succeed in crafting {0} eventually. I also hope that the materials can suffer the wear that my poor crafting skills are placing on them. I may even need to replace some components that I am damaging on each attempt.\n\t\n\tAlthough I have many ideas on what to craft with the items in my inventory, some of them may be quite difficult to craft without first having an intermediate, advanced or even expert skill level in the craft for each item."],
        [a.default.Gardening]: ["Gardening", "As I work on {0}, I reflect on the growth stages of vegetation that I have witnessed. Most plants seem to begin producing the most valuable resources at around the flowering stage, but I have observed the most bountiful haul comes during the ripening stage, when the fruits and vegetables are ripe for the taking and the seeds are available to gather.\n\t\n\tIf I want to succeed at gardening, I may also need to consider trying my hand at crafting fertilizer and fertile soil for my garden. I mustn't also forget to water my plants. Watering them will surely help them grow and survive long enough to produce the resources which seem all too dire in my situation."],
        [a.default.HealthIssues]: ["Health Issues", "My wellbeing is at an all-time low. I'm bruised, battered, and nearly defeated. My only chance at a respite is through medical intervention, rest, healthy foods, or ideally, all three.\n\t\n\t{clothing?As much as it pains me to consider it, disassembling my clothing to craft makeshift bandages appears to be a good option in my current predicament.}{healing?Luckily, I do have some items to be used for healing within my inventory including {healingItemName}.}"],
        [a.default.Inedible]: ["Inedible", "Consuming {item} may not have been the best of ideas. I {poisoned?think I may:am probably lucky not to} have been poisoned by it... It would be prudent to pay better attention to what I ingest. Something like that should only be consumed when I am in dire straits."],
        [a.default.Mercantile]: ["Mercantile", "I meet {0} today, a person in a similar state as myself; surviving on this island and living off the land. They seemed friendly enough and offered to trade items they had found with me.\n\t\n\tMy skill in bartering may pay off when deciding on a trade value, which we have signified with a credit system. {0} gives me credit when I give items to them, and reversely, removes credits when I find an item in their inventory worth taking for myself.\n\t\n\tEven though I found this valuable trading partner, the thought of something more nefarious has crossed my mind. Taking their supply by force would likely put me at odds with the island, but it may be worth it for their belongings and equipment."],
        [a.default.Nightfall]: ["Nightfall", "Dusk is quickly approaching. Who could know what creatures lurk in the darkness — it would be wise to seek shelter or make a camp for the night."],
        [a.default.Poisoned]: ["Poisoned", "My vision blurs as I write this; my stomach tied in knots. {0} has caused me to become poisoned. I can feel myself getting weaker even through the process of writing this note. Thirst and hunger consumes me, and my wellbeing is in jeopardy. I must attempt to fabricate a cure. Perhaps plants of a medicinal nature may aid me in this bodily turmoil."],
        [a.default.Reputation]: ["Reputation", "It seems that as time passes and the struggle for survival continues, the actions I take which are averse to the benefit of the island come back to haunt me.\n\t\n\tWhen I sow plants, or respect the island's inhabitants, less of them seem to be hostile. Likewise, when I gather resources, deface the landscape, or attack creatures, I see malicious beasts much more frequently.\n\t\n\tAs of writing this, it seems as though the island is {0?{#--message-type-good:benign}:{#--message-type-bad:malign}}. For the benefit of my survival, I may want to limit the scope of my damage to the natural environment."],
        [a.default.StaminaReplenishment]: ["Stamina Replenishment", "My breath is fast and heavy. I'm nearly worked to the point of exhaustion. I should proceed to slow my work to a bare minimum while my stamina replenishes itself. More efficiently, I could try resting on the ground, or even sleep in a bedroll for maximum benefits. Rest is important for my sanity and my survival."],
        [a.default.Stranded]: ["Stranded", "I awake to find myself no longer in the company of good men or a fine seafaring vessel. Instead I discover myself in tattered clothing, with but a few possessions: {0}, and other shoddy items.\n\t\n\tTreasure... The thought is vague and fleeting, but... I remember something about treasure."],
        [a.default.ToolUse]: ["Tool Use", "I'm reminded of the proverb, //\"the right tool for the right job\"// as I attempt to {0} using my bare hands. I know that using a tool for {1} would reduce my change of injury as well as provide much needed efficiency.\n\t\n\tFurthermore, I've observed the increased efficiency of using a bladed tool while lumberjacking and using a blunt tool while mining. The proverb proves its innate truth."],
        [a.default.ItemQualities]: ["Item Qualities", "As I pick up {0}, I notice it is {Misc:ItemQualityColor:({1},{reformat(1, true):{2} specimen})} indeed. I'm sure using this in a craft will benefit the end result greatly. I also observe it appears to have greater durability and strength than most other items in its class, resulting in much greater endurance when used."],
        [a.default.TreasureHunting]: ["Treasure Hunting", "I have happened upon a tattered map and on closer inspection of the drawings, appears to be a marked location. It may take several attempts to decode the map and find the location based on my surroundings, but I believe I should investigate this further. As my skill in cartography improves, I'm sure I will be able to make more of the drawings out. This could very well be a treasure map.\n\t\n\tAlthough my memory is fleeting, I do recall my penchant for treasure."]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/player/OnEquips", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.OnEquipType.LightSource]: "Light Source",
        [a.OnEquipType.Telescopy]: "Telescopy"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/player/quest/Quests", ["require", "exports", "player/quest/quest/IQuest"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.QuestType.Challenge]: ["Challenge", ""]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/player/quest/Requirements", ["require", "exports", "player/quest/requirement/IRequirement"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.RequirementType.SailToCivilization]: "Sail to civilization",
        [a.RequirementType.KillCreature]: "Kill {0}: {1}/{2}",
        [a.RequirementType.KillCreatures]: "Kill creatures: {0}/{1}",
        [a.RequirementType.CollectItem]: "Collect {0}: {1}/{2}",
        [a.RequirementType.LearnSkill]: "Learn {0}: {1}/{2}%",
        [a.RequirementType.LearnSkills]: "Learn total skills: {0}/{1}%",
        [a.RequirementType.LearnAnySkill]: "Learn any one skill: {1}/{2}%{1? ({0} at {1}%)}",
        [a.RequirementType.Equip]: "Equip {0} in {1}",
        [a.RequirementType.Craft]: "Craft {0}: {1}/{2}",
        [a.RequirementType.Dismantle]: "Dismantle {0}: {1}/{2}",
        [a.RequirementType.Build]: "Build {0}",
        [a.RequirementType.TameCreature]: "Tame {0}: {1}/{2}",
        [a.RequirementType.TameCreatures]: "Tame creatures: {0}/{1}"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/player/Skills", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.SkillType.Anatomy]: ["anatomy", "- Increases accuracy of creature health, resistance, and vulnerability descriptions.\n\t\t - Decreases chance of bleeding, poisoning, and burning pain from creatures.\n\t\t - Increases effectiveness of healing consumables.\n\t\t - Increases success chance when healing.\n\t\t - Decreases chance of bleeding when using bare hands during combat/gathering.\n\t\t - Increases the amount of resources carved at a time."],
        [a.SkillType.Bartering]: ["bartering", " - Influences the amount of barter credit received when trading items."],
        [a.SkillType.Blacksmithing]: ["blacksmithing", " - Influences quality, repair, and success rate of crafted items using metal."],
        [a.SkillType.Botany]: ["botany", "- Increases effectiveness of eating plant-based consumables.\n\t\t - Decreases chance of trampling plants when stepping on them.\n\t\t - Increases chance of gathering/harvesting resources on plants.\n\t\t - Decreases chance of stamina reduction while gathering/harvesting from plants.\n\t\t - Decreases chance of damaging the plant when harvesting or gathering from it.\n\t\t - Decreases seed germination time.\n\t\t - Increases the amount of resources gathered/harvested at a time."],
        [a.SkillType.Camping]: ["camping", "- Increases the amount of turns slept when using a bedroll.\n\t\t - Increases chance of starting a fire.\n\t\t - Increases the accuracy of telling the time with a sundial.\n\t\t - Increases the effectiveness of extinguishing open fires with the smother action."],
        [a.SkillType.Cartography]: ["cartography", "- Increases chance to successfully read tattered maps.\n\t\t - Decreases obscurity when reading tattered maps.\n\t\t - Increases accuracy of detecting the treasure's direction."],
        [a.SkillType.Chemistry]: ["chemistry", " - Influences quality and success rate of crafted items using chemical mixtures."],
        [a.SkillType.Claythrowing]: ["clay throwing", " - Influences quality and success rate of crafting items using clay."],
        [a.SkillType.Cooking]: ["cooking", "- Influences quality and success rate of cooking items (via crafting).\n\t\t - Influences decay of cooked items."],
        [a.SkillType.Fishing]: ["fishing", "- Increases chance to successfully catch a fish. Increases maximum range when using a fishing rod.\n\t\t - Increases the range in which you can gather underwater treasure from.\n\t\t - Increases the chance of successfully catching a fish without bait."],
        [a.SkillType.Fletching]: ["fletching & rangedcraft", " - Influences quality and repair rate of crafted arrows, bows, and slings."],
        [a.SkillType.Gardening]: ["gardening", "- Increases chance of planting a plant or mushroom.\n\t\t - Decreases growth time when watering plants or mushrooms.\n\t\t - Increases chance of successfully tilling.\n\t\t - Decreases chance of stamina reduction while tilling.\n\t\t - Influences quality and success rate of crafting items requiring gardening skill."],
        [a.SkillType.Glassblowing]: ["glassblowing", " - Influences quality and success rate of crafted items using glass."],
        [a.SkillType.Leatherworking]: ["leatherworking", " - Influences quality, repair, and success rate of crafted items using leather."],
        [a.SkillType.LockPicking]: ["lock picking", " - Increases chance to successfully unlock a chest."],
        [a.SkillType.Lumberjacking]: ["lumberjacking", "- Increases chance of gathering resources on trees.\n\t\t - Decreases chance of stamina reduction while lumberjacking.\n\t\t - Increases the amount of resources gathered at a time."],
        [a.SkillType.Marksmanship]: ["marksmanship", " - Increases attack damage, accuracy, and maximum range when using bows and firearms."],
        [a.SkillType.Mining]: ["mining", "- Increases chance of gathering resources while hitting rock/sandstone or digging.\n\t\t - Decreases chance of stamina reduction while mining and digging.\n\t\t - Increases the range in which you can gather treasure from.\n\t\t - Increases the amount of resources gathered at a time."],
        [a.SkillType.Mycology]: ["mycology", "- Increases effectiveness of eating mushroom consumables.\n\t\t - Decreases chance of trampling mushrooms when stepping on them.\n\t\t - Increases chance of gathering/harvested resources on mushrooms.\n\t\t - Decreases chance of stamina reduction while gathering/harvesting from mushrooms.\n\t\t - Decreases chance of damaging the mushrooms when harvesting or gathering from it.\n\t\t - Decreases spore germination time.\n\t\t - Increases the amount of resources gathered/harvested at a time."],
        [a.SkillType.Parrying]: ["parrying", "- Increases your base defense value when holding an item in each hand.\n\t\t - Increases chance to take less damage in combat.\n\t\t - Decreases chance of stamina reduction from being attacked."],
        [a.SkillType.Stonecrafting]: ["stonecrafting", " - Influences quality, repair, and success rate of crafted items using stones and rocks."],
        [a.SkillType.Swimming]: ["swimming", "- Increases speed in water travel.\n\t\t - Decreases chance of stamina reduction in water."],
        [a.SkillType.Tactics]: ["tactics", "- Increases your base attack value.\n\t\t - Increases chance to hit targets in combat.\n\t\t - Decreases chance of stamina reduction while attacking.\n\t\t - Increases damage when using throwing or marksmanship."],
        [a.SkillType.Tailoring]: ["tailoring", " - Influences quality, repair, and success rate of crafted items using cloth or fabric."],
        [a.SkillType.Taming]: ["taming", "- Increases chance of successfully taming a creature.\n\t\t - Increases length of time creature will be tamed for.\n\t\t - Decreases chance of stamina reduction when taming/offering/milking/hitching.\n\t\t - Decreases amount of happiness reduced when milking goats.\n\t\t - Increases chance of taming when offering an aberrant creature items.\n\t\t - Increased chance of hitching aberrant or untamed creatures."],
        [a.SkillType.Throwing]: ["throwing", " - Increases attack damage, accuracy, and maximum range when throwing or slinging an item."],
        [a.SkillType.Tinkering]: ["tinkering", " - Influences quality, repair, and success rate of crafted items using miscellaneous resources and methods."],
        [a.SkillType.Trapping]: ["trapping", "- Increases the amount of damage and success rate of trapping creatures.\n\t\t - Reduces chance of setting off traps and reduces damage taken from traps."],
        [a.SkillType.Woodworking]: ["woodworking", " - Influences quality, repair, and success rate of crafted items using wood."]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/player/Slot", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.EquipType.Back]: "back",
        [a.EquipType.Belt]: "belt",
        [a.EquipType.Chest]: "chest",
        [a.EquipType.Feet]: "feet",
        [a.EquipType.Hands]: "hands",
        [a.EquipType.Head]: "head",
        [a.EquipType.Held]: "held",
        [a.EquipType.LeftHand]: "left hand",
        [a.EquipType.Legs]: "legs",
        [a.EquipType.Neck]: "neck",
        [a.EquipType.None]: "none",
        [a.EquipType.RightHand]: "right hand"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/Stats", ["require", "exports", "entity/IStats"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.Stat.Health]: "health",
        [a.Stat.Stamina]: "stamina",
        [a.Stat.Hunger]: "hunger",
        [a.Stat.Thirst]: "thirst",
        [a.Stat.Weight]: "weight",
        [a.Stat.Attack]: "attack",
        [a.Stat.Benignity]: "benignity",
        [a.Stat.Malignity]: "malignity",
        [a.Stat.Defense]: "defense",
        [a.Stat.Reputation]: "reputation",
        [a.Stat.Metabolism]: "metabolism",
        [a.Stat.Produce]: "produce",
        [a.Stat.Happiness]: "happiness",
        [a.Stat.Tamed]: "tamed",
        [a.Stat.Strength]: "strength"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/StatusEffects", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.StatusType.Bleeding]: ["bleeding", "bleeding"],
        [a.StatusType.Poisoned]: ["poisoned", "poison"],
        [a.StatusType.Burned]: ["burned", "burn"]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/Terrains", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.TerrainType.Ash]: ["ash"],
        [a.TerrainType.BeachSand]: ["beach sand"],
        [a.TerrainType.CaveEntrance]: ["cave entrance"],
        [a.TerrainType.Clay]: ["clay"],
        [a.TerrainType.ClayBrickFlooring]: ["clay brick flooring"],
        [a.TerrainType.CobblestoneFlooring]: ["cobblestone flooring"],
        [a.TerrainType.CoolingLava]: ["cooling lava"],
        [a.TerrainType.DeepFreshWater]: ["deep fresh water"],
        [a.TerrainType.DeepSeawater]: ["deep seawater"],
        [a.TerrainType.DesertSand]: ["desert sand"],
        [a.TerrainType.Dirt]: ["dirt"],
        [a.TerrainType.FertileSoil]: ["fertile soil"],
        [a.TerrainType.FreshWater]: ["fresh water"],
        [a.TerrainType.Grass]: ["grass"],
        [a.TerrainType.Gravel]: ["gravel"],
        [a.TerrainType.Lava]: ["lava"],
        [a.TerrainType.Obsidian]: ["obsidian"],
        [a.TerrainType.RedCarpet]: ["red carpet"],
        [a.TerrainType.Rocks]: ["rocks"],
        [a.TerrainType.RocksWithCoal]: ["rocks with coal"],
        [a.TerrainType.RocksWithCopper]: ["rocks with copper"],
        [a.TerrainType.RocksWithIron]: ["rocks with iron"],
        [a.TerrainType.RocksWithLimestone]: ["rocks with limestone"],
        [a.TerrainType.RocksWithTalc]: ["rocks with talc"],
        [a.TerrainType.Sandstone]: ["sandstone"],
        [a.TerrainType.SandstoneFlooring]: ["sandstone flooring"],
        [a.TerrainType.SandstoneWithCopper]: ["sandstone with copper"],
        [a.TerrainType.SandstoneWithIron]: ["sandstone with iron"],
        [a.TerrainType.SandstoneWithNiter]: ["sandstone with niter"],
        [a.TerrainType.Seawater]: ["seawater"],
        [a.TerrainType.ShallowFreshWater]: ["shallow fresh water"],
        [a.TerrainType.ShallowSeawater]: ["shallow seawater"],
        [a.TerrainType.Snow]: ["snow"],
        [a.TerrainType.Swamp]: ["swamp"],
        [a.TerrainType.WoodenFlooring]: ["wooden flooring"]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/TileEvents", ["require", "exports", "tile/ITileEvent"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.TileEventType.Fire]: ["fire", "A dangerous open flame providing heat and light."],
        [a.TileEventType.HoneyFungus]: ["honey fungus", "A parasitic tree fungus that can grow and spread on living, decaying, and dead plant material."],
        [a.TileEventType.TumblingTumbleweed]: ["tumbling tumbleweed", "A dry and brittle tumbling weed, broken off from its roots and spreading seeds in its meandering path."]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/Bindables", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.Bindable.None]: "none",
        [a.Bindable.DeveloperReloadAndContinueGame]: "Reload and Continue Game",
        [a.Bindable.DeveloperReloadGame]: "Reload Game",
        [a.Bindable.DeveloperToggleDeveloperMode]: "Toggle Developer Mode",
        [a.Bindable.DeveloperToggleDeveloperTools]: "Toggle Developer Tools",
        [a.Bindable.DialogCloseAll]: "Close All Dialogs",
        [a.Bindable.DialogCrafting]: "Toggle Crafting",
        [a.Bindable.DialogDismantle]: "Toggle Dismantle",
        [a.Bindable.DialogEquipment]: "Toggle Equipment",
        [a.Bindable.DialogHelp]: "Toggle Help",
        [a.Bindable.DialogInventory]: "Toggle Inventory",
        [a.Bindable.DialogMessages]: "Toggle Messages",
        [a.Bindable.DialogMessagesChatFocus]: "Focus Chat Input",
        [a.Bindable.DialogMilestones]: "Toggle Milestones",
        [a.Bindable.DialogNotes]: "Toggle Notes",
        [a.Bindable.DialogOptions]: "Toggle Quick Settings",
        [a.Bindable.DialogQuests]: "Toggle Quests",
        [a.Bindable.DialogSkills]: "Toggle Skills",
        [a.Bindable.GameActions]: "Actions",
        [a.Bindable.GameContextMenu1]: "Context Menu Item 1",
        [a.Bindable.GameContextMenu10]: "Context Menu Item 10",
        [a.Bindable.GameContextMenu11]: "Context Menu Item 11",
        [a.Bindable.GameContextMenu12]: "Context Menu Item 12",
        [a.Bindable.GameContextMenu13]: "Context Menu Item 13",
        [a.Bindable.GameContextMenu14]: "Context Menu Item 14",
        [a.Bindable.GameContextMenu15]: "Context Menu Item 15",
        [a.Bindable.GameContextMenu16]: "Context Menu Item 16",
        [a.Bindable.GameContextMenu17]: "Context Menu Item 17",
        [a.Bindable.GameContextMenu18]: "Context Menu Item 18",
        [a.Bindable.GameContextMenu19]: "Context Menu Item 19",
        [a.Bindable.GameContextMenu2]: "Context Menu Item 2",
        [a.Bindable.GameContextMenu20]: "Context Menu Item 20",
        [a.Bindable.GameContextMenu21]: "Context Menu Item 21",
        [a.Bindable.GameContextMenu22]: "Context Menu Item 22",
        [a.Bindable.GameContextMenu23]: "Context Menu Item 23",
        [a.Bindable.GameContextMenu24]: "Context Menu Item 24",
        [a.Bindable.GameContextMenu3]: "Context Menu Item 3",
        [a.Bindable.GameContextMenu4]: "Context Menu Item 4",
        [a.Bindable.GameContextMenu5]: "Context Menu Item 5",
        [a.Bindable.GameContextMenu6]: "Context Menu Item 6",
        [a.Bindable.GameContextMenu7]: "Context Menu Item 7",
        [a.Bindable.GameContextMenu8]: "Context Menu Item 8",
        [a.Bindable.GameContextMenu9]: "Context Menu Item 9",
        [a.Bindable.GameFaceDirection]: "Face Towards Mouse",
        [a.Bindable.GameFaceDown]: "Face Down",
        [a.Bindable.GameFaceLeft]: "Face Left",
        [a.Bindable.GameFaceRight]: "Face Right",
        [a.Bindable.GameFaceUp]: "Face Up",
        [a.Bindable.GameFullscreen]: "Toggle Fullscreen",
        [a.Bindable.GameHandToggleLeft]: "Toggle Using Left Hand",
        [a.Bindable.GameHandToggleRight]: "Toggle Using Right Hand",
        [a.Bindable.GameIdle]: "Idle",
        [a.Bindable.GameInspect]: "Inspect",
        [a.Bindable.GameItemDrop]: "Drop Hovered Item",
        [a.Bindable.GameItemDropAll]: "Drop All Similar Items",
        [a.Bindable.GameItemEquipToggle]: "Toggle Item Equipped",
        [a.Bindable.GameItemMenu]: "Hovered Item Menu",
        [a.Bindable.GameItemMove]: "Move Hovered Item",
        [a.Bindable.GameItemQuickMove]: "Quick-move Hovered Item",
        [a.Bindable.GameItemQuickMoveAll]: "Quick-move Similar Items",
        [a.Bindable.GameMoreInformation]: "Show More Information",
        [a.Bindable.GameMoveDirection]: "Move Towards Mouse",
        [a.Bindable.GameMoveDown]: "Move Down",
        [a.Bindable.GameMoveLeft]: "Move Left",
        [a.Bindable.GameMoveRight]: "Move Right",
        [a.Bindable.GameMoveToTile]: "Move To Tile",
        [a.Bindable.GameMoveToTilePreview]: "Show Path Preview",
        [a.Bindable.GameMoveUp]: "Move Up",
        [a.Bindable.GamePause]: "Pause Menu",
        [a.Bindable.GameQuickSlot1]: "Quickslot 1",
        [a.Bindable.GameQuickSlot2]: "Quickslot 2",
        [a.Bindable.GameQuickSlot3]: "Quickslot 3",
        [a.Bindable.GameQuickSlot4]: "Quickslot 4",
        [a.Bindable.GameQuickSlot5]: "Quickslot 5",
        [a.Bindable.GameQuickSlot6]: "Quickslot 6",
        [a.Bindable.GameQuickSlot7]: "Quickslot 7",
        [a.Bindable.GameQuickSlot8]: "Quickslot 8",
        [a.Bindable.GameQuickSlot9]: "Quickslot 9",
        [a.Bindable.GameQuickSlotClear]: "Clear Quickslot",
        [a.Bindable.GameQuickSlotToggle1]: "Quickslot Toggle 1",
        [a.Bindable.GameQuickSlotToggle2]: "Quickslot Toggle 2",
        [a.Bindable.GameQuickSlotToggle3]: "Quickslot Toggle 3",
        [a.Bindable.GameQuickSlotToggle4]: "Quickslot Toggle 4",
        [a.Bindable.GameQuickSlotToggle5]: "Quickslot Toggle 5",
        [a.Bindable.GameQuickSlotToggle6]: "Quickslot Toggle 6",
        [a.Bindable.GameQuickSlotToggle7]: "Quickslot Toggle 7",
        [a.Bindable.GameQuickSlotToggle8]: "Quickslot Toggle 8",
        [a.Bindable.GameQuickSlotToggle9]: "Quickslot Toggle 9",
        [a.Bindable.GameSave]: "Save Game",
        [a.Bindable.GameScreenshotMode]: "Toggle Screenshot Mode",
        [a.Bindable.GameZoomIn]: "Zoom In",
        [a.Bindable.GameZoomOut]: "Zoom Out",
        [a.Bindable.MenuCancel]: "Cancel",
        [a.Bindable.MenuContextMenu]: "Context Menu",
        [a.Bindable.MenuDown]: "Selection Down",
        [a.Bindable.MenuEnter]: "Choose Selected",
        [a.Bindable.MenuLeft]: "Selection Left",
        [a.Bindable.MenuNext]: "Selection Next",
        [a.Bindable.MenuPrevious]: "Selection Previous",
        [a.Bindable.MenuRight]: "Selection Right",
        [a.Bindable.MenuUp]: "Selection Up"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/BindableTypes", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.BindableType.Game]: "Gameplay",
        [a.BindableType.Dialog]: "Dialogs",
        [a.BindableType.Menu]: "Menus",
        [a.BindableType.Developer]: "Developer",
        [a.BindableType.Mod]: "Mods"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/BindPresses", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const a = {
        AltLeft: "Left Alt",
        AltRight: "Right Alt",
        ArrowDown: "Down",
        ArrowLeft: "Left",
        ArrowRight: "Right",
        ArrowUp: "Up",
        AudioVolumeDown: "Volume Down",
        AudioVolumeMute: "Volume Mute",
        AudioVolumeUp: "Volume Up",
        Backquote: "`",
        Backslash: "\\",
        BracketLeft: "[",
        BracketRight: "]",
        BrowserBack: "Browser Back",
        BrowserFavorites: "Browser Favorites",
        BrowserForward: "Browser Forward",
        BrowserHome: "Browser Home",
        BrowserRefresh: "Browser Refresh",
        BrowserSearch: "Browser Search",
        BrowserStop: "Browser Stop",
        CapsLock: "Caps Lock",
        Comma: ",",
        ContextMenu: "Context Menu",
        ControlLeft: "Left Ctrl",
        ControlRight: "Right Ctrl",
        Digit0: "0",
        Digit1: "1",
        Digit2: "2",
        Digit3: "3",
        Digit4: "4",
        Digit5: "5",
        Digit6: "6",
        Digit7: "7",
        Digit8: "8",
        Digit9: "9",
        Equal: "=",
        Fn: "Function",
        FnLock: "Function Lock",
        IntlBackslash: "|",
        IntlRo: "ろ",
        IntlYen: "¥",
        KeyA: "A",
        KeyB: "B",
        KeyC: "C",
        KeyD: "D",
        KeyE: "E",
        KeyF: "F",
        KeyG: "G",
        KeyH: "H",
        KeyI: "I",
        KeyJ: "J",
        KeyK: "K",
        KeyL: "L",
        KeyM: "M",
        KeyN: "N",
        KeyO: "O",
        KeyP: "P",
        KeyQ: "Q",
        KeyR: "R",
        KeyS: "S",
        KeyT: "T",
        KeyU: "U",
        KeyV: "V",
        KeyW: "W",
        KeyX: "X",
        KeyY: "Y",
        KeyZ: "Z",
        LaunchApp1: "Launch App #1",
        LaunchApp2: "Launch App #2",
        LaunchMail: "Email",
        MediaPlayPause: "Play/Pause",
        MediaSelect: "Select",
        MediaStop: "Stop",
        MediaTrackNext: "Next Track",
        MediaTrackPrevious: "Previous Track",
        MetaLeft: "Left OS",
        MetaRight: "Right OS",
        Minus: "-",
        ModifierAlt: "Alt",
        ModifierControl: "Ctrl",
        ModifierShift: "Shift",
        Mouse0: "Left Click",
        Mouse1: "Middle Click",
        Mouse2: "Right Click",
        MouseDown: "Scroll Down",
        MouseUp: "Scroll Up",
        NumLock: "Num Lock",
        Numpad0: "Numpad 0",
        Numpad1: "Numpad 1",
        Numpad2: "Numpad 2",
        Numpad3: "Numpad 3",
        Numpad4: "Numpad 4",
        Numpad5: "Numpad 5",
        Numpad6: "Numpad 6",
        Numpad7: "Numpad 7",
        Numpad8: "Numpad 8",
        Numpad9: "Numpad 9",
        NumpadAdd: "Numpad +",
        NumpadBackspace: "Numpad Backspace",
        NumpadClear: "Numpad Clear",
        NumpadClearEntry: "Numpad Clear Entry",
        NumpadComma: "Numpad ,",
        NumpadDecimal: "Numpad .",
        NumpadDivide: "Numpad /",
        NumpadEnter: "Numpad Enter",
        NumpadEqual: "Numpad =",
        NumpadHash: "Numpad Hash",
        NumpadMemoryAdd: "Numpad Memory Add",
        NumpadMemoryClear: "Numpad Memory Clear",
        NumpadMemoryRecall: "Numpad Memory Recall",
        NumpadMemoryStore: "Numpad Memory Store",
        NumpadMemorySubtract: "Numpad Memory Subtract",
        NumpadMultiply: "Numpad *",
        NumpadParenLeft: "Numpad (",
        NumpadParenRight: "Numpad )",
        NumpadStar: "Numpad Star",
        NumpadSubtract: "Numpad -",
        PageDown: "Page Down",
        PageUp: "Page Up",
        Period: ".",
        PrintScreen: "Print Screen",
        Quote: '"',
        ScrollLock: "Scroll Lock",
        Semicolon: ";",
        ShiftLeft: "Left Shift",
        ShiftRight: "Right Shift",
        Slash: "/",
        VolumeDown: "Volume Down",
        VolumeMute: "Volume Mute",
        VolumeUp: "Volume Up",
        WakeUp: "Wake Up"
    };
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/ChangelogSections", ["require", "exports", "utilities/Trello"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.ChangelogSection.Balance]: "Balance",
        [a.ChangelogSection.Bug]: "Bug Fixes",
        [a.ChangelogSection.Improvement]: "Improvements",
        [a.ChangelogSection.Mod]: "Mods",
        [a.ChangelogSection.Modding]: "Modding",
        [a.ChangelogSection.New]: "New",
        [a.ChangelogSection.Technical]: "Technical"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/GameEndMessages", ["require", "exports", "language/dictionary/GameEndMessage"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.GameEndMessage.Win]: ["You find your way back to civilization and end your journey.", "You sail back and enjoyed a good life with your riches.", "You travelled back to civilization, but is this the end?"],
        [a.GameEndMessage.Dead]: ["Your bones lay bleaching, lost to time.", "The end is just the beginning.", "Sadly, no trace of you was ever found."]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/HelpArticles", ["require", "exports", "newui/screen/screens/menu/menus/help/HelpArticleDescriptions"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.HelpArticle.Welcome]: ["Welcome to Wayward", "A short summary of the help menu, and links to more resources on the game.", "Welcome to the Early Access version of Wayward!", "Disclaimer: Wayward is currently in beta status and many things will change and improve over time.\n\t\n\t\tThis is the help menu, which you can use to learn mechanics of the game. If you can't find the information you're looking for in this menu, you can also visit the {link(http://steamcommunity.com/app/379210/discussions/):Steam Discussion forums}.\n\t\n\t\tIf you want to keep up with Wayward, please visit the {link(http://www.waywardgame.com):Wayward Website}, {link(http://www.reddit.com/r/Wayward):Subreddit}, or {link(https://discord.gg/wayward):Discord}.\n\t\n\t\tWant to help Wayward? Spread the word, or follow us on one of the following sites: {link(https://www.facebook.com/waywardgame):Facebook}, {link(https://twitter.com/Wayward_Game):Twitter}, or {link(http://www.indiedb.com/games/wayward):IndieDB}."],
        [a.HelpArticle.Controls]: ["Controls", "A guide on using the keybindings associated with common actions in the game, to speed up gameplay, and other related tips and tricks.", "Learn common keybinds for the game.", '{heading:Main Keybinds}\n\t\n\t\t{#--text-color-faded:Pause Menu:} {Bindings:GamePause}\n\t\t{#--text-color-faded:Save Game:} {Bindings:GameSave}\n\t\t{#--text-color-faded:Help:} {Bindings:DialogHelp}\n\t\t{#--text-color-faded:Options:} {Bindings:DialogOptions}\n\t\t{#--text-color-faded:Milestones:} {Bindings:DialogMilestones}\n\t\t{#--text-color-faded:Notes:} {Bindings:DialogNotes}\n\t\t{#--text-color-faded:Messages:} {Bindings:DialogMessages}\n\t\t{#--text-color-faded:Actions:} {Bindings:GameActions}\n\t\t{#--text-color-faded:Inventory:} {Bindings:DialogInventory}\n\t\t{#--text-color-faded:Crafting:} {Bindings:DialogCrafting}\n\t\t{#--text-color-faded:Equipment:} {Bindings:DialogEquipment}\n\t\t{#--text-color-faded:Skills:} {Bindings:DialogSkills}\n\t\t{#--text-color-faded:Close All Dialogs:} {Bindings:DialogCloseAll}\n\t\t\n\t\tKeybindings can be changed in the {link(Menu.Options.5):Options Menu}. \n\t\t\n\t\tFor more binds, see the {link(Menu.Options.5):Options Menu}.\n\t\t\n\t\t{heading:Movement}\n\t\t\n\t\t{#--text-color-faded:Directional movement:} {Bindings:GameMoveUp} (up), {Bindings:GameMoveLeft} (left), {Bindings:GameMoveDown} (down), {Bindings:GameMoveRight} (right)\n\t\t\n\t\t{#--text-color-faded:Move towards mouse:} {Bindings:GameMoveDirection}\n\n\t\t{#--text-color-faded:Move to the tile under the mouse:} {Bindings:GameMoveToTile}\n\t\t\n\t\t{#--text-color-faded:Skip/pass a turn:} {Bindings:GameIdle} or {Bindings:GameMoveDirection} (with your mouse over your character).\n\t\t\n\t\t{#--text-color-faded:Facing a direction without moving:} {Bindings:GameFaceDirection} and your character will face towards your mouse (there are corresponding facing binds for all directions as well).\n\t\t\n\t\tIf there is too much or too little delay between turning a direction and moving, you can fine-tune it in the {link(Menu.Options.3):Options Menu}.\n\t\t\n\t\t{heading:Actions}\n\t\t\n\t\tInteracting through the world is done mostly through the {link(Menu.HelpArticle.Actions):actions} menu, opened using {Bindings:GameActions}.\n\t\t\n\t\t{heading:Using Items}\n\t\t\n\t\tSee {link(Menu.HelpArticle.Actions):Actions} and {link(Menu.HelpArticle.Quickslots):Quickslots}.\n\t\t\n\t\t{heading:Item Management}\n\t\t\n\t\t__Dropping items__\n\t\t\n\t\t{#--text-color-faded:Drop an item:} {Bindings:GameItemDrop} (when the mouse is over the item), or use the {link(Menu.HelpArticle.Actions):"Drop" action} on the item. \n\t\t\n\t\t{#--text-color-faded:Drop all of a type of item:} {Bindings:GameItemDropAll} (when the mouse is over the type of item to drop), or use the {link(Menu.HelpArticle.Actions):"Drop All" action}.\n\t\t\n\t\tIf there is a tile in the way of dropping an item, by default nothing will happen. You may change this functionality in the "Drop Location" setting, available in the {link(Menu.Options.3):Options Menu} and the Quick Settings dialog.\n\t\t\n\t\t__Moving items__\n\t\t\n\t\t{#--text-color-faded:Quickly moving items between containers:} {Bindings:GameItemQuickMove} (when the mouse is over the item)\n\t\t\n\t\t{#--text-color-faded:Quickly moving all of the same type of item between containers:} {Bindings:GameItemQuickMoveAll} (when the mouse is over the type of item)\n\t\t\n\t\tQuick-moving items works with your open container dialog, or, if there is no container dialog open, the container your character is facing.\n\t\t\n\t\t{heading:More Information}\n\t\t\n\t\tHovering over elements on screen will typically reveal more information, usually in a tooltip. Some examples include items in dialogs, and doodads, creatures, and items in the world. Items in the crafting dialog will highlight the items that will be used when they are crafted.\n\t\t\n\t\tTooltips for tiles in the world can be disabled. When this is the case, you can still get information about the tile you are hovering over with {Bindings:GameInspect}.'],
        [a.HelpArticle.Interface]: ["Interface", "How to interact with and customize the windows/dialogs.", "The customizable windows/dialogs of Wayward.", 'Wayward uses dialogs, or windows, for displaying most in-game information. This means the interface is almost completely customizable.\n\t\n\t\tYou can move the dialogs by dragging them by the title bar, and you can resize them by dragging on their edges or corners.\n\t\n\t\tThe "static" elements on the screen, namely, your stats, the menu bar, and the list of messages, can all be moved to other corners or edges of the screen, using the options in their context menus ({Bindings:MenuContextMenu}). The list of messages can be put into a dialog with {Bindings:DialogMessages} or using the "Show as Dialog" option in its context menu.\n\t\n\t\tThe interface setup for each world is retained between saving and loading the game.'],
        [a.HelpArticle.InventoryManagement]: ["Inventory\nManagement", "Learn ways of organizing, moving, and dropping items.", "Organizing, moving, and dropping items.", 'There are many ways to organize and move items in Wayward.\n\t\n\t\t1. __Drag and Drop__: By holding {Bindings:GameItemMove}, you may drag and drop items into a container window, quickslot, equipment slot, or directly on to the ground. Dragging and dropping to the game screen will drop it in front of you, or inside a chest if you are facing one.\n\t\t\n\t\t2. __Quickmoving__: With {Bindings:GameItemQuickMove} you can move an item instantly from your inventory to a container or vice-versa. You can use this while the container is not open, if your character is facing towards it. You may also use {Bindings:GameItemQuickMoveAll} to instantly move all items of the same type.\n\t\t\n\t\t3. __From the item\'s menu__: You can use {link(Menu.HelpArticle.Actions):actions} to drop and move items as well: namely, "Drop", "Drop All", "Move", and "Move All". The "Move" actions will only appear if there is a container window open. If the item in question is of a {link(Menu.HelpArticle.ItemQualities):high quality}, there will be actions for dropping or moving all items of that quality.\n\t\t\n\t\t4. __Dropping items__: By pressing {Bindings:GameItemDrop}, you may drop an item onto the ground. If the tile in front of you is blocked, nothing will happen, or the item will be dropped at your feet, if your "Drop Location" option is set to "Drop at Feet When Blocked". You may also press {Bindings:GameItemDropAll} to drop all items of the same type.'],
        [a.HelpArticle.Quickslots]: ["Quickslots", "Learn the easier way to use actions on items.", "The easier way to use actions on items.", '{link(Menu.HelpArticle.Actions):Opening an item\'s menu to perform actions} can be tiresome. Quickslots are for using an action on an item with the press of a bind.\n\t\n\t\t{heading:Quickslotting an Item}\n\t\t\n\t\tYou can drag any item into one of your nine quickslots to quickslot the item in that slot. You can also use any of the quickslot binds to toggle the item being quickslotted to the slot of the bind you press. Alternatively, you can use the {link(Menu.HelpArticle.Actions):"Add to Quickslot" action} to add it to an open quickslot.\n\t\t\n\t\t{heading:Using a Quickslotted Item}\n\t\t\n\t\tBy default, pressing the bind for a quickslot will perform the default {link(Menu.HelpArticle.Actions):action} for the item in that slot; the action depends on what kind of item it is. \n\t\t\n\t\tYou can change the action to perform for a quickslot item by opening the actions menu ({Bindings:GameItemMenu}), and clicking the x icon next to the preferred action, turning it into a √.\n\t\t\n\t\t{heading:Removing a Quickslotted Item}\n\t\t\n\t\tThere are two binds provided for removing items from quickslots. You can press {Bindings:GameQuickSlotClear} to clear the hovered item from its quickslot, or to clear the hovered quickslot. You can also press any of the quickslot binds to toggle the hovered item being quickslotted to that slot.'],
        [a.HelpArticle.FastPickup]: ["Fast Pick-up", "A summary on ways to pick up items on the ground.", "A quick way to get items on the ground.", 'If there is an item on a tile that you would like to pick up, you can either walk onto the tile (if the {link(Menu.Options.3):"Auto Pick-up" option} is enabled) or use the {link(Menu.HelpArticle.Actions):"Pick-up Item" action} while facing the tile. \n\t\t\n\t\tThere can be multiple items on a tile. When you are standing over them, you can press {Bindings:GameIdle} to pass the turn and gather the items one at a time. Alternatively, you can pick up all the items on the tile by facing the tile, then using the {link(Menu.HelpArticle.Actions):"Pick-up All Items" action}.'],
        [a.HelpArticle.Actions]: ["Actions", "A guide on how to interact with items, tiles, or the things on a tile.", "Interacting with tiles and items.", "Opening up the actions menu ({Bindings:GameActions}) will bring up a list of actions you can perform, usually on the tile or object you're facing. Some examples include collecting fruits from plants, picking up {link(Menu.HelpArticle.Doodads):doodads} you've placed, and resting. There is also the \"Jump\" action that can help you get out of tight spots, but be careful when using it as it reduces stamina based on the weight you're carrying.\n\t\t\n\t\tAll items also have actions that can be performed on them. The item actions menu is opened by pressing {Bindings:GameItemMenu}. Tools will usually have actions that can be used on the facing tile, while other items will have actions that affect the tile you're standing on, or just you, such as consuming a food with the \"Eat\" action.\n\t\t\n\t\tSince finding an item in your inventory and using the item action menu on it can be a pain, you can use {link(Menu.HelpArticle.Quickslots):quickslots} to speed up the process."],
        [a.HelpArticle.Stats]: ["Stats", "Learn how to understand and manage your health, stamina, hunger, and thirst.", "A numerical representation of your wellbeing.", "You have four core stats: {#--stat-color-health:Health}, {#--stat-color-stamina:Stamina}, {#--stat-color-hunger:Hunger}, and {#--stat-color-thirst:Thirst}.\n\t\t\n\t\t{heading:Decaying Stats}\n\t\t\n\t\tIf your {#--stat-color-stamina:stamina} is 0 and you take an action, you will lose {#--stat-color-health:health}.\n\t\t\n\t\tWhen your {#--stat-color-hunger:hunger} or {#--stat-color-thirst:thirst} tick below zero, each subsequent time they go down, your health will be reduced by their current amount. For example, if you have -4 {#--stat-color-hunger:hunger}, and it goes down to -5, you will lose 5 {#--stat-color-health:health}.\n\t\t\n\t\tWhen your {#--stat-color-health:health} reaches 0, you will die.\n\t\t\n\t\t{heading:Replenishing Stats}\n\t\t \n\t\t{#--stat-color-stamina:Stamina} replenishes slowly over time, but can also be replenished by resting, most food items, and sleeping for maximum benefits.\n\t\t \n\t\t{#--stat-color-hunger:Hunger} and {#--stat-color-thirst:thirst} can be replenished by food and water.\n\t\t \n\t\t{#--stat-color-health:Health} recovers slowly over time, but can be restored with bandages, other health items, and some types of food.\n\t\t\n\t\t{heading:Maximum Stats}\n\t\t\n\t\tUsing skills have the chance to increase the maximum values of your stats. An increase in strength will increase the maximum value of your {#--stat-color-health:health} as well as your {link(Menu.HelpArticle.Overweight):weight limit}. An increase in dexterity will increase your maximum {#--stat-color-stamina:stamina}. An increase in metabolism will increase both {#--stat-color-hunger:hunger} and {#--stat-color-thirst:thirst}.\n\t\t\n\t\tThere are also {link(Menu.HelpArticle.ItemQualities):legendary} items that can be {link(Menu.HelpArticle.Crafting):crafted} or found that will increase your stats when equipped."],
        [a.HelpArticle.Doodads]: ["Doodads", "Learn about, and how to interact with, objects placed in the world, such as plants or structures.", "A guide on plants, structures, and other objects affixed to the ground.", 'Objects attached to the ground like plants, piles of rocks, furnaces, and even campfires are considered to be a "doodad". \n\t\t\n\t\tTo "collect" them (pick them up), you can do one of the following:\n\t\n\t\t1. While facing the doodad, use the {link(Menu.HelpArticle.Actions):"Collect Object With Hands" action}.\n\t\t2. Use an item with a "Digging" use, such as a stone shovel.\n\t\t3. Use an item with a "Carving" use, such as a sharp rock.\n\t\t4. Use an item with a "Gather" use, such as a wooden pole.\n\t\t5. Use an item with a "Harvest" use, such as a stone knife.\n\t\t\n\t\tUsing your bare hands (the first of the above options) can sometimes harm you. The other options are safe, as they use tools, but they will decrease the durability of that tool.'],
        [a.HelpArticle.ResourceGathering]: ["Resource\nGathering", "A guide on collecting items from the environment or creatures.", "Collecting items from the environment.", 'To gather resources from trees or rocks, you must use the "Gather" action from an item\'s menu. It is also recommended you quickslot it for quick usage. You may have to default its usage as "Gather" if it is not the default action. See {link(Menu.HelpArticle.Quickslots):Quickslots} for more information on this functionality. You may not always succeed in gathering materials (the chances are based on your skill and tool).\n\t\n\t\tAlternatively, if you have the "Auto Gather/Harvest" option set, you can simply move into resource tiles that block movement to gather. You will use whatever is in your hands to gather. You can choose what tool specifically is used in either your left or right hand by selecting which to use at the bottom of your equipment menu. It is harmful to try to resource gather without tools.\n\t\n\t\tSome resources are not gathered in this fashion. Things like small plants and other objects attached to the ground (referred to as doodads) require different methods. Review the {link(Menu.HelpArticle.Doodads):"Doodads" help entry} for more information on these items.\n\t\t\n\t\t{heading:Resource Stages}\n\t\t\n\t\tMany plant-based resources have cycles of growth, following a predictable pattern from "germinating" all the way up to "ripening". Every plant and fungus features unique resources at each stage of growth. If you attempt to gather or harvest from a plant too early, you may not get the full amount of resources. Knowing the steps of growth is also important when {link(Menu.HelpArticle.Gardening):gardening}.\n\t\t\n\t\t{heading:Gathering & Harvesting}\n\t\t\n\t\tGathering is a destructive process, meaning, you will attempt to gather everything from the plant. Some vegetables and fruits require this to get the edible portion, such as potatoes or carrots for example.\n\n\t\tHarvesting a plant will only attempt to get what will keep the plant alive and/or sustainable. This is not always an option for all plants, and sometimes will only result in getting their seeds.'],
        [a.HelpArticle.Milestones]: ["Milestones", "A short guide on Wayward's achievement system.", "The achievement system of the game.", 'Milestones are a list of goals or achievements you can work towards. Milestone progress is retained between characters and saves. Completing a milestone unlocks higher starting skills, stat points, and even more items.\n\t\t\n\t\tMost milestones add up over time, such as "Friendly", which counts how many creatures you tame, or "Chef", which counts how many times you cook food. However, there are a few milestones that simply require an amount of something to be unlocked. Examples of this milestone type are "Malevolent" and "Benevolent", which require your malignity or benignity to be at 64000.'],
        [a.HelpArticle.HeldItems]: ["Held Items", "Using the left and right hand equipment slots.", "Understanding the use of both of your hands.", 'Your left and right hand equipment slots are interchangeable. You can equip two weapons, two tools, two shields or any combination in between. \n\t\t\n\t\tYou will notice the options "Left Hand" and "Right Hand" in the equipment dialog ({Bindings:DialogEquipment}). With both options enabled, you will use both hands (and whatever is equipped in each slot) in combat and in gathering/harvesting (with "Auto Gather/Harvest" enabled). Only one hand is used per turn, so both being enabled means the hands switch off. Be careful to disable a hand if you don\'t have something equipped in it, as you could harm a hand by mistake. \n\t\t\n\t\tIf both hands are disabled, automatic gathering and combat is not possible.\n\t\n\t\tTo receive a parrying defense bonus, you must be holding an item in each hand (one to parry with, one to fight with).'],
        [a.HelpArticle.Crafting]: ["Crafting", "A guide to the crafting system: What items to use, and affecting the output durability and quality.", "The ins and outs of smashing materials together.", 'You can open the crafting dialog with the "Crafting" menu bar button, or with {Bindings:DialogCrafting}.\n\t\t\n\t\tCrafting is simple to perform, but the system has a lot of depth.\n\t\t\n\t\t__Which Items Are Used__\n\n\t\tWhen hovering over a recipe (item) in the crafting window, the items that will be used to craft it will be highlighted with a white border. \n\t\t\n\t\tYou may notice that the recipe always uses the first instance of the item in your inventory. To change what items are used in a craft, you can simply change the order of the items in your inventory.\n\t\t\n\t\t__Durability and Quality__\n\t\t\n\t\tThe durability and {link(Menu.HelpArticle.ItemQualities):quality} of crafting ingredients affects the durability and quality of the resulting item:\n\t\t- Ingredients that are damaged will cause the resulting item to be less durable.\n\t\t- Using remarkable, exceptional or legendary items increases your chances to craft a high-quality item.\n\t\t- Decayable items (such as food) also gain decay bonuses from using higher quality items in the craft.\n\t\t\n\t\t__Unlocking New Recipes__\n\t\t\n\t\tYou can find new crafting recipes by gathering the required items in your inventory and by finding old instructional scrolls.'],
        [a.HelpArticle.ItemQualities]: ["Item Qualities", "Understanding the differences between normal items and those of quality.", "Remarkable, exceptional and legendary item qualities.", "There are three item qualities, each with differing properties.\n\n\t\t1. Remarkable: Outlined in a {#--item-quality-remarkable:blue} border, these items will have a slightly higher durability than normal items.\n\t\t2. Exceptional: Outlined in a {#--item-quality-exceptional:purple} border, these items will have a higher durability than normal items.\n\t\t3. Legendary: Outlined in a {#--item-quality-legendary:orange} border, these items will have a much higher durability than normal items and feature a unique magical property. These magical properties include such things as increased skills or stats on equipping, reduced item weight, increased weight capacity, and many more depending on the item.\n\t\t\n\t\tBesides the bonuses to durability, item quality will also provide bonuses to item uses such as consumption potency, fuel values, and others depending on the type of item it is. Additionally, the more items of quality used in a {link(Menu.HelpArticle.Crafting):craft}, the higher the chance of producing a higher quality item is."],
        [a.HelpArticle.Death]: ["Death", "It will happen to us all eventually. This contains information about what carries over between lives.", "What carries over between lives.", "Death is permanent. Although you may have died, all of the crafting recipes you have discovered will be ready on your next playthrough. Your {link(Menu.HelpArticle.Milestones):milestones} will also carry over, providing you multiple starting benefits."],
        [a.HelpArticle.Taming]: ["Creature Taming", "A small guide on how to tame creatures using a variety of methods.", "Learn about all the options for taming creatures.", 'There\'s a variety of methods for attempting to tame creatures in Wayward. These include:\n\t\t\n\t\t1. Using the {link(Menu.HelpArticle.Actions): "Tame" action in the action menu} when facing a \n\t\tcreature. The chances of success of this method are quite low, especially at lower skill levels and varies depending on what the creature is and their difficulty.\n\t\t2. Using the "Offer" option on an item when facing a creature. If the creature wants the item, it will accept you as its owner.\n\t\t3. Dropping items on the ground and having creatures move over it will have them become tame towards you (or any player that is closest to the creature) if they accept the item.\n\t\t\n\t\tAberrant creatures are harder to tame and will sometimes reject you as its owner even when offering items. This chance is based on your animal taming skill.'],
        [a.HelpArticle.Gardening]: ["Gardening", "Learn about the cycles of growth for plant-life and tips on gardening.", "Tips on gardening and information on growth cycles.", 'The full plant life cycle is represented within Wayward. In order, these are: germinating, seedling, vegetative, budding, flowering, ripening, and dead. Fungus follows the same steps, but are named: germinating, spreading, forming, young, fruiting, and full. Each of these stages provide different {link(Menu.HelpArticle.ResourceGathering):resources when gathering or harvesting}.\n\t\t\n\t\tYou can attempt to water plants (by using the "Pour" action on water containers) or plant them on fertile soil to reduce their growth time. Watering plants will also heal them if they became damaged through harvesting or trampling.\n\t\t\n\t\tThrough the use of fertilization, you can promote the fertility of plants (spreading and propagation) and decrease growing time. By combining compostable items to produce compost, and making bone meal through the grinding of bones, you can craft fertilizer. Combine it with soil (produced when digging dirt) to create fertile soil. Fertile soil can be placed down, tilled, then used as the target for planting seeds and mushrooms.'],
        [a.HelpArticle.Overweight]: ["Overweight", "Learn the impacts of being overweight.", "Understanding being encumbered and overburdened.", 'If you are carrying too much weight, you will be "Encumbered". The first level of encumbrance will slow down your movement and reduce {link(Menu.HelpArticle.Stats):stamina regeneration}. If it progresses to the second level, "Overburdened", you will take damage as you move. \n\t\n\t\tYou can drop items from your inventory with {Bindings:GameItemDrop}, {Bindings:GameItemDropAll} (to drop all of one type of item), you can use the {link(Menu.HelpArticle.Actions):"Drop" action on the item}, or you can drag and drop them on to the game screen.'],
        [a.HelpArticle.Merchants]: ["Merchants", "Learn how to trade and interact with wandering merchants.", "Interacting with non-playable characters.", 'You can drag items into the wandering merchant\'s inventory to receive barter credit. Alternatively, you can also use the item\'s menu to trade as well. You can use this barter credit to trade for other items that you wish to receive in return. You can come back at any time to trade with the merchant, but be careful, they may "wander" away for good eventually.\n\t\t\n\t\tYour bartering skill influences the amount of barter credit received when trading items; however, merchants will always trade items back at a higher value.\n\t\t\n\t\tIf you do not wish to trade with the merchant, you can also choose to instigate an attack towards the wanderer using the {link(Menu.HelpArticle.Actions):"Attack" option in the action menu}. But, be careful; they won\'t take kindly to such hostile actions.'],
        [a.HelpArticle.Multiplayer]: ["Multiplayer", "Information on the multiplayer system in Wayward.", "Survival is easier with company!", 'Multiplayer in Wayward is enabled for up to 32 players. Multiplayer works on a simulated real-time mode where each turn happens on a fixed interval. "Casual" and "Hardcore" modes work a bit differently than in single player. Casual mode allows players to respawn as per normal, but in hardcore mode, when you die you will continue to play in ghost form, allowing you to spectate but not interact normally. Multiplayer also allows for a special PVP flag to be set to allow players to hurt and kill other players. Multiplayer options can be set in the multiplayer menu via the pause menu accessed with {Bindings:GamePause}.\n\t\n\t\tCreature spawn rates, creature difficulty, and reputation are all based on how many connected players there are and will scale and average based on each individual player.\n\t\t\n\t\t{heading:Commands}\n\t\tYou can use several special commands while playing multiplayer. To see a list of all possible commands, type "/commands" in the chat bar and hit enter. The following commands are also available for use:\n\t\n\t\t{#--text-color-faded:/players} — Shows a list of all connected players.\n\t\t{#--text-color-faded:/ping} — Shows your latency to the host player.\n\t\t{#--text-color-faded:/kick} — Allows the host to kick a player.\n\t\t{#--text-color-faded:/banned} — Shows a list of all banned players.\n\t\t{#--text-color-faded:/ban} — Allows the host to ban a player.\n\t\t{#--text-color-faded:/unban} — Allows the host to unban a player.'],
        [a.HelpArticle.Bugs]: ["Bugs and Errors", "Did you get an error? Please report it!", "Learn how to report bugs and debug Wayward.", "Please report all the issues you spot! While we try to ensure Wayward is very stable, some things fall through the cracks. Wayward is still in beta status and our development team is very small. Therefore, without players reporting issues, they may stay unresolved. If you do report your bugs, we cannot express just how much we appreciate them! \n\t\t\n\t\tWith that being said, {link(https://steamcommunity.com/sharedfiles/filedetails/?id=798938225):here is a guide on how to report and debug issues you have with Wayward}.\n\t\t\n\t\tReport bugs and issues at:\n\t\t1. {link(http://steamcommunity.com/app/379210/discussions/1/):Steam Discussions Bug Reports forum} OR\n\t\t2. {link(https://discord.gg/wayward):Discord}"]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/InterruptChoices", ["require", "exports", "language/dictionary/InterruptChoice"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.default.Cancel]: "Cancel",
        [a.default.ContinueAnyway]: "Continue Anyway",
        [a.default.LocalFile]: "Local File",
        [a.default.No]: "No",
        [a.default.NoWarn]: "{#--message-type-bad:No}",
        [a.default.Ok]: "OK",
        [a.default.OpenSaveFolderAndQuit]: "Open Save Folder and Quit",
        [a.default.Quit]: "Quit",
        [a.default.Rejoin]: "Rejoin",
        [a.default.Rename]: "Rename",
        [a.default.Retry]: "Retry",
        [a.default.SteamWorkshop]: "Steam Workshop",
        [a.default.Yes]: "Yes"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/MessagesTimestampModes", ["require", "exports", "newui/screen/screens/game/IGameScreenApi"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.MessageTimestamp.None]: "None",
        [a.MessageTimestamp.RealTime]: "Real Time",
        [a.MessageTimestamp.Turn]: "Turn"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/ModLoadErrors", ["require", "exports", "mod/IModManager"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.CanLoadState.ModLoadError]: "Error loading mod.",
        [a.CanLoadState.DependencyIssue]: "Issues found with dependencies.",
        [a.CanLoadState.ModRequiresItself]: "Mod requires itself.",
        [a.CanLoadState.MissingRequiredMod]: "Missing a required mod.",
        [a.CanLoadState.ReqiredModNotLoaded]: "Required mod is not loaded.",
        [a.CanLoadState.LocalModPrecedence]: "Installed locally; local mods have precedence.",
        [a.CanLoadState.IncompatibleVersion]: "Incompatible with this version.",
        [a.CanLoadState.CannotLoadRequiredMod]: "Can't load required mod."
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/MusicPlaylists", ["require", "exports", "save/data/ISaveDataGlobal"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.MusicPlaylist.Dynamic]: ["Dynamic", "Tracks are chosen based on situation."],
        [a.MusicPlaylist.Ordered]: ["Ordered", "Tracks play in order."],
        [a.MusicPlaylist.Shuffle]: ["Shuffle", "Tracks are randomized."]
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/PowerModes", ["require", "exports", "save/data/ISaveDataGlobal"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.PowerMode.Default]: "Default",
        [a.PowerMode.LowPower]: "Low Power",
        [a.PowerMode.HighPerformance]: "High Performance"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/sort/CharacterSorts", ["require", "exports", "newui/screen/screens/menu/menus/character/Character"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.CharacterSort.LastUse]: "Last Use",
        [a.CharacterSort.Name]: "Name",
        [a.CharacterSort.UseCount]: "Times Used"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/sort/HighscoreSorts", ["require", "exports", "newui/screen/screens/menu/menus/highscores/IHighscoresMenu"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.HighscoreSort.Recency]: "Last Played",
        [a.HighscoreSort.SaveName]: "Save Name",
        [a.HighscoreSort.Score]: "Score"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/sort/ModSorts", ["require", "exports", "newui/screen/screens/menu/menus/mods/IModsMenu"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.ModSort.Author]: "Author",
        [a.ModSort.CreatedDate]: "Created Date",
        [a.ModSort.InstallDate]: "Install Date",
        [a.ModSort.LastUpdated]: "Last Update Date",
        [a.ModSort.Name]: "Name"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/sort/SaveSlotSorts", ["require", "exports", "save/ISaveManager"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.SaveSort.CreatedTime]: "Creation Time",
        [a.SaveSort.Name]: "Name",
        [a.SaveSort.SaveTime]: "Last Played",
        [a.SaveSort.TurnCount]: "Turn Count"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/TeamMemberResponsibilities", ["require", "exports", "newui/screen/screens/menu/menus/main/AboutMenu"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.Responsibility.Art]: "Art",
        [a.Responsibility.Design]: "Design",
        [a.Responsibility.Music]: "Music",
        [a.Responsibility.PR]: "PR",
        [a.Responsibility.Programming]: "Programming",
        [a.Responsibility.UX]: "UX",
        [a.Responsibility.Web]: "Web"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/UiQuadrants", ["require", "exports", "newui/screen/screens/game/component/QuadrantComponent"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.Quadrant.None]: "Storage",
        [a.Quadrant.TopLeft]: "Top Left",
        [a.Quadrant.Top]: "Top",
        [a.Quadrant.TopRight]: "Top Right",
        [a.Quadrant.BottomRight]: "Bottom Right",
        [a.Quadrant.Bottom]: "Bottom",
        [a.Quadrant.BottomLeft]: "Bottom Left"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/english/ui/UiTranslations", ["require", "exports", "language/dictionary/UiTranslation"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        [a.default.GameActionGather]: "gather",
        [a.default.GameDialogMessagesName]: "Messages",
        [a.default.GameDialogMessagesOptionTimestamp]: "Message Timestamp",
        [a.default.GameDialogMessagesOptionShowSendButton]: "Show Send Button",
        [a.default.GameDialogMessagesOptionShowOptionsButton]: "Show Options Button",
        [a.default.GameDialogMessagesOptionMaxMessages]: "Log Length",
        [a.default.GameDialogMessagesEditFiltersName]: "Edit Filters",
        [a.default.GameDialogMessagesEditFiltersLabelName]: "Name",
        [a.default.GameDialogMessagesEditFiltersButtonDelete]: "Delete",
        [a.default.GameDialogMessagesEditFiltersButtonSave]: "Save",
        [a.default.GameDialogMessagesEditFiltersButtonNew]: "New",
        [a.default.GameDialogMessagesEditFiltersButtonReset]: "Reset",
        [a.default.GameDialogMessagesEditFiltersInterruptSaveOverExisting]: "There is already a filter with this name.",
        [a.default.GameDialogMessagesEditFiltersInterruptSaveOverExistingDescription]: "Would you like to save over it?",
        [a.default.GameDialogMessagesEditFiltersInterruptResetConfirm]: "Are you sure you want\nto reset your filters?",
        [a.default.GameDialogMessagesEditFiltersInterruptResetConfirmDescription]: "There is no undo.",
        [a.default.GameDialogNotesName]: "Notes",
        [a.default.GameDialogNotesNoteTime]: "Day {0}, {1}",
        [a.default.GameDialogNotesNoteNumber]: "{0} / {1}",
        [a.default.GameDialogNotesNoteLockedTitle]: "?",
        [a.default.GameDialogNotesNoteLockedDescription]: "...",
        [a.default.GameDialogNotesLinkId]: "#{0}",
        [a.default.GameDialogNotesLinkLearnMore]: "Learn More",
        [a.default.GameDialogNotesSettingsPinUnreadNotesAutomatically]: "Pin New/Unread Notes",
        [a.default.GameDialogQuickSettingsName]: "Quick Settings",
        [a.default.GameDialogMilestonesName]: "Milestones",
        [a.default.GameDialogMilestonesInvisibleMilestone]: "???",
        [a.default.GameDialogMilestonesProgress]: "{0}/{1}",
        [a.default.GameDialogMilestonesProgressHidden]: "?/?",
        [a.default.GameDialogMilestonesMilestone]: "{0}: {1}",
        [a.default.GameDialogMilestonesTooltipHidden]: "This milestone is hidden.",
        [a.default.GameDialogMilestonesTooltipInvisible]: "This milestone is invisible.",
        [a.default.GameDialogMilestonesSortName]: "Name",
        [a.default.GameDialogMilestonesSortProgress]: "Progress",
        [a.default.GameDialogSkillsName]: "Skills",
        [a.default.GameDialogSkillsSkill]: "{0}: {1}%",
        [a.default.GameDialogSkillsTooltipReputationImpact]: "{#--text-color-faded:Reputation Impact:} {0}",
        [a.default.GameDialogSkillsTooltipCanIncrease]: "{#--text-color-faded:Can Increase:} {0}",
        [a.default.GameDialogSkillsSortName]: "Name",
        [a.default.GameDialogSkillsSortLevel]: "Level",
        [a.default.GameDialogBookName]: "Book",
        [a.default.GameDialogMapName]: "Map",
        [a.default.GameDialogMapTooltipDecode]: "Re-decode",
        [a.default.GameDialogQuestsName]: "Quests",
        [a.default.GameDialogQuestsLink]: "{0}: {1}/{2}",
        [a.default.GameDialogQuestsChildQuests]: "Unlocked Quests",
        [a.default.GameDialogQuestsRequirements]: "Requirements",
        [a.default.GameDialogQuestsActiveQuests]: "Active Quests",
        [a.default.GameDialogQuestsCompletedQuests]: "Completed Quests",
        [a.default.GameDialogQuestsCompleteQuest]: "Complete Quest",
        [a.default.GameTooltipShowMoreInformation]: "See More: {Bindings:GameMoreInformation}",
        [a.default.GameTooltipLegendaryMaxWeightLabel]: "Max Weight",
        [a.default.GameStatsPercentage]: "{0}%",
        [a.default.GameStatsStatAttack]: "{0}/{1}",
        [a.default.GameStatsStatGeneric]: "{0}",
        [a.default.GameStatsStatGenericWithMax]: "{0}/{1}",
        [a.default.GameStatsStatbar]: "{0} ({1}%)",
        [a.default.GameStatsStatHealthTooltip]: "Health {#--text-color-faded:(Strength)}",
        [a.default.GameStatsStatStaminaTooltip]: "Stamina {#--text-color-faded:(Dexterity)}",
        [a.default.GameStatsStatHungerTooltip]: "Hunger {#--text-color-faded:(Metabolism/Starvation)}",
        [a.default.GameStatsStatThirstTooltip]: "Thirst {#--text-color-faded:(Metabolism/Dehydration)}",
        [a.default.GameStatsStatReputationTooltipDifficulty]: "Difficulty: {#--stat-color:{0}}",
        [a.default.GameStatsStatReputationTooltipDifficultyEasy]: "Easy",
        [a.default.GameStatsStatReputationTooltipDifficultyHard]: "Hard",
        [a.default.GameStatsStatReputationTooltipDifficultyInsane]: "Insane",
        [a.default.GameStatsStatReputationTooltipDifficultyMedium]: "Medium",
        [a.default.GameStatsStatReputationTooltipDifficultySimple]: "Simple",
        [a.default.GameStatsStatReputationTooltipDifficultyVeryEasy]: "Very Easy",
        [a.default.GameStatsStatReputationTooltipDifficultyVeryHard]: "Very Hard",
        [a.default.GameStatsStatReputationTooltipBenignity]: "Benignity: {#--stat-color:{0}/{1}}",
        [a.default.GameStatsStatReputationTooltipMalignity]: "Malignity: {#--stat-color:{0}/{1}}",
        [a.default.GameStatsStatReputationTooltipScore]: "Score: {#--stat-color:{0}}",
        [a.default.GameStatsStatReputationTooltipTurn]: "Turn: {#--stat-color:{0}}",
        [a.default.GameStatsStatReputationTooltipTicks]: "Ticks: {#--stat-color:{0}}",
        [a.default.GameStatsStatWeightTooltip]: "Weight {#--text-color-faded:(Strength)}",
        [a.default.GameStatsStatAttackTooltipTactics]: "Attack from Tactics: {#--stat-color:{0}}",
        [a.default.GameStatsStatAttackTooltipLeftHand]: "Left Hand Attack: {#--stat-color:{0}} {#--text-color-faded:({1})}",
        [a.default.GameStatsStatAttackTooltipRightHand]: "Right Hand Attack: {#--stat-color:{0}} {#--text-color-faded:({1})}",
        [a.default.GameStatsStatDefenseTooltipBase]: "Base Defense: {#--stat-color:{0}}",
        [a.default.GameStatsStatDefenseTooltipBlunt]: "Blunt Resist: {#--stat-color:{0}}",
        [a.default.GameStatsStatDefenseTooltipParrying]: "Defense From Parrying: {#--stat-color:{0}}",
        [a.default.GameStatsStatDefenseTooltipFire]: "Fire Resist: {#--stat-color:{0}}",
        [a.default.GameStatsStatDefenseTooltipPiercing]: "Piercing Resist: {#--stat-color:{0}}",
        [a.default.GameStatsStatDefenseTooltipSlashing]: "Slashing Resist: {#--stat-color:{0}}",
        [a.default.GameQuadrantElementStats]: "Stats",
        [a.default.GameQuadrantElementMenuBar]: "Menu Bar",
        [a.default.GameQuadrantElementQuickslots]: "Quickslots",
        [a.default.GameQuadrantElementMessages]: "Messages",
        [a.default.GameQuadrantElementContextMenuMoveTo]: "Move {0} To",
        [a.default.GameQuadrantElementContextMenuSwitchWith]: "Switch With",
        [a.default.GameItemBarterCredit]: "Barter Credit: ",
        [a.default.GameItemBarterCreditTrade]: "Barter Credit Trade: ",
        [a.default.GameInterruptItemMayBeDestroyedOnUse]: "Item may be destroyed on use.",
        [a.default.GameInterruptItemMayBeDestroyedOnUseDescription]: "Do you wish to continue?",
        [a.default.GameInterruptItemMayBeDestroyedInCraft]: "Items in the craft may be destroyed on failure or use.",
        [a.default.GameInterruptItemMayBeDestroyedInCraftDescription]: "Do you wish to continue?",
        [a.default.GameInterruptReleaseCreature]: "Are you sure you want to release {0}?",
        [a.default.GameInterruptReleaseCreatureDescription]: "",
        [a.default.GameInterruptRenameItem]: "What would you like to name the {0}?",
        [a.default.GameInterruptRenameItemDescription]: "",
        [a.default.GameInterruptRenameDoodad]: "What would you like to name the {0}?",
        [a.default.GameInterruptRenameDoodadDescription]: "",
        [a.default.GameInterruptRenameCreature]: "What would you like to name the {0}?",
        [a.default.GameInterruptRenameCreatureDescription]: "",
        [a.default.GameInterruptReturnToTitleScreen]: "Are you sure you want to\nreturn to the title screen?",
        [a.default.GameInterruptReturnToTitleScreenDescription]: "Your progress will be saved automatically.",
        [a.default.GameInterruptReturnToTitleScreenChallenge]: "Are you sure you want to\nreturn to the title screen?",
        [a.default.GameInterruptReturnToTitleScreenChallengeDescription]: "Your progress is not saved in Challenge Mode!",
        [a.default.GameInterruptLoadingSaving]: "Saving Game",
        [a.default.GameInterruptLoadingSavingDescription]: "",
        [a.default.GameInterruptLoadingQuitting]: "Quitting Game",
        [a.default.GameInterruptLoadingQuittingDescription]: "",
        [a.default.GameInterruptLoadingWorld]: "Loading World",
        [a.default.GameInterruptLoadingWorldDescription]: "",
        [a.default.GameInterruptLoadingGeneratingWorld]: "Generating World",
        [a.default.GameInterruptLoadingGeneratingWorldDescription]: "",
        [a.default.GameInterruptLoadingFinalizingWorld]: "Finalizing World",
        [a.default.GameInterruptLoadingFinalizingWorldDescription]: "",
        [a.default.GameInterruptSailAwayEnd]: "Are you sure you want\nto sail to civilization?",
        [a.default.GameInterruptSailAwayEndDescription]: "Your journey will be over.",
        [a.default.GameInterruptSailAwayReturnable]: "Are you sure you want\nto sail to civilization?",
        [a.default.GameInterruptSailAwayReturnableDescription]: "Your journey will be over, but you can always return back to these lands.\nFood and water are recommended.",
        [a.default.GameInterruptTravelAway]: "Are you sure you want to\ntravel away from these lands?",
        [a.default.GameInterruptTravelAwayDescription]: "You can never return. Make sure to grab all you need!\nFood and water are recommended.",
        [a.default.GameInterruptLoadingResting]: "Resting",
        [a.default.GameInterruptLoadingRestingDescription]: "",
        [a.default.GameInterruptLoadingSleeping]: "Sleeping",
        [a.default.GameInterruptLoadingSleepingDescription]: "",
        [a.default.GameInterruptLoadingTraveling]: "Traveling",
        [a.default.GameInterruptLoadingTravelingDescription]: "",
        [a.default.GameInterruptLoadingLostGLContext]: "Lost GL Context",
        [a.default.GameInterruptLoadingLostGLContextDescription]: "",
        [a.default.GameInterruptLoadingAutoSaving]: "Auto Saving",
        [a.default.GameInterruptLoadingAutoSavingDescription]: "",
        [a.default.GameInterruptLoadingMods]: "Loading Mods",
        [a.default.GameInterruptLoadingModsDescription]: "",
        [a.default.GameInterruptLoadingMultiplayerPlayerConnecting]: "Player Connecting",
        [a.default.GameInterruptLoadingMultiplayerSyncing]: "Syncing With Server",
        [a.default.GameInterruptLoadingReloadingWebGl]: "Reloading WebGl",
        [a.default.GameInterruptDangerousStep]: "Are you sure you want to step there?",
        [a.default.GameInterruptDangerousStepDescription]: "Stepping onto {0} is dangerous!",
        [a.default.GameInterruptSaveFailure]: "Failed to Save the Game",
        [a.default.GameInterruptSaveFailureDescription]: "Please create a topic and send us your logs on the {link(https://steamcommunity.com/app/379210/discussions/1/):Bug Reports Forum}.",
        [a.default.GameInterruptLoadFailure]: "Failed to Load the Game",
        [a.default.GameInterruptLoadFailureDescription]: "Please create a topic and send us your logs on the {link(https://steamcommunity.com/app/379210/discussions/1/):Bug Reports Forum}.",
        [a.default.GameInterruptDesalinationNoNeed]: "This water does not need to undergo the desalination process.",
        [a.default.GameInterruptDesalinationNoNeedDescription]: "Do you want to pour it in the still to purify?",
        [a.default.GameInterruptWellConvert]: "Pouring this water will convert the water in the well to seawater.",
        [a.default.GameInterruptWellConvertDescription]: "Do you want to convert the water in the well?",
        [a.default.GameInterruptNoHealingRequired]: "Your target for healing is not damaged or bleeding.",
        [a.default.GameInterruptNoHealingRequiredDescription]: "Are you sure you want to heal anyways?",
        [a.default.GameInterruptConfirmationActionOnFire]: "Are you sure you want to\n{1} from {0}?",
        [a.default.GameInterruptConfirmationActionOnFireDescription]: "It is on fire!",
        [a.default.GameInterruptConfirmationDestroyOnGather]: "{0} does not have any resources to gather or harvest yet.",
        [a.default.GameInterruptConfirmationDestroyOnGatherDescription]: "Are you sure you want to destroy it?",
        [a.default.GameInterruptLoadingGame]: "Loading Game",
        [a.default.GameInterruptLoadingGameDescription]: "",
        [a.default.GameInterruptLoadingSprites]: "Loading Sprites",
        [a.default.GameInterruptLoadingSpritesDescription]: "",
        [a.default.GameInterruptMultiplayerSynchronizing]: "Synchronizing",
        [a.default.GameInterruptMultiplayerSynchronizingDescription]: "Synchronizing game state with the server.",
        [a.default.GameInterruptNoSaveOnDeath]: "You Have Died",
        [a.default.GameInterruptNoSaveOnDeathDescription]: "You cannot save while dead in hardcore mode.",
        [a.default.GameInterruptItemsMayBeDestroyedOnUse]: "Your {0} may be destroyed.",
        [a.default.GameInterruptItemsMayBeDestroyedOnUseDescription]: "Are you sure you want to do that?",
        [a.default.GameMenuBarButtonTooltipBindable]: " {#--text-color-faded:({Bindings:{0}})}",
        [a.default.GameMenuBarButtonTooltipMenu]: "Menu",
        [a.default.GameMenuBarButtonTooltipSave]: "Save",
        [a.default.GameMenuBarButtonTooltipHelp]: "Help",
        [a.default.GameMenuBarButtonTooltipNotes]: "Notes",
        [a.default.GameMenuBarButtonTooltipMilestones]: "Milestones",
        [a.default.GameMenuBarButtonTooltipMessages]: "Messages",
        [a.default.GameMenuBarButtonTooltipQuickSettings]: "Quick Settings",
        [a.default.GameMenuBarButtonTooltipActions]: "Actions",
        [a.default.GameMenuBarButtonTooltipInventory]: "Inventory",
        [a.default.GameMenuBarButtonTooltipCrafting]: "Crafting",
        [a.default.GameMenuBarButtonTooltipEquipment]: "Equipment",
        [a.default.GameMenuBarButtonTooltipSkills]: "Skills",
        [a.default.GameMenuBarButtonTooltipQuests]: "Quests",
        [a.default.GameMessagesButtonSend]: "Say",
        [a.default.GameMessagesContextMenuShowAsDialog]: "Show Messages As Dialog",
        [a.default.GameMessagesContextMenuClear]: "Clear Message History",
        [a.default.GameMessagesContextMenuCopy]: "Copy Log",
        [a.default.GameMessagesContextMenuExport]: "Export Filtered History",
        [a.default.GameMessagesContextMenuClearInterrupt]: "Are you sure you want to clear\nyour //entire// message history?",
        [a.default.GameMessagesContextMenuClearInterruptDescription]: "There is no undo.",
        [a.default.GameMessagesFilter]: "Filter: {0}",
        [a.default.GameMessagesFilterAll]: "All",
        [a.default.GameMessagesFilterGame]: "Game",
        [a.default.GameMessagesFilterChat]: "Chat",
        [a.default.GameMessagesFiltersEdit]: "Edit",
        [a.default.GameMessagesNewNote]: "You have written a note: {0}",
        [a.default.GameMessagesTurn]: "Turn {0}",
        [a.default.GameMultiplayerInterruptBanned]: "You have been banned from the server.",
        [a.default.GameMultiplayerInterruptConnected]: "Connected",
        [a.default.GameMultiplayerInterruptConnectedDescriptionDownloadingWorldData]: "Downloading world data - {0}%",
        [a.default.GameMultiplayerInterruptConnectedDescriptionWaitingForWorldData]: "Waiting for world data",
        [a.default.GameMultiplayerInterruptConnecting]: "Connecting",
        [a.default.GameMultiplayerInterruptConnectingDescription]: "Waiting for the server to respond...",
        [a.default.GameMultiplayerInterruptFailedToConnect]: "Failed to connect.",
        [a.default.GameMultiplayerInterruptFailedToLoadMods]: "Required mod(s) have the following issues:\n{0}",
        [a.default.GameMultiplayerInterruptKicked]: "You have been kicked from the server.",
        [a.default.GameMultiplayerInterruptLostConnection]: "Lost connection to server.",
        [a.default.GameMultiplayerInterruptRequiredModIsDisabled]: "{name}@{version} is disabled",
        [a.default.GameMultiplayerInterruptRequiredModNotInstalled]: "{name}@{version} is not installed",
        [a.default.GameMultiplayerInterruptRequiredModNotMultiplayerCompatible]: "{name}@{version} is not a multiplayer-compatible mod.",
        [a.default.GameMultiplayerInterruptRequiredModUnableToLoad]: "Unable to load {name}@{version}",
        [a.default.GameMultiplayerInterruptRequiredModVersionMismatch]: "Required {name}@{version}. Currently running version {1}",
        [a.default.GameMultiplayerInterruptRestartServerAfterLoadingSave]: "Multiplayer",
        [a.default.GameMultiplayerInterruptRestartServerAfterLoadingSaveDescription]: "Would you like to reopen your multiplayer server?",
        [a.default.GameMultiplayerInterruptServerShutdown]: "The server is shutting down.",
        [a.default.GameMultiplayerInterruptSynchronizationError]: "Your game became\nout of sync with the server.",
        [a.default.GameMultiplayerInterruptSynchronizationErrorDescription]: "Would you like to rejoin?",
        [a.default.GameMultiplayerInterruptUnableToJoinGame]: "Unable to Join the Game",
        [a.default.GameMultiplayerInterruptUnableToJoinGameBuildMismatch]: "The server build ({0}) is different than your build ({1}).",
        [a.default.GameMultiplayerInterruptUnableToJoinGameDuplicateIdentifier]: "A player with your ID is already playing on this server.\nTry to rejoin in a minute.",
        [a.default.GameMultiplayerInterruptUnableToJoinGameFriendsOnly]: "The server only allows friends to join.",
        [a.default.GameMultiplayerInterruptUnableToJoinGameServerFull]: "The server is full.",
        [a.default.GameMultiplayerInterruptUnableToJoinGameSteamRequired]: "You must run the game from Steam to join this server.",
        [a.default.GameMultiplayerInterruptUnableToJoinGameUnknownError]: "Error code {0}.",
        [a.default.GameMultiplayerInterruptUnableToJoinGameVersionMismatch]: "The server version ({0}) is different than your version ({1}).",
        [a.default.MenuAboutTitle]: "About",
        [a.default.MenuAboutDescription]: "Learn more about Wayward.",
        [a.default.MenuAboutGameDescription]: "Wayward is a challenging turn-based, top-down, wilderness survival roguelike. Explore, build, and most importantly, survive in these unforgiving lands.",
        [a.default.MenuAboutSectionTeam]: "Team",
        [a.default.MenuAboutTeamMemberResponsibilities]: "{0}",
        [a.default.MenuAboutTeamMemberName]: "{0} {2}{1}",
        [a.default.MenuAboutTeamMemberNickname]: '"{0}" ',
        [a.default.MenuAboutSectionContributors]: "Contributors",
        [a.default.MenuAboutSectionSpecialThanks]: "Special Thanks",
        [a.default.MenuAboutTextSpecialThanksTestorsAndDonators]: "An extra special thank you to all the early testers, donators, and other supporters.",
        [a.default.MenuAboutSectionLibraries]: "Libraries",
        [a.default.MenuAboutSectionLibrariesDescription]: "Wayward is made possible with the following projects:",
        [a.default.MenuBindings]: "Bindings",
        [a.default.MenuBindingsDescription]: "Configure the keybinds for all of the game's actions.",
        [a.default.MenuChangelogTitle]: "Changelog",
        [a.default.MenuChangelogDescription]: "View major and minor updates to Wayward.",
        [a.default.MenuChangelogHeadingFailedLoad]: "Failed to load the changelog for {0}.",
        [a.default.MenuChangelogHeadingChangeCount]: "({0} changes)",
        [a.default.MenuChangelogInterruptLoadingChangelog]: "Loading Changelog",
        [a.default.MenuChangelogInterruptLoadingChangelogDescription]: "",
        [a.default.MenuCharacterCreationButtonRandomizeName]: "Random",
        [a.default.MenuCharacterCreationLabelName]: "Name",
        [a.default.MenuCharacterCreationButtonExportTooltip]: "Export",
        [a.default.MenuCharacterCreationButtonImportTooltip]: "Import",
        [a.default.MenuCharacterCreationButtonStartGame]: "Start Game",
        [a.default.MenuCharacterCreationButtonJoinGame]: "Join Game",
        [a.default.MenuCharacterCreationDescription]: "Customize your character.",
        [a.default.MenuCharacterCreationHeadingHairColor]: "Hair Color",
        [a.default.MenuCharacterCreationHeadingHairStyle]: "Hairstyle",
        [a.default.MenuCharacterCreationHeadingSkinTone]: "Skin Tone",
        [a.default.MenuCharacterCreationTitle]: "Character Creation",
        [a.default.MenuCharacterCreationInterruptImportCharacterFailure]: "Unable to Import Character",
        [a.default.MenuCharacterCreationInterruptImportCharacterFailureDescription]: "",
        [a.default.MenuCharacterCreationButtonRotateLeftTooltip]: "Rotate Clockwise",
        [a.default.MenuCharacterCreationButtonRotateRightTooltip]: "Rotate Counter-clockwise",
        [a.default.MenuCharacterCreationButtonRandomizeTooltip]: "Randomize",
        [a.default.MenuCharacterSelectionButtonNewCharacter]: "New Character",
        [a.default.MenuCharacterSelectionDescription]: "Randomize a new character or create from a template.",
        [a.default.MenuCharacterSelectionHeadingNoCharacters]: "No Saved Templates",
        [a.default.MenuCharacterSelectionLabelLastUse]: "Last Used: {0}",
        [a.default.MenuCharacterSelectionLabelUseCount]: "Used {0} times",
        [a.default.MenuCharacterSelectionTitle]: "Character Selection",
        [a.default.MenuCharacterSelectionCharacterButtonDeleteTooltip]: "Delete",
        [a.default.MenuCharacterSelectionCharacterButtonCustomizeTooltip]: "Customize",
        [a.default.MenuCharacterSelectionInterruptDeleteCharacter]: "Are you sure you want to delete the character template '{0}'?",
        [a.default.MenuMultiplayerDescription]: "Join your companions on their adventures.",
        [a.default.MenuMultiplayerTitle]: "Multiplayer",
        [a.default.MenuMultiplayerButtonJoinById]: "Join by Game Code or IP",
        [a.default.MenuMultiplayerServerLabelReputation]: "Reputation: {0}",
        [a.default.MenuMultiplayerServerLabelDays]: "Days: {0}",
        [a.default.MenuMultiplayerButtonNewGame]: "New Game",
        [a.default.MenuMultiplayerButtonLoadGame]: "Load Game",
        [a.default.MenuMultiplayerServerTooltipPVP]: "PVP",
        [a.default.MenuMultiplayerServerTooltipModsLabel]: "Mods: {0}",
        [a.default.MenuMultiplayerServerTooltipFriendsLabel]: "Friends: {0}",
        [a.default.MenuMultiplayerServerPlayers]: "Players: {0}/{1}",
        [a.default.MenuMultiplayerServerRegion]: "Region: {0?{0}:Unknown}",
        [a.default.MenuMultiplayerServerHost]: "Host: {0}",
        [a.default.MenuMultiplayerServerDedicated]: "Dedicated Server",
        [a.default.MenuMultiplayerHeadingPlayersOnline]: "Players Online: {0}",
        [a.default.MenuGameEndTitleDead]: "You Died",
        [a.default.MenuGameEndTitleWon]: "You Won",
        [a.default.MenuGameEndShareFacebook]: "Share on Facebook",
        [a.default.MenuGameEndShareTwitter]: "Share on Twitter",
        [a.default.MenuGameEndContinueAsGhost]: "Explore as Ghost",
        [a.default.MenuGameEndReturnToIsland]: "Return to the Island",
        [a.default.MenuGameEndExitToMenu]: "Exit to Title Screen",
        [a.default.MenuGameEndInterruptGhostDeleteSave]: "You are dead.\nDo you want to keep this save?",
        [a.default.MenuGameEndInterruptWonDeleteSave]: "You have won.\nDo you want to keep this save?",
        [a.default.MenuGameEndInterruptDeleteSaveDescription]: "Your highscore and unlocks are saved.",
        [a.default.MenuGameEndInterruptReturnToTitleScreen]: "Are you sure you want to\nreturn to the title screen?",
        [a.default.MenuGameEndInterruptReturnToTitleScreenChallengeMultiplayerDescription]: "{#--message-type-bad:{0?There are other players connected.\n}Saving is disabled in Challenge Mode!}",
        [a.default.MenuGameEndInterruptReturnToTitleScreenChallengeDescription]: "This world will be gone forever.",
        [a.default.MenuGameEndInterruptReturnToTitleScreenMultiplayerDescription]: "{#--message-type-bad:{0?There are other players connected.}}",
        [a.default.MenuHelpTitle]: "Help",
        [a.default.MenuHelpDescription]: "Information, guides, and other help for playing Wayward.",
        [a.default.MenuHelpLabelSearch]: "Search",
        [a.default.MenuHighscoresTitle]: "Highscores",
        [a.default.MenuHighscoresDescription]: "See how well you did in your past adventures.",
        [a.default.MenuHighscoresDifficultyFilterAll]: "All",
        [a.default.MenuHighscoresHighscoreLabelDifficulty]: "{0}",
        [a.default.MenuHighscoresHighscoreLabelTurns]: "Turns: {0}",
        [a.default.MenuHighscoresHighscoreLabelScore]: "Score: {0}",
        [a.default.MenuHighscoresHighscoreLabelDate]: "{0}",
        [a.default.MenuHighscoresHighscoreLabelPlace]: "{0}.",
        [a.default.MenuHighscoresHighscoreLabelDeathBy]: "{0}",
        [a.default.MenuHighscoresHighscoreTitle]: "{0}, {1}",
        [a.default.MenuHighscoresCharacterNameUnknown]: "Unknown",
        [a.default.MenuLoadGameButtonNewGame]: "New Game",
        [a.default.MenuLoadGameButtonNewGameButtonImportTooltip]: "Import Save",
        [a.default.MenuLoadGameDescription]: "Continue a past game, or create a new game.",
        [a.default.MenuLoadGameSaveButtonDeleteTooltip]: "Delete Save",
        [a.default.MenuLoadGameSaveButtonEditNameTooltip]: "Edit Name",
        [a.default.MenuLoadGameSaveButtonExportTooltip]: "Export Save",
        [a.default.MenuLoadGameSaveTooltipLabelCreatedTime]: "{#--text-color-faded:Created Time:} {0}",
        [a.default.MenuLoadGameSaveTooltipLabelSaveTime]: "{#--text-color-faded:Save Time:} {0}",
        [a.default.MenuLoadGameSaveTooltipLabelDifficulty]: "{#--text-color-faded:Difficulty:} {0}",
        [a.default.MenuLoadGameSaveTooltipLabelScore]: "{#--text-color-faded:Score:} {0}",
        [a.default.MenuLoadGameSaveTooltipLabelSeed]: "{#--text-color-faded:Seed:} {0}",
        [a.default.MenuLoadGameSaveTooltipLabelTurns]: "{#--text-color-faded:Turns:} {0}",
        [a.default.MenuLoadGameSaveTooltipLabelMods]: "{#--text-color-faded:Mods:} {0}",
        [a.default.MenuLoadGameSaveTooltipLabelOriginalVersion]: "{#--text-color-faded:Original Version:} {0}",
        [a.default.MenuLoadGameSaveTooltipMod]: "{#--{1}:{0}}",
        [a.default.MenuLoadGameSlotsRemaining]: "Slots remaining: {0}",
        [a.default.MenuLoadGameTitle]: "Load Game",
        [a.default.MenuLoadGameInterruptDeleteSave]: "Are you sure you want to\ndelete the save '{0}'?",
        [a.default.MenuLoadGameInterruptDeleteSaveDescription]: "",
        [a.default.MenuLoadGameInterruptLoadingExportingSave]: "Exporting Save",
        [a.default.MenuLoadGameInterruptLoadingExportingSaveDescription]: "",
        [a.default.MenuLoadGameInterruptLoadingImportingSave]: "Importing Save",
        [a.default.MenuLoadGameInterruptLoadingImportingSaveDescription]: "",
        [a.default.MenuLoadGameInterruptImportSaveFailure]: "Unable to Import Save",
        [a.default.MenuLoadGameInterruptImportSaveFailureDescription]: "",
        [a.default.MenuLoadGameInterruptExportType]: "How would you like to export this save?",
        [a.default.MenuLoadGameInterruptExportTypeDescription]: "",
        [a.default.MenuLoadGameInterruptPublishingSave]: "Publishing Save",
        [a.default.MenuLoadGameInterruptPublishingSaveDescription]: "",
        [a.default.MenuLoadGameInterruptMissingMod]: "Are you sure you want to load this save?\nMod(s) are missing. This may cause bugs.",
        [a.default.MenuLoadGameInterruptMissingModDescription]: "{0}\n{1}",
        [a.default.MenuLoadGameInterruptMissingModDescriptionLabelModsMissing]: "Missing Mods: {0}",
        [a.default.MenuLoadGameInterruptMissingModDescriptionLabelModsDisabled]: "Disabled Mods: {0}",
        [a.default.MenuLoadGameInterruptLoading]: "Loading Saves",
        [a.default.MenuLoadGameInterruptLoadingDescription]: "",
        [a.default.MenuMainButtonAbout]: "About",
        [a.default.MenuMainButtonChangelog]: "Changelog",
        [a.default.MenuMainButtonContinueGame]: "Continue Game",
        [a.default.MenuMainButtonMultiplayer]: "Multiplayer",
        [a.default.MenuMainButtonHighscores]: "Highscores",
        [a.default.MenuMainButtonLoadGame]: "Load Game",
        [a.default.MenuMainButtonMods]: "Mods",
        [a.default.MenuMainButtonNewGame]: "New Game",
        [a.default.MenuMainButtonNews]: "News",
        [a.default.MenuMainButtonOptions]: "Options",
        [a.default.MenuMainButtonQuitGame]: "Quit Game",
        [a.default.MenuMainInterruptLoadingNews]: "Loading News",
        [a.default.MenuMainInterruptLoadingNewsDescription]: "",
        [a.default.MenuMainInterruptLoadingChangelog]: "Loading Changelog",
        [a.default.MenuMainInterruptLoadingChangelogDescription]: "",
        [a.default.MenuMainInterruptWelcomeToVersion]: "Welcome to Wayward {0}!",
        [a.default.MenuMainInterruptWelcomeToVersionDescription]: "Please visit the News menu to see what's new.\nAll mods have been disabled by default.",
        [a.default.MenuMainInterruptOldVersionWarning]: "You've loaded an older version\nof the game!",
        [a.default.MenuMainInterruptOldVersionWarningDescription]: "You previously played {0}. You're now playing {1}.\nUnintended side effects may occur, such as losing all save data.\nIt is highly recommended you backup the Wayward save folder before continuing.",
        [a.default.MenuModsButtonDisableAll]: "Disable All",
        [a.default.MenuModsButtonEnableAll]: "Enable All",
        [a.default.MenuModsButtonModdingGuide]: "Modding Guide",
        [a.default.MenuModsButtonOpenFolder]: "Open Mods Folder",
        [a.default.MenuModsButtonOpenWorkshop]: "Open Steam Workshop",
        [a.default.MenuModsDescription]: "Manage installed mods and publish your own.",
        [a.default.MenuModsSectionHeading]: "{0} Mods",
        [a.default.MenuModsInterruptConfirmPublish]: "Are you sure you want\nto publish this mod?",
        [a.default.MenuModsInterruptConfirmPublishUpdate]: "Are you sure you want to publish\nan update to this mod?",
        [a.default.MenuModsInterruptModEnableMultipleLanguages]: "This mod provides multiple languages.",
        [a.default.MenuModsInterruptModEnableMultipleLanguagesDescription]: "Would you like to go to the\noptions menu and change language?",
        [a.default.MenuModsInterruptModEnableUseLanguage]: "This mod provides a language.\nWould you like to switch to it?",
        [a.default.MenuModsInterruptModEnableUseLanguageDescription]: "",
        [a.default.MenuModsInterruptPublishedReminderRequiredModsOnWorkshop]: "Don't forget to add the required mods\non the Steam Workshop page!",
        [a.default.MenuModsInterruptInfoMissingDependencies]: "{0} can't be enabled because it is missing other required mods.",
        [a.default.MenuModsInterruptInfoMissingDependenciesDescription]: "Required mods: {0}",
        [a.default.MenuModsInterruptConfirmEnableDisabledDependencies]: "{0} can't be enabled without enabling its required mods. Would you like to enable them?",
        [a.default.MenuModsInterruptConfirmEnableDisabledDependenciesDescription]: "Required mods: {0}",
        [a.default.MenuModsInterruptConfirmDisableDependents]: "{0} can't be disabled without disabling its dependent mods. Would you like to disable them?",
        [a.default.MenuModsInterruptConfirmDisableDependentsDescription]: "Dependents: {0}",
        [a.default.MenuModsInterruptConfirmUninstallMod]: "Are you sure you want to\nuninstall {0}?",
        [a.default.MenuModsInterruptConfirmUninstallModDescription]: "",
        [a.default.MenuModsInterruptUnloadableSaveGameMod]: "Unloadable Save Game",
        [a.default.MenuModsInterruptUnloadableSaveGameModDescription]: "The save game '{0}' cannot be loaded due to being too old or incompatible with this version of Wayward.",
        [a.default.MenuModsTitle]: "Mods",
        [a.default.MenuModsTooltipLabelAuthor]: "{#--text-color-faded:Author:} {0}",
        [a.default.MenuModsTooltipLabelTags]: "{#--text-color-faded:Tags:} {0}",
        [a.default.MenuModsTooltipLabelDependencies]: "{#--text-color-faded:Dependencies:} {0}",
        [a.default.MenuModsTooltipLabelProvides]: "{#--text-color-faded:Provides:} {0}",
        [a.default.MenuModsTooltipLabelVersion]: "{#--text-color-faded:Version:} {0}",
        [a.default.MenuModsTooltipLabelDescription]: "{#--text-color-faded:Description:} {0}",
        [a.default.MenuModsTooltipLabelInstallDate]: "{#--text-color-faded:Install Date:} {0}",
        [a.default.MenuModsTooltipLabelCreatedDate]: "{#--text-color-faded:Created Date:} {0}",
        [a.default.MenuModsTooltipLabelLastUpdatedDate]: "{#--text-color-faded:Last Updated Date:} {0}",
        [a.default.MenuModsTooltipMultiplayerCompatibility]: "{0?Clientside:{1?Multiplayer Compatible:Singleplayer Only}}",
        [a.default.MenuModsTooltipModOptions]: "Mod Options",
        [a.default.MenuModsTooltipProvidesCustomizations]: "Customizations",
        [a.default.MenuModsTooltipProvidesImageOverrides]: "Retextures",
        [a.default.MenuModsTooltipProvidesLanguage]: "Language",
        [a.default.MenuModsTooltipProvidesLanguageExtensions]: "Language Extensions",
        [a.default.MenuModsTooltipProvidesScript]: "Scripts",
        [a.default.MenuModsTooltipProvidesStylesheet]: "Restyles",
        [a.default.MenuModsTooltipPublishMod]: "Publish Mod",
        [a.default.MenuModsTooltipUninstallMod]: "Uninstall Mod",
        [a.default.MenuModsTooltipViewInSteamWorkshop]: "View Steam Workshop Page",
        [a.default.MenuModsInterruptPublishedReminderRequiredModsOnWorkshopDescription]: "",
        [a.default.MenuModsInterruptConfirmPublishDescription]: "",
        [a.default.MenuModsInterruptConfirmPublishUpdateDescription]: "",
        [a.default.MenuModsInterruptPublishingMod]: "Publishing Mod",
        [a.default.MenuModsInterruptPublishingModDescription]: "",
        [a.default.MenuModsInterruptPublishError]: "Could Not Publish Mod",
        [a.default.MenuModsInterruptPublishErrorDescription]: "Error: {0}",
        [a.default.MenuModsInterruptUpdatingMod]: "Publishing Mod Update",
        [a.default.MenuModsInterruptUpdatingModDescription]: "",
        [a.default.MenuModsInterruptPublishUpdateError]: "Could Not Publish Mod Update",
        [a.default.MenuModsInterruptPublishUpdateErrorDescription]: "Error: {0}",
        [a.default.MenuModsButtonEditInternalMods]: "Edit Internal Mods",
        [a.default.MenuModsSubmenuEditInternalModsTitle]: "Edit Internal Mods",
        [a.default.MenuModsSubmenuEditInternalModsDescription]: "Edit the list of internal mods.",
        [a.default.MenuModsSubmenuEditInternalModsInterruptModsListChangeReload]: "Reload the game?",
        [a.default.MenuModsSubmenuEditInternalModsInterruptModsListChangeReloadDescription]: "Changing the internal mods list requires a reload.",
        [a.default.MenuModsSubmenuEditInternalModsPlaceholderAddNewInternalMod]: "Add New Internal Mod",
        [a.default.MenuNewGameButtonNext]: "Next",
        [a.default.MenuNewGameButtonStartServer]: "Start Server",
        [a.default.MenuNewGameDescription]: "Create a new world with your choice of settings.",
        [a.default.MenuNewGameLabelEditName]: "Name",
        [a.default.MenuNewGameLabelEditSeed]: "Seed",
        [a.default.MenuNewGamePlaceholderEditSeed]: "Random",
        [a.default.MenuNewGameTitle]: "New Game",
        [a.default.MenuNewGameChoiceDifficulty]: "{0} Mode",
        [a.default.MenuNewGameChoiceSingleplayer]: "Singleplayer",
        [a.default.MenuNewGameChoiceSingleplayerDescription]: "Survive on your own.",
        [a.default.MenuNewGameChoiceMultiplayer]: "Multiplayer",
        [a.default.MenuNewGameChoiceMultiplayerDescription]: "Allow friends to join your world. Limited to real-time turns mode.",
        [a.default.MenuNewGameChoiceTurnModeManual]: "Manual Turns",
        [a.default.MenuNewGameChoiceTurnModeManualDescription]: 'Turns only pass as players perform actions (also known as "turn-based").',
        [a.default.MenuNewGameChoiceTurnModeSimulated]: "Simulated Turns",
        [a.default.MenuNewGameChoiceTurnModeSimulatedDescription]: "Turns happen automatically as long as player(s) are performing actions.",
        [a.default.MenuNewGameChoiceTurnModeRealTime]: "Real-time Turns",
        [a.default.MenuNewGameChoiceTurnModeRealTimeDescription]: "Turns happen automatically as time passes.",
        [a.default.MenuNewGameChoiceDifficultyTooltipMaxSaves]: "You have used all {0} save slots. As Challenge requires no save slot, it is the only difficulty you may choose.",
        [a.default.MenuNewGameChoiceDifficultyTooltipCustomGameOptions]: "Customize",
        [a.default.MenuNewGameChoiceDifficultyChallengeDaily]: "Daily",
        [a.default.MenuNewGameChoiceDifficultyChallengeDailyTooltip]: "A randomized challenge every day, that everyone around the world will have the chance to play!",
        [a.default.MenuCustomGameOptionsTitle]: "Custom Game Options",
        [a.default.MenuCustomGameOptionsDescription]: "Customize how the game will play.",
        [a.default.MenuCustomGameOptionsPeaceful]: "Peaceful",
        [a.default.MenuCustomGameOptionsPeacefulDescription]: "Creatures will only attack when provoked.",
        [a.default.MenuCustomGameOptionsRespawnOnDeath]: "Respawn On Death",
        [a.default.MenuCustomGameOptionsRespawnOnDeathDescription]: "Players will respawn when they die.",
        [a.default.MenuCustomGameOptionsBenignityInitial]: "Initial Benignity",
        [a.default.MenuCustomGameOptionsBenignityMultiplier]: "Benignity Multiplier",
        [a.default.MenuCustomGameOptionsBenignityMultiplierTooltip]: "Scales the benignity gained from actions.",
        [a.default.MenuCustomGameOptionsMalignityInitial]: "Initial Malignity",
        [a.default.MenuCustomGameOptionsMalignityMultiplier]: "Malignity Multiplier",
        [a.default.MenuCustomGameOptionsMalignityMultiplierTooltip]: "Scales the malignity gained from actions.",
        [a.default.MenuCustomGameOptionsStatMultiplier]: "Multiplier",
        [a.default.MenuCustomGameOptionsStatMultiplierTooltip]: "Scales the {0} rate.",
        [a.default.MenuCustomGameOptionsStatRegenerationMultiplierTooltip]: "Scales the rate of {0} regeneration.",
        [a.default.MenuCustomGameOptionsHeadingGeneral]: "General",
        [a.default.MenuCustomGameOptionsHeadingTime]: "Time",
        [a.default.MenuCustomGameOptionsHeadingStats]: "Stats",
        [a.default.MenuCustomGameOptionsHeadingReputation]: "Reputation",
        [a.default.MenuCustomGameOptionsHeadingInventory]: "Inventory",
        [a.default.MenuCustomGameOptionsHeadingSkills]: "Skills",
        [a.default.MenuCustomGameOptionsHeadingStatusEffects]: "Effects",
        [a.default.MenuCustomGameOptionsEternalNight]: "Eternal Night",
        [a.default.MenuCustomGameOptionsTimeFrozen]: "Time Never Passes",
        [a.default.MenuCustomGameOptionsTimeInitial]: "Initial Time",
        [a.default.MenuCustomGameOptionsTimeDayLength]: "Day Length",
        [a.default.MenuCustomGameOptionsTimeDayLengthTooltip]: "The number of turns/ticks in a day.",
        [a.default.MenuCustomGameOptionsTimeDayPercent]: "Day Percent",
        [a.default.MenuCustomGameOptionsTimeDayPercentTooltip]: 'A number representing how much of the day is "daytime" and, inversely, how much of the day is //not// "night time".',
        [a.default.MenuCustomGameOptionsEternalNightDescription]: "The moon will never set; the sun will never rise.",
        [a.default.MenuCustomGameOptionsStatStarting]: "Initial",
        [a.default.MenuCustomGameOptionsStatMax]: "Max",
        [a.default.MenuCustomGameOptionsStatNoChange]: "Stationary",
        [a.default.MenuCustomGameOptionsStatStartingDisplay]: "{1?{0}%:Random}",
        [a.default.MenuCustomGameOptionsStatMaxDisplay]: "{1?{0}:Random}",
        [a.default.MenuCustomGameOptionsStatStrengthTooltip]: "Affects max health and max weight.",
        [a.default.MenuCustomGameOptionsStatusEffectPassChanceMultiplier]: "Pass Multiplier",
        [a.default.MenuCustomGameOptionsStatusEffectPassChanceMultiplierTooltip]: "When {0}, scales the chance of the negative effect passing.",
        [a.default.MenuCustomGameOptionsStatusEffectStartWith]: "{0} Initially",
        [a.default.MenuCustomGameOptionsStatusEffectUntreatable]: "Untreatable",
        [a.default.MenuCustomGameOptionsStatusEffectUntreatableTooltip]: "Whether this status effect is untreatable - if checked, the effect must pass naturally.",
        [a.default.MenuCustomGameOptionsSkillsGenerateRandom]: "Generate Random Starting Skill",
        [a.default.MenuCustomGameOptionsSkillsGenerateRandomDescription]: "The random starting skill may be overwritten by custom starting skills.",
        [a.default.MenuCustomGameOptionsSkillNone]: "None",
        [a.default.MenuCustomGameOptionsSkillConfigure]: "Add",
        [a.default.MenuCustomGameOptionsSkillInitial]: "Initial",
        [a.default.MenuCustomGameOptionsSkillMultiplier]: "Gain Multiplier",
        [a.default.MenuCustomGameOptionsSkillMultiplierTooltip]: "Scales the rate at which this skill is gained.",
        [a.default.MenuCustomGameOptionsRandomItems]: "Generate Random Starting Items",
        [a.default.MenuCustomGameOptionsRandomItemsDescription]: "If disabled, players will spawn in the world without starting items.",
        [a.default.MenuNewsButtonDiscord]: "Discord",
        [a.default.MenuNewsButtonFacebook]: "Facebook",
        [a.default.MenuNewsButtonReddit]: "Reddit",
        [a.default.MenuNewsButtonTwitter]: "Twitter",
        [a.default.MenuNewsDescription]: "Find information pertaining to the game and its updates.",
        [a.default.MenuNewsHeadingSocial]: "Join Our Community:",
        [a.default.MenuNewsTitle]: "News",
        [a.default.MenuNewsHeadingUnableToLoad]: "Unable to Load News",
        [a.default.MenuNewsButtonAllNews]: "See All News on Steam",
        [a.default.MenuOptionsDeveloperLogSourceFilterHeading]: "Console Log Filtering",
        [a.default.MenuOptionsInterruptLoading]: "Loading Options",
        [a.default.MenuOptionsInterruptLoadingDescription]: "",
        [a.default.MenuOptionsButtonDitherFogOfWar]: "Dither Style Fog of War",
        [a.default.MenuOptionsButtonFullscreen]: "Fullscreen",
        [a.default.MenuOptionsButtonPixelFont]: "Pixel Font",
        [a.default.MenuOptionsButtonDisableCustomCursor]: "Disable Custom Cursor",
        [a.default.MenuOptionsButtonDeveloperMode]: "Developer Mode",
        [a.default.MenuOptionsButtonDeveloperModeContextMenu]: "Context Menu",
        [a.default.MenuOptionsButtonReloadGame]: "Reload Game",
        [a.default.MenuOptionsButtonExportGlobalSaveData]: "Export Non-world Save Data",
        [a.default.MenuOptionsButtonImportGlobalSaveData]: "Import Non-world Save Data",
        [a.default.MenuOptionsButtonSaveDataClearAll]: "Remove All Save Data",
        [a.default.MenuOptionsButtonSaveDataClearHighscores]: "Remove Highscores",
        [a.default.MenuOptionsButtonSaveDataClearMilestones]: "Reset Milestone Progress",
        [a.default.MenuOptionsButtonSaveDataClearOptions]: "Reset All Options to Defaults",
        [a.default.MenuOptionsButtonSaveDataClearCraftingRecipes]: "Reset Unlocked Crafting Recipes",
        [a.default.MenuOptionsButtonSaveDataClearSaves]: "Remove Saved Games",
        [a.default.MenuOptionsButtonSkipSplash]: "Skip Splash Screen",
        [a.default.MenuOptionsButtonToggleDevTools]: "Toggle Developer Tools",
        [a.default.MenuOptionsButtonTooltipsCreatures]: "Creatures",
        [a.default.MenuOptionsButtonTooltipsDoodads]: "Doodads",
        [a.default.MenuOptionsButtonTooltipsItems]: "Items",
        [a.default.MenuOptionsButtonTooltipsTerrain]: "Terrain",
        [a.default.MenuOptionsButtonOpenLogsFolder]: "Open Logs Folder",
        [a.default.MenuOptionsDescription]: "Change your game settings.",
        [a.default.MenuOptionsHeadingAudio]: "Audio",
        [a.default.MenuOptionsHeadingDeveloper]: "Developer Options",
        [a.default.MenuOptionsHeadingGameplayOptions]: "Gameplay Options",
        [a.default.MenuOptionsHeadingGeneralOptions]: "General",
        [a.default.MenuOptionsHeadingControls]: "Controls",
        [a.default.MenuOptionsHeadingLanguage]: "Language",
        [a.default.MenuOptionsHeadingPowerPreference]: "Power Mode",
        [a.default.MenuOptionsHeadingModOptions]: "Mod Options",
        [a.default.MenuOptionsHeadingOther]: "Other Options",
        [a.default.MenuOptionsHeadingSaveData]: "Save Data",
        [a.default.MenuOptionsHeadingTooltips]: "Tooltips",
        [a.default.MenuOptionsHeadingVideo]: "Video",
        [a.default.MenuOptionsInterruptReloadGame]: "Are you sure you want\nto reload the game?",
        [a.default.MenuOptionsInterruptSaveDataClearAll]: "Are you sure you want\nto clear all save data?",
        [a.default.MenuOptionsInterruptSaveDataClearAllDescription]: "This includes options, game saves, and milestone progress.",
        [a.default.MenuOptionsInterruptSaveDataClearHighscores]: "Are you sure you want to\nremove your highscores?",
        [a.default.MenuOptionsInterruptSaveDataClearMilestones]: "Are you sure you want to\nreset your milestone progress?",
        [a.default.MenuOptionsInterruptSaveDataClearOptions]: "Are you sure you want to\nreset all of your options?",
        [a.default.MenuOptionsInterruptSaveDataClearSaves]: "Are you sure you want to\ndelete all of your game saves?",
        [a.default.MenuOptionsInterruptSaveDataClearCraftingRecipes]: "Are you sure you want to reset\nyour unlocked crafting recipes?",
        [a.default.MenuOptionsLabelInterfaceScale]: "Interface Scale",
        [a.default.MenuOptionsLabelDirectionTurnDelay]: "Turn Delay",
        [a.default.MenuOptionsLabelMouseTurnDelay]: "Mouse Turn Delay",
        [a.default.MenuOptionsLabelVolumeEffects]: "Effects",
        [a.default.MenuOptionsLabelVolumeMusic]: "Music",
        [a.default.MenuOptionsTabAudio]: "Audio",
        [a.default.MenuOptionsTabDeveloper]: "Developer",
        [a.default.MenuOptionsTabGameplay]: "Gameplay",
        [a.default.MenuOptionsTabGeneral]: "General",
        [a.default.MenuOptionsTabControls]: "Controls",
        [a.default.MenuOptionsTabMods]: "Mod Options",
        [a.default.MenuOptionsTabSaveData]: "Save Data",
        [a.default.MenuOptionsTabVideo]: "Video",
        [a.default.MenuOptionsTitle]: "Options",
        [a.default.MenuOptionsTooltipMusicNextTrack]: "Next Track",
        [a.default.MenuOptionsInterruptSaveDataClearCharacters]: "Are you sure you want to\ndelete all of your previous characters?",
        [a.default.MenuOptionsButtonSaveDataClearCharacters]: "Remove Saved Characters",
        [a.default.MenuOptionsBindChoose]: "Press anything to choose the bind.",
        [a.default.MenuOptionsBindChooseAdd]: "Press anything to choose the secondary bind.",
        [a.default.MenuOptionsBindLabelModifier]: "{0} + ",
        [a.default.MenuOptionsBindButtonResetTooltip]: "Reset to Default",
        [a.default.MenuOptionsBindButtonDeleteTooltip]: "Remove Binding",
        [a.default.MenuOptionsBindButtonAddTooltip]: "Add Secondary Binding",
        [a.default.MenuOptionsButtonAlternatingDirectionMovement]: "Alternating Direction Movement",
        [a.default.MenuOptionsButtonAllowAlternatingDirectionMovementTooltip]: "If checked, you will move in alternating directions when two directions are pressed or diagonal angles are used with the mouse.",
        [a.default.MenuOptionsButtonAlwaysShowMoreInformation]: "Always Show More Information",
        [a.default.MenuOptionsButtonAutoGatherHarvest]: "Auto Gather/Harvest",
        [a.default.MenuOptionsButtonAutoGatherHarvestTooltip]: "If checked, you will automatically gather/harvest when moving into resource tiles (with whichever hand(s) you have selected).",
        [a.default.MenuOptionsButtonAutoPickup]: "Auto Pick-up",
        [a.default.MenuOptionsButtonAutoPickupTooltip]: "If checked, you will automatically pick-up items as you move on top of them.",
        [a.default.MenuOptionsButtonDropOnGatherHarvest]: "Drop on Gather/Harvest",
        [a.default.MenuOptionsButtonDropOnGatherHarvestTooltip]: "If checked, you will automatically drop items under your character as you gather/harvest them.",
        [a.default.MenuOptionsButtonDropLocationFacing]: "Drop Items on Facing Tile",
        [a.default.MenuOptionsButtonDropLocationFeet]: "Drop Items at Feet",
        [a.default.MenuOptionsButtonDropLocationFeetWhenFacingBlocked]: "Drop Items at Feet When Facing Tile is Blocked",
        [a.default.MenuOptionsButtonKeepSortActive]: "Keep Sort Active",
        [a.default.MenuOptionsButtonKeepSortActiveTooltip]: "If checked, your inventory will keep sorting automatically as you get items.",
        [a.default.MenuOptionsButtonProtectCraftingItemsInInventory]: "Protect Crafting Items",
        [a.default.MenuOptionsButtonProtectCraftingItemsInInventoryTooltip]: "If checked, equipped and quickslotted items won't be used in crafting.",
        [a.default.MenuOptionsButtonProtectCraftingItemContainers]: "Protect Crafting Items for Containers",
        [a.default.MenuOptionsButtonProtectCraftingItemsContainersTooltip]: "If checked items inside equipped and quickslotted containers won't be used in crafting.",
        [a.default.MenuOptionsButtonUseAdjacentContainers]: "Use Adjacent Containers/Items",
        [a.default.MenuOptionsButtonUseAdjacentContainersTooltip]: "If checked, items in adjacent containers or tiles can be used in crafting and other actions.",
        [a.default.MenuOptionsButtonHideEquippedHeadgear]: "Hide Equipped Headgear",
        [a.default.MenuOptionsButtonHideEquippedHeadgearTooltip]: "If checked, equipped headgear on your character will not be visible to you.",
        [a.default.MenuOptionsButtonEnableAutoSave]: "Enable Auto Save",
        [a.default.MenuOptionsButtonEnableAutoSaveTooltip]: "If checked, your game will periodically be saved to help avoid data loss.",
        [a.default.MenuOptionsButtonWarnOnDangerousActions]: "Warn on Dangerous Actions",
        [a.default.MenuOptionsButtonWarnOnDangerousActionsTooltip]: "If checked, a confirmation screen will display when stepping over doodads or objects that could injure you.",
        [a.default.MenuOptionsButtonWarnWhenBreakingItemsOnCraft]: "On Craft/Dismantle",
        [a.default.MenuOptionsButtonWarnWhenBreakingItemsOnCraftTooltip]: "If checked, a confirmation screen will display when trying to craft/dismantle using items that will break on use or failure.",
        [a.default.MenuOptionsButtonWarnWhenBreakingItemsOnUse]: "On Use",
        [a.default.MenuOptionsButtonWarnWhenBreakingItemsOnUseTooltip]: "If checked, a confirmation screen will display when trying to use damaged items that may break on use.",
        [a.default.MenuOptionsHeadingWarnWhenBreakingItems]: "Warn when Breaking Items",
        [a.default.MenuOptionsTooltipTurnDelay]: "The amount of movement delay that occurs after switching a direction or turning.",
        [a.default.MenuOptionsTooltipMouseTurnDelay]: "The amount of movement delay that occurs after switching a direction or turning when using your mouse.",
        [a.default.MenuOptionsTooltipUiScaleClamped]: "Currently clamped to {#--text-color-faded:{0}} by the viewport resolution.",
        [a.default.MenuOptionsTooltipControlsFilter]: "Filter the game's bindable actions. You can do multiple selections at once with a comma {#--text-color-faded:({#--text-color-bind:,})} and invert a selection by prefixing it with an exclamation point {#--text-color-faded:({#--text-color-bind:!})}",
        [a.default.MenuOptionsButtonAlwaysShowMoreInformationTooltip]: "If checked, you will never have to hold down a key to show more information in tooltips.",
        [a.default.MenuOptionsButtonSaveDataClearBindings]: "Reset All Bindings",
        [a.default.MenuOptionsInterruptSaveDataClearBindings]: "Are you sure you want to\nreset all bindings to defaults?",
        [a.default.MenuOptionsTooltipDialogOpacity]: "Controls how opaque the in-game dialogs are.",
        [a.default.MenuOptionsLabelDialogOpacity]: "Dialog Opacity",
        [a.default.MenuOptionsInterruptConfirmImportGlobalData]: "Are you sure you want to replace\nyour non-world save data?",
        [a.default.MenuOptionsInterruptConfirmImportGlobalDataDescription]: "This will delete your existing options, highscores, milestones,\nmod states, characters, and unlocked crafting recipes.",
        [a.default.MenuOptionsInterruptLoadingImportingGlobalData]: "Replacing non-world save data...",
        [a.default.MenuOptionsInterruptLoadingImportingGlobalDataDescription]: "",
        [a.default.MenuOptionsAudioVolumeDisplay]: "{1?{0}%:Muted}",
        [a.default.MenuOptionsMusicPlaylist]: "Playlist",
        [a.default.MenuOptionsButtonConfigureBindings]: "Configure Bindings",
        [a.default.MenuPauseButtonContinue]: "Continue Game",
        [a.default.MenuPauseButtonOptions]: "Options",
        [a.default.MenuPauseButtonModes]: "Modes",
        [a.default.MenuPauseButtonPaused]: "Paused",
        [a.default.MenuPauseButtonMultiplayer]: "Multiplayer",
        [a.default.MenuPauseButtonTitleScreen]: "Return to Title Screen",
        [a.default.MenuPauseButtonStopServer]: "Stop Server",
        [a.default.MenuPauseHeadingPaused]: "The Game Is Paused",
        [a.default.MenuPauseParagraphPaused]: "",
        [a.default.MenuPauseHeadingNotPaused]: "The Game Is Not Paused!",
        [a.default.MenuPauseParagraphNotPaused]: "In multiplayer, the game does not pause unless the host has paused it.",
        [a.default.MenuPauseHeadingDedicatedServer]: "Dedicated Server",
        [a.default.MenuPauseParagraphDedicatedServer]: "The server is up and running.",
        [a.default.MenuPauseInterruptGhostKeepSave]: "You are dead.\nDo you want to keep this save?",
        [a.default.MenuPauseInterruptGhostKeepSaveDescription]: "Your highscore and unlocks are saved.",
        [a.default.MenuPauseInterruptReturnToTitleScreen]: "Are you sure you want to\nreturn to the title screen?",
        [a.default.MenuPauseInterruptReturnToTitleScreenDescription]: "Your progress will be saved automatically.",
        [a.default.MenuPauseInterruptReturnToTitleScreenChallengeDescription]: "{#--message-type-bad:Your progress is not saved in Challenge Mode!}",
        [a.default.MenuPauseInterruptReturnToTitleScreenChallengeMultiplayerDescription]: "{#--message-type-bad:{0?There are players connected.\n}Your progress is not saved in Challenge Mode!}",
        [a.default.MenuPauseInterruptReturnToTitleScreenMultiplayerDescription]: "{0?{#--message-type-bad:There are players connected.}{1?:\n}}{1?:Your progress will be saved automatically.}",
        [a.default.MenuModesTitle]: "Modes",
        [a.default.MenuModesDescription]: "Configure game mode settings.",
        [a.default.MenuMultiplayerOptionsTitle]: "Multiplayer",
        [a.default.MenuMultiplayerOptionsDescription]: "Configure multiplayer settings.",
        [a.default.MenuMultiplayerOptionsOpenServer]: "Open Server",
        [a.default.MenuMultiplayerOptionsOpenServerDescription]: "Allow players to join your game.",
        [a.default.MenuMultiplayerOptionsCopyGameCode]: "Copy Game Code",
        [a.default.MenuMultiplayerOptionsCopyGameCodeTooltip]: "Copy the game code to your clipboard. Share it with your friends to play together!",
        [a.default.MenuMultiplayerOptionsInviteSteamFriends]: "Invite Steam Friends",
        [a.default.MenuJoinServerTitle]: "Join a Server",
        [a.default.MenuJoinServerDescription]: "Join a multiplayer server.",
        [a.default.MenuJoinServerInputPlaceholder]: "Game Code, IP Address, or Hostname",
        [a.default.MenuJoinServerNext]: "Next",
        [a.default.MenuSharedMultiplayerChoiceLobbyTypeFriends]: "Open to Friends",
        [a.default.MenuSharedMultiplayerChoiceLobbyTypeFriendsDescription]: "Anyone may be invited to the server, and the game will be visible and joinable to your friends.",
        [a.default.MenuSharedMultiplayerChoiceLobbyTypePublic]: "Open to Anyone",
        [a.default.MenuSharedMultiplayerChoiceLobbyTypePublicDescription]: "The game will be visible and joinable for anyone.",
        [a.default.MenuSharedMultiplayerChoiceLobbyTypePrivate]: "Private",
        [a.default.MenuSharedMultiplayerChoiceLobbyTypePrivateDescription]: "The only way for players to join the game is to be invited.",
        [a.default.MenuSharedMultiplayerChoicePVP]: "PVP",
        [a.default.MenuSharedMultiplayerChoicePVPDescription]: "Allow players to attack each other.",
        [a.default.MenuSharedMultiplayerMaxPlayers]: "Max Players",
        [a.default.MenuSharedRealTimeTickSpeedTooltip]: "The time it takes for a tick to occur in real-time mode.",
        [a.default.MenuSharedRealTimeTickSpeedLabel]: "Tick Time",
        [a.default.MenuSharedButtonDefault]: "Default",
        [a.default.MenuSharedValueTickSpeed]: "{0}ms",
        [a.default.MenuSharedValuePercentage]: "{0}%",
        [a.default.MiscSortBy]: "Sort By",
        [a.default.MiscSortDirection]: "Sort Direction",
        [a.default.MiscFilter]: "Filter",
        [a.default.MiscPlayerNameDefault]: "Player",
        [a.default.MiscPlayerNameServer]: "Server",
        [a.default.MiscSaveNameDefault]: "Untitled Save {0}",
        [a.default.MiscSaveVersionUnknown]: "Unknown",
        [a.default.MiscSaveNameDailyChallenge]: "Daily Challenge {0}",
        [a.default.MiscSaveNameChallenge]: "Challenge Game",
        [a.default.MiscVersion]: "{0?Beta:Release} {1}.{2}.{3}",
        [a.default.MiscBindableOr]: "{0} OR ",
        [a.default.MiscBindableNoBindings]: "No Bindings",
        [a.default.MiscTime]: "{0}{2?::{1}}{3?{3}}",
        [a.default.MiscTimeMeridiem]: " {0?AM:PM}",
        [a.default.SteamworksInterruptURLOpenedInBrowser]: "The URL has been opened in your default web browser.",
        [a.default.SteamworksInterruptURLOpenedInBrowserDescription]: "",
        [a.default.SteamworksInterruptWorkshopOpenedInBrowser]: "The Steam Workshop has been opened in a browser.",
        [a.default.SteamworksInterruptWorkshopOpenedInBrowserDescription]: "Press OK after you're done viewing the Workshop.",
        [a.default.SteamworksInterruptModWithNameAlreadyExists]: "A mod with that name already exists. Try changing the name of the slot.",
        [a.default.SteamworksInterruptModWithNameAlreadyExistsDescription]: "",
        [a.default.SteamworksInterruptModImportSaveGameFailure]: "Failed to import the save game from the mod '{0}'.",
        [a.default.SteamworksInterruptModImportSaveGameFailureDescription]: "",
        [a.default.SteamworksInterruptModImportedSaveGame]: "The mod '{0}' has imported a saved game.",
        [a.default.SteamworksInterruptModImportedSaveGameDescription]: "",
        [a.default.SteamworksInterruptLoadingRefreshingMods]: "Refreshing Mods",
        [a.default.SteamworksInterruptLoadingRefreshingModsDescription]: "",
        [a.default.SteamworksInterruptOpenFolderFailure]: "Failed to open the folder.",
        [a.default.SteamworksInterruptOpenFolderFailureDescription]: "Please navigate to the folder manually.",
        [a.default.DifficultyOptionsPeaceful]: "Peaceful",
        [a.default.DifficultyOptionsRespawn]: "Respawn on Death",
        [a.default.DifficultyOptionsEternalNight]: "Eternal Night",
        [a.default.DifficultyOptionsTimeInitial]: "{#--text-color-faded:Initial Time:} {0}",
        [a.default.DifficultyOptionsTimeFrozen]: "Time Never Passes",
        [a.default.DifficultyOptionsTimeDayLength]: "{#--text-color-faded:Day Length:} {0}",
        [a.default.DifficultyOptionsTimeDayPercent]: "{0}% Day, {1}% Night",
        [a.default.DifficultyOptionsNoItems]: "No Starting Items",
        [a.default.DifficultyOptionsBenignityInitial]: "{#--text-color-faded:Initial Benignity:} {0}",
        [a.default.DifficultyOptionsBenignityMultiplier]: "{#--text-color-faded:Benignity Multiplier:} {num(2):{0}}",
        [a.default.DifficultyOptionsMalignityInitial]: "{#--text-color-faded:Initial Malignity:} {0}",
        [a.default.DifficultyOptionsMalignityMultiplier]: "{#--text-color-faded:Malignity Multiplier:} {num(2):{0}}",
        [a.default.DifficultyOptionsStatInitial]: "{#--text-color-faded:Initial {0}:} {1}%",
        [a.default.DifficultyOptionsStatMax]: "{#--text-color-faded:Max {0}:} {1}",
        [a.default.DifficultyOptionsStatMultiplier]: "{#--text-color-faded:{0} Regen/Loss Multiplier:} {num(2):{1}}",
        [a.default.DifficultyOptionsStatusEffectStartWith]: "{0} Initially",
        [a.default.DifficultyOptionsStatusEffectUntreatable]: "Untreatable {0}",
        [a.default.DifficultyOptionsStatusEffectPassChanceMultiplier]: "{#--text-color-faded:{0} Pass Chance Multiplier:} {num(2):{1}}",
        [a.default.DifficultyOptionsNoRandomSkills]: "No Randomly Generated Skills",
        [a.default.DifficultyOptionsSkillGainMultiplier]: "{#--text-color-faded:{0} Skill Gain Multiplier:} {num(2):{1}}",
        [a.default.DifficultyOptionsSkillInitial]: "{#--text-color-faded:Initial {0} Skill:} {1}",
        [a.default.DifficultyOptionsStatusEffectPermanent]: "Permanently {0}",
        [a.default.DifficultyOptionsStatusEffectRateMultiplier]: "{#--text-color-faded:{0} Rate Multiplier:} {num(2):{1}}",
        [a.default.DifficultyOptionsStatusEffectMultiplier]: "{#--text-color-faded:{0} Damage Multiplier:} {num(2):{1}}",
        [a.default.EquipmentBack]: "Back",
        [a.default.EquipmentBelt]: "Belt",
        [a.default.EquipmentChest]: "Chest",
        [a.default.EquipmentFeet]: "Feet",
        [a.default.EquipmentHands]: "Hands",
        [a.default.EquipmentHead]: "Head",
        [a.default.EquipmentLeftHand]: "Left Hand (Held)",
        [a.default.EquipmentLeftHandOption]: "Left Hand",
        [a.default.EquipmentLegs]: "Legs",
        [a.default.EquipmentNeck]: "Neck",
        [a.default.EquipmentRightHand]: "Right Hand (Held)",
        [a.default.EquipmentRightHandOption]: "Right Hand",
        [a.default.EquipmentUse]: "Use",
        [a.default.HudFilter]: "Filter",
        [a.default.QuickSlot1]: "1",
        [a.default.QuickSlot2]: "2",
        [a.default.QuickSlot3]: "3",
        [a.default.QuickSlot4]: "4",
        [a.default.QuickSlot5]: "5",
        [a.default.QuickSlot6]: "6",
        [a.default.QuickSlot7]: "7",
        [a.default.QuickSlot8]: "8",
        [a.default.QuickSlot9]: "9",
        [a.default.TabCrafting]: "Crafting",
        [a.default.TabDismantle]: "Dismantle",
        [a.default.Version]: "Wayward {0}",
        [a.default.WindowTitleContainer]: "Container",
        [a.default.WindowTitleCrafting]: "Crafting",
        [a.default.WindowTitleEquipment]: "Equipment",
        [a.default.WindowTitleInventory]: "Inventory"
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/English", ["require", "exports", "language/Dictionaries", "language/english/creature/Corpses", "language/english/creature/Creatures", "language/english/DamageTypes", "language/english/doodad/DoodadGroups", "language/english/doodad/DoodadItems", "language/english/doodad/Doodads", "language/english/doodad/Growth", "language/english/doodad/GrowthFungus", "language/english/game/Actions", "language/english/game/Difficulties", "language/english/game/Messages", "language/english/game/PartsOfDay", "language/english/item/Books", "language/english/item/ItemGroups", "language/english/item/ItemQualities", "language/english/item/Items", "language/english/item/LegendaryItems", "language/english/misc/Commands", "language/english/misc/InspectTypes", "language/english/misc/MiscTranslations", "language/english/misc/ModTypes", "language/english/misc/Numbers", "language/english/misc/Sources", "language/english/player/Milestones", "language/english/player/Names", "language/english/player/Notes", "language/english/player/OnEquips", "language/english/player/quest/Quests", "language/english/player/quest/Requirements", "language/english/player/Skills", "language/english/player/Slot", "language/english/Stats", "language/english/StatusEffects", "language/english/Terrains", "language/english/TileEvents", "language/english/ui/Bindables", "language/english/ui/BindableTypes", "language/english/ui/BindPresses", "language/english/ui/ChangelogSections", "language/english/ui/GameEndMessages", "language/english/ui/HelpArticles", "language/english/ui/InterruptChoices", "language/english/ui/MessagesTimestampModes", "language/english/ui/ModLoadErrors", "language/english/ui/MusicPlaylists", "language/english/ui/PowerModes", "language/english/ui/sort/CharacterSorts", "language/english/ui/sort/HighscoreSorts", "language/english/ui/sort/ModSorts", "language/english/ui/sort/SaveSlotSorts", "language/english/ui/TeamMemberResponsibilities", "language/english/ui/UiQuadrants", "language/english/ui/UiTranslations", "language/Language", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L, O, F, _, H, W, N, q, U, z, V, j, Q, $, Y, J, K, X, Z, ee, te, ae, ie) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.english = new ae.default("English",!1),
    t.default = t.english;
    const ne = {
        [a.Dictionary.Action]: p.default,
        [a.Dictionary.Bindable]: _.default,
        [a.Dictionary.BindableType]: H.default,
        [a.Dictionary.BindPress]: W.default,
        [a.Dictionary.Book]: y.default,
        [a.Dictionary.ChangelogSection]: N.default,
        [a.Dictionary.CharacterSort]: Y.default,
        [a.Dictionary.Command]: I.default,
        [a.Dictionary.Corpse]: i.default,
        [a.Dictionary.Creature]: n.default,
        [a.Dictionary.DamageType]: o.default,
        [a.Dictionary.Difficulty]: c.default,
        [a.Dictionary.Doodad]: l.default,
        [a.Dictionary.DoodadGroup]: r.default,
        [a.Dictionary.DoodadItem]: s.default,
        [a.Dictionary.EquipSlot]: B.default,
        [a.Dictionary.GameEndMessage]: q.default,
        [a.Dictionary.Growth]: u.default,
        [a.Dictionary.GrowthFungus]: d.default,
        [a.Dictionary.HelpArticle]: U.default,
        [a.Dictionary.HighscoreSort]: J.default,
        [a.Dictionary.HumanName]: D.default,
        [a.Dictionary.InspectType]: v.default,
        [a.Dictionary.InterruptChoice]: z.default,
        [a.Dictionary.Item]: T.default,
        [a.Dictionary.ItemGroup]: g.default,
        [a.Dictionary.ItemQuality]: f.default,
        [a.Dictionary.LegendaryType]: S.default,
        [a.Dictionary.Message]: m.default,
        [a.Dictionary.MessagesTimestampMode]: V.default,
        [a.Dictionary.Milestone]: C.default,
        [a.Dictionary.Misc]: w.default,
        [a.Dictionary.ModLoadError]: j.default,
        [a.Dictionary.ModSort]: K.default,
        [a.Dictionary.ModType]: M.default,
        [a.Dictionary.MusicPlaylist]: Q.default,
        [a.Dictionary.Note]: A.default,
        [a.Dictionary.Number]: b.default,
        [a.Dictionary.OnEquip]: P.default,
        [a.Dictionary.PartOfDay]: h.default,
        [a.Dictionary.PowerMode]: $.default,
        [a.Dictionary.Quest]: G.default,
        [a.Dictionary.QuestRequirement]: R.default,
        [a.Dictionary.SaveSlotSort]: X.default,
        [a.Dictionary.Skill]: x.default,
        [a.Dictionary.Source]: k.default,
        [a.Dictionary.Stat]: E.default,
        [a.Dictionary.StatusEffect]: L.default,
        [a.Dictionary.TeamMemberResponsibility]: Z.default,
        [a.Dictionary.Terrain]: O.default,
        [a.Dictionary.TileEvent]: F.default,
        [a.Dictionary.Ui]: te.default,
        [a.Dictionary.UiQuadrant]: ee.default
    };
    for (const [e,i] of ie.default.entries(ne))
        t.english.setDictionary(a.Dictionary[e], i);
    t.english.setIrregularRules(["I", "we"], ["me", "us"], ["he", "they"], ["she", "they"], ["them", "them"], ["myself", "ourselves"], ["yourself", "yourselves"], ["itself", "themselves"], ["herself", "themselves"], ["himself", "themselves"], ["themself", "themselves"], ["is", "are"], ["was", "were"], ["has", "have"], ["this", "these"], ["that", "those"], ["echo", "echoes"], ["dingo", "dingoes"], ["volcano", "volcanoes"], ["tornado", "tornadoes"], ["torpedo", "torpedoes"], ["genus", "genera"], ["viscus", "viscera"], ["stigma", "stigmata"], ["stoma", "stomata"], ["dogma", "dogmata"], ["lemma", "lemmata"], ["schema", "schemata"], ["anathema", "anathemata"], ["ox", "oxen"], ["axe", "axes"], ["die", "dice"], ["yes", "yeses"], ["foot", "feet"], ["eave", "eaves"], ["goose", "geese"], ["tooth", "teeth"], ["quiz", "quizzes"], ["human", "humans"], ["proof", "proofs"], ["carve", "carves"], ["valve", "valves"], ["looey", "looies"], ["thief", "thieves"], ["groove", "grooves"], ["pickaxe", "pickaxes"], ["whiskey", "whiskies"]),
    t.english.setPluralizationRules([/\bbottle of (.*)/i, "bottles of $1"], [/\bbundle of (.*)/i, "bundles of $1"], [/\bbushel of (.*)/i, "bushels of $1"], [/\bcontainer of (.*)/i, "containers of $1"], [/\bjug of (.*)/i, "jugs of $1"], [/\borb of (.*)/i, "orbs of $1"], [/\bpile of (.*)/i, "piles of $1"], [/\broll of (.*)/i, "rolls of $1"], [/\bsheaf of (.*)/i, "sheaves of $1"], [/\bsheeet of (.*)/i, "sheets of $1"], [/\bwaterskin of (.*)/i, "waterskins of $1"], [/[^s]$/i, "$&s"], [/[^\u0000-\u007F]$/i, "$&"], [/([^aeiou]ese)$/i, "$1"], [/(ax|test)is$/i, "$1es"], [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"], [/(e[mn]u)s?$/i, "$1s"], [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"], [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"], [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"], [/(seraph|cherub)(?:im)?$/i, "$1im"], [/(her|at|gr)o$/i, "$1oes"], [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"], [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"], [/sis$/i, "ses"], [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"], [/([^aeiouy]|qu)y$/i, "$1ies"], [/([^ch][ieo][ln])ey$/i, "$1ies"], [/(x|ch|ss|sh|zz)$/i, "$1es"], [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"], [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"], [/(pe)(?:rson|ople)$/i, "$1ople"], [/(child)(?:ren)?$/i, "$1ren"], [/eaux$/i, "$&"], [/m[ae]n$/i, "men"], ["thou", "you"]),
    t.english.setSingularizationRules([/s$/i, ""], [/(ss)$/i, "$1"], [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"], [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"], [/ies$/i, "y"], [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"], [/\b(mon|smil)ies$/i, "$1ey"], [/\b((?:tit)?m|l)ice$/i, "$1ouse"], [/(seraph|cherub)im$/i, "$1"], [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|ris)(?:es)?$/i, "$1"], [/(analy|ba|diagno|parenthe|progno|synop|the|empha|cri)(?:sis|ses)$/i, "$1sis"], [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"], [/(test)(?:is|es)$/i, "$1is"], [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"], [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"], [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"], [/(alumn|alg|vertebr)ae$/i, "$1a"], [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"], [/(matr|append)ices$/i, "$1ix"], [/(pe)(rson|ople)$/i, "$1rson"], [/(child)ren$/i, "$1"], [/(eau)x?$/i, "$1"], [/men$/i, "man"]),
    t.english.setUncountableRules("acid", "bark", "bleeding", "charcoal", "clay", "coal", "copal", "cotton", "dough", "ectoplasm", "essence", "fabric", "fat", "fertilizer", "flooring", "flour", "fruit", "fungus", "fur", "gelatin", "glass", "glue", "hardtack", "iron", "ivy", "lava", "leather", "lettuce", "limestone", "meal", "meat", "niter", "nopal", "obsidian", "offal", "ore", "pants", "pemmican", "poison", "powder", "resin", "saltpeter", "sandstone", "shale", "silk", "sinew", "soil", "string", "talc", "tannin", "tinder", "vegetation", "vera", /^([a-z]+\s+)?[a-z]*grass$/, /^([a-z]+\s+)?sand$/, /^([a-z]+\s+)?wheat$/, /^blood($| in )?/, "adulthood", "advice", "agenda", "aid", "alcohol", "ammo", "anime", "athletics", "audio", "bison", "bream", "buffalo", "butter", "carp", "cash", "chassis", "chess", "clothing", "cod", "commerce", "cooperation", "corps", "debris", "diabetes", "digestion", "elk", "energy", "equipment", "excretion", "expertise", "flounder", "fun", "gallows", "garbage", "graffiti", "headquarters", "health", "herpes", "highjinks", "homework", "housework", "information", "jeans", "justice", "kudos", "labour", "literature", "machinery", "mackerel", "mail", "media", "mews", "moose", "music", "mud", "manga", "news", "pike", "plankton", "pliers", "police", "pollution", "premises", "rain", "research", "rice", "salmon", "scissors", "series", "sewage", "shambles", "shrimp", "species", "staff", "swine", "tennis", "traffic", "transportation", "trout", "tuna", "wealth", "welfare", "whiting", "wildebeest", "wildlife", "you", /[^aeiou]ese$/i, /deer$/i, /fish$/i, /\bmeasles$/i, /o[iu]s$/i, /pox$/i, /sheep$/i),
    t.english.setArticleRules([1, /^(?=[aeiou])/, "an "], [1, /^(?![aeiou])/, "a "])
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/TabGeneral", ["require", "exports", "language/dictionary/UiTranslation", "language/English", "language/Language", "language/Translation", "newui/component/BlockRow", "newui/component/CheckButton", "newui/component/Dropdown", "newui/component/Text", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/options/IOptionsTabs", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class y extends d.Tab {
        constructor(e) {
            super(e, p.OptionsTab.General),
            this.setText(a.default.MenuOptionsTabGeneral),
            new d.MenuSection(this.api).setTitle(e=>e.setText(a.default.MenuOptionsHeadingGeneralOptions)).addContent(this.skipSplash = new s.CheckButton(this.api).setText(a.default.MenuOptionsButtonSkipSplash).setRefreshMethod(()=>saveDataGlobal.options.skipSplash).on(s.CheckButtonEvent.Change, this.toggleSkipSplash)).addContent(new r.BlockRow(this.api).classes.add("heading-row").append(new u.Heading(this.api).setText(a.default.MenuOptionsHeadingLanguage)).append(this.language = new l.default(this.api).setRefreshMethod(this.getLanguageDropdownData).on(l.DropdownEvent.Selection, this.onLanguageSelect))).schedule(this.setSection)
        }
        refresh() {
            return this.language.refresh(),
            this.skipSplash.refresh(),
            this
        }
        toggleSkipSplash(e, t) {
            saveDataGlobal.options.skipSplash = t
        }
        onLanguageSelect(e, t, a) {
            languageManager.language === t || a || (languageManager.language = t)
        }
        getLanguageDropdownData() {
            const e = saveDataGlobal.languageManagerSaveData.language && languageManager.providers.values().filter(e=>e instanceof n.default && e.language.toLowerCase() === saveDataGlobal.languageManagerSaveData.language.toLowerCase()).collect(c.default.first());
            return {
                defaultOption: e && e.language || i.english.language,
                options: languageManager.providers.values().filter(e=>e instanceof n.default).map(({language: e})=>m.tuple(e, t=>t.setText(o.default.generator(e))))
            }
        }
    }
    __decorate([h.Bound], y.prototype, "toggleSkipSplash", null),
    __decorate([h.Bound], y.prototype, "onLanguageSelect", null),
    __decorate([h.Bound], y.prototype, "getLanguageDropdownData", null),
    t.default = y
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/TabSaveData", ["require", "exports", "language/dictionary/UiTranslation", "newui/component/Button", "newui/component/Component", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/screen/screens/menu/menus/options/IOptionsTabs", "save/ISaveManager", "utilities/Async", "utilities/Files", "utilities/Log", "utilities/Objects", "utilities/string/Strings"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class h extends o.Tab {
        constructor(e) {
            super(e, s.OptionsTab.SaveData),
            this.setText(a.default.MenuOptionsTabSaveData);
            const t = `#save-data-global-import-${Math.random().toString().slice(2)}`;
            new o.MenuSection(this.api).setTitle(e=>e.setText(a.default.MenuOptionsHeadingSaveData)).addContent(new i.default(this.api).classes.add("button-export", "has-icon-before").setText(a.default.MenuOptionsButtonExportGlobalSaveData).on(i.ButtonEvent.Activate, this.exportGlobalSaveData)).addContent(new i.default(this.api,"label").classes.add("button-import", "has-icon-before", "warning").attributes.set("for", t).setText(a.default.MenuOptionsButtonImportGlobalSaveData)).addContent(new n.default(this.api,"input").setId(t).classes.add("internal-button-import").attributes.set("type", "file").on("InputChange", this.importGlobalSaveData)).addContent(new r.default(this.api)).addContent(new i.default(this.api).setText(a.default.MenuOptionsButtonSaveDataClearBindings).classes.add("warning").on(i.ButtonEvent.Activate, this.onClearBindings)).addContent(new i.default(this.api).setText(a.default.MenuOptionsButtonSaveDataClearOptions).classes.add("warning").on(i.ButtonEvent.Activate, this.onClearOptions)).addContent(new i.default(this.api).setText(a.default.MenuOptionsButtonSaveDataClearSaves).classes.add("warning").on(i.ButtonEvent.Activate, this.onClearSaves)).addContent(new i.default(this.api).setText(a.default.MenuOptionsButtonSaveDataClearCharacters).classes.add("warning").on(i.ButtonEvent.Activate, this.onClearCharacters)).addContent(new i.default(this.api).setText(a.default.MenuOptionsButtonSaveDataClearHighscores).classes.add("warning").on(i.ButtonEvent.Activate, this.onClearHighscores)).addContent(new i.default(this.api).setText(a.default.MenuOptionsButtonSaveDataClearMilestones).classes.add("warning").on(i.ButtonEvent.Activate, this.onClearMilestones)).addContent(new i.default(this.api).setText(a.default.MenuOptionsButtonSaveDataClearCraftingRecipes).classes.add("warning").on(i.ButtonEvent.Activate, this.onClearCraftingRecipes)).addContent(new i.default(this.api).setText(a.default.MenuOptionsButtonSaveDataClearAll).classes.add("warning").on(i.ButtonEvent.Activate, this.onClearAll)).schedule(this.setSection)
        }
        refresh() {
            return this
        }
        async onClearBindings() {
            const e = await this.api.interrupt(a.default .MenuOptionsInterruptSaveDataClearBindings).withConfirmation();
            e && (saveDataGlobal.options.bindings = {},
            this.emit("refresh"))
        }
        async onClearOptions() {
            const e = await this.api.interrupt(a.default .MenuOptionsInterruptSaveDataClearOptions).withConfirmation();
            e && (saveDataGlobal.resetOptions(),
            this.emit("refresh"))
        }
        async onClearSaves() {
            const e = await this.api.interrupt(a.default .MenuOptionsInterruptSaveDataClearSaves).withConfirmation();
            e && saveManager.deleteAllSlots()
        }
        async onClearCharacters() {
            const e = await this.api.interrupt(a.default .MenuOptionsInterruptSaveDataClearCharacters).withConfirmation();
            e && (saveDataGlobal.characters = [])
        }
        async onClearHighscores() {
            const e = await this.api.interrupt(a.default .MenuOptionsInterruptSaveDataClearHighscores).withConfirmation();
            e && (saveDataGlobal.gameHighscores = [])
        }
        async onClearMilestones() {
            const e = await this.api.interrupt(a.default .MenuOptionsInterruptSaveDataClearMilestones).withConfirmation();
            e && (saveDataGlobal.playerMilestoneData = {})
        }
        async onClearCraftingRecipes() {
            const e = await this.api.interrupt(a.default .MenuOptionsInterruptSaveDataClearCraftingRecipes).withConfirmation();
            e && (saveDataGlobal.gameCrafted = {})
        }
        async exportGlobalSaveData() {
            await this.api.interrupt(a.default .MenuLoadGameInterruptLoadingExportingSave).withDescription(a.default .MenuLoadGameInterruptLoadingExportingSaveDescription).withLoading();
            const e = await saveManager.exportSave(l.SLOT_GLOBAL);
            d.default.download(`wayward-global-${m.default.generateTimestamp()}.json`, e),
            await this.api.hideLoadingInterrupt()
        }
        async importGlobalSaveData(e, t) {
            let i;
            try {
                const n = await this.api.interrupt(a.default .MenuOptionsInterruptConfirmImportGlobalData).withDescription(a.default .MenuOptionsInterruptConfirmImportGlobalDataDescription).withConfirmation();
                if (!n)
                    return;
                await this.api.interrupt(a.default .MenuOptionsInterruptLoadingImportingGlobalData).withDescription(a.default .MenuOptionsInterruptLoadingImportingGlobalDataDescription).withLoading(),
                i = await d.default .upload(t)
            } catch (e) {
                return p.default.warn(e),
                void await this.api.interrupt(a.default .MenuLoadGameInterruptImportSaveFailure).withDescription(a.default .MenuLoadGameInterruptImportSaveFailureDescription).withInfo()
            } finally {
                e.element.value = null
            }
            await saveManager.importSave(l.SLOT_GLOBAL,i),
            await saveManager.load(l.SLOT_GLOBAL),
            await this.api.hideLoadingInterrupt(),
            steamworks.reload()
        }
        async onClearAll() {
            const e = await this.api.interrupt(a.default .MenuOptionsInterruptSaveDataClearAll).withDescription(a.default .MenuOptionsInterruptSaveDataClearAllDescription).withConfirmation();
            e && saveManager.isEnabled() && (await saveManager.deleteAllData(),
            await u.sleep(10),
            game.saveClear = !0,
            steamworks.reload())
        }
    }
    __decorate([c.Bound], h.prototype, "onClearBindings", null),
    __decorate([c.Bound], h.prototype, "onClearOptions", null),
    __decorate([c.Bound], h.prototype, "onClearSaves", null),
    __decorate([c.Bound], h.prototype, "onClearCharacters", null),
    __decorate([c.Bound], h.prototype, "onClearHighscores", null),
    __decorate([c.Bound], h.prototype, "onClearMilestones", null),
    __decorate([c.Bound], h.prototype, "onClearCraftingRecipes", null),
    __decorate([c.Bound], h.prototype, "exportGlobalSaveData", null),
    __decorate([c.Bound], h.prototype, "importGlobalSaveData", null),
    __decorate([c.Bound], h.prototype, "onClearAll", null),
    t.default = h
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/options/TabVideo", ["require", "exports", "game/IGame", "game/inspection/IInspection", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Block", "newui/component/BlockRow", "newui/component/CheckButton", "newui/component/Dropdown", "newui/component/IComponent", "newui/component/RangeInput", "newui/component/RangeRow", "newui/component/Text", "newui/INewUi", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/options/IOptionsTabs", "save/data/ISaveDataGlobal", "utilities/enum/Enums", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class v extends g.Tab {
        constructor(e) {
            super(e, f.OptionsTab.Video),
            this.refreshables = [],
            this.setText(o.default.MenuOptionsTabVideo),
            new g.MenuSection(this.api).setTitle(e=>e.setText(o.default.MenuOptionsHeadingVideo)).addContent(this.checkButtonFullscreen = new u.CheckButton(this.api).setText(o.default.MenuOptionsButtonFullscreen).setRefreshMethod(()=>saveDataGlobal.options.fullscreen).schedule(this.addRefreshable).on(u.CheckButtonEvent.Change, this.onFullscreen)).addContent(new l.BlockRow(this.api).classes.add("heading-row").append(new h.Heading(this.api).setText(o.default.MenuOptionsHeadingPowerPreference)).append(new d.default(this.api).setRefreshMethod(this.getPowerPreferenceDropdownData).on(d.DropdownEvent.Selection, this.onPowerPreferenceSelect))).addContent(new u.CheckButton(this.api).setText(o.default.MenuOptionsButtonPixelFont).setRefreshMethod(()=>saveDataGlobal.options.fontStyle).schedule(this.addRefreshable).on(u.CheckButtonEvent.Change, this.onPixelFont)).addContent(new u.CheckButton(this.api).setText(o.default.MenuOptionsButtonDitherFogOfWar).setRefreshMethod(()=>saveDataGlobal.options.visionMode).schedule(this.addRefreshable).on(u.CheckButtonEvent.Change, this.onDitherFOW)).addContent(new u.CheckButton(this.api).setText(o.default.MenuOptionsButtonDisableCustomCursor).setRefreshMethod(()=>saveDataGlobal.options.defaultCursor).schedule(this.addRefreshable).on(u.CheckButtonEvent.Change, this.onDefaultCursor)).addContent(new m.RangeRow(this.api).setLabel(e=>e.setText(o.default.MenuOptionsLabelDialogOpacity)).editRange(e=>e.setMin(y.DIALOG_OPACITY_MIN).setMax(100).setRefreshMethod(()=>Math.round(100 * saveDataGlobal.options.dialogOpacity)).schedule(this.addRefreshable)).addDefaultButton(()=>y.DIALOG_OPACITY_DEFAULT).setDisplayValue(r.default.ui(o.default.MenuSharedValuePercentage).get).setTooltip(e=>e.setLocation(p.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(o.default.MenuOptionsTooltipDialogOpacity))).on(c.RangeInputEvent.Finish, (e,t)=>{
                this.api.setDialogOpacity(t)
            }
            )).addContent(this.inputUiScale = new m.RangeRow(this.api).setLabel(e=>e.setText(o.default.MenuOptionsLabelInterfaceScale)).editRange(e=>e.noClampOnRefresh().setMin(.5, !1).setMax(this.api.scale.getMaximum(), !1).setStep(.25).setRefreshMethod(()=>this.api.scale.getRequested()).schedule(this.addRefreshable)).addDefaultButton(()=>1).setDisplayValue(!0).setTooltip(this.getUiScaleTooltip).on(c.RangeInputEvent.Finish, this.onInterfaceScaleChangeFinish)).addContent(new s.Block(this.api).append(new h.Heading(this.api).setText(o.default.MenuOptionsHeadingTooltips)).append(S.default.values(i.InspectType).map(e=>new u.CheckButton(this.api).classes.add("menu-clearbg").setText(new r.default(n.Dictionary.InspectType,e)).setRefreshMethod(()=>void 0 === saveDataGlobal.options.tooltips[e] || saveDataGlobal.options.tooltips[e]).schedule(this.addRefreshable).on(u.CheckButtonEvent.Change, (t,a)=>{
                saveDataGlobal.options.tooltips[e] = a
            }
            )))).addContent(new u.CheckButton(this.api).setText(o.default.MenuOptionsButtonAlwaysShowMoreInformation).setTooltip(e=>e.setLocation(p.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(o.default.MenuOptionsButtonAlwaysShowMoreInformationTooltip))).setRefreshMethod(()=>saveDataGlobal.options.alwaysShowMoreInformation).schedule(this.addRefreshable).on(u.CheckButtonEvent.Change, (e,t)=>{
                saveDataGlobal.options.alwaysShowMoreInformation = t
            }
            )).schedule(this.setSection);
            const t = this.checkButtonFullscreen.refreshText;
            document.addEventListener("fullscreenchange", t),
            document.addEventListener("webkitfullscreenchange", t),
            this.on("Remove", ()=>{
                document.removeEventListener("fullscreenchange", t),
                document.removeEventListener("webkitfullscreenchange", t)
            }
            ),
            this.api.on(y.UiApiEvent.Resize, this.onViewportResize)
        }
        refresh() {
            for (const e of this.refreshables)
                e.refresh();
            return this
        }
        addRefreshable(e) {
            this.refreshables.push(e)
        }
        onFullscreen(e, t) {
            this.api.toggleFullscreen(t)
        }
        onPixelFont(e, t) {
            saveDataGlobal.options.fontStyle = t,
            ui.setFontStyle()
        }
        onDitherFOW(e, t) {
            saveDataGlobal.options.visionMode = t,
            game.updateRender(a.RenderSource.OptionVisionMode)
        }
        onDefaultCursor(e, t) {
            saveDataGlobal.options.defaultCursor = t,
            document.documentElement.classList.toggle("default-cursor", t)
        }
        onInterfaceScaleChangeFinish(e, t) {
            this.api.scale.request(t)
        }
        onViewportResize() {
            this.inputUiScale.editRange(e=>e.setMax(this.api.scale.getMaximum(), !1))
        }
        getUiScaleTooltip(e) {
            return this.api.scale.getRequested() !== this.api.scale.getCurrent() ? e.addText(e=>e.setText(()=>r.default.ui(o.default.MenuOptionsTooltipUiScaleClamped).get(this.api.scale.getCurrent()))).setLocation(p.TooltipLocation.CenterRight) : e
        }
        async onPowerPreferenceSelect(e, t, a) {
            saveDataGlobal.options.powerPreference === t || a || (saveDataGlobal.options.powerPreference = t,
            game.playing && await newui.showLoadingInterrupt(o.default .GameInterruptLoadingReloadingWebGl),
            await game.initGl(),
            game.playing && newui.hideLoadingInterrupt())
        }
        getPowerPreferenceDropdownData() {
            return {
                defaultOption: saveDataGlobal.options.powerPreference || T.PowerMode.Default,
                options: S.default.values(T.PowerMode).map(e=>[e, t=>t.setText(new r.default(n.Dictionary.PowerMode,e))])
            }
        }
    }
    __decorate([I.Bound], v.prototype, "addRefreshable", null),
    __decorate([I.Bound], v.prototype, "onFullscreen", null),
    __decorate([I.Bound], v.prototype, "onPixelFont", null),
    __decorate([I.Bound], v.prototype, "onDitherFOW", null),
    __decorate([I.Bound], v.prototype, "onDefaultCursor", null),
    __decorate([I.Bound], v.prototype, "onInterfaceScaleChangeFinish", null),
    __decorate([I.Bound], v.prototype, "onViewportResize", null),
    __decorate([I.Bound], v.prototype, "getUiScaleTooltip", null),
    __decorate([I.Bound], v.prototype, "onPowerPreferenceSelect", null),
    __decorate([I.Bound], v.prototype, "getPowerPreferenceDropdownData", null),
    t.default = v
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/OptionsMenu", ["require", "exports", "language/dictionary/UiTranslation", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/screen/screens/menu/menus/options/TabAudio", "newui/screen/screens/menu/menus/options/TabControls", "newui/screen/screens/menu/menus/options/TabDeveloper", "newui/screen/screens/menu/menus/options/TabGameplay", "newui/screen/screens/menu/menus/options/TabGeneral", "newui/screen/screens/menu/menus/options/TabMods", "newui/screen/screens/menu/menus/options/TabSaveData", "newui/screen/screens/menu/menus/options/TabVideo", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class y extends n.default {
        constructor(e) {
            super(e, i.MenuId.Options),
            this.refreshables = [],
            this.setTitle(e=>e.setText(a.default.MenuOptionsTitle)),
            this.setDescription(e=>e.setText(a.default.MenuOptionsDescription)),
            this.addRefreshableTabs([new d.default(this.api), new r.default(this.api), new m.default(this.api), new u.default(this.api), new p.default(this.api), new s.default(this.api), new c.default(this.api).on("refresh", this.refresh), new l.default(this.api)]),
            this.on("Show", this.refresh)
        }
        addRefreshableTabs(...e) {
            for (const t of e.values().flatMap())
                this.addTabs(t),
                this.refreshables.push(t),
                new o.default(this.api).appendTo(this.content)
        }
        refresh() {
            for (const e of this.refreshables)
                e.refresh()
        }
    }
    __decorate([h.Bound], y.prototype, "refresh", null),
    t.default = y
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/mods/ModRow", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Language", "language/Translation", "mod/IModInfo", "mod/IModManager", "newui/component/Button", "newui/component/CheckButton", "newui/component/IComponent", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/menus/options/IOptionsTabs", "newui/screen/screens/menu/menus/options/TabMods", "newui/util/Misc", "utilities/iterable/Generators", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f) {
    var T;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.ShouldRefreshMenu = 0] = "ShouldRefreshMenu"
    }(T = t.ModRowEvent || (t.ModRowEvent = {}));
    class S extends u.CheckButton {
        constructor(e, t, n) {
            super(e),
            this.setText(o.default.generator(n.config.name)),
            this.setRefreshMethod(()=>modManager.isEnabled(t) && modManager.canLoad(t, !0) === s.CanLoadState.Loadable),
            this.setTooltip(e=>{
                e.setLocation(d.TooltipLocation.CenterRight);
                const r = modManager.canLoad(this.index, !0);
                return r !== s.CanLoadState.Loadable && r !== s.CanLoadState.Disabled && r !== s.CanLoadState.ReqiredModNotLoaded && e.addParagraph(e=>e.classes.add("menu-mods-tooltip-error").setText(new o.default(a.Dictionary.ModLoadError,r))),
                e.addParagraph(e=>e.setText(o.default.ui(i.default.MenuModsTooltipLabelDescription).addArgs(n.config.description))),
                e.addParagraph(e=>e.setText(o.default.ui(i.default.MenuModsTooltipLabelVersion).addArgs(n.config.version))),
                e.addParagraph(e=>e.setText(o.default.ui(i.default.MenuModsTooltipLabelAuthor).addArgs(n.config.author))),
                e.addParagraph(e=>e.setText(o.default.ui(i.default.MenuModsTooltipLabelTags).addArgs(modManager.getTags(t).values().collect(o.default.formatList, !1)))),
                void 0 !== n.installDate && e.addParagraph(e=>e.setText(o.default.ui(i.default.MenuModsTooltipLabelInstallDate).addArgs(new Date(1e3 * n.installDate).toLocaleString()))),
                void 0 !== n.createdDate && e.addParagraph(e=>e.setText(o.default.ui(i.default.MenuModsTooltipLabelCreatedDate).addArgs(new Date(1e3 * n.createdDate).toLocaleString()))),
                void 0 !== n.lastUpdated && e.addParagraph(e=>e.setText(o.default.ui(i.default.MenuModsTooltipLabelLastUpdatedDate).addArgs(new Date(1e3 * n.lastUpdated).toLocaleString()))),
                e.addParagraph(e=>e.setText(()=>o.default.ui(i.default.MenuModsTooltipLabelProvides).get(y.pipe(n.provides.scripts && o.default.ui(i.default.MenuModsTooltipProvidesScript), n.provides.customizations && o.default.ui(i.default.MenuModsTooltipProvidesCustomizations), n.provides.languages && o.default.ui(i.default.MenuModsTooltipProvidesLanguage), n.provides.imageOverrides && o.default.ui(i.default.MenuModsTooltipProvidesImageOverrides), n.provides.stylesheets && o.default.ui(i.default.MenuModsTooltipProvidesStylesheet), n.provides.languageExtensions && o.default.ui(i.default.MenuModsTooltipProvidesLanguageExtensions)).filter2(e=>!!e).map(e=>e.get()).collect(o.default.formatList, !1)))),
                n.config.dependencies && n.config.dependencies.length > 0 && e.addParagraph(e=>e.setText(o.default.ui(i.default.MenuModsTooltipLabelDependencies).addArgs(n.config.dependencies.values().map(this.isLoadable).map(([e,t])=>o.default.ui(i.default.MenuLoadGameSaveTooltipMod).get(e, `text-color-dependency-${t}`)).collect(o.default.formatList, !1)))),
                e.addParagraph(e=>e.setText(o.default.ui(i.default.MenuModsTooltipMultiplayerCompatibility).addArgs(modManager.isMultiplayerClientSide(this.index), modManager.isMultiplayerCompatible(this.index)))),
                e
            }
            ),
            this.on(u.CheckButtonEvent.Change, async(e,t)=>{
                const a = await this.onChecked(t);
                t !== a && this.setChecked(a)
            }
            ),
            this.info = n,
            this.index = t,
            n.type === r.ModType.Workshop && this.addButton(e=>e.classes.add("button-delete").on(l.ButtonEvent.Activate, async()=>{
                const e = await this.api.interrupt(()=>o.default .ui(i.default .MenuModsInterruptConfirmUninstallMod).get(this.info.config.name)).withDescription(i.default .MenuModsInterruptConfirmUninstallModDescription).withConfirmation();
                if (e) {
                    if (modManager.isEnabled(this.index)) {
                        const e = this.trySetChecked(!1);
                        if (!e)
                            return void g.default.warn(g.LogSource.NewUi)("Unable to disable mod for uninstallation")
                    }
                    const e = modManager.getPublishFileId(this.index);
                    void 0 !== e && (await steamworks.unsubscribe(e),
                    await this.emitAsync(T.ShouldRefreshMenu))
                }
            }
            ).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuModsTooltipUninstallMod)))),
            this.addButton(e=>this.buttonPublish = e.classes.add("button-publish").on(l.ButtonEvent.Activate, this.onPublish).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuModsTooltipPublishMod)))),
            this.addButton(e=>this.buttonView = e.classes.add("button-view").on(l.ButtonEvent.Activate, async()=>{
                await steamworks.openWorkshop(n.publishedFileId),
                await this.emitAsync(T.ShouldRefreshMenu)
            }
            ).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuModsTooltipViewInSteamWorkshop)))),
            this.addButton(e=>this.buttonOptions = e.classes.add("button-options").on(l.ButtonEvent.Activate, h.menuSwitcher(p.MenuId.Options, e=>e.schedule(500, e=>e.scrollToTabSection(n.config.name)))).setTooltip(e=>e.addText(e=>e.setText(i.default.MenuModsTooltipModOptions)))),
            this.updateButtons();
            const c = modManager.canLoad(this.index, !0)
              , m = c === s.CanLoadState.Loadable || c === s.CanLoadState.Disabled || c === s.CanLoadState.ReqiredModNotLoaded;
            this.setDisabled(!m)
        }
        updateButtons() {
            this.buttonPublish.toggle(this.canPublish()),
            this.buttonView.toggle(!!this.info.publishedFileId),
            this.buttonOptions.toggle(m.default.modHasOptions(this.index))
        }
        async onChecked(e, t=!0) {
            if (e) {
                const e = modManager.canLoad(this.index, !0)
                  , a = e === s.CanLoadState.Loadable || e === s.CanLoadState.Disabled || e === s.CanLoadState.ReqiredModNotLoaded;
                if (!a)
                    return !1;
                if (this.info.config.dependencies) {
                    const e = []
                      , a = [];
                    e: for (const t of this.info.config.dependencies) {
                        const i = modManager.getIndexFromPublishId(t);
                        if (0 !== i.length) {
                            for (const e of i)
                                if (modManager.isEnabled(e))
                                    continue e;
                            a.push(i)
                        } else
                            e.push(i[0])
                    }
                    if (e.length > 0)
                        return t && await this.api.interrupt(()=>o.default .ui(i.default .MenuModsInterruptInfoMissingDependencies).get(this.info.config.name)).withDescription(()=>o.default .ui(i.default .MenuModsInterruptInfoMissingDependenciesDescription).get(this.getDependencyNames(e))).withInfo(),
                        !1;
                    if (a.length > 0) {
                        if (t) {
                            const e = await this.api.interrupt(()=>o.default .ui(i.default .MenuModsInterruptConfirmEnableDisabledDependencies).get(this.info.config.name)).withDescription(()=>o.default .ui(i.default .MenuModsInterruptConfirmEnableDisabledDependenciesDescription).get(a.values().map(e=>e[0]).collect(this.getDependencyNames))).withConfirmation();
                            if (!e)
                                return !1
                        }
                        for (const e of a) {
                            let t = !1;
                            for (const a of e) {
                                const e = this.api.getVisibleScreen().getMenu(p.MenuId.Mods)
                                  , i = e.getModRow(a)
                                  , n = i.setChecked(!0);
                                if (n) {
                                    t = !0;
                                    break
                                }
                            }
                            if (!t)
                                return g.default.warn(g.LogSource.NewUi)(`Unable to enable dependency ${modManager.getName(e[0])}`),
                                !1
                        }
                    }
                }
            } else if (this.info.publishedFileId) {
                const e = [];
                for (const t of modManager.getEnabledMods())
                    modManager.getRequiredMods(t).includes(this.info.publishedFileId) && e.push(t);
                if (e.length > 0) {
                    const t = await this.api.interrupt(()=>o.default .ui(i.default .MenuModsInterruptConfirmDisableDependents).get(this.info.config.name)).withDescription(()=>o.default .ui(i.default .MenuModsInterruptConfirmDisableDependentsDescription).get(this.getDependencyNames(e))).withConfirmation();
                    if (!t)
                        return !1;
                    for (const t of e) {
                        const e = this.api.getVisibleScreen().getMenu(p.MenuId.Mods)
                          , a = e.getModRow(t)
                          , i = a.setChecked(!1);
                        if (!i)
                            return g.default.warn(g.LogSource.NewUi)(`Unable to disable dependency ${modManager.getName(t)}`),
                            !1
                    }
                }
            }
            return new Promise(async(a,o)=>{
                const s = await modManager.setState(this.index,e?r.ModState.Enabled:r.ModState.Disabled,!1,!0)
                  , l = s ? e : !e;
                if (t && e)
                    if (this.info.provides.languages > 1) {
                        const e = await this.api.interrupt(i.default .MenuModsInterruptModEnableMultipleLanguages).withDescription(i.default .MenuModsInterruptModEnableMultipleLanguagesDescription).withConfirmation();
                        e && this.api.getVisibleScreen().showMenu(p.MenuId.Options, e=>e.scrollToTabSection(c.OptionsTab.General))
                    } else if (1 === this.info.provides.languages && this.info.languages) {
                        const e = this.info.languages[0].instance;
                        if (e && e instanceof n.default && languageManager.language !== e.language) {
                            const t = await this.api.interrupt(i.default .MenuModsInterruptModEnableUseLanguage).withDescription(i.default .MenuModsInterruptModEnableUseLanguageDescription).withConfirmation();
                            t && (languageManager.language = e.language)
                        }
                    }
                a(l),
                this.updateButtons()
            }
            )
        }
        canPublish() {
            return steamworks.isElectron() && this.info.type === r.ModType.Local && (!this.info.publishedFileId || void 0 !== steamworks.getPublishedMod(this.info.publishedFileId))
        }
        getDependencyNames(e) {
            if (void 0 === e) {
                if (!this.info.config.dependencies)
                    return "";
                e = this.info.config.dependencies.values().map(e=>modManager.getIndexFromPublishId(e)[0])
            } else
                e = e.values();
            return e.map(e=>[{
                content: modManager.getName(e)
            }]).collect(o.default.formatList)
        }
        isLoadable(e) {
            const t = modManager.canLoadFromIdentifier(e);
            let a = "error";
            if (t.loadable) {
                a = "notenabled";
                for (const t of modManager.getIndexFromPublishId(e))
                    if (modManager.isEnabled(t)) {
                        a = "enabled";
                        break
                    }
            }
            return [t.name, a]
        }
        async onPublish() {
            let e = !1
              , t = this.info.publishedFileId;
            if (t) {
                if (e = await this.api.interrupt(i.default .MenuModsInterruptConfirmPublishUpdate).withDescription(i.default .MenuModsInterruptConfirmPublishUpdateDescription).withConfirmation()) {
                    await this.api.interrupt(i.default .MenuModsInterruptUpdatingMod).withDescription(i.default .MenuModsInterruptUpdatingModDescription).withLoading();
                    try {
                        t = await steamworks.publishMod(this.index)
                    } catch (e) {
                        await this.api.hideLoadingInterrupt(),
                        this.api.interrupt(()=>o.default.ui(i.default.MenuModsInterruptPublishUpdateError).get(e.message)).withInfo(),
                        t = void 0
                    }
                }
            } else if (e = await this.api.interrupt(i.default .MenuModsInterruptConfirmPublish).withDescription(i.default .MenuModsInterruptConfirmPublishDescription).withConfirmation()) {
                await this.api.interrupt(i.default .MenuModsInterruptPublishingMod).withDescription(i.default .MenuModsInterruptPublishingModDescription).withLoading();
                try {
                    t = await steamworks.publishMod(this.index),
                    await this.api.hideLoadingInterrupt();
                    const e = modManager.getRequiredMods(this.index);
                    e.length > 0 && await this.api.interrupt(i.default .MenuModsInterruptPublishedReminderRequiredModsOnWorkshop).withDescription(i.default .MenuModsInterruptPublishedReminderRequiredModsOnWorkshopDescription).withInfo(),
                    await steamworks.openWorkshop(t),
                    await this.emitAsync(T.ShouldRefreshMenu)
                } catch (e) {
                    await this.api.hideLoadingInterrupt(),
                    this.api.interrupt(()=>o.default.ui(i.default.MenuModsInterruptPublishError).get(e.message)).withInfo(),
                    t = void 0
                }
            }
            if (await this.api.hideLoadingInterrupt(),
            e && t) {
                const e = modManager.getRequiredMods(this.index);
                e && e.length > 0 && await this.api.interrupt(i.default .MenuModsInterruptPublishedReminderRequiredModsOnWorkshop).withDescription(i.default .MenuModsInterruptPublishedReminderRequiredModsOnWorkshopDescription).withInfo(),
                await steamworks.openWorkshop(t),
                await this.emitAsync(T.ShouldRefreshMenu)
            }
        }
    }
    __decorate([f.Bound], S.prototype, "getDependencyNames", null),
    __decorate([f.Bound], S.prototype, "isLoadable", null),
    __decorate([f.Bound], S.prototype, "onPublish", null),
    t.default = S
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/ModsMenu", ["require", "exports", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "mod/IModInfo", "newui/component/BlockRow", "newui/component/Button", "newui/component/Component", "newui/component/SortRow", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/menus/mods/EditInternalModsMenu", "newui/screen/screens/menu/menus/mods/IModsMenu", "newui/screen/screens/menu/menus/mods/ModRow", "newui/util/Misc", "steamworks/ISteamworks", "utilities/Async", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class S extends p.default {
        constructor(e) {
            super(e, d.MenuId.Mods),
            this.sections = {},
            this.setTitle(e=>e.setText(i.default.MenuModsTitle)),
            this.setDescription(e=>e.setText(i.default.MenuModsDescription)),
            this.create(),
            this.on("Show", this.refreshMods),
            this.until("Remove").bind(steamworks, g.SteamworksEvent.OverlayHidden, async()=>f.sleep(500).then(this.refreshMods));
            for (const e in this.sections)
                this.sections[e].sortRow.refresh()
        }
        getModRow(e) {
            for (const t in this.sections)
                for (const a of this.sections[t].modRows)
                    if (a.index === e)
                        return a
        }
        create() {
            new r.BlockRow(this.api).append(new s.default(this.api).setText(i.default.MenuModsButtonEnableAll).on(s.ButtonEvent.Activate, this.setAllModStates(!0))).append(new s.default(this.api).setText(i.default.MenuModsButtonDisableAll).on(s.ButtonEvent.Activate, this.setAllModStates(!1))).appendTo(this.content),
            this.sections[o.ModType.Workshop] = this.addModSection(o.ModType.Workshop, [], [new s.default(this.api).setText(i.default.MenuModsButtonOpenWorkshop).on(s.ButtonEvent.Activate, async()=>{
                await steamworks.openWorkshop()
            }
            )]),
            this.sections[o.ModType.Local] = this.addModSection(o.ModType.Local, [m.ModSort.CreatedDate, m.ModSort.InstallDate, m.ModSort.LastUpdated], [new s.default(this.api).setText(i.default.MenuModsButtonOpenFolder).on(s.ButtonEvent.Activate, ()=>{
                steamworks.openModsFolder()
            }
            ), new s.default(this.api).setText(i.default.MenuModsButtonModdingGuide).on(s.ButtonEvent.Activate, ()=>{
                steamworks.openUrl("https://waywardgame.github.io/")
            }
            )]),
            this.sections[o.ModType.Internal] = this.addModSection(o.ModType.Internal, [m.ModSort.CreatedDate, m.ModSort.InstallDate, m.ModSort.LastUpdated], steamworks.isElectron() ? [] : [new s.default(this.api).setText(i.default.MenuModsButtonEditInternalMods).on(s.ButtonEvent.Activate, y.menuSwitcher(new c.default(this.api)))])
        }
        refreshMods() {
            for (const e in this.sections)
                this.sections[e].modsWrapper.dump(),
                this.sections[e].modRows = [];
            const e = modManager.getMods();
            for (let t = 0; t < e.length; t++) {
                if (!modManager.isValid(t))
                    continue;
                const a = e[t]
                  , i = this.sections[a.type].modsWrapper;
                this.sections[a.type].modRows.push(new h.default(this.api,t,a).on(h.ModRowEvent.ShouldRefreshMenu, this.refreshMods).appendTo(i))
            }
            for (const e in this.sections)
                0 === this.sections[e].modsWrapper.childCount ? this.sections[e].sortRow.hide() : (this.sections[e].sortRow.show(),
                this.sortMods(+e, this.sections[e].sortRow.sort, this.sections[e].sortRow.sortDirection))
        }
        sortMods(e, t, a) {
            const i = this.sections[e];
            i.modRows.sort((e,i)=>{
                switch (t) {
                case m.ModSort.Name:
                    return e.info.config.name.localeCompare(i.info.config.name) * a;
                case m.ModSort.Author:
                    return e.info.config.author.localeCompare(i.info.config.author) * a;
                case m.ModSort.LastUpdated:
                    return (i.info.lastUpdated - e.info.lastUpdated) * a;
                case m.ModSort.InstallDate:
                    return (i.info.installDate - e.info.installDate) * a;
                case m.ModSort.CreatedDate:
                    return (i.info.createdDate - e.info.createdDate) * a
                }
            }
            );
            for (const e of i.modRows)
                e.appendTo(i.modsWrapper)
        }
        setAllModStates(e) {
            return async()=>{
                for (const t in this.sections)
                    for (const a of this.sections[t].modsWrapper.getChildren())
                        if (!a.disabled) {
                            const t = await a.onChecked(e,!1);
                            a.setChecked(t, !1)
                        }
                this.emit(h.ModRowEvent.ShouldRefreshMenu)
            }
        }
        addModSection(e, t=[], o=[], r=[]) {
            let s, d;
            return new p.Tab(this.api,e).setText(new n.default(a.Dictionary.ModType,e)).setSection(new p.MenuSection(this.api).setTitle(t=>t.setText(n.default.ui(i.default.MenuModsSectionHeading).addArgs(new n.default(a.Dictionary.ModType,e)))).addContent(...o).addContent(d = new u.default(this.api).setDisabledSorts(t).setRefreshMethod(()=>({
                sortEnum: m.ModSort,
                defaultSort: m.ModSort.Name,
                initializeOption: (e,[,t])=>e.setText(new n.default(a.Dictionary.ModSort,t))
            })).on(u.SortRowEvent.Sort, (t,a,i)=>{
                this.sortMods(e, a, i)
            }
            )).addContent(s = new l.default(this.api)).addContent(...r)).schedule(this.addTabs),
            {
                sortRow: d,
                modsWrapper: s,
                modRows: []
            }
        }
    }
    __decorate([T.Bound], S.prototype, "refreshMods", null),
    t.default = S
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/multiplayer/ServerRow", ["require", "exports", "game/Difficulty", "language/Dictionaries", "language/dictionary/Misc", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Button", "newui/component/Component", "newui/component/Text", "newui/util/Misc", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class m extends s.default {
        constructor(e, t, a) {
            super(e),
            this.getFriend = a,
            this._place = 0,
            this.classes.add("menu-server", "menu-block"),
            this._server = t,
            new l.default(e).classes.add("server-icons").append(this.difficulty = new l.default(e).classes.add("icon-difficulty", "has-icon-before", "icon-center").setTooltip(e=>e.addHeading(e=>e.setText(new r.default(i.Dictionary.Difficulty,this.server.gameDetails.difficulty))))).append(this.pvp = new l.default(e).classes.add("icon-pvp", "has-icon-before", "icon-center").setTooltip(e=>e.addHeading(e=>e.setText(o.default.MenuMultiplayerServerTooltipPVP)))).append(this.mods = new l.default(e).classes.add("icon-mods", "has-icon-before", "icon-center").setTooltip(this.getModsTooltip)).append(this.friends = new l.default(e).classes.add("icon-friends", "has-icon-before", "icon-center").setTooltip(this.getFriendsTooltip)).appendTo(this),
            new u.Paragraph(e).classes.add("menu-server-description").setText(r.default.generator(()=>this.server.serverDetails.description)).appendTo(this),
            new u.default(e).classes.add("menu-server-reputation").setText(r.default.ui(o.default.MenuMultiplayerServerLabelReputation).addArgs(()=>this.server.gameDetails.reputation)).appendTo(this),
            new u.default(e).classes.add("menu-server-days").setText(r.default.ui(o.default.MenuMultiplayerServerLabelDays).addArgs(()=>this.server.gameDetails.days - 1)).appendTo(this),
            new u.default(e).classes.add("menu-server-players").setText(r.default.ui(o.default.MenuMultiplayerServerPlayers).addArgs(()=>this.server.gameDetails.players.length, ()=>this.server.gameDetails.maxPlayers)).appendTo(this),
            new u.default(e).classes.add("menu-server-region").setText(r.default.ui(o.default.MenuMultiplayerServerRegion).addArgs(()=>this.server.serverDetails.region)).appendTo(this),
            new u.default(e).classes.add("menu-server-host").setText(r.default.ui(o.default.MenuMultiplayerServerHost).addArgs(()=>this.server.serverDetails.isDedicatedServer ? r.default.ui(o.default.MenuMultiplayerServerDedicated) : this.server.serverDetails.hostPlayerName)).appendTo(this),
            this.setText(r.default.generator(()=>this.server.serverDetails.name)),
            this.on(s.ButtonEvent.Activate, ()=>{
                const e = [];
                for (const t of this.server.gameDetails.mods)
                    "error" === h(t)[1] && e.push(r.default.ui(o.default.GameMultiplayerInterruptRequiredModUnableToLoad).getString({
                        name: t.name,
                        version: t.version
                    }));
                e.length > 0 ? newui.interrupt(o.default.GameMultiplayerInterruptUnableToJoinGame, ()=>r.default.ui(o.default.GameMultiplayerInterruptFailedToLoadMods).get(e.join("\n"))).withInfo() : d.switchToJoinServer(multiplayer.convertGameCodeToServerInfo(this.server.serverDetails.code))
            }
            )
        }
        get server() {
            return this._server
        }
        set server(e) {
            this._server = e,
            this.refresh()
        }
        get place() {
            return this._place
        }
        set place(e) {
            this._place = e,
            this.headingPlace.refresh()
        }
        refresh() {
            return this.setDisabled(this.server.gameDetails.players.length === this.server.gameDetails.maxPlayers),
            this.difficulty.data.set("difficulty", a.Difficulty[this.server.gameDetails.difficulty]),
            this.pvp.toggle(this.server.gameDetails.pvp),
            this.mods.toggle(this.server.gameDetails.mods.length > 0),
            this.friends.toggle(this.server.gameDetails.players.some(e=>void 0 !== this.getFriend(e))),
            this.api.refreshTranslations(this),
            this
        }
        getModsTooltip(e) {
            return e.addText(e=>e.setText(r.default.ui(o.default.MenuMultiplayerServerTooltipModsLabel).addArgs(()=>this.server.gameDetails.mods.values().map(h).map(([e,t])=>r.default.ui(o.default.MenuLoadGameSaveTooltipMod).get(e.name, `text-color-dependency-${t}`)).collect(r.default.formatList))))
        }
        getFriendsTooltip(e) {
            return e.addText(e=>e.setText(r.default.ui(o.default.MenuMultiplayerServerTooltipFriendsLabel).addArgs(()=>this.server.gameDetails.players.map(e=>this.getFriend(e)).filter(e=>void 0 !== e).map(e=>new r.default(i.Dictionary.Misc,n.MiscTranslation.HumanName).addArgs(e.name || e.steamId)).collect(r.default.formatList))))
        }
    }
    function h(e) {
        return p.tuple(e, e.publishFileId ? d.isModLoadable(e.publishFileId)[1] : "error")
    }
    __decorate([c.Bound], m.prototype, "getModsTooltip", null),
    __decorate([c.Bound], m.prototype, "getFriendsTooltip", null),
    t.ServerRow = m
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/MultiplayerMenu", ["require", "exports", "language/dictionary/UiTranslation", "language/Translation", "multiplayer/IMultiplayer", "newui/component/BlockRow", "newui/component/Button", "newui/component/Component", "newui/component/Text", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/screen/screens/menu/menus/multiplayer/ServerRow", "newui/util/Misc", "steamworks/ISteamworks", "utilities/Async", "utilities/Files", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class v extends d.default {
        constructor(e) {
            super(e, u.MenuId.Multiplayer),
            this.serverMap = new Map,
            this.playersOnline = 0,
            this.setTitle(e=>e.setText(a.default.MenuMultiplayerTitle)),
            this.setDescription(e=>e.setText(a.default.MenuMultiplayerDescription)),
            new r.default(e).setText(a.default.MenuMultiplayerButtonJoinById).on(r.ButtonEvent.Activate, m.menuSwitcher(u.MenuId.JoinServer)).appendTo(this.content),
            new o.BlockRow(e).append(new r.default(e).setText(a.default.MenuMultiplayerButtonNewGame).on(r.ButtonEvent.Activate, m.menuSwitcher(u.MenuId.NewGame, e=>e.schedule(1, ()=>{
                e.multiplayerMode.choose(e.choiceMultiplayer)
            }
            )))).append(new r.default(e).setText(a.default.MenuMultiplayerButtonLoadGame).on(r.ButtonEvent.Activate, m.menuSwitcher(u.MenuId.LoadGame, e=>e.isMultiplayer = !0))).appendTo(this.content),
            new p.default(e).appendTo(this.content),
            this.playersHeading = new l.Heading(e).setText(i.default.ui(a.default.MenuMultiplayerHeadingPlayersOnline).addArgs(()=>this.playersOnline)).appendTo(this.content),
            this.serversContainer = new s.default(e).classes.add("menu-servers").appendTo(this.content),
            this.on("Show", async()=>{
                await y.sleep(100),
                this.refresh()
            }
            )
        }
        async refresh() {
            if (!this.isVisible())
                return;
            this.friends = steamworks.getFriends() || [];
            const e = await this.getMultiplayerInfo();
            this.playersOnline = e.players,
            this.playersHeading.refresh();
            const t = e.servers.filter(this.isVisibleServer).map(e=>T.tuple(e.id, e)).collect(f.default.toMap);
            for (const [e,a] of this.serverMap.entries()) {
                const i = t.get(e);
                i ? a.server = i : (a.remove(),
                this.serverMap.delete(e))
            }
            let a = 0;
            for (const [e,i] of t.entries().collect(f.default.toArray).sort(this.sortServers))
                this.serverMap.has(e) || this.serverMap.set(e, new c.ServerRow(this.api,i,e=>this.friends.find(t=>t.staticAccountId === e)).appendTo(this.serversContainer)),
                this.serverMap.get(e).refresh().style.setProperty("--order", `${a++}`);
            await y.sleep(3e3),
            this.refresh()
        }
        async getMultiplayerInfo() {
            const e = await g.default .getJson(`http://${n.networkingOptions.matchmakingServer}:38741/api/v1/info`).catch (e=>{S.default .warn(S.LogSource.Multiplayer)("Unable to get server list",e)});
            return e || {
                players: 0,
                servers: []
            }
        }
        isVisibleServer(e) {
            const t = e.serverDetails.buildTime;
            if (void 0 !== t) {
                const e = steamworks.getBuildTime();
                if (void 0 !== e && t !== e)
                    return !1
            }
            return e.serverDetails.lobbyType !== h.LobbyType.FriendsOnly || this.isFriend(e.serverDetails.hostPlayerId)
        }
        sortServers([,e], [,t]) {
            return this.getSortValue(t) - this.getSortValue(e)
        }
        getSortValue(e) {
            return (this.isFriend(e.serverDetails.hostPlayerId) ? 999999 : 0) + e.gameDetails.players.filter(this.isFriend).length
        }
        isFriend(e) {
            return this.friends.some(t=>t.staticAccountId === e)
        }
    }
    __decorate([I.Bound], v.prototype, "refresh", null),
    __decorate([I.Bound], v.prototype, "isVisibleServer", null),
    __decorate([I.Bound], v.prototype, "sortServers", null),
    __decorate([I.Bound], v.prototype, "isFriend", null),
    t.default = v
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/InterruptScreen", ["require", "exports", "newui/screen/IScreen", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/MenuScreen", "newui/screen/screens/menu/menus/InterruptMenu", "newui/util/IInterrupt", "utilities/Async"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class u extends o.default {
        constructor(e) {
            super(e, a.ScreenId.Interrupt),
            this.canBeInstant = !0,
            this.classes.add("no-offset-parent"),
            this.isOverlayScreen = !0,
            this.on("Hide", ()=>{
                this.menuChain.splice(0, 1 / 0)
            }
            )
        }
        get interruptType() {
            return this.visibleMenu && this.visibleMenu.menuId === i.MenuId.Interrupt ? this.getMenu(i.MenuId.Interrupt).type : void 0
        }
        backOneMenu() {
            return this.visibleMenu ? (this.visibleMenu.classes.remove("left").classes.add("right").hide().emit(n.MenuEvent.GoBackFrom),
            this.menuChain.pop(),
            this.menuChain.length && this.visibleMenu.classes.remove("right").classes.add("left").show(),
            this) : this
        }
        async interrupt(e) {
            if (void 0 !== e.menuId) {
                this.canBeInstant && (this.classes.until(800).add("insta-animation-in"),
                this.canBeInstant = !1),
                this.visibleMenu && this.visibleMenu.menuId === e.menuId || this.showMenu(e.menuId, t=>{
                    t.isSubmenu = !0,
                    t.schedule(e.initializer)
                }
                );
                const t = this.menus[e.menuId];
                return new Promise((e,a)=>{
                    t.once(n.MenuEvent.GoBackFrom, (t,a)=>{
                        this.classes.remove("insta-animation-in"),
                        l.sleep(300).then(()=>this.canBeInstant = !0),
                        e()
                    }
                    )
                }
                )
            }
            {
                let t = this.menus[i.MenuId.Interrupt];
                if (t || (t = this.menus[i.MenuId.Interrupt] = this.getMenu(i.MenuId.Interrupt)),
                this.visibleMenu && this.visibleMenu.menuId === i.MenuId.Interrupt && t.emitAsync(r.InterruptMenuEvent.Resolve),
                await t.setOptions(e),
                this.visibleMenu && this.visibleMenu.menuId === i.MenuId.Interrupt || this.showMenu(i.MenuId.Interrupt),
                e.isTopMenu && this.setTopMenu(),
                e.type !== s.InterruptType.Loading) {
                    const e = await t.waitFor();
                    return this.backOneMenu(),
                    e
                }
            }
        }
        async hideLoadingInterrupt() {
            this.classes.remove("insta-animation-in");
            const e = this.menus[i.MenuId.Interrupt];
            e.type === s.InterruptType.Loading && (this.visibleMenu.menuId === i.MenuId.Interrupt && this.backOneMenu(),
            0 === this.menuChain.length && this.api.hideScreen(a.ScreenId.Interrupt),
            await e.emitAsync(r.InterruptMenuEvent.Resolve))
        }
    }
    __decorate([Override], u.prototype, "backOneMenu", null),
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/pause/ModesMenu", ["require", "exports", "Enums", "game/IGame", "language/dictionary/UiTranslation", "language/Translation", "multiplayer/IMultiplayer", "newui/component/ChoiceList", "newui/component/IComponent", "newui/component/RangeInput", "newui/component/RangeRow", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class h extends p.default {
        constructor(e) {
            super(e, "modes"),
            this.setTitle(e=>e.setText(n.default.MenuModesTitle)),
            this.setDescription(e=>e.setText(n.default.MenuModesDescription)),
            this.turnMode = new s.default(this.api).appendTo(this.content),
            this.tickSpeed = new d.RangeRow(this.api).setLabel(e=>e.setText(n.default.MenuSharedRealTimeTickSpeedLabel)).editRange(e=>e.setMin(Math.round(a.TickSpeed.Min * i.interval)).setMax(Math.round(a.TickSpeed.Max * i.interval)).setRefreshMethod(()=>Math.round(game.getTickSpeed() * i.interval))).addDefaultButton(()=>Math.round(a.TickSpeed.Default * i.interval)).setDisplayValue(o.default.ui(n.default.MenuSharedValueTickSpeed).get).setTooltip(e=>e.setLocation(l.TooltipLocation.CenterRight).setMaxWidth(200).addText(e=>e.setText(n.default.MenuSharedRealTimeTickSpeedTooltip))).on(u.RangeInputEvent.Finish, (e,t)=>{
                saveDataGlobal.options.realTimeTickSpeed = t / i.interval,
                game.setTickSpeed(saveDataGlobal.options.realTimeTickSpeed)
            }
            ).appendTo(this.content),
            this.turnMode.on(s.ChoiceListEvent.Choose, ()=>{
                this.updateTurnModes(),
                game.setTurnMode(this.turnMode.choice === this.choiceTurnModeSimulated ? a.TurnMode.Simulated : this.turnMode.choice === this.choiceTurnModeManual ? a.TurnMode.Manual : a.TurnMode.RealTime),
                this.tickSpeed.setDisabled(this.turnMode.choice === this.choiceTurnModeManual),
                game.paused || game.getTurnMode() !== a.TurnMode.RealTime || multiplayer.isConnected() || game.setPaused(!0, !0)
            }
            ).setChoices(this.choiceTurnModeManual = new s.Choice(this.api,void 0).setText(n.default.MenuNewGameChoiceTurnModeManual).addDescription(e=>e.setText(n.default.MenuNewGameChoiceTurnModeManualDescription)).setRefreshMethod(()=>game.getTurnMode() === a.TurnMode.Manual), this.choiceTurnModeSimulated = new s.Choice(this.api,void 0).setText(n.default.MenuNewGameChoiceTurnModeSimulated).addDescription(e=>e.setText(n.default.MenuNewGameChoiceTurnModeSimulatedDescription)).setRefreshMethod(()=>game.getTurnMode() === a.TurnMode.Simulated), this.choiceTurnModeRealTime = new s.Choice(this.api,void 0).setText(n.default.MenuNewGameChoiceTurnModeRealTime).addDescription(e=>e.setText(n.default.MenuNewGameChoiceTurnModeRealTimeDescription)).setRefreshMethod(()=>game.getTurnMode() === a.TurnMode.RealTime)).setRefreshMethod(()=>{
                const e = game.getTurnMode();
                return e === a.TurnMode.Simulated ? this.choiceTurnModeSimulated : e === a.TurnMode.Manual ? this.choiceTurnModeManual : this.choiceTurnModeRealTime
            }
            ),
            new c.default(this.api).appendTo(this.content),
            this.on("Show", this.refresh);
            const t = this.until("Remove");
            t.bind(multiplayer, [r.MultiplayerEvent.Connect, r.MultiplayerEvent.Disconnect], ()=>{
                this.updateTurnModes()
            }
            )
        }
        refresh() {
            this.turnMode.refresh(),
            this.tickSpeed.refresh(),
            this.updateTurnModes()
        }
        updateTurnModes() {
            const e = multiplayer.isServer();
            this.choiceTurnModeManual.setDisabled(e),
            this.choiceTurnModeSimulated.setDisabled(!e),
            steamworks.isDedicatedServer() ? this.choiceTurnModeManual.hide() : this.choiceTurnModeManual.show()
        }
    }
    __decorate([m.Bound], h.prototype, "refresh", null),
    t.default = h
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Clipboard", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        function t(e) {
            const t = document.createElement("textarea");
            t.value = e,
            document.body.appendChild(t),
            t.select(),
            document.execCommand("copy"),
            document.body.removeChild(t)
        }
        e.write = t
    }(a || (a = {})),
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/UUID", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        const t = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;
        function a() {
            return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1)
        }
        function i() {
            return `${a()}${a()}-${a()}-${a()}-${a()}-${a()}${a()}${a()}`
        }
        function n(e) {
            return null !== e.match(t)
        }
        e.create = i,
        e.isValid = n
    }(a || (a = {})),
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/pause/MultiplayerOptionsMenu", ["require", "exports", "Enums", "language/dictionary/UiTranslation", "multiplayer/IMultiplayer", "newui/component/Button", "newui/component/CheckButton", "newui/component/ChoiceList", "newui/component/IComponent", "newui/component/RangeInput", "newui/component/RangeRow", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "steamworks/ISteamworks", "utilities/Clipboard", "utilities/Objects", "utilities/UUID"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class f extends p.default {
        constructor(e) {
            super(e, "multiplayer-menu"),
            this.setTitle(e=>e.setText(i.default.MenuMultiplayerOptionsTitle)),
            this.setDescription(e=>e.setText(i.default.MenuMultiplayerOptionsDescription)),
            this.openServer = new r.CheckButton(this.api).setText(i.default.MenuMultiplayerOptionsOpenServer).addDescription(e=>e.setText(i.default.MenuMultiplayerOptionsOpenServerDescription)).setRefreshMethod(()=>multiplayer.isServer()).on(r.CheckButtonEvent.Change, (e,t)=>{
                t ? (game.paused || game.setPaused(!0, !0),
                game.setTurnMode(a.TurnMode.Simulated),
                multiplayer.createServer(g.default.create())) : (multiplayer.disconnect(),
                game.getTurnMode() === a.TurnMode.Simulated && game.setTurnMode(a.TurnMode.Manual))
            }
            ).appendTo(this.content),
            new c.default(this.api).appendTo(this.content),
            this.copyGameCode = new o.default(this.api).on(o.ButtonEvent.Activate, this.copyGameCodeClick).setText(i.default.MenuMultiplayerOptionsCopyGameCode).setTooltip(e=>e.setLocation(l.TooltipLocation.CenterRight).addText(e=>e.setText(i.default.MenuMultiplayerOptionsCopyGameCodeTooltip))).appendTo(this.content),
            this.inviteSteamFriends = new o.default(this.api).on(o.ButtonEvent.Activate, this.inviteSteamFriendsClick).setText(i.default.MenuMultiplayerOptionsInviteSteamFriends).appendTo(this.content),
            new c.default(this.api).appendTo(this.content);
            const t = [];
            steamworks.isDedicatedServer() || (this.choiceLobbyFriends = new s.Choice(this.api,void 0).setText(i.default.MenuSharedMultiplayerChoiceLobbyTypeFriends).addDescription(e=>e.setText(i.default.MenuSharedMultiplayerChoiceLobbyTypeFriendsDescription)),
            t.push(this.choiceLobbyFriends)),
            this.choiceLobbyPublic = new s.Choice(this.api,void 0).setText(i.default.MenuSharedMultiplayerChoiceLobbyTypePublic).addDescription(e=>e.setText(i.default.MenuSharedMultiplayerChoiceLobbyTypePublicDescription)),
            t.push(this.choiceLobbyPublic),
            this.choiceLobbyPrivate = new s.Choice(this.api,void 0).setText(i.default.MenuSharedMultiplayerChoiceLobbyTypePrivate).addDescription(e=>e.setText(i.default.MenuSharedMultiplayerChoiceLobbyTypePrivateDescription)),
            t.push(this.choiceLobbyPrivate),
            this.lobbyType = new s.default(this.api).setRefreshMethod(()=>{
                switch (multiplayer.getOptions().lobbyType) {
                case m.LobbyType.Private:
                    return this.choiceLobbyPrivate;
                case m.LobbyType.Public:
                    return this.choiceLobbyPublic;
                default:
                    return steamworks.isDedicatedServer() ? this.choiceLobbyPublic : this.choiceLobbyFriends
                }
            }
            ).on(s.ChoiceListEvent.Choose, (e,t)=>{
                const a = t === this.choiceLobbyFriends ? m.LobbyType.FriendsOnly : t === this.choiceLobbyPublic ? m.LobbyType.Public : m.LobbyType.Private;
                multiplayer.getOptions().lobbyType !== a && multiplayer.updateOptions({
                    lobbyType: a
                })
            }
            ).setChoices(t).appendTo(this.content),
            this.pvp = new r.CheckButton(this.api).setText(i.default.MenuSharedMultiplayerChoicePVP).addDescription(e=>e.setText(i.default.MenuSharedMultiplayerChoicePVPDescription)).setRefreshMethod(()=>multiplayer.getOptions().pvp).on(r.CheckButtonEvent.Change, (e,t)=>{
                multiplayer.updateOptions({
                    pvp: t
                })
            }
            ).appendTo(this.content),
            this.maxPlayers = new d.RangeRow(this.api).setLabel(e=>e.setText(i.default.MenuSharedMultiplayerMaxPlayers)).editRange(e=>e.setMin(2).setMax(n.maxPlayers).setRefreshMethod(()=>multiplayer.getOptions().maxPlayers)).addDefaultButton(()=>n.maxPlayers).setDisplayValue(!0).on(u.RangeInputEvent.Finish, (e,t)=>{
                multiplayer.updateOptions({
                    maxPlayers: t
                })
            }
            ).appendTo(this.content),
            this.on("Show", this.refresh);
            const p = this.until("Remove");
            p.bind(multiplayer, [n.MultiplayerEvent.Connect, n.MultiplayerEvent.Disconnect, n.MultiplayerEvent.JoinLobby, n.MultiplayerEvent.LeaveLobby], ()=>{
                this.updateMultiplayer()
            }
            )
        }
        refresh() {
            this.openServer.refresh(),
            this.lobbyType.refresh(),
            this.pvp.refresh(),
            this.maxPlayers.refresh(),
            this.updateMultiplayer()
        }
        updateMultiplayer() {
            steamworks.isDedicatedServer() && (this.openServer.hide(),
            this.inviteSteamFriends.hide());
            const e = multiplayer.isServer();
            this.copyGameCode.setDisabled(!e),
            steamworks.isOverlayWorking() && steamworks.isInLobby() ? this.inviteSteamFriends.show() : this.inviteSteamFriends.hide()
        }
        copyGameCodeClick() {
            const e = multiplayer.getConnectedGameCode();
            void 0 !== e && h.default.write(e)
        }
        inviteSteamFriendsClick() {
            steamworks.openInviteDialog()
        }
    }
    __decorate([y.Bound], f.prototype, "refresh", null),
    __decorate([y.Bound], f.prototype, "copyGameCodeClick", null),
    __decorate([y.Bound], f.prototype, "inviteSteamFriendsClick", null),
    t.default = f
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/PauseMenu", ["require", "exports", "Enums", "game/IGame", "language/dictionary/InterruptChoice", "language/dictionary/UiTranslation", "language/Translation", "newui/component/BlockRow", "newui/component/Button", "newui/component/CheckButton", "newui/component/Component", "newui/component/Text", "newui/screen/IScreen", "newui/screen/screens/game/static/Messages", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/screen/screens/menu/menus/pause/DifficultyOptionsIcons", "newui/screen/screens/menu/menus/pause/ModesMenu", "newui/screen/screens/menu/menus/pause/MultiplayerOptionsMenu", "newui/util/Misc", "newui/util/Style", "resources/IResourceLoader", "utilities/Async", "utilities/enum/Enums", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class D extends y.default {
        constructor(e) {
            super(e, h.MenuId.Pause),
            this.classes.add("menu-interrupt-style"),
            this.canCancel = !0,
            this.content.append(new p.Heading(this.api).setText(this.getHeadingText), new p.Paragraph(this.api).setText(this.getParagraphText), this.difficultyOptionIcons = new d.default(this.api).classes.add("difficulty-options-icons"), !steamworks.isDedicatedServer() && new l.default(this.api).setText(o.default.MenuPauseButtonContinue).on(l.ButtonEvent.Activate, I.menuSwitcher(h.MenuId.BACK)), this.optionsRow = new s.BlockRow(this.api), this.multiplayerRow = new s.BlockRow(this.api), new l.default(this.api).setText(steamworks.isDedicatedServer() ? o.default.MenuPauseButtonStopServer : o.default.MenuPauseButtonTitleScreen).on(l.ButtonEvent.Activate, this.onQuitButtonClick), new g.default(this.api), steamworks.isDedicatedServer() && new m.default(this.api)),
            new l.default(this.api).setText(o.default.MenuPauseButtonOptions).on(l.ButtonEvent.Activate, I.menuSwitcher(h.MenuId.Options)).appendTo(this.optionsRow),
            this.modesButton = new l.default(this.api).setText(o.default.MenuPauseButtonModes).on(l.ButtonEvent.Activate, this.showWModesMenu),
            this.pauseButton = new u.CheckButton(this.api).setText(o.default.MenuPauseButtonPaused).setRefreshMethod(()=>game.paused).on(u.CheckButtonEvent.Change, (e,t)=>{
                game.setPaused(t)
            }
            ),
            this.multiplayerButton = new l.default(this.api).setText(o.default.MenuPauseButtonMultiplayer).on(l.ButtonEvent.Activate, this.showMultiplayerOptionsMenu),
            this.refreshDifficultyOptions(),
            this.on("Show", this.onShow);
            const t = this.until("Remove");
            t.bind(game, [i.GameEvent.Pause, i.GameEvent.Resume], this.pauseButton.refresh)
        }
        showMultiplayerOptionsMenu() {
            return I.switchMenu(this.multiplayerOptionsMenu = this.multiplayerOptionsMenu || new S.default(this.api)),
            this
        }
        showWModesMenu() {
            return I.switchMenu(new T.default(this.api)),
            this
        }
        onShow() {
            this.isSubmenu = !1;
            const e = !multiplayer.isConnected() || multiplayer.isServer();
            e ? (this.modesButton.appendTo(this.optionsRow),
            this.multiplayerRow.append([game.getTurnMode() !== a.TurnMode.Manual && this.pauseButton, this.multiplayerButton]).appendTo(this.content, {
                after: this.optionsRow
            }),
            game.getTurnMode() === a.TurnMode.Manual && this.pauseButton.store()) : (this.modesButton.store(),
            this.pauseButton.store(),
            this.multiplayerRow.store())
        }
        refreshDifficultyOptions() {
            this.difficultyOptionIcons.dump();
            const e = game.getDifficultyOptions();
            b.default.values(f.DifficultyOptionsIcon).map(e=>k.tuple(e, f.default[e])).filter(([,{check: t}])=>t(e)).forEach(([t,a],i)=>new d.default(this.api).classes.add("icon-difficulty-options", "has-icon-before", "icon-center").setStyle("--index", i).setStyle("--difficulty-options-icon", this.getDifficultyOptionsIcon(t, a)).setTooltip(a.tooltip ? t=>a.tooltip(t, e) : void 0).appendTo(this.difficultyOptionIcons)),
            this.difficultyOptionIcons.setStyle("--icon-count", this.difficultyOptionIcons.childCount)
        }
        getDifficultyOptionsIcon(e, t) {
            let a;
            return t && t.imagePath && (a = t.imagePath),
            v.default.getImagePath(w.PathType.DifficultyOptionsIcon, e, void 0, !0, a)
        }
        getHeadingText() {
            return steamworks.isDedicatedServer() ? [{
                content: saveData.gameSlotName
            }] : game.paused || !game.isRealTimeMode() && game.getTurnMode() !== a.TurnMode.Simulated ? o.default.MenuPauseHeadingPaused : o.default.MenuPauseHeadingNotPaused
        }
        getParagraphText() {
            return steamworks.isDedicatedServer() ? [{
                content: multiplayer.getOptions().description || ""
            }] : game.paused || !game.isRealTimeMode() && game.getTurnMode() !== a.TurnMode.Simulated ? o.default.MenuPauseParagraphPaused : o.default.MenuPauseParagraphNotPaused
        }
        async onQuitButtonClick() {
            const e = localPlayer.state === a.PlayerState.Ghost;
            let t = !0
              , i = !0
              , s = !1;
            if (game.isChallenge ? (i = !1,
            t = multiplayer.isConnected() ? multiplayer.isServer() ? await this.api.interrupt(o.default .MenuPauseInterruptReturnToTitleScreen).withDescription(r.default .ui(o.default .MenuPauseInterruptReturnToTitleScreenChallengeMultiplayerDescription).addArgs(players.length-1)).withConfirmation() : await this.api.interrupt(o.default .MenuPauseInterruptReturnToTitleScreen).withConfirmation() : await this.api.interrupt(o.default .MenuPauseInterruptReturnToTitleScreen).withDescription(r.default .ui(o.default .MenuPauseInterruptReturnToTitleScreenChallengeDescription).addArgs(e)).withConfirmation()) : multiplayer.isConnected() ? multiplayer.isServer() ? (t = await this.api.interrupt(o.default .MenuPauseInterruptReturnToTitleScreen).withDescription(r.default .ui(o.default .MenuPauseInterruptReturnToTitleScreenMultiplayerDescription).addArgs(players.length-1,e)).withConfirmation(),
            e && (s = !0)) : t = await this.api.interrupt(o.default .MenuPauseInterruptReturnToTitleScreen).withConfirmation() : e ? s = !0 : t = await this.api.interrupt(o.default .MenuPauseInterruptReturnToTitleScreen).withDescription(o.default .MenuPauseInterruptReturnToTitleScreenDescription).withConfirmation(),
            t) {
                if (s) {
                    this.api.getVisibleScreen().classes.until(650).add("insta-animation-in", "insta-animation-out", "insta-animation-submenu");
                    const e = await this.api.interrupt(o.default .MenuPauseInterruptGhostKeepSave).withDescription(o.default .MenuPauseInterruptGhostKeepSaveDescription).withChoice(n.default .Yes,n.default .NoWarn,n.default .Cancel);
                    switch (e) {
                    case n.default.Cancel:
                        return;
                    case n.default.NoWarn:
                        saveManager.deleteSlot(game.slot),
                        i = !1
                    }
                }
                this.api.getVisibleScreen().classes.until(650).add("insta-animation-in", "insta-animation-out", "insta-animation-submenu"),
                this.api.hideScreen(c.ScreenId.Interrupt),
                await this.api.interrupt(i?o.default .GameInterruptLoadingSaving:o.default .GameInterruptLoadingQuitting).withDescription(i?o.default .GameInterruptLoadingSavingDescription:o.default .GameInterruptLoadingQuittingDescription).withLoading(),
                this.api.getVisibleScreen().classes.until(650).add("insta-animation-in", "insta-animation-out", "insta-animation-submenu"),
                await M.sleep(100),
                await game.resetGameState(!i)
            }
        }
    }
    __decorate([C.Bound], D.prototype, "showMultiplayerOptionsMenu", null),
    __decorate([C.Bound], D.prototype, "showWModesMenu", null),
    __decorate([C.Bound], D.prototype, "onShow", null),
    __decorate([C.Bound], D.prototype, "getHeadingText", null),
    __decorate([C.Bound], D.prototype, "getParagraphText", null),
    __decorate([C.Bound], D.prototype, "onQuitButtonClick", null),
    t.default = D
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/MenuMap", ["require", "exports", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/menus/CharacterSelectionMenu", "newui/screen/screens/menu/menus/GameEndMenu", "newui/screen/screens/menu/menus/HelpMenu", "newui/screen/screens/menu/menus/HighscoresMenu", "newui/screen/screens/menu/menus/InterruptMenu", "newui/screen/screens/menu/menus/JoinServerMenu", "newui/screen/screens/menu/menus/LoadGameMenu", "newui/screen/screens/menu/menus/MainMenu", "newui/screen/screens/menu/menus/ModsMenu", "newui/screen/screens/menu/menus/MultiplayerMenu", "newui/screen/screens/menu/menus/NewGameMenu", "newui/screen/screens/menu/menus/OptionsMenu", "newui/screen/screens/menu/menus/PauseMenu"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const g = {
        [a.MenuId.CharacterSelection]: i.default,
        [a.MenuId.GameEnd]: n.default,
        [a.MenuId.Help]: o.default,
        [a.MenuId.Highscores]: r.default,
        [a.MenuId.Interrupt]: s.default,
        [a.MenuId.JoinServer]: l.default,
        [a.MenuId.LoadGame]: u.default,
        [a.MenuId.Main]: d.default,
        [a.MenuId.Mods]: p.default,
        [a.MenuId.Multiplayer]: c.default,
        [a.MenuId.NewGame]: m.default,
        [a.MenuId.Options]: h.default,
        [a.MenuId.Pause]: y.default
    };
    t.default = g
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/component/MenuScreen", ["require", "exports", "newui/screen/Screen", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/MenuMap", "utilities/iterable/Collectors", "utilities/Objects"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l extends a.default {
        constructor(e, t) {
            super(e, t),
            this.menus = {},
            this.menuChain = [],
            this.on("Hide", this.onHide)
        }
        get visibleMenu() {
            return this.menuChain.collect(r.default.last())
        }
        showMenu(e, t) {
            "number" == typeof e && (e = this.getMenu(e));
            const a = this.menuChain.collect(r.default.last());
            return a === e ? this : (void 0 !== a && this.visibleMenu.classes.remove("right").classes.add("left").hide(),
            this.menuChain.push(e),
            e.appendTo(this).classes.remove("left").classes.add("right").classes.toggle(void 0 !== a, "submenu").schedule(t).show(),
            this)
        }
        backOneMenu() {
            return this.menuChain.length < 2 ? this : (this.visibleMenu.classes.remove("left").classes.add("right").hide().emit(n.MenuEvent.GoBackFrom),
            this.menuChain.pop(),
            this.visibleMenu.classes.remove("right").classes.add("left").show(),
            this)
        }
        backToFirstMenu() {
            return this.menuChain.length < 2 ? this : (this.visibleMenu.classes.remove("left").classes.add("right").hide().emit(n.MenuEvent.GoBackFrom),
            this.menuChain.splice(1, 1 / 0),
            this.visibleMenu.classes.remove("right").classes.add("left").show(),
            this)
        }
        getMenu(e) {
            if (this.menus[e])
                return this.menus[e];
            this.log.info(`Initialized menu '${i.MenuId[e]}'`);
            const t = o.default[e];
            if (!t)
                throw this.log.error(`Can't load the menu by id: ${e} (${i.MenuId[e]})`),
                new Error("Being unable to initialize a menu is non-recoverable.");
            return this.menus[e] = new t(this.api).appendTo(this)
        }
        removeFromChain(e) {
            const t = this.menuChain.indexOf(e);
            return t > -1 && this.menuChain.splice(t, 1),
            this
        }
        setTopMenu(e=this.visibleMenu) {
            for (; this.menuChain[0] !== e; )
                this.menuChain.shift();
            return this
        }
        onHide() {
            this.visibleMenu && this.visibleMenu.hide()
        }
    }
    __decorate([s.Bound], l.prototype, "showMenu", null),
    __decorate([s.Bound], l.prototype, "onHide", null),
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/Text", ["require", "exports", "language/segment/TextDecorationSegments", "language/Translation", "newui/component/Component", "newui/screen/screens/menu/component/IMenu", "utilities/iterable/Collectors", "utilities/Objects"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l extends n.default {
        constructor(e, t="span") {
            super(e, t),
            this.segments = [],
            this.classes.add("text"),
            this.listen("refresh", this.refresh)
        }
        static resolve(e, t=[]) {
            let a = "function" == typeof e ? e() : e;
            if (!a)
                return [];
            "number" == typeof a ? a = i.default.ui(a) : i.default.isSerializedTranslation(a) && (a = i.default.deserialize(a)),
            a instanceof i.default && (a = a.withSegments(...t).get()),
            a = Array.isArray(a) ? a : a.collect(r.default.toArray);
            const n = [];
            for (const e of a) {
                const t = n.collect(r.default.last());
                t && l.areIdenticalSections(e, t) ? t.content += e.content : n.push(Object.assign({}, e))
            }
            return n
        }
        static areIdenticalSections(e, t) {
            const a = Object.keys(e);
            if (a.length !== Object.keys(t).length)
                return !1;
            for (const i of a)
                if ("content" !== i && e[i] !== t[i])
                    return !1;
            return !0
        }
        static toString(e, t=[]) {
            return l.resolve(e, t).map(e=>e.content).join("")
        }
        setSegments(...e) {
            return this.segments = e,
            this.refresh(),
            this
        }
        setText(e) {
            return this.text && !e && this.dumpFast(),
            this.text = e,
            this.refresh(),
            this
        }
        getText() {
            return this.text
        }
        getTextAsString() {
            return l.toString(this.text, this.segments)
        }
        refresh() {
            if (!this.text)
                return;
            this.dumpFast();
            const e = l.resolve(this.text, this.segments);
            if (e)
                for (const t of e)
                    new p(this.api).setText(t).appendTo(this)
        }
    }
    __decorate([s.Bound], l.prototype, "refresh", null),
    t.default = l;
    class u extends l {
        constructor(e) {
            super(e, "p"),
            this.classes.add("paragraph")
        }
    }
    t.Paragraph = u;
    class d extends l {
        constructor(e) {
            super(e, "h1"),
            this.classes.add("heading")
        }
    }
    t.Heading = d;
    class p extends n.default {
        constructor(e) {
            super(e, "span"),
            this.classes.add("text-basic")
        }
        setText(e) {
            this.attributes.set("style", "color"in e ? `color:${e.color}` : ""),
            this.dataset.text = e.content;
            for (const [t,i] of a.getDecorations(e))
                this.classes.toggle(!!i, `text-decoration-${a.TextDecoration[t].toLowerCase()}`);
            return this.classes.toggle("fontSize"in e && "heading" === e.fontSize, "heading"),
            this._link = "link"in e ? e.link : void 0,
            this.classes.toggle(!!this._link, "link"),
            this._link ? this.listen("click", this.onClick) : this.element.removeEventListener("click", this.onClick),
            this
        }
        setLinkHandler(e) {
            this.linkHandler = e
        }
        onClick() {
            if (!(void 0 === this._link || this.linkHandler && this.linkHandler(this._link)))
                if ("string" == typeof this._link)
                    steamworks.openUrl(this._link);
                else {
                    const [e,t] = this._link;
                    this.api.getVisibleScreen().showMenu(o.MenuId[e], e=>{
                        t && e.scrollToTabSection(isNaN(+t) ? t : +t)
                    }
                    )
                }
        }
    }
    __decorate([s.Bound], p.prototype, "onClick", null),
    t.BasicText = p
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/Button", ["require", "exports", "newui/BindingManager", "newui/component/Component", "newui/component/IComponent", "newui/component/Text", "utilities/Objects"], function(e, t, a, i, n, o, r) {
    var s;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Activate = "Activate"
    }(s = t.ButtonEvent || (t.ButtonEvent = {}));
    class l extends i.default {
        constructor(e, t, a=!0) {
            super(e, t),
            this.playSound = !0,
            this._activated = !1,
            this._disabled = !1,
            this.setSelectable(n.SelectableLayer.Primary),
            this.classes.add("button"),
            this.text = new o.default(this.api).classes.add("button-text").appendTo(this),
            a && (this.element.addEventListener("click", this._onActivate),
            this.element.addEventListener("activate", this._onActivate))
        }
        get disabled() {
            return this._disabled
        }
        setDisabled(e=!0) {
            return this._disabled = e,
            this.classes.toggle(e, "disabled"),
            this
        }
        activate(e=this.playSound) {
            if (!this._disabled && !this._activated) {
                e && this.api.playActivateSound(),
                this._activated = !0;
                try {
                    this.emit(s.Activate)
                } finally {
                    this._activated = !1
                }
            }
        }
        addButton(e) {
            return this.classes.add("has-button-buttons"),
            this.buttons || (this.buttons = new i.default(this.api).classes.add("button-buttons").appendTo(this, this.description ? n.AppendStrategy.after(this.description) : n.AppendStrategy.Append)),
            e(new l(this.api).setSelectable(n.SelectableLayer.Secondary).classes.add("has-icon-before", "icon-center", "selectable-escapeable")).appendTo(this.buttons),
            this
        }
        addDescription(e) {
            return this.description && this.description.remove(),
            this.append(this.description = new o.Paragraph(this.api).schedule(e))
        }
        setText(e) {
            return this.text.setText(e),
            this
        }
        getText() {
            return this.text.getText()
        }
        getTextAsString() {
            return this.text.getTextAsString()
        }
        refreshText() {
            return this.text.refresh(),
            this
        }
        _onActivate(e) {
            if (!(a.bindingManager.areBindsDisabled() || e && "button"in e && 0 !== e.button)) {
                e && e.stopPropagation();
                const t = this.api.getVisibleScreen();
                t && t.hideContextMenu(),
                this.activate(),
                this.element.blur()
            }
        }
    }
    __decorate([r.Bound], l.prototype, "refreshText", null),
    __decorate([r.Bound], l.prototype, "_onActivate", null),
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/menus/GameEndMenu", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/GameEndMessage", "language/dictionary/InterruptChoice", "language/dictionary/UiTranslation", "language/Translation", "newui/component/Button", "newui/component/Text", "newui/screen/IScreen", "newui/screen/screens/menu/component/HighscoreRow", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/Menu", "newui/screen/screens/menu/component/Spacer", "newui/util/Misc", "utilities/Async", "utilities/Objects", "utilities/string/Interpolator"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class S extends m.default {
        constructor(e) {
            super(e, c.MenuId.GameEnd),
            new u.Heading(e).setText(this.getHeading).appendTo(this.content),
            new u.Paragraph(e).setText(this.getTagline).appendTo(this.content),
            new h.default(e).appendTo(this.content),
            this.highscore = new p.HighscoreRow(e).appendTo(this.content),
            new h.default(e).appendTo(this.content),
            new l.default(e).classes.add("button-facebook", "has-icon-before", "icon-scale").on(l.ButtonEvent.Activate, this.share("facebook")).setText(r.default.MenuGameEndShareFacebook).appendTo(this.content),
            new l.default(e).classes.add("button-twitter", "has-icon-before", "icon-scale").on(l.ButtonEvent.Activate, this.share("twitter")).setText(r.default.MenuGameEndShareTwitter).appendTo(this.content),
            new h.default(e).appendTo(this.content),
            new l.default(e).on(l.ButtonEvent.Activate, this.continue).setText(this.getContinueButtonText).appendTo(this.content),
            new l.default(e).on(l.ButtonEvent.Activate, this.exitToMenu).setText(r.default.MenuGameEndExitToMenu).appendTo(this.content),
            this.on("Show", this.onShow)
        }
        setGameEndData(e) {
            return this.gameEndData = e,
            this
        }
        onShow() {
            this.isSubmenu = !1;
            const e = this.api.getVisibleScreen();
            e.background = this.gameEndData.state === a.PlayerState.Won ? d.Background.Win : d.Background.Death,
            e.setTopMenu(this),
            this.api.refreshTranslations(this.content),
            this.highscore.highscore = this.gameEndData.highscore,
            this.highscore.place = [...saveDataGlobal.gameHighscores].filter(e=>e.difficulty === this.gameEndData.highscore.difficulty).sort((e,t)=>t.score - e.score).findIndex(e=>e.date === this.gameEndData.highscore.date) + 1
        }
        getHeading() {
            return this.gameEndData && this.gameEndData.state === a.PlayerState.Won ? r.default.MenuGameEndTitleWon : r.default.MenuGameEndTitleDead
        }
        getTagline() {
            const e = this.gameEndData ? this.gameEndData.state : a.PlayerState.Dead;
            return new s.default(i.Dictionary.GameEndMessage,e === a.PlayerState.Won ? n.GameEndMessage.Win : n.GameEndMessage.Dead,s.default.RANDOM)
        }
        getContinueButtonText() {
            return this.gameEndData && this.gameEndData.state === a.PlayerState.Won ? r.default.MenuGameEndReturnToIsland : r.default.MenuGameEndContinueAsGhost
        }
        continue() {
            y.switchMenu(c.MenuId.BACK),
            game.playing = !0
        }
        async exitToMenu() {
            game.playing = !0;
            const e = !this.gameEndData || this.gameEndData.state === a.PlayerState.Dead;
            let t = !0
              , i = !0
              , n = !1;
            if (game.isChallenge ? (i = !1,
            t = multiplayer.isConnected() ? multiplayer.isServer() ? await this.api.interrupt(r.default .MenuGameEndInterruptReturnToTitleScreen).withDescription(s.default .ui(r.default .MenuGameEndInterruptReturnToTitleScreenChallengeMultiplayerDescription).addArgs(players.length-1)).withConfirmation() : await this.api.interrupt(r.default .MenuGameEndInterruptReturnToTitleScreen).withConfirmation() : await this.api.interrupt(r.default .MenuGameEndInterruptReturnToTitleScreen).withDescription(r.default .MenuGameEndInterruptReturnToTitleScreenChallengeDescription).withConfirmation()) : multiplayer.isConnected() ? multiplayer.isServer() ? (t = await this.api.interrupt(r.default .MenuGameEndInterruptReturnToTitleScreen).withDescription(s.default .ui(r.default .MenuGameEndInterruptReturnToTitleScreenMultiplayerDescription).addArgs(players.length-1)).withConfirmation(),
            n = !0) : t = await this.api.interrupt(r.default .MenuGameEndInterruptReturnToTitleScreen).withConfirmation() : n = !0,
            t) {
                if (n) {
                    this.api.getVisibleScreen().classes.until(650).add("insta-animation-in", "insta-animation-out").visibleMenu.classes.until(650).add("insta-animation-in", "insta-animation-out");
                    const t = await this.api.interrupt(e?r.default .MenuGameEndInterruptGhostDeleteSave:r.default .MenuGameEndInterruptWonDeleteSave).withDescription(r.default .MenuGameEndInterruptDeleteSaveDescription).withChoice(o.default .Yes,o.default .NoWarn,o.default .Cancel);
                    switch (t) {
                    case o.default.Cancel:
                        return;
                    case o.default.NoWarn:
                        saveManager.deleteSlot(game.slot),
                        i = !1
                    }
                }
                this.api.getVisibleScreen().classes.until(650).add("insta-animation-in", "insta-animation-out", "insta-animation-submenu"),
                this.api.interrupt(i ? r.default.GameInterruptLoadingSaving : r.default.GameInterruptLoadingQuitting).withDescription(i ? r.default.GameInterruptLoadingSavingDescription : r.default.GameInterruptLoadingQuittingDescription).withLoading(),
                await g.sleep(1e3),
                this.api.getVisibleScreen().removeFromChain(this),
                this.emit(m.MenuEvent.GoBackFrom),
                await game.resetGameState(!i)
            }
        }
        share(e) {
            return ()=>{
                steamworks.openUrl(T.interpolate(I[e], localPlayer.score))
            }
        }
    }
    __decorate([f.Bound], S.prototype, "onShow", null),
    __decorate([f.Bound], S.prototype, "getHeading", null),
    __decorate([f.Bound], S.prototype, "getTagline", null),
    __decorate([f.Bound], S.prototype, "getContinueButtonText", null),
    __decorate([f.Bound], S.prototype, "continue", null),
    __decorate([f.Bound], S.prototype, "exitToMenu", null),
    t.default = S;
    const I = {
        facebook: "https://www.facebook.com/sharer/sharer.php?u=http%3A//store.steampowered.com/app/379210/",
        twitter: "https://twitter.com/home?status=I%20got%20a%20highscore%20of%20{0}%20in%20Wayward%20http%3A//store.steampowered.com/app/379210/%20%23wayward"
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/note/Corpse", ["require", "exports", "creature/corpse/Corpses", "language/dictionary/Note"], function(e, t, a, i) {
    function n(e, t) {
        if (!t.corpses || t.corpses.length < 1)
            return;
        const n = t.corpses.filter(e=>!a.default[e.type] || !a.default[e.type].blood);
        e.notes.write(i.default.Corpse, {
            corpses: corpseManager.getCorpseListTranslation(n),
            multiple: n.length > 1
        })
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/Player", ["require", "exports", "action/ActionExecutor", "action/IAction", "creature/Creature", "creature/Pathing", "entity/Human", "entity/IEntity", "entity/IStats", "entity/StatusEffects", "Enums", "game/Challenge", "game/IGame", "item/ItemRecipeRequirementChecker", "item/Items", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Misc", "language/dictionary/Note", "language/dictionary/UiTranslation", "language/Translation", "mod/IHookManager", "multiplayer/IMultiplayer", "multiplayer/packets/client/DisplayInterruptPacket", "multiplayer/packets/server/UpdateDialogInfoPacket", "multiplayer/packets/server/UpdateQuickSlotInfoPacket", "multiplayer/packets/shared/UpdateMovementIntentPacket", "multiplayer/packets/shared/UpdateWalkPathPacket", "newui/BindingManager", "newui/screen/IScreen", "newui/screen/screens/menu/component/IMenu", "player/Customizations", "player/IMessageManager", "player/IMilestone", "player/IPlayer", "player/MessageManager", "player/Milestones", "player/note/Corpse", "player/note/NoteManager", "player/quest/quest/IQuest", "player/quest/QuestManager", "save/ISerializer", "tile/ITileEvent", "tile/Terrains", "utilities/Arrays", "utilities/Async", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/Log", "utilities/math/Math2", "utilities/Objects", "utilities/Random", "utilities/TileHelpers", "utilities/TilePosition"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L, O, F, _, H, W, N, q, U, z, V, j, Q, $, Y, J, K, X, Z) {
    var ee;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.None = 0] = "None",
        e[e.DangerousObject = 1] = "DangerousObject",
        e[e.GatherOnFire = 2] = "GatherOnFire"
    }(ee || (ee = {}));
    class te extends r.default {
        constructor(e) {
            super(),
            this.entityType = s.EntityType.Player,
            this.absentLastUsedTime = 0,
            this.containerSortInfo = {},
            this.dialogContainerInfo = [],
            this.dialogInfo = {},
            this.hintSeen = [],
            this.isConnecting = !1,
            this.isMoving = !1,
            this.movementComplete = !1,
            this.movementCompleteZ = void 0,
            this.noInputReceived = !1,
            this.quickSlotInfo = [],
            this.realTimeTickActionDelay = 0,
            this.revealedItems = {},
            this.spawnPoint = {},
            this.tamedCreatures = [],
            this.turns = 0,
            this.walkSoundCounter = 4,
            this.isMovingClientside = !1,
            this.wasAbsentPlayer = !1,
            this.nextX = -1,
            this.nextY = -1,
            this.movementProgress = 1,
            this.movementFinishTime = 0,
            this.nextMoveTime = 0,
            this._milestoneUpdates = [],
            this._movementIntent = {},
            e && (this.identifier = e),
            this.notes = new _.default({
                onWriteNote: this.onWriteNote,
                canWriteInHours: this.canWriteInHours,
                canWriteNote: this.canWriteNote
            }),
            this.messages = new L.default({
                canSeePosition: (e,t,a)=>this.canSeePosition(e, t, a, !0),
                shouldDisplayMessage: this.shouldDisplayMessage,
                onDisplayMessage: this.onDisplayMessage,
                getMessageStorageMax: ()=>this.isLocalPlayer() ? 5e3 : 50
            }),
            this.quests = new W.default(this),
            this.on(s.EntityEvent.StatChanged, this.onStatChange),
            this.on(s.EntityEvent.StatMaxChanged, (e,t,a)=>{
                t.type === l.Stat.Strength && this.updateStrength()
            }
            ),
            this.on(s.EntityEvent.StatusChange, this.onStatusEffectChanged)
        }
        get clientStore() {
            return saveManager.getClientStore(this)
        }
        setOptions(e) {
            super.setOptions(e),
            this.updateHandToUse()
        }
        setStatChangeTimerIgnoreDifficultyOptions(e, t, a) {
            super.setStatChangeTimer(e, t, a)
        }
        setStatChangeTimer(e, t, a) {
            const i = "number" == typeof e ? e : e.type
              , n = game.getDifficultyOptions().player.stats.get(i);
            if (n) {
                if (0 === n.changeTimerMultiplier) {
                    const e = this.getStatInternal(i);
                    return delete e.changeTimer,
                    delete e.nextChangeTimer,
                    void (e.changeAmount = 0)
                }
                t *= 1 / n.changeTimerMultiplier
            }
            super.setStatChangeTimer(e, Math.ceil(t), a)
        }
        setStatus(e, t, a) {
            const i = game.getDifficultyOptions().player.statusEffects.get(e);
            a === s.StatusEffectChangeReason.Treated && i && i.untreatable || super.setStatus(e, t, a)
        }
        startResting(e) {
            super.startResting(e),
            this.onStaminaUseChanged(),
            this.isLocalPlayer() && this.showRestInterrupt(e.type)
        }
        cancelResting(e) {
            return !!super.cancelResting(e) && (this.tick(),
            !0)
        }
        showRestInterrupt(e) {
            e === d.RestType.Resting ? newui.interrupt(S.default.GameInterruptLoadingResting, S.default.GameInterruptLoadingRestingDescription).withLoading(void 0, ()=>{
                a.default.get(i.ActionType.Rest).execute(this, void 0, void 0, void 0, !0)
            }
            , "rest") : newui.showLoadingInterrupt(S.default.GameInterruptLoadingSleeping, S.default.GameInterruptLoadingSleepingDescription, void 0, "rest")
        }
        updateStatuses() {
            for (const e of this.statuses()) {
                const t = u.default[e];
                if (!t)
                    continue;
                const a = game.getDifficultyOptions().player.statusEffects.get(e) || {
                    passChanceMultiplier: 1,
                    effectMultiplier: 1,
                    effectRateMultiplier: 1
                };
                if (game.time.ticks % Math.floor(20 * a.effectRateMultiplier) != 0)
                    return;
                t.shouldPass(this, a.passChanceMultiplier) ? (this.setStatus(e, !1, s.StatusEffectChangeReason.Passed),
                t.onPassed(this)) : t.onTick(this, a.effectMultiplier)
            }
        }
        resetMovementStates() {
            this.updateMovementIntent({})
        }
        setId(e) {
            for (const t of players)
                if (t.tamedCreatures)
                    for (const a of t.tamedCreatures) {
                        const t = game.creatures[a];
                        t && t.enemy === this.id && !0 === t.enemyIsPlayer && (t.enemy = e)
                    }
            this.id = e;
            for (const e of this.inventory.containedItems)
                void 0 !== e.equippedId && (e.equippedId = this.id)
        }
        setRaft(e) {
            return !!super.setRaft(e) && (this.raft ? this.messages.source(x.Source.Action).send(g.default.BeginUsingRaft) : this.messages.source(x.Source.Action).send(g.default.StopUsingRaft),
            this.updateTablesAndWeight(),
            !0)
        }
        skillGain(e, t, a) {
            this.isGhost() || (super.skillGain(e, t, a),
            this.isLocalPlayer() && this.checkSkillMilestones())
        }
        checkSkillMilestones() {
            let e = 0;
            for (const t of j.default.values(d.SkillType)) {
                const a = this.skills[t];
                a && (e += a.core,
                this.addMilestone(B.MilestoneType.Boundless, this.getSkill(t)))
            }
            this.addMilestone(B.MilestoneType.Talented, Y.default.roundNumber(e, 1)),
            this.updateMilestones()
        }
        staminaCheck() {
            const e = this.getStat(l.Stat.Stamina);
            if (e.value <= 0) {
                this.setStat(e, 1);
                const t = this.getMaxHealth()
                  , a = K.default.intInRange(Math.ceil(t / 60), Math.ceil(t / 40));
                return this.damage(-1 * a, this.swimming ? g.default.DeathByDrowning : g.default.DeathByExhaustion, 0, !1),
                this.messages.source(x.Source.Action, x.Source.Wellbeing).type(L.MessageType.Bad).send(this.swimming ? g.default.WorkingYourselfIntoExhaustionAndDrowning : g.default.WorkingYourselfIntoExhaustion),
                this.staminaSyncCheck(),
                !1
            }
            return !0
        }
        addMilestone(e, t) {
            this.isLocalPlayer() && !this.isGhost() && this._milestoneUpdates.push({
                milestone: e,
                data: t
            })
        }
        calculateEquipmentStats() {
            super.calculateEquipmentStats(),
            this.isLocalPlayer() && (fieldOfView && (this._fovRadius = modManager.getHook(v.Hook.GetPlayerFieldOfViewRadius, this._fovRadius).call(this),
            fieldOfView.updateRadius(this._fovRadius, this._fovMaxRadius)),
            this.checkSkillMilestones())
        }
        getDefaultCarveTool() {
            for (const e of itemManager.getItemsInContainer(this.inventory, !0)) {
                const t = h.itemDescriptions[e.type];
                if (t && t.use && -1 !== t.use.indexOf(i.ActionType.Carve))
                    return e
            }
        }
        isFacingCarvableTile() {
            const e = this.getFacingTile();
            if (e.corpses)
                return !0;
            const t = e.doodad;
            return !(!t || !(t.canPickup(this) || t.canHarvest() || t.canGather())) || !(!e.events || !tileEventManager.canGather(e))
        }
        hasTamedCreature(e) {
            return -1 !== this.tamedCreatures.indexOf(e.id)
        }
        hasHandToUse() {
            return this.options.leftHand || this.options.rightHand
        }
        getAndSwitchHandToUse() {
            return multiplayer.addSyncCheck(w.MultiplayerSyncCheck.HandToUse, `${this.id},${this.options.leftHand ? 1 : 0},${this.options.rightHand ? 1 : 0},${this.handToUse}`),
            this.options.leftHand && this.options.rightHand ? this.handToUse === d.EquipType.LeftHand ? (this.handToUse = d.EquipType.RightHand,
            d.EquipType.LeftHand) : (this.handToUse = d.EquipType.LeftHand,
            d.EquipType.RightHand) : this.options.leftHand ? d.EquipType.LeftHand : this.options.rightHand ? d.EquipType.RightHand : void 0
        }
        updateHandToUse() {
            this.options.leftHand && this.options.rightHand ? void 0 === this.handToUse && (this.handToUse = d.EquipType.LeftHand) : this.options.leftHand ? this.handToUse = d.EquipType.LeftHand : this.options.rightHand ? this.handToUse = d.EquipType.RightHand : this.handToUse = void 0
        }
        equip(e, t, a=!1, i=!1) {
            const n = e.description();
            if (!n)
                return;
            const o = n.equip;
            if (!o)
                return;
            if (o !== t) {
                if (o !== d.EquipType.Held)
                    return void this.messages.source(x.Source.Equipment, x.Source.Item).send(g.default.CannotEquipThatThere, e.getName());
                if (t !== d.EquipType.LeftHand && t !== d.EquipType.RightHand)
                    return void this.messages.source(x.Source.Equipment, x.Source.Item).send(g.default.CannotEquipThatThere, e.getName())
            }
            e.containedWithin !== this.inventory && itemManager.moveToContainer(this, e, this.inventory),
            e.isEquipped() && this.unequip(e, a, a, t === d.EquipType.Held || t === d.EquipType.LeftHand || t === d.EquipType.RightHand),
            t === d.EquipType.Held && (t = d.EquipType.LeftHand,
            void 0 !== this.getEquippedItem(t) && (t = d.EquipType.RightHand));
            const r = this.getEquippedItem(t);
            void 0 !== r && this.unequip(r, a, a, i),
            super.equip(e, t),
            this.isLocalPlayer() && ui.setEquipSlot(t, e.id, a),
            itemManager.checkMilestones(this, e),
            this.calculateEquipmentStats(),
            this.updateTablesAndWeight(),
            modManager.getHook(v.Hook.OnItemEquip).call(this, e, t),
            a || (this.messages.source(x.Source.Equipment, x.Source.Action, x.Source.Item).send(g.default.YouEquip, e.getName()),
            this.queueSoundEffect(d.SfxType.PickUp),
            this.isLocalPlayer() && o === d.EquipType.Held && this.defense.parrying >= 1 && this.setStat(l.Stat.Defense, 0, s.IStatChangeInfo.get(!0)))
        }
        unequip(e, t=!1, a=!1, i=!1) {
            const n = e.getEquipSlot();
            if (void 0 === n)
                return;
            super.unequip(e);
            const o = e.description();
            if (!i && o && o.revert && o.isTorch && (e.changeInto(o.revert),
            this.messages.source(x.Source.Equipment, x.Source.Action, x.Source.Item).send(g.default.ExtinguishedTorch)),
            this.isLocalPlayer() && ui.removeItemFromEquipSlot(n),
            a || this.messages.source(x.Source.Equipment, x.Source.Action, x.Source.Item).send(g.default.YouUnequip, e.getName()),
            e.type === d.ItemType.AberrantSlitherSucker || e.type === d.ItemType.SlitherSucker) {
                const t = e.spawnCreatureOnItem(d.CreatureType.SlitherSucker, e.type === d.ItemType.AberrantSlitherSucker, !0, this);
                if (t) {
                    const a = t.getStat(l.Stat.Health);
                    t.setStatMax(a, e.maxDur ? e.maxDur : 1),
                    t.setStat(a, a.max),
                    itemManager.remove(e)
                }
            }
            t || (this.queueSoundEffect(d.SfxType.PickUp),
            this.calculateEquipmentStats(),
            game.updateView(c.RenderSource.ItemEquip, !(!o || !o.onEquipEffect)))
        }
        unequipAll() {
            let e = !1
              , t = !1;
            const a = this.getEquippedItems();
            for (const i of a) {
                e = !0,
                this.unequip(i, !0, !0);
                const a = i.description();
                a && a.onEquipEffect && (t = !0)
            }
            e && (this.calculateEquipmentStats(),
            this.queueSoundEffect(d.SfxType.PickUp),
            this.messages.source(x.Source.Equipment, x.Source.Action, x.Source.Item).send(g.default.AllEquipmentUnEquipped),
            game.updateView(c.RenderSource.ItemUnequip, t))
        }
        getMovementIntent() {
            if (this.walkPath) {
                let e = this.walkPath[0];
                if (e && (e.x === this.x && e.y === this.y && (this.walkPath.shift(),
                e = this.walkPath[0]),
                e && !o.isWalkToTileBlocked(this, game.getTile(e.x, e.y, this.z), e, !1))) {
                    const t = E.getDirectionFromMovement(e.x - this.x, e.y - this.y);
                    return {
                        intent: t,
                        shouldDisableTurnDelay: !0
                    }
                }
                this.walkAlongPath(void 0)
            }
            return this._movementIntent
        }
        updateMovementIntent(e) {
            if ((this._movementIntent.intent !== e.intent || this._movementIntent.turnDelay !== e.turnDelay) && (this._movementIntent.intent = e.intent,
            this._movementIntent.turnDelay = e.turnDelay,
            multiplayer.isConnected() && this.isLocalPlayer())) {
                const t = new C.default;
                t.intent = e,
                t.send()
            }
        }
        resetStatTimers() {
            super.resetStatTimers()
        }
        getMaxHealth() {
            const e = this.getStatInternal(l.Stat.Strength).value;
            return modManager.getHook(v.Hook.GetPlayerMaxHealth, e).call(e, this)
        }
        getMaxWeight() {
            const e = this.getStatValue(l.Stat.Strength);
            return modManager.getHook(v.Hook.GetPlayerMaxWeight, e).call(e, this)
        }
        setup(e) {
            if (multiplayer.isConnected())
                this.spawnPoint = {
                    x: this.x,
                    y: this.y,
                    z: this.z
                };
            else {
                for (game.spawnCoords.z = d.WorldZ.Overworld; 0 === game.spawnCoords.x && 0 === game.spawnCoords.y; ) {
                    const e = K.default.int(game.mapSize)
                      , t = K.default.int(game.mapSize)
                      , a = game.getTile(e, t, d.WorldZ.Overworld)
                      , i = U.default[X.default.getType(a)];
                    i && i.passable && X.default.getType(a) !== d.TerrainType.ShallowSeawater && X.default.getType(a) !== d.TerrainType.BeachSand && (game.spawnCoords.x = e,
                    game.spawnCoords.y = t)
                }
                this.x = game.spawnCoords.x,
                this.y = game.spawnCoords.y,
                this.spawnPoint = game.spawnCoords
            }
            this.customization || (this.customization = R.generateRandomCustomization()),
            game.isChallenge && K.default.generator.pushSeed(K.convertStringToSeed(game.seeds.base));
            const t = game.getDifficultyOptions()
              , a = t.player.initialItems;
            !0 === a && (this.equip(this.createItemInInventory(d.ItemType.TatteredShirt), d.EquipType.Chest, !0),
            this.equip(this.createItemInInventory(d.ItemType.TatteredPants), d.EquipType.Legs, !0));
            const i = this.getStat(l.Stat.Stamina)
              , n = this.getStat(l.Stat.Health)
              , o = this.getStat(l.Stat.Hunger)
              , r = this.getStat(l.Stat.Thirst)
              , u = game.isChallenge ? 0 : e;
            this.setStatMax(i, K.default.int(10 + u) + 70),
            this.setStat(l.Stat.Strength, K.default.int(5 + u) + 45),
            this.setStatMax(o, K.default.int(5 + u) + 15),
            this.setStatMax(r, K.default.int(5 + u) + 15),
            this.setStat(i, i.max - K.default.int(10)),
            this.setStat(n, this.getMaxHealth() - K.default.int(5)),
            this.setStat(o, o.max - K.default.int(2)),
            this.setStat(r, r.max - K.default.int(2));
            const c = t.player.stats;
            for (const [e,t] of c.entries())
                if (void 0 !== t.maxValue && this.setStatMax(e, t.maxValue),
                void 0 !== t.initialValue) {
                    const a = e === l.Stat.Strength ? t.initialValue : Math.floor(this.getStatMax(e) * t.initialValue / 100);
                    this.setStat(e, a)
                }
            for (const [e,t] of c.entries())
                if (void 0 !== t.initialValue) {
                    const a = e === l.Stat.Strength ? t.initialValue : Math.floor(this.getStatMax(e) * t.initialValue / 100);
                    this.setStat(e, a)
                }
            if (t.player.randomSkills && !game.isChallenge) {
                const t = j.default.getRandom(d.SkillType);
                this.skills[t] && this.setSkillCore(t, K.default.int(4) + 8 + (game.isChallenge ? 0 : e))
            }
            if (!0 === a) {
                this.createItemInInventory(d.ItemType.LeafBedroll);
                const t = K.default.intInRange(7, 10 + (game.isChallenge ? 0 : e));
                for (let e = 0; e < t - 1; e++)
                    this.createItemInInventory(K.default.getElement(E.setupSpawnItems));
                this.createItemInInventory(d.ItemType.WoodenPole)
            }
            const m = t.player.statusEffects;
            for (const [e,t] of m.entries())
                t.startWith && this.setStatus(e, !0, s.StatusEffectChangeReason.Gained);
            const h = t.player.reputation;
            if (h.initialMalignity && this.setStat(l.Stat.Malignity, h.initialMalignity),
            h.initialBenignity && this.setStat(l.Stat.Benignity, h.initialBenignity),
            game.isChallenge) {
                let e = 0;
                p.isPermanentEffect(d.StatusType.Burned) ? e += 2 : (p.isPermanentEffect(d.StatusType.Poisoned) || p.isPermanentEffect(d.StatusType.Bleeding)) && (e += 6);
                const t = this.getReputation();
                t <= 0 && (e += -1 * Math.floor(t / 5e3));
                const a = K.default.intInRange(1, 4) + e;
                for (let e = 0; e < a - 1; e++)
                    this.createItemInInventory(K.default.getElement(E.setupHealthItems));
                if (p.isEternalNight()) {
                    const e = this.createItemInInventory(K.default.getElement(E.setupLightItems));
                    this.equip(e, d.EquipType.RightHand)
                }
            } else
                e >= 1 && (this.messages.source(x.Source.Milestone).type(L.MessageType.Stat).send(g.default.PastExperiencesProvideBenefits),
                !0 === a && K.default.int(100) - e <= 0 && this.createItemInInventory(d.ItemType.OrnateCape));
            const y = d.Direction.South
              , f = game.directionToMovement(y);
            if (this.direction.x = f.x,
            this.direction.y = f.y,
            this.facingDirection = y,
            !0 === a && (this.createItemInInventory(K.default.getElement(E.setupWaterItems)),
            this.createItemInInventory(K.default.getElement(E.setupToolItems)),
            this.createItemInInventory(K.default.getElement(E.setupMiscItems)),
            !game.isChallenge && e >= 1 && this.createItemInInventory(K.default.getElement(E.setupBookItems))),
            Array.isArray(a))
                for (const e of a)
                    this.createItemInInventory(e);
            const S = t.player.skills;
            for (const [e,t] of S.entries())
                t.initial && this.setSkillCore(e, t.initial);
            this.updateStatsAndAttributes();
            const v = z.default.random(this.inventory.containedItems, 3, !1);
            this.notes.write(T.default.Stranded, itemManager.getItemTranslations(v).collect(I.default.formatList, !1)),
            game.isChallenge && (this.quests.add(H.QuestType.Challenge),
            K.default.generator.popSeed())
        }
        updateReputation(e) {
            super.updateReputation(e),
            (this.getStatValue(l.Stat.Benignity) >= 2500 || this.getStatValue(l.Stat.Malignity) >= 2500) && this.notes.write(T.default.Reputation, this.getStatValue(l.Stat.Benignity) >= 2500),
            this.checkReputationMilestones()
        }
        checkWeight() {
            const e = this.getWeightMovementPenalty()
              , t = this.getWeightStatus();
            if (t === d.WeightStatus.Overburdened) {
                this.messages.source(x.Source.Wellbeing, x.Source.Item).type(L.MessageType.Bad).send(g.default.CarryingTooMuchWeight);
                const e = this.getStat(l.Stat.Stamina)
                  , t = this.getStat(l.Stat.Weight);
                if (this.reduceStat(e, Math.ceil((t.value - t.max) / 2)),
                this.staminaSyncCheck(),
                !this.notes.wasWritten(T.default.Encumbered)) {
                    const e = itemManager.getItemsInContainer(this.inventory, !0);
                    e.sort((e,t)=>itemManager.getItemsByWeight(e.id, t.id));
                    const t = e.filter((e,t,a)=>a.map(e=>e.type).indexOf(e.type) === t);
                    t.length >= 3 && this.notes.write(T.default.Encumbered, t[0].getName(), t[1].getName(), t[2].getName())
                }
            }
            e >= 1 && this.addDelay(e)
        }
        getWeightStatus() {
            let e = modManager.getHook(v.Hook.GetPlayerWeightStatus, d.WeightStatus.None).call(this);
            if (e !== d.WeightStatus.None)
                return e;
            const t = this.getStat(l.Stat.Weight);
            return t.value > t.max ? e = d.WeightStatus.Overburdened : t.value > .9 * t.max && (e = d.WeightStatus.Encumbered),
            e
        }
        getWeightMovementPenalty() {
            const e = modManager.getHook(v.Hook.GetPlayerWeightMovementPenalty).call(this);
            if (void 0 !== e)
                return e;
            const t = this.getWeightStatus()
              , a = this.getStat(l.Stat.Weight);
            return t === d.WeightStatus.Overburdened || t === d.WeightStatus.Encumbered ? Math.min(Math.ceil((a.value - .9 * a.max) / 2), 25) : 0
        }
        checkForStill() {
            const e = this.getFacingTile();
            if (!e)
                return !1;
            if (e.doodad) {
                const t = e.doodad
                  , a = t.description();
                if (a && void 0 !== t.decay && a.isWaterSource && -1 === t.decay)
                    return !0
            }
            return !1
        }
        checkForWell() {
            const e = this.getFacingTile();
            if (!e)
                return !1;
            const {x: t, y: a, z: i} = this.getFacingPoint();
            if (e.doodad) {
                const n = e.doodad
                  , o = n.description()
                  , r = game.wellData[Z.getTileId(t, a, i)];
                if (o && o.group === d.DoodadTypeGroup.Well && r && r.waterType === c.WaterType.FreshWater)
                    return !0
            }
            return !1
        }
        checkForGather() {
            const e = this.getFacingTile();
            if (e && e.doodad) {
                const t = e.doodad.description()
                  , a = e.doodad.getGrowingStage();
                if (!t || !t.gather || void 0 === a || e.doodad.canHarvest())
                    return;
                if (!e.doodad.canGather())
                    return e.doodad
            }
        }
        updateTables() {
            const e = this.options.useAdjacentContainers ? itemManager.getAdjacentContainers(this) : void 0;
            this.updateCraftTable(e),
            this.updateDismantleTable(e)
        }
        updateCraftTable(e) {
            if (!this.isLocalPlayer())
                return;
            const t = []
              , a = []
              , i = game.isChallenge ? j.default.values(d.ItemType).collect(Q.default.toArray) : Object.keys(game.crafted).map(e=>+e)
              , n = new m.default(this,void 0,!1,!0);
            n.setAdjacentContainers(e);
            for (const e of i) {
                const i = h.itemDescriptions[e];
                if (!i)
                    continue;
                if (!1 === i.craftable)
                    continue;
                const o = i.recipe;
                o && (n.setRecipe(o),
                n.process() ? t.push(e) : a.push(e))
            }
            ui.updateCraftingDialog(t, a)
        }
        updateDismantleTable(e) {
            if (!this.isLocalPlayer())
                return;
            const t = {}
              , a = [this.inventory];
            this.options.useAdjacentContainers && a.push(...e||itemManager.getAdjacentContainers(this));
            for (const e of a)
                for (const a of itemManager.getItemsInContainer(e, !0, this.getProtectedItemsOptions())) {
                    const e = h.itemDescriptions[a.type];
                    e && e.dismantle && !t[a.type] && (t[a.type] = a.id)
                }
            ui.updateDismantleTab(t)
        }
        updateTablesAndWeight() {
            let e = 0;
            multiplayer.addSyncCheck(w.MultiplayerSyncCheck.InventoryCount, `${this.getName().getString()},${this.inventory.containedItems.length}`);
            for (let t = 0; t < this.inventory.containedItems.length; t++) {
                const a = this.inventory.containedItems[t]
                  , i = h.itemDescriptions[a.type];
                i && (this.raft !== a.id && (e += a.weight,
                a.legendary && a.legendary.type === d.LegendaryType.ItemWeight && (e -= a.legendary.value),
                multiplayer.addSyncCheck(w.MultiplayerSyncCheck.Item, `${this.id}-${t}-${a.id}-${a.weight}-${void 0 !== a.minDur ? a.minDur : ""}-${void 0 !== a.maxDur ? a.maxDur : ""}-${void 0 !== a.quickSlot ? a.quickSlot : ""}`),
                itemManager.isContainer(a) && (e += itemManager.computeContainerWeight(a) * a.getContainerWeightReduction())))
            }
            e = Y.default.roundNumber(e, 1);
            const t = modManager.getHook(v.Hook.OnUpdateWeight).call(this, e);
            void 0 !== t && (e = t),
            this.setStat(l.Stat.Weight, e),
            multiplayer.addSyncCheck(w.MultiplayerSyncCheck.Weight, e),
            this.onStaminaUseChanged(),
            this.isLocalPlayer() && this.updateTables()
        }
        checkReputationMilestones() {
            this.addMilestone(B.MilestoneType.Benevolent, this.getStat(l.Stat.Benignity).value),
            this.addMilestone(B.MilestoneType.Malevolent, this.getStat(l.Stat.Malignity).value)
        }
        hurtHands(e, t, a) {
            const i = this.getEquippedItem(d.EquipType.Hands);
            if (i)
                return this.messages.source(x.Source.Wellbeing, x.Source.Equipment, x.Source.Item).send(g.default.HandProtectionPreventedInjury),
                i.damage("HH"),
                !1;
            if (10 <= K.default.int(100))
                return !1;
            t && (this.messages.source(x.Source.Wellbeing, x.Source.Equipment).type(L.MessageType.Bad).send(g.default.HurtHandsWithNoTool, I.default.message(a || g.default.BothHands), I.default.message(t)),
            this.notes.write(T.default.ToolUse, I.default.message(e), I.default.message(t)));
            const n = this.getMaxHealth()
              , o = K.default.intInRange(n / 50, n / 25);
            this.damage(-1 * o, I.default.message(g.default.UsingBareHands).addArgs(I.default.message(e)));
            const r = Math.floor(this.getSkill(d.SkillType.Anatomy) / 10)
              , l = K.default.percent();
            return !this.hasStatus(d.StatusType.Bleeding) && l <= 15 - r && (this.messages.source(x.Source.Wellbeing).send(g.default.BleedingProfusely),
            this.skillGain(d.SkillType.Anatomy, .1),
            this.setStatus(d.StatusType.Bleeding, !0, s.StatusEffectChangeReason.Gained),
            this.notes.write(T.default.Bleeding, !1, I.default.message(e))),
            !0
        }
        setTamedCreatureEnemy(e) {
            if (this.tamedCreatures)
                for (const t of this.tamedCreatures) {
                    const a = game.creatures[t];
                    a && a.isDefender() && void 0 === a.enemy && (a.enemy = e.id,
                    a.enemyIsPlayer = e instanceof te,
                    a.enemyAttempts = void 0)
                }
        }
        setPosition(e) {
            this.nextX = game.getWrappedCoord(e.x),
            this.nextY = game.getWrappedCoord(e.y),
            super.setPosition(e)
        }
        setZ(e) {
            const t = game.getTile(this.x, this.y, e)
              , a = t.creature;
            a && (a.stopNextMovement = !0,
            a.fromX = a.x,
            a.fromY = a.y,
            a.moveTo(this.x, this.y, this.z),
            a.checkUnder()),
            this.z = e,
            this.addDelay(25, !0),
            game.particle.clear(),
            game.updateView(c.RenderSource.MovementPlayerZPre, this.isLocalPlayer())
        }
        isGhost() {
            return super.isGhost() || this.isServer()
        }
        isServer() {
            return this.state === d.PlayerState.Server
        }
        getName() {
            return new I.default(y.Dictionary.Misc,f.MiscTranslation.HumanName).addArgs(this.isGhost() ? I.default.message(g.default.GhostOf).addArgs(this.name) : this.name)
        }
        canSeePosition(e, t, a, i) {
            return !this.isServer() && super.canSeePosition(e, t, a, i)
        }
        updateQuickSlotInfo(e, t, a) {
            if (void 0 === t && void 0 !== a ? this.quickSlotInfo[e].action = a : void 0 === t ? delete this.quickSlotInfo[e] : this.quickSlotInfo[e] = {
                itemType: t,
                action: a
            },
            multiplayer.isConnected() && multiplayer.isClient() && this.isLocalPlayer()) {
                const t = new k.default;
                t.quickSlot = e,
                t.quickSlotInfo = this.quickSlotInfo[e],
                multiplayer.syncPacket(t, void 0, !0)
            }
        }
        updateDialogInfo(e) {
            if (multiplayer.isConnected() && multiplayer.isClient() && this.isLocalPlayer()) {
                const t = new b.default;
                t.index = e,
                t.info = "string" == typeof e ? this.dialogInfo[e] : this.dialogContainerInfo[e],
                multiplayer.syncPacket(t, void 0, !0)
            }
            "string" == typeof e && (saveDataGlobal.savedDialogInfo[e] = this.dialogInfo[e])
        }
        getDialogInfo(e) {
            let t = this.dialogInfo[e];
            if (!t) {
                const a = saveDataGlobal.savedDialogInfo[e];
                a && (t = this.dialogInfo[e] = {
                    x: a.x,
                    y: a.y,
                    width: a.width,
                    height: a.height,
                    open: a.open
                })
            }
            return t
        }
        passTurn(e) {
            modManager.getHook(v.Hook.OnTurnStart).call(this),
            this.processMovement(e),
            this.isGhost() || this.swimCheck();
            const t = multiplayer.isConnected() ? this.isMoving : this.isMovingClientside;
            t || modManager.getHook(v.Hook.OnTurnEnd).call(this)
        }
        tick(e) {
            if (modManager.getHook(v.Hook.OnPlayerTickStart).call(this),
            F.default(this, this.getFacingTile()),
            multiplayer.isConnected() && (this.noInputReceived && modManager.getHook(v.Hook.OnNoInputReceived).call(this),
            this.movementComplete && (this.movementComplete = !1,
            modManager.getHook(v.Hook.OnMoveComplete).call(this))),
            !e && this.isResting())
                this.restTick();
            else if (!this.isGhost() && !this.isConnecting) {
                this.updateStats(),
                this.staminaCheck(),
                this.updateMilestones();
                const e = game.isChallenge ? Y.default.roundNumberToMultiple(0 + this.turns / 200, 5) : 0;
                game.isRealTimeMode() ? 0 === this.realTimeTickActionDelay ? (this.swimming && (this.anim = 1 - this.anim),
                this.slitherSuckerDamage(),
                game.isChallenge && (this.score -= 10 * e),
                this.isOnFire() !== d.FireType.None && this.isOnFire() !== d.FireType.CoolingLava && this.burn(!1, !!d.FireType.Fire, d.EquipType.Feet),
                this.realTimeTickActionDelay = 3) : this.realTimeTickActionDelay-- : (this.slitherSuckerDamage(),
                game.isChallenge && (this.score -= e))
            }
            modManager.getHook(v.Hook.OnPlayerTickEnd).call(this)
        }
        kill() {
            if (!1 === modManager.getHook(v.Hook.OnPlayerDeath).call(this))
                return;
            this.state = d.PlayerState.Dead;
            let e = !1;
            const t = game.getDifficultyOptions().respawn;
            if (this.messages.source(x.Source.Wellbeing).type(L.MessageType.Bad).send(g.default.YouHaveDied, this.deathBy),
            L.default.toAll((e,t)=>t !== this && e.source(x.Source.Multiplayer, x.Source.Allies).type(multiplayer.getOptions().pvp || game.isChallenge ? L.MessageType.Good : L.MessageType.Bad).send(g.default.MultiplayerPlayerDied, this.getName(), this.deathBy)),
            multiplayer.isConnected() && !this.isLocalPlayer() || t || (e = !0,
            audio.updateMusicSpeed(1),
            saveData.gameState = d.PlayerState.Ghost,
            saveDataGlobal.gameHighscores.push({
                name: saveData.gameSlotName,
                score: this.score,
                turns: this.turns,
                message: I.default.message(g.default.Killed).addArgs(this.deathBy).serialize(),
                difficulty: game.getDifficulty(),
                date: Date.now(),
                characterName: this.name
            }),
            this.addDelay(100),
            A.bindingManager.disableBindsUntil(4e3),
            V.sleep(200).then(async()=>{
                game.isChallenge || multiplayer.isConnected() || (await game.saveGame(d.SaveType.Death),
                game.playing = !1),
                await V.sleep(3e3),
                newui.interrupt().withMenu(G.MenuId.GameEnd, e=>e.setGameEndData({
                    state: d.PlayerState.Dead,
                    highscore: saveDataGlobal.gameHighscores.collect(Q.default.last())
                }))
            }
            )),
            this.isLocalPlayer() && (ui.closeAllContainers(),
            e ? ui.onGameEnd() : ui.cancelSorting()),
            this.lastAttackedBy)
                if (this.lastAttackedBy instanceof r.default)
                    this.lastAttackedBy.updateReputation(Math.floor(this.getReputation() / 4 * -1));
                else if (this.lastAttackedBy instanceof n.default) {
                    const e = this.lastAttackedBy.getOwner();
                    e && e.updateReputation(Math.floor(this.getReputation() / 8 * -1))
                }
            if (itemManager.placeItemsAroundLocation(this.inventory, this.x, this.y, this.z),
            this.queueSoundEffect(d.SfxType.Death, void 0, void 0, this.isLocalPlayer()),
            t) {
                this.state = d.PlayerState.None,
                void 0 === this.spawnPoint.z && (this.spawnPoint.z = d.WorldZ.Overworld);
                let e = this.spawnPoint && void 0 !== this.spawnPoint.x ? X.default.findMatchingTile(this.spawnPoint, X.default.isSuitableSpawnPointTile) : void 0;
                void 0 === e && (e = players[0]),
                this.x = this.fromX = e.x,
                this.y = this.fromY = e.y,
                this.z = e.z;
                const t = Math.sign(this.getReputation()) * Math.round(10 * Math.pow(Math.abs(this.getReputation()), .6));
                this.updateReputation(-1 * t)
            } else
                this.state = d.PlayerState.Ghost,
                this.isLocalPlayer() && (fieldOfView.disabled = !0);
            if (this.state !== d.PlayerState.Ghost) {
                const e = this.getStat(l.Stat.Stamina)
                  , t = this.getStat(l.Stat.Health)
                  , a = this.getStat(l.Stat.Hunger)
                  , i = this.getStat(l.Stat.Thirst);
                t.changeTimer = 0,
                this.setStat(t, Math.round(this.getMaxHealth() * (K.default.intInRange(25, 50) / 100))),
                t.value <= 0 && (this.setStat(t, 10),
                $.default.info($.LogSource.Player)("invalid health value", this.getMaxHealth())),
                e.changeTimer = 0,
                this.setStat(e, Math.round(e.max * (K.default.intInRange(25, 50) / 100))),
                a.changeTimer = 0,
                this.setStat(a, Math.round(a.max * (K.default.intInRange(25, 50) / 100))),
                i.changeTimer = 0,
                this.setStat(i, Math.round(i.max * (K.default.intInRange(25, 50) / 100)))
            }
            this.setStatus(d.StatusType.Bleeding, !1, s.StatusEffectChangeReason.Passed),
            this.setStatus(d.StatusType.Burned, !1, s.StatusEffectChangeReason.Passed),
            this.setStatus(d.StatusType.Poisoned, !1, s.StatusEffectChangeReason.Passed),
            this.equipped = {},
            this.isMoving = !1,
            this.isMovingClientside = !1,
            this.movementComplete = !1,
            this.movementCompleteZ = void 0,
            this.movementProgress = 1,
            this.raft = void 0,
            this.restData = void 0,
            this.swimming = !1,
            this.stopNextMovement = !1,
            this.walkPath = void 0;
            for (const e of players)
                if (e.tamedCreatures)
                    for (const t of e.tamedCreatures) {
                        const e = game.creatures[t];
                        e && e.enemy === this.id && e.enemyIsPlayer && (e.enemy = void 0,
                        e.enemyIsPlayer = void 0)
                    }
            if (this.staminaSyncCheck(),
            this.updateTablesAndWeight(),
            this.updateStatsAndAttributes(),
            this.tick(),
            this.addDelay(100),
            !this.isGhost()) {
                const e = this.getTile()
                  , t = X.default.getType(e)
                  , a = U.default[t];
                a && a.water && (this.swimming = !0)
            }
            game.updateView(c.RenderSource.PlayerKill, this.isLocalPlayer())
        }
        getMovementProgress() {
            return this.movementProgress
        }
        checkUnder(e, t, a=!0, i=!1, n=!1) {
            const o = e ? this.getFacingTile() : this.getTile();
            if (o && (super.checkUnder(e, t, a, i, n),
            t)) {
                const t = o;
                if (!this.isGhost() && (this.options.autoPickup || e || i) && t.containedItems && t.containedItems.length > 0) {
                    const e = t.containedItems[t.containedItems.length - 1];
                    itemManager.moveToContainer(this, e, this.inventory) && this.updateTablesAndWeight(),
                    this.messages.source(x.Source.Action, x.Source.Item).send(g.default.YouPickedUp, e.getName()),
                    this.addDelay(25)
                }
                if (a && !e && X.default.getType(o) === d.TerrainType.CaveEntrance) {
                    const e = this.z === d.WorldZ.Cave ? d.WorldZ.Overworld : d.WorldZ.Cave;
                    game.isPlayerAtPosition(this.x, this.z, e) || (this.isMoving = !0,
                    this.isMovingClientside = !0,
                    this.movementCompleteZ = e,
                    this.z === d.WorldZ.Overworld && this.notes.write(T.default.Caving))
                }
            }
        }
        hasWalkPath() {
            return void 0 !== this.walkPath
        }
        walkAlongPath(e) {
            if (e && e.length > 0) {
                const t = e[0];
                t.x === this.x && t.y === this.y || (e = void 0)
            }
            if (multiplayer.isConnected())
                if (multiplayer.isServer()) {
                    const t = new D.default;
                    t.pid = this.id,
                    t.path = e,
                    t.sendTo(this)
                } else if (this.isLocalPlayer()) {
                    const t = new D.default;
                    return t.path = e,
                    void multiplayer.syncPacket(t, ()=>{
                        this.walkPath = e,
                        modManager.getHook(v.Hook.OnPlayerWalkToTilePath).call(this, this.walkPath)
                    }
                    , !0, !0)
                }
            this.walkPath = e,
            modManager.getHook(v.Hook.OnPlayerWalkToTilePath).call(this, this.walkPath)
        }
        processInput() {
            if (!1 === modManager.getHook(v.Hook.ProcessInput).call(this))
                return;
            if (this.hasDelay() || this.isResting() || this.isLocalPlayer() && newui.isScreenVisible(P.ScreenId.Interrupt) || multiplayer.isConnected() && multiplayer.isClient())
                return;
            const e = modManager.getHook(v.Hook.GetPlayerMovementIntent, this.getMovementIntent()).call(this)
              , t = E.gameMovement.find(t=>t.moveBind === e.intent);
            if (void 0 === t)
                "idle" !== e.intent || a.default.get(i.ActionType.Idle).execute(this);
            else {
                const n = game.directionToMovement(t.direction);
                n.x += this.x,
                n.y += this.y;
                const o = game.getTile(n.x, n.y, this.z)
                  , r = X.default.getType(o);
                if (this.facingDirection !== t.direction)
                    return a.default.get(i.ActionType.UpdateDirection).execute(this, t.direction, e.turnDelay),
                    void this.addDelay(2);
                if (this.nextMoveTime >= game.absoluteTime)
                    return;
                if (this.options.warnOnDangerousActions && !this.isGhost() && this.moveType !== d.MoveType.Flying) {
                    let e = !1, n, s = ee.None;
                    const l = o.doodad;
                    if (l && !o.creature) {
                        const t = l.description()
                          , a = l.getGrowingStage();
                        if (t)
                            if (l.isDangerous(this))
                                e = !0,
                                s = ee.DangerousObject,
                                n = l.getName();
                            else if (this.options.autoGatherHarvest && t.blockMove && l.canGather() && void 0 !== a && a >= d.GrowingStage.Budding) {
                                const t = this.checkForGatherFire();
                                void 0 !== t && (e = !0,
                                n = t,
                                s = ee.GatherOnFire)
                            }
                    }
                    const u = tileEventManager.get(o, q.TileEventType.Fire);
                    if (u && !o.creature && this.getBurnDamage(!0, d.EquipType.Feet) >= 1) {
                        let t = !1;
                        if (l) {
                            const e = l.getGrowingStage()
                              , a = l.description();
                            a && (a.blockMove && !a.isTree || a.isTree && void 0 !== e && e >= d.GrowingStage.Budding) && (t = !0)
                        }
                        t || (e = !0,
                        s = ee.DangerousObject,
                        n = I.default.nameOf(y.Dictionary.TileEvent, u))
                    }
                    if (r === d.TerrainType.Lava && !o.creature && this.getBurnDamage(!0, d.EquipType.Feet) >= 1 && (e = !0,
                    s = ee.DangerousObject,
                    n = I.default.nameOf(y.Dictionary.Terrain, d.TerrainType.Lava)),
                    e && n) {
                        this.resetMovementStates();
                        const e = s === ee.GatherOnFire ? S.default.GameInterruptConfirmationActionOnFire : S.default.GameInterruptDangerousStep
                          , o = s === ee.GatherOnFire ? S.default.GameInterruptConfirmationActionOnFireDescription : S.default.GameInterruptDangerousStepDescription
                          , r = [n.serialize(), I.default.ui(S.default.GameActionGather).serialize()];
                        if (this.hasHandToUse() && s === ee.GatherOnFire || s === ee.DangerousObject)
                            if (multiplayer.isConnected() && !this.isLocalPlayer()) {
                                this.nextMoveDirection = t.direction;
                                const a = new M.default;
                                a.title = e,
                                a.description = o,
                                a.args = r,
                                a.sendTo(this)
                            } else
                                newui.interrupt(()=>I.default.ui(e).get(...r)).withDescription(()=>I.default.ui(o).get(...r)).withConfirmation().then(e=>{
                                    e && void 0 !== t && a.default.get(i.ActionType.Move).execute(this, t.direction)
                                }
                                );
                        return
                    }
                }
                a.default.get(i.ActionType.Move).execute(this, t.direction)
            }
        }
        faceDirection(e, t) {
            return !(this.hasDelay() || this.isResting() || this.isLocalPlayer() && newui.isScreenVisible(P.ScreenId.Interrupt)) && (this.facingDirection !== e && (a.default.get(i.ActionType.UpdateDirection).execute(this, e, t),
            this.addDelay(2),
            !0))
        }
        revealItem(e) {
            this.revealedItems[e] = !0
        }
        getMovementFinishTime() {
            return game.absoluteTime + (10 + this.getWeightMovementPenalty()) * game.interval
        }
        updateMilestones() {
            const e = this._milestoneUpdates;
            if (0 !== e.length) {
                this._milestoneUpdates = [];
                for (const t of e) {
                    const a = t.milestone
                      , i = t.data
                      , n = O.milestones[a];
                    if (!n)
                        continue;
                    let o = saveDataGlobal.playerMilestoneData[a];
                    if (o) {
                        if (-1 === o.amount)
                            continue
                    } else
                        o = {
                            amount: 0
                        },
                        saveDataGlobal.playerMilestoneData[a] = o;
                    switch (n.dataType) {
                    case B.MilestoneDataType.Counter:
                        if (void 0 === i)
                            throw new Error(`Invalid data for milestone ${B.MilestoneType[a]} ${JSON.stringify(e)}`);
                        o.data || (o.data = []),
                        -1 === o.data.indexOf(i) && (o.data.push(i),
                        o.amount++);
                        break;
                    case B.MilestoneDataType.Check:
                        if (void 0 === i)
                            throw new Error(`Invalid data for milestone ${B.MilestoneType[a]} ${JSON.stringify(e)}`);
                        i > o.amount && (o.amount = i);
                        break;
                    default:
                        o.amount++
                    }
                    this.emit("MilestoneUpdate", a, o.amount, n.amount),
                    o.amount >= n.amount && (o.amount = -1,
                    this.queueSoundEffect(d.SfxType.Exceptional),
                    this.messages.source(x.Source.Milestone).type(L.MessageType.Good).send(g.default.EarnedMilestone, a))
                }
            }
        }
        healthSyncCheck() {
            multiplayer.addSyncCheck(w.MultiplayerSyncCheck.HealthChange, `${this.id}-${this.getStat(l.Stat.Health).value}`)
        }
        updateStrength() {
            this.setStatMax(l.Stat.Health, this.getMaxHealth()),
            this.setStatMax(l.Stat.Weight, this.getMaxWeight()),
            this.onStaminaUseChanged(),
            this.updateTablesAndWeight()
        }
        calculateStats() {
            if (this.isGhost())
                return;
            super.calculateStats();
            const e = this.getMaxHealth()
              , t = this.getStat(l.Stat.Health);
            if (this.isLocalPlayer() && (ui.refreshStats(),
            audio.updateMusicSpeed(t.value / e <= .1 ? 1.5 : 1)),
            this.getStat(l.Stat.Stamina).value <= 8 && this.notes.write(T.default.StaminaReplenishment),
            this.getStat(l.Stat.Health).value <= 8 && !this.notes.wasWritten(T.default.HealthIssues)) {
                let e = !1, t = !1, a;
                const i = itemManager.getItemInContainerByGroup(this.inventory, d.ItemTypeGroup.Health);
                if (i)
                    e = !0,
                    a = i.getName();
                else {
                    const e = itemManager.getItemInContainer(this.inventory, d.ItemType.TatteredPants);
                    if (e)
                        t = !0;
                    else {
                        const e = itemManager.getItemInContainer(this.inventory, d.ItemType.TatteredShirt);
                        e && (t = !0)
                    }
                }
                this.notes.write(T.default.HealthIssues, {
                    healing: e,
                    healingItemName: a,
                    clothing: t
                })
            }
            this.getStat(l.Stat.Thirst).value <= 3 && this.notes.write(T.default.Dehydration),
            t.value <= 0 && this.kill()
        }
        swimCheck() {
            if (super.swimCheck(),
            this.swimming) {
                const e = this.getSkill(d.SkillType.Swimming);
                this.addDelay(Math.max(25 - e / 2, 10))
            }
        }
        slitherSuckerDamage() {
            const e = this.getEquippedItem(d.EquipType.Head);
            if (e && (e.type === d.ItemType.AberrantSlitherSucker || e.type === d.ItemType.SlitherSucker)) {
                const t = this.getMaxHealth()
                  , a = e.type === d.ItemType.AberrantSlitherSucker ? K.default.intInRange(t / 20, t / 10) : K.default.intInRange(t / 40, t / 20);
                a && 0 === K.default.int(100) && (this.damage(a, I.default.message(g.default.DeathBy).addArgs(e.getName())),
                this.messages.source(x.Source.Wellbeing, x.Source.Equipment).type(L.MessageType.Bad).send(g.default.SlitherSuckerConstricts, e.getName()))
            }
        }
        processMovement(e) {
            this.movementFinishTime = this.getMovementFinishTime(),
            this.fromX = this.x,
            this.fromY = this.y,
            -1 !== this.nextX && (this.x = this.nextX,
            this.y = this.nextY,
            this.movementProgress = 0,
            modManager.getHook(v.Hook.OnTileUpdate).call(game.getTile(this.fromX, this.fromY, this.z), this.fromX, this.fromY, this.z),
            modManager.getHook(v.Hook.OnTileUpdate).call(this.getTile(), this.x, this.y, this.z),
            this.nextX = -1,
            this.nextY = -1,
            this.isLocalPlayer() && (this.updateTables(),
            fieldOfView.compute(!0))),
            this.fromX === game.mapSize - 1 && 0 === this.x && (this.fromX = -1),
            0 === this.fromX && this.x === game.mapSize - 1 && (this.fromX = game.mapSize),
            this.fromY === game.mapSize - 1 && 0 === this.y && (this.fromY = -1),
            0 === this.fromY && this.y === game.mapSize - 1 && (this.fromY = game.mapSize),
            e === d.TurnType.DontEnterCaves ? this.checkUnder(!1, !1, !1) : e === d.TurnType.CheckUnderPlayer ? this.checkUnder(!1, !0) : e === d.TurnType.ForcePickUp ? this.checkUnder(!1, !0, !0, !0) : this.checkUnder(),
            this.anim = 1 - this.anim,
            this.turns++,
            this.addMilestone(B.MilestoneType.Survivor),
            this.addMilestone(B.MilestoneType.Weathered),
            this.addMilestone(B.MilestoneType.Seasoned),
            this.realTimeTickActionDelay = 3
        }
        onStaminaUseChanged() {
            const e = this.getStat(l.Stat.Weight);
            this.isResting() || (this.getStat(l.Stat.Stamina).changeAmount = e.value <= .9 * e.max ? 1 : 0)
        }
        onStatusEffectChanged(e, t, a) {
            const i = !this.hasStatus(d.StatusType.Bleeding) && !this.hasStatus(d.StatusType.Burned) && !this.hasStatus(d.StatusType.Poisoned);
            this.getStat(l.Stat.Health).changeAmount = i ? 1 : 0,
            t === d.StatusType.Burned && a && this.notes.write(T.default.Burned)
        }
        onStatChange(e, t, a, i) {
            if (i.reason === s.StatChangeReason.Upgrade)
                return;
            const n = i.reason === s.StatChangeReason.ChangeTimer;
            switch (t.type) {
            case l.Stat.Stamina:
                n && this.isResting() && this.restData && this.restData.type === d.RestType.Resting && t.value >= t.max && this.cancelResting(d.RestCancelReason.FullStamina),
                this.staminaSyncCheck();
                break;
            case l.Stat.Health:
                this.healthSyncCheck();
                break;
            case l.Stat.Hunger:
                n && t.value < 0 && (this.damage(t.value, g.default.DueToStarvation, 0, !1),
                this.increaseStat(l.Stat.Stamina, t.value),
                this.messages.source(x.Source.Wellbeing).type(L.MessageType.Bad).send(g.default.StarvingToDeath));
                break;
            case l.Stat.Thirst:
                n && t.value < 0 && (this.damage(t.value, g.default.DueToDehydration, 0, !1),
                this.increaseStat(l.Stat.Stamina, t.value),
                this.messages.source(x.Source.Wellbeing).type(L.MessageType.Bad).send(g.default.DyingOfDehydration));
                break;
            case l.Stat.Malignity:
            case l.Stat.Benignity:
                this.emit(s.EntityEvent.StatChanged, {
                    type: l.Stat.Reputation,
                    value: this.getReputation()
                }, NaN, i);
                break;
            case l.Stat.Strength:
                this.updateStrength()
            }
        }
        restTick() {
            const e = this.restData;
            void 0 === e.cycle && (e.cycle = 0);
            const t = e.type
              , a = Math.min(30, e.totalCycles - e.cycle)
              , i = I.default.message(t === d.RestType.Resting ? g.default.Rest : g.default.Sleep);
            let n = !1;
            const o = game.isRealTimeMode();
            this.anim = 1 - this.anim,
            game.updateRender(c.RenderSource.PlayerRest);
            for (let t = 0; t < a; t++) {
                const t = e.cancelReason;
                if (void 0 !== t) {
                    switch (t) {
                    case d.RestCancelReason.NearbyCreatureDamagedDoodad:
                        this.messages.source(x.Source.Wellbeing, x.Source.Combat).type(L.MessageType.Bad).send(g.default.RestInterrupted, i, I.default.message(g.default.RestInterruptedLoudNoise)),
                        this.queueSoundEffect(d.SfxType.Hit);
                        break;
                    case d.RestCancelReason.FullStamina:
                        this.messages.source(x.Source.Wellbeing).send(g.default.StaminaIsFull);
                        break;
                    case d.RestCancelReason.Damaged:
                        this.messages.source(x.Source.Wellbeing).type(L.MessageType.Bad).send(g.default.RestInterrupted, i, I.default.message(g.default.RestInterruptedPain)),
                        this.queueSoundEffect(d.SfxType.Hurt);
                        break;
                    case d.RestCancelReason.CreatureDamaged:
                        this.messages.source(x.Source.Wellbeing, x.Source.Combat).type(L.MessageType.Bad).send(g.default.RestInterrupted, i, I.default.message(g.default.RestInterruptedDamage)),
                        this.queueSoundEffect(d.SfxType.Hurt);
                        break;
                    case d.RestCancelReason.CreatureNearby:
                        this.messages.source(x.Source.Wellbeing, x.Source.Combat).type(L.MessageType.Bad).send(g.default.RestInterrupted, i, I.default.message(g.default.RestInterruptedStirring)),
                        this.queueSoundEffect(d.SfxType.CreatureNoise)
                    }
                    n = !0;
                    break
                }
                if (o ? this.tick(!0) : game.passTurn(this),
                !this.isResting())
                    return;
                e.cycle++
            }
            if (n || e.cycle === e.totalCycles) {
                let a;
                a = t === d.RestType.Resting ? g.default.Rested : g.default.Slept;
                const i = Math.floor(e.cycle / 160);
                if (i < 1)
                    this.messages.source(x.Source.Wellbeing).send(g.default.FewMinutes, I.default.message(a));
                else if (o) {
                    let e;
                    e = i <= 3 ? g.default.RestShortTime : i <= 6 ? g.default.RestModerateTime : g.default.RestLongTime,
                    this.messages.source(x.Source.Wellbeing).send(g.default.RestTime, I.default.message(a), I.default.message(e))
                } else {
                    let e, t = g.default.Hours;
                    switch (i) {
                    case 1:
                        t = g.default.Hour,
                        e = g.default.NumberOne;
                        break;
                    case 2:
                        e = g.default.NumberTwo;
                        break;
                    case 3:
                        e = g.default.NumberThree;
                        break;
                    case 4:
                        e = g.default.NumberFour;
                        break;
                    case 5:
                        e = g.default.NumberFive;
                        break;
                    case 6:
                        e = g.default.NumberSix;
                        break;
                    case 7:
                        e = g.default.NumberSeven;
                        break;
                    case 8:
                        e = g.default.NumberEight;
                        break;
                    case 9:
                        e = g.default.NumberNine;
                        break;
                    default:
                    case 10:
                        e = g.default.NumberTen
                    }
                    this.messages.source(x.Source.Wellbeing).send(g.default.AboutHours, I.default.message(a), I.default.message(e), I.default.message(t))
                }
                if (this.onStaminaUseChanged(),
                this.resetStatTimers(),
                void 0 !== e.itemId) {
                    const t = game.items[e.itemId];
                    t && t.damage("PR")
                } else if (void 0 !== e.doodadId) {
                    const t = game.doodads[e.doodadId];
                    t && t.damage(!1, !1, !0)
                } else
                    this.messages.source(x.Source.Wellbeing).send(g.default.RestingOnGroundNotEffective);
                this.restData = void 0,
                this.updateStatsAndAttributes(),
                game.updateView(c.RenderSource.PlayerRestStop, this.isLocalPlayer()),
                this.isLocalPlayer() && newui.hideScreen(P.ScreenId.Interrupt)
            }
        }
        staminaSyncCheck() {
            multiplayer.addSyncCheck(w.MultiplayerSyncCheck.StaminaChanges, `${this.id}-${this.getStat(l.Stat.Stamina).value}`)
        }
        canWriteInHours() {
            return this.getSkill(d.SkillType.Camping) >= 50 && itemManager.isItemInContainer(this.inventory, d.ItemType.Sundial)
        }
        canWriteNote(e) {
            return !this.isServer() && !this.isGhost() && !1 !== modManager.getHook(v.Hook.OnWriteNote).call(this, e)
        }
        onWriteNote(e) {
            modManager.getHook(v.Hook.OnWrittenNote).call(this, e),
            this.addMilestone(B.MilestoneType.Notekeeper, this.notes.notes.length)
        }
        shouldDisplayMessage(e, t) {
            return !1 !== modManager.getHook(v.Hook.ShouldDisplayMessage).call(this, e, t)
        }
        onDisplayMessage(e) {
            modManager.getHook(v.Hook.OnDisplayMessage).call(this, e)
        }
    }
    __decorate([Override], te.prototype, "entityType", void 0),
    __decorate([N.SaveProperty()], te.prototype, "absentLastUsedTime", void 0),
    __decorate([N.SaveProperty()], te.prototype, "containerSortInfo", void 0),
    __decorate([N.SaveProperty()], te.prototype, "dialogContainerInfo", void 0),
    __decorate([N.SaveProperty()], te.prototype, "dialogInfo", void 0),
    __decorate([N.SaveProperty()], te.prototype, "hintSeen", void 0),
    __decorate([N.SaveProperty()], te.prototype, "isConnecting", void 0),
    __decorate([N.SaveProperty()], te.prototype, "isMoving", void 0),
    __decorate([N.SaveProperty()], te.prototype, "lastAttackedBy", void 0),
    __decorate([Override, N.SaveProperty()], te.prototype, "messages", void 0),
    __decorate([N.SaveProperty()], te.prototype, "movementComplete", void 0),
    __decorate([N.SaveProperty()], te.prototype, "movementCompleteZ", void 0),
    __decorate([N.SaveProperty()], te.prototype, "name", void 0),
    __decorate([N.SaveProperty()], te.prototype, "noInputReceived", void 0),
    __decorate([Override, N.SaveProperty()], te.prototype, "notes", void 0),
    __decorate([N.SaveProperty()], te.prototype, "quests", void 0),
    __decorate([N.SaveProperty()], te.prototype, "quickSlotInfo", void 0),
    __decorate([N.SaveProperty()], te.prototype, "realTimeTickActionDelay", void 0),
    __decorate([N.SaveProperty()], te.prototype, "revealedItems", void 0),
    __decorate([N.SaveProperty()], te.prototype, "spawnPoint", void 0),
    __decorate([N.SaveProperty()], te.prototype, "tamedCreatures", void 0),
    __decorate([N.SaveProperty()], te.prototype, "travelData", void 0),
    __decorate([N.SaveProperty()], te.prototype, "turns", void 0),
    __decorate([N.SaveProperty()], te.prototype, "walkSoundCounter", void 0),
    __decorate([Override], te.prototype, "setOptions", null),
    __decorate([Override], te.prototype, "setStatChangeTimer", null),
    __decorate([Override], te.prototype, "setStatus", null),
    __decorate([Override], te.prototype, "startResting", null),
    __decorate([Override], te.prototype, "cancelResting", null),
    __decorate([Override], te.prototype, "setRaft", null),
    __decorate([Override], te.prototype, "skillGain", null),
    __decorate([Override], te.prototype, "addMilestone", null),
    __decorate([Override], te.prototype, "calculateEquipmentStats", null),
    __decorate([Override], te.prototype, "hasHandToUse", null),
    __decorate([Override], te.prototype, "getAndSwitchHandToUse", null),
    __decorate([Override], te.prototype, "equip", null),
    __decorate([Override], te.prototype, "unequip", null),
    __decorate([Override], te.prototype, "unequipAll", null),
    __decorate([Override], te.prototype, "resetStatTimers", null),
    __decorate([Override], te.prototype, "getMaxHealth", null),
    __decorate([Override], te.prototype, "updateReputation", null),
    __decorate([Override], te.prototype, "setPosition", null),
    __decorate([Override], te.prototype, "setZ", null),
    __decorate([Override], te.prototype, "isGhost", null),
    __decorate([Override], te.prototype, "getName", null),
    __decorate([Override], te.prototype, "canSeePosition", null),
    __decorate([Override], te.prototype, "getMovementProgress", null),
    __decorate([Override], te.prototype, "checkUnder", null),
    __decorate([Override], te.prototype, "getMovementFinishTime", null),
    __decorate([Override], te.prototype, "calculateStats", null),
    __decorate([Override], te.prototype, "swimCheck", null),
    __decorate([J.Bound], te.prototype, "onStatusEffectChanged", null),
    __decorate([J.Bound], te.prototype, "onStatChange", null),
    __decorate([J.Bound], te.prototype, "canWriteInHours", null),
    __decorate([J.Bound], te.prototype, "canWriteNote", null),
    __decorate([J.Bound], te.prototype, "onWriteNote", null),
    __decorate([J.Bound], te.prototype, "shouldDisplayMessage", null),
    __decorate([J.Bound], te.prototype, "onDisplayMessage", null),
    t.default = te
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("creature/Creature", ["require", "exports", "creature/corpse/Corpses", "creature/Creatures", "creature/Pathing", "doodad/Doodads", "entity/Entity", "entity/IEntity", "entity/IStats", "entity/StatFactory", "Enums", "flowfield/IFlowFieldManager", "item/LootGroups", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Misc", "language/dictionary/Note", "language/Messages", "language/Translation", "mod/IHookManager", "multiplayer/IMultiplayer", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "player/Player", "renderer/particle/IParticle", "renderer/particle/Particles", "save/ISerializer", "tile/ITileEvent", "tile/Terrains", "utilities/enum/Enums", "utilities/math/Vector2", "utilities/math/Vector3", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const L = Math.pow(10, 2);
    class O extends r.default {
        constructor(e, t=0, a=0, i=0, n) {
            if (super(),
            this.entityType = s.EntityType.Creature,
            void 0 === e)
                return;
            this.type = e,
            this.x = t,
            this.y = a,
            this.z = i,
            this.fromX = t,
            this.fromY = a,
            this.anim = 0,
            this.facingDirection = d.Direction.South;
            const o = this.description();
            if (!o)
                return;
            let r = B.default.intInRange(o.minhp, o.maxhp);
            if (this.ai = o.ai,
            n) {
                this.aberrant = !0,
                this.ai |= s.AiType.Hostile,
                this.ai &= ~s.AiType.Scared;
                let e = game.getMaxHealth();
                e <= 0 && (e = 60),
                r = Math.ceil(r * Math.max(e / 15, 2))
            }
            multiplayer.isConnected() && (r = Math.ceil(r * Math.max(game.getPlayers().length / 3, 1.5)));
            const l = this.aberrant && o.aberrantLoot ? o.aberrantLoot : o.loot;
            if (l) {
                this.loot = [];
                for (const e of l) {
                    const t = e.chance;
                    t ? B.default.percent() <= t && this.loot.push(e.item) : this.loot.push(e.item)
                }
            }
            this.initializeStats(r),
            this.setMoveType(o.moveType)
        }
        initializeStats(e, t) {
            const a = this.description();
            if (!a)
                return;
            let i;
            this.type !== d.CreatureType.Chicken && this.type !== d.CreatureType.Goat || (i = new u.default(l.Stat.Produce,this.type === d.CreatureType.Chicken ? 4e3 + B.default.int(1e3) : 2e3 + B.default.int(500)).setChangeTimer(1, -1)),
            this.stats = u.default.getStats(new u.default(l.Stat.Health,e).setMax(void 0 === t ? e : t), i)
        }
        getName(e, t) {
            return T.default.nameOf(m.Dictionary.Creature, this, t, e).addReformatter(T.default.message(h.default.Aberrant).addArgs(this.aberrant), !0).addReformatter(this.aberrant ? new T.default(m.Dictionary.Misc,y.MiscTranslation.Aberrant) : void 0)
        }
        description() {
            return this._description || (this._description = i.default[this.type]),
            this._description
        }
        inspect({inspector: e, context: t, inspectEntityHealth: a}, i) {
            if (this.isHidden())
                return;
            i.border = this.aberrant ? "var(--message-type-bad)" : void 0,
            i.add({
                title: !0,
                name: !0,
                text: this.getName()
            }),
            i.add(new T.default(m.Dictionary.Creature,this.type,1).setFailWith("")),
            this.aberrant && i.add({
                messageType: M.MessageType.Bad,
                text: T.default.message(h.default.AppearsToBeAberrant).inContext(4).addArgs(T.default.message(h.default.TheCreature))
            });
            const n = T.default.message(h.default.TheCreature).addArgs(this.getName(!1));
            i.addExtra(a(this, n));
            const o = e.getSkill(d.SkillType.Anatomy);
            i.addExtra(this.inspectResistancesAndVulnerabilities(e, n, T.default.message(o > 50 ? h.default.ItAlsoReveals : h.default.ItAlsoSeems))),
            i.add(this.inspectHappiness(e))
        }
        isHidden() {
            return 0 != (this.ai & s.AiType.Hidden)
        }
        isDefender() {
            return 0 != (this.ai & s.AiType.Defender)
        }
        checkForBurn(e=this.getMoveType() ) {
            const t = this.description();
            if (!t)
                return !1;
            if ((e & d.MoveType.Flying) === d.MoveType.Flying)
                return !1;
            const a = this.getTile()
              , i = E.default.getType(a);
            if (tileEventManager.get(a, A.TileEventType.Fire) || i === d.TerrainType.Lava) {
                const e = B.default.intInRange(4, 8);
                if (this.damage({
                    amount: e,
                    type: d.DamageType.Fire
                }),
                !a.creature)
                    return !1
            }
            return !0
        }
        isTamed() {
            return 0 != (this.ai & s.AiType.Tamed)
        }
        tame(e) {
            if (this.isTamed())
                return !1;
            this.ai = s.AiType.Tamed | s.AiType.Follower | s.AiType.Defender,
            this._owner = e,
            e.tamedCreatures.push(this.id),
            this.increaseTamedCount();
            const t = this.description();
            t && new u.default(l.Stat.Happiness,creatureManager.getHappinessLevel(e, this)).setChangeTimer(1, -1).initializeOn(this);
            const a = this.getStat(l.Stat.Health);
            if (this.setStatMax(a, Math.floor(a.max / 1.15)),
            this.setStat(a, Math.floor(a.value / 1.15)),
            a.max <= 0 && this.setStatMax(a, 1),
            a.value <= 0 && this.setStat(a, 1),
            this.hasStat(l.Stat.Produce)) {
                this.getStat(l.Stat.Produce).value <= 100 && this.setStat(l.Stat.Produce, 50 + B.default.int(100));
                const e = this.getStat(l.Stat.Produce);
                e && (e.changeAmount *= 2)
            }
            return e.addMilestone(w.MilestoneType.Friendly),
            e.addMilestone(w.MilestoneType.Pacifier, this.type),
            modManager.getHook(S.Hook.OnCreatureTamed).call(this, e),
            !0
        }
        increaseTamedCount() {
            this.hasStat(l.Stat.Tamed) ? this.increaseStat(l.Stat.Tamed, 1) : new u.default(l.Stat.Tamed,1).initializeOn(this)
        }
        release() {
            if (!this.isTamed())
                return !1;
            this.ai = s.AiType.Neutral,
            this._owner = void 0;
            const e = this.id;
            for (const t of players) {
                const a = t.tamedCreatures.indexOf(e);
                if (-1 !== a) {
                    t.tamedCreatures.splice(a, 1);
                    break
                }
            }
            if (this.hasStat(l.Stat.Produce)) {
                const e = this.getStat(l.Stat.Produce);
                e && (e.changeAmount /= 2)
            }
            return this.removeStat(l.Stat.Happiness),
            !0
        }
        pet() {
            return !!this.isTamed()
        }
        skipNextUpdate() {
            this.shouldSkipNextUpdate = !0
        }
        getMoveType() {
            if (void 0 === this.moveType) {
                const e = this.description();
                this.moveType = e ? e.moveType : d.MoveType.None
            }
            return this.moveType
        }
        queueSoundEffect(e, t=0, a=(this.aberrant?.5:1) ) {
            super.queueSoundEffect(e, t, a)
        }
        update() {
            const e = this.description();
            if (!e)
                return !1;
            if (this.shouldSkipNextUpdate)
                return this.shouldSkipNextUpdate = !1,
                !1;
            const t = this.getMoveType();
            this.fromX = this.x,
            this.fromY = this.y,
            this.isInFov() && (this.anim = 1 - this.anim),
            this.updateStats();
            const a = this.getStat(l.Stat.Happiness, !0);
            a && a.value <= 0 && (this.release(),
            M.default.toAll(e=>e.ifVisible(this).source(v.Source.Allies, v.Source.Creature).send(h.default.CreatureUntamed, this.getName())));
            const i = game.getNearestPlayer(this.x, this.y);
            let n = i;
            if (void 0 !== this.enemy)
                if (!0 === this.enemyIsPlayer) {
                    const e = players[this.enemy];
                    e && this.z === e.z && !e.isGhost() ? n = e : this.enemy = void 0
                } else {
                    const e = game.creatures[this.enemy];
                    !e || this.z !== e.z || this.isTamed() && e.isTamed() ? this.enemy = void 0 : n = e
                }
            if (this.isTamed() && (this.isDefender() ? n === this.getOwner() ? n = void 0 : !(n instanceof b.default) || multiplayer.isConnected() && multiplayer.getOptions().pvp || (n = void 0) : n = void 0),
            !e.fishable && n) {
                const a = game.getTile(this.x, this.y, this.z);
                if (a && a.doodad && a.doodad.checkForTrampling(this),
                this.processAttack(e, t, n))
                    return !1
            }
            return !(void 0 !== e.skipMovementChance && B.default.percent() <= e.skipMovementChance) && this.processMovement(e, t, n, i)
        }
        moveTo(e, t, a) {
            const i = this.getTile();
            delete i.creature,
            game.updateFlowFieldTile(i, this.x, this.y, this.z);
            const n = game.getTile(e, t, a);
            return n.creature = this,
            this.x = e,
            this.y = t,
            this.z = a,
            game.updateFlowFieldTile(n, this.x, this.y, this.z),
            this._movementFinishTime = game.getMovementFinishTime(),
            !0
        }
        checkUnder(e=this.x, t=this.y) {
            const a = this.description()
              , i = game.getTile(e, t, this.z)
              , n = P.default[E.default.getType(i)];
            if ((n && (n.shallowWater || n.water) && (this.getMoveType() & d.MoveType.Flying) !== d.MoveType.Flying || n && a && a.particlesOnMove) && game.particle.create(e, t, this.z, n.particles),
            !this.checkForBurn())
                return !0;
            const o = i.doodad;
            if (o) {
                const a = o.description();
                if (a && a.isTrap) {
                    const i = B.default.percent();
                    let n = 0;
                    if (o.type === d.DoodadType.SetHobgoblinSnare)
                        75 >= i - 50 && (n = B.default.int(6) + 3,
                        this.queueSoundEffect(d.SfxType.CreatureHit));
                    else {
                        const r = o.getOwner()
                          , s = game.getSkillPercent(d.SkillType.Trapping);
                        if (s >= i - 50) {
                            const e = a.trapDamage ? a.trapDamage : 0;
                            n = e + Math.floor(s / 10) + B.default.int(3),
                            o.legendary && o.legendary.type === d.LegendaryType.TrapDamage && (n += o.legendary.value),
                            this.queueSoundEffect(d.SfxType.CreatureHit),
                            r && (r.skillGain(d.SkillType.Trapping),
                            r.addMilestone(w.MilestoneType.Trapper))
                        } else
                            this.queueSoundEffect(d.SfxType.Miss),
                            r && r.canSeePosition(e, t, this.z) && r.skillGain(d.SkillType.Trapping, .1),
                            M.default.toAll(e=>e.ifVisible(o).source(v.Source.Combat).type(M.MessageType.Miss).send(h.default.TrapMissed, this.getName())),
                            game.notifier.addStat(this.x, this.y, this.z, d.StatType.Miss, 0)
                    }
                    if (n) {
                        const a = this.damage({
                            amount: n,
                            type: d.DamageType.Blunt
                        }, e, t);
                        return this.getStatValue(l.Stat.Health) <= 0 && modManager.getHook(S.Hook.OnEntityKill).call(o, this),
                        this.stopNextMovement = !0,
                        M.default.toAll(e=>e.ifVisible(o).source(v.Source.Combat, v.Source.Creature).type(a ? M.MessageType.Attack : M.MessageType.Miss).send(a ? h.default.HasBeenHurtByATrap : h.default.HasSetTrapOffNoDamage, this.getName(), a)),
                        o.setOffTrap(),
                        !1
                    }
                }
            }
            if (i.containedItems && i.containedItems.length > 0 && !this.isTamed() && (!this.hasStat(l.Stat.Happiness) || this.getStat(l.Stat.Happiness).value <= 0)) {
                const a = this.offer(i.containedItems);
                if (void 0 !== a) {
                    const i = game.getNearestPlayer(e, t, this.z);
                    if (i && i.canSeePosition(e, t, this.z)) {
                        const e = this.hasStat(l.Stat.Tamed) ? this.getStatValue(l.Stat.Tamed) : void 0;
                        return this.aberrant && B.default.percent() - Math.floor(i.getSkill(d.SkillType.Taming) / 7.5) - (void 0 !== e ? e : 1) >= 50 ? M.default.get(i).source(v.Source.Creature).send(h.default.YouNoticeTakeFromGround, this.getName(), a.getName()) : (this.tame(i),
                        M.default.get(i).source(v.Source.Allies, v.Source.Creature).send(h.default.TakenFromGroundBecomeTamed, this.getName(), a.getName())),
                        i.skillGain(d.SkillType.Taming),
                        this.queueSoundEffect(d.SfxType.CreatureNoise),
                        itemManager.remove(a),
                        !1
                    }
                }
            }
            return !0
        }
        canSwapWith(e) {
            return void 0 === this.hitchedTo && 0 === this.checkCreatureMove(e.x, e.y, e.z, e.getTile(), this.getMoveType(), !1, e)
        }
        getOwner() {
            if (this.isTamed()) {
                if (this._owner)
                    return this._owner;
                for (const e of players)
                    if (e.hasTamedCreature(this))
                        return this._owner = e,
                        e
            }
        }
        damage(e, t=this.x, i=this.y, n=this.z) {
            const o = this.description();
            if (!o)
                return;
            const r = game.damage(this, e);
            if (this.getStat(l.Stat.Health).value > 0)
                return e.human && void 0 === this.enemy && (this.isTamed() && this.isDefender() || game.getDifficultyOptions().peaceful) && (this.enemy = e.human.id,
                this.enemyIsPlayer = !0,
                this.enemyAttempts = void 0),
                r;
            for (const e of game.getPlayersThatSeePosition(t, i, n))
                e.notes.write(g.default.CreatureTaming, this.getName(!1));
            if (void 0 !== this.hitchedTo) {
                const e = game.doodads[this.hitchedTo];
                e && (e.hitchedCreature = void 0)
            }
            if (e.weaponName && M.default.get(e.human).source(v.Source.Combat, v.Source.Action, v.Source.Creature).send(h.default.YouHaveKilled, this.getName()),
            e.skipMilestones || !e.human || this.respawned || (e.human.addMilestone(w.MilestoneType.Hunter),
            e.human.addMilestone(w.MilestoneType.Exterminator),
            e.human.addMilestone(w.MilestoneType.Huntsman, this.type)),
            !this.respawned) {
                const a = this.loot;
                if (a)
                    for (let e = 0; e < a.length; e++) {
                        const o = itemManager.getRandomQuality(a[e], this.aberrant ? 560 : 200);
                        itemManager.create(a[e], itemManager.getTileContainer(t, i, n), o)
                    }
                if (void 0 !== o.lootGroup) {
                    const e = c.default[o.lootGroup];
                    if (e) {
                        const a = B.default.getElement(e)
                          , o = itemManager.getRandomQuality(a, this.aberrant ? 560 : 200);
                        itemManager.create(a, itemManager.getTileContainer(t, i, n), o)
                    }
                }
                this.aberrant && e.human && e.human.addMilestone(w.MilestoneType.Abnormalizer)
            }
            const s = a.default[this.type];
            return this.type !== d.CreatureType.Cod && this.type !== d.CreatureType.Blindfish && s && corpseManager.create(this.type, t, i, n, s.decay, this.aberrant, this.renamed),
            this.type === d.CreatureType.JellyCube ? creatureManager.spawn(d.CreatureType.Slime, t, i, n) : this.type === d.CreatureType.Drake && e.human && e.human.addMilestone(w.MilestoneType.DragonSlayer),
            this.aberrant && o.reputation < 0 ? game.updateReputation(Math.floor(-1 * o.reputation / 2)) : game.updateReputation(o.reputation),
            modManager.getHook(S.Hook.OnCreatureDeath).call(this),
            creatureManager.remove(this),
            r
        }
        onUnserialized() {
            this.description()
        }
        offer(e) {
            const t = this.description();
            if (!t)
                return;
            const a = t.acceptedItems;
            if (a)
                for (const t of e) {
                    const e = t.description();
                    if (e)
                        for (const i of a)
                            if (!e.recipe || t.ownerIdentifier) {
                                if (i === t.type)
                                    return t;
                                if (itemManager.isGroup(i) && itemManager.isInGroup(t.type, i))
                                    return t
                            }
                }
        }
        inspectResistancesAndVulnerabilities(e, t=this.getName() , a) {
            const i = this.description();
            if (!i)
                return;
            const n = i.defense.resist
              , o = i.defense.vulnerable
              , r = e.getSkill(d.SkillType.Anatomy)
              , s = []
              , l = []
              , u = new T.default(m.Dictionary.Skill,d.SkillType.Anatomy);
            if (r <= 25) {
                a = a || T.default.message(h.default.YourLowSkill).addArgs(u);
                const e = Object.keys(n)
                  , i = Object.keys(o);
                return T.default.message(h.default.RevealsSomeResistancesAndVulnerabilities).inContext(4).addArgs(a, t, e.length, i.length)
            }
            for (const e of G.default.values(d.DamageType))
                n[e] && s.push(e),
                o[e] && l.push(e);
            if (r <= 50)
                return a = a || T.default.message(h.default.YourModerateSkill).addArgs(u),
                T.default.message(h.default.RevealsNumberOfResistancesAndVulnerabilities).inContext(4).addArgs(a, t, f.fullDamageType(s), f.fullDamageType(l));
            {
                a = a || T.default.message(h.default.YourHighSkill).addArgs(u);
                const e = f.fullDamageType(s, e=>T.default.message(99 === n[e] || 100 === n[e] ? h.default.ResistOrVulnAll : h.default.ResistOrVuln).addArgs(n[e]).inContext(1))
                  , i = f.fullDamageType(l, e=>T.default.message(99 === o[e] || 100 === o[e] ? h.default.ResistOrVulnAll : h.default.ResistOrVuln).addArgs(o[e]).inContext(1));
                return T.default.message(h.default.RevealsResistancesAndVulnerabilities).inContext(4).addArgs(a, t, e, i)
            }
        }
        inspectHappiness(e) {
            if (!this.isTamed() || !this.hasStat(l.Stat.Happiness))
                return;
            let t, a = M.MessageType.Good;
            const i = creatureManager.getHappinessLevel(e, this)
              , n = this.getStat(l.Stat.Happiness);
            return n.value / i <= .25 ? (t = h.default.TamedAppearsAngered,
            a = M.MessageType.Bad) : t = n.value / i <= .5 ? h.default.TamedAppearsUpset : n.value / i <= .75 ? h.default.TamedAppearsContended : h.default.TamedAppearsHappy,
            {
                messageType: a,
                text: T.default.message(h.default.TamedCreature).addArgs(T.default.message(t))
            }
        }
        findPath(e) {
            const t = this.getMoveType()
              , a = (a,i)=>0 !== this.checkCreatureMove(i.x, i.y, this.z, a, t, i.x === e.x && i.y === e.y);
            return n.findPath(this, e, this.z, a)
        }
        checkCreatureMove(e, t, a, i, n, o=!1, r) {
            const s = this.description();
            if (!s)
                return -1;
            const l = modManager.getHook(S.Hook.CanCreatureMove).call(this, i, e, t, a, n);
            if (!1 === l)
                return 1;
            if (!0 === l)
                return 0;
            if (n === d.MoveType.None)
                return 2;
            if (!s.fishable)
                for (const i of game.getPlayers(!1, !0))
                    if (i !== r && e === i.x && t === i.y && a === i.z)
                        return 3;
            const u = creatureManager.getMovePenalty(n, i, o);
            return u >= p.blockedPenalty ? 4 : 0
        }
        findPlayersWithinRadius(e, t, a, i) {
            const n = [];
            for (const o of game.getPlayers())
                o.z === a && o.x >= e - i && o.x <= e + i && o.y >= t - i && o.y <= t + i && n.push(o);
            return n
        }
        processAttack(e, t, a) {
            const i = this.getStat(l.Stat.Health);
            (i.value / e.maxhp <= .1 || i.value <= 1) && t !== d.MoveType.None && (this.ai |= s.AiType.Scared,
            this.ai &= ~s.AiType.Hostile);
            let n = !1;
            if (a) {
                let e;
                e = 0 === B.default.int(20) ? this.findPlayersWithinRadius(this.x, this.y, this.z, 3) : this.findPlayersWithinRadius(this.x, this.y, this.z, 2);
                for (const t of e)
                    t.cancelResting(d.RestCancelReason.CreatureNearby)
            }
            if (a && this.z === a.z && Math.abs(this.x - a.x) + Math.abs(this.y - a.y) === 1 && (this.isDefender() || t === d.MoveType.None ? n = !0 : (0 == (this.ai & s.AiType.Hostile) || game.getDifficultyOptions().peaceful && (void 0 === this.enemy || this.enemy !== a.id)) && ((this.ai & s.AiType.Scared) !== s.AiType.Scared && this.ai !== s.AiType.Neutral || 0 !== B.default.int(3)) || (n = !0)),
            n && (t & d.MoveType.Flying) !== d.MoveType.Flying) {
                const t = this.getTile();
                tileEventManager.get(t, A.TileEventType.Fire) && 100 !== e.defense.resist[d.DamageType.Fire] && (n = !1)
            }
            if (!n || !a || !1 === modManager.getHook(S.Hook.CanCreatureAttack).call(this, a))
                return !1;
            let o = B.default.intInRange(e.minatk, e.maxatk)
              , r = 1;
            if (this.aberrant && (a instanceof b.default ? (r = Math.max(a.skills[d.SkillType.Parrying].core / 35, 2),
            o = Math.ceil(o * r)) : o *= 2,
            o > 75 && (o = 75),
            this.isTamed() || (this.ai |= s.AiType.Hostile,
            this.ai &= ~s.AiType.Scared)),
            this.fromX = this.x + (a.x - this.x) / 3,
            this.fromY = this.y + (a.y - this.y) / 3,
            this.facingDirection = Math.ceil((Math.atan2(a.y - this.y, this.x - a.x) + Math.PI) / (Math.PI / 2)) % 4,
            this.isHidden())
                return this.ai |= s.AiType.Hostile,
                this.ai &= ~s.AiType.Hidden,
                !0;
            let u = 0, p = 0, c;
            if (a instanceof b.default) {
                u += a.defense.base;
                for (const t of G.default.values(d.DamageType))
                    e.damageType & t && (u += a.defenses[t] * r,
                    p += a.defenses[t])
            }
            p > 0 ? c = T.default.message(h.default.ArmorAppeared).addArgs(T.default.message(h.default.Resistant)) : p < 0 && (c = T.default.message(h.default.ArmorAppeared).addArgs(T.default.message(h.default.Vulnerable)));
            let m = 0;
            if (a instanceof b.default) {
                if (m = a.defense.parrying + u,
                m = u / 3 + B.default.int(m),
                0 != (this.ai & s.AiType.Hostile)) {
                    const t = e.defense.resist
                      , i = e.defense.vulnerable
                      , n = []
                      , o = [];
                    for (const e of G.default.values(d.DamageType))
                        t[e] && n.push(e),
                        i[e] && o.push(e);
                    a.notes.write(g.default.Combat, this.getName(), f.fullDamageType(n), f.fullDamageType(o))
                }
                a.damageRandomEquipment()
            }
            if (o = Math.ceil(o - m),
            this.type === d.CreatureType.LavaBeetle && 0 === B.default.int(10)) {
                const e = game.getTile(a.x, a.y, a.z);
                if (void 0 === e.doodad) {
                    game.changeTile(d.TerrainType.Lava, a.x, a.y, a.z, !1),
                    game.particle.create(a.x, a.y, a.z, C.default[k.ParticleType.Fire]),
                    a.queueSoundEffect(d.SfxType.Water),
                    M.default.toAll(e=>e.ifVisible(a).source(v.Source.Combat, v.Source.Creature).send(h.default.YouSeeSpewLava, this.getName()));
                    const t = e;
                    (t.containedItems || void 0 !== e.corpses) && (tileEventManager.get(e, A.TileEventType.Fire) || tileEventManager.create(A.TileEventType.Fire, a.x, a.y, a.z))
                }
            } else if (this.type === d.CreatureType.Drake && 0 === B.default.int(6))
                game.fireBreath(this.x, this.y, this.z, this.facingDirection),
                M.default.toAll(e=>e.ifVisible(this).source(v.Source.Combat, v.Source.Creature).send(h.default.YouSeeEngulfFire, this.getName()));
            else if (a instanceof b.default && this.type === d.CreatureType.SlitherSucker && 0 === B.default.int(6)) {
                const e = itemManager.create(this.aberrant ? d.ItemType.AberrantSlitherSucker : d.ItemType.SlitherSucker, a.inventory)
                  , t = a.getEquippedItem(d.EquipType.Head);
                return t && a.unequip(t, !0, !0),
                e.maxDur = i.max,
                e.minDur = i.value,
                a.equip(e, d.EquipType.Head, !0),
                a.messages.source(v.Source.Equipment, v.Source.Combat, v.Source.Wellbeing, v.Source.Creature).send(h.default.SlitherSuckerJumpedOnHead, this.getName()),
                creatureManager.remove(this),
                !0
            }
            if (o > 0 || o <= 0 && 0 === B.default.int(8))
                if (o <= 0 && (o = 1),
                a instanceof b.default) {
                    let t;
                    game.particle.create(a.x, a.y, a.z, C.default[k.ParticleType.Blood]),
                    0 === B.default.int(15) && corpseManager.createBlood(a.x, a.y, a.z),
                    a.defense.parrying > 0 && a.skillGain(d.SkillType.Parrying, .1),
                    a.messages.source(v.Source.Wellbeing, v.Source.Combat, v.Source.Creature).type(M.MessageType.Bad).send(h.default.HasHitYouForDamage, this.getName(), o, c);
                    const i = this.aberrant ? 16 : 8
                      , n = Math.floor(a.getSkill(d.SkillType.Anatomy) / (this.aberrant ? 10 : 20));
                    if (e.canCauseStatus)
                        for (const o of e.canCauseStatus)
                            switch (o) {
                            case d.StatusType.Bleeding:
                                a.hasStatus(d.StatusType.Bleeding) || (t = B.default.percent()) <= i - n && (a.messages.source(v.Source.Wellbeing, v.Source.Combat).send(h.default.BleedingProfusely),
                                a.skillGain(d.SkillType.Anatomy, .1),
                                a.setStatus(d.StatusType.Bleeding, !0, s.StatusEffectChangeReason.Gained),
                                a.notes.write(g.default.Bleeding, this.getName()));
                                break;
                            case d.StatusType.Poisoned:
                                a.hasStatus(d.StatusType.Poisoned) || (t = B.default.percent()) <= i - n && (a.messages.source(v.Source.Combat, v.Source.Wellbeing).type(M.MessageType.Bad).send(h.default.BeenPoisoned),
                                a.skillGain(d.SkillType.Anatomy, .1),
                                a.setStatus(d.StatusType.Poisoned, !0, s.StatusEffectChangeReason.Gained),
                                a.notes.write(g.default.Poisoned, this.getName()));
                                break;
                            case d.StatusType.Burned:
                                if (!a.hasStatus(d.StatusType.Burned) && (t = B.default.percent()) <= i - n) {
                                    const e = a.burn(!1, !1, void 0, !0);
                                    e && a.skillGain(d.SkillType.Anatomy, .1)
                                }
                            }
                    a.damage({
                        amount: o,
                        type: d.DamageType.True,
                        creature: this,
                        damageMessage: T.default.message(h.default.DeathBy).addArgs(this.getName()),
                        soundDelay: 6,
                        legacy: !0
                    }),
                    a.getStat(l.Stat.Health).value <= 0 && 0 != (this.ai & s.AiType.Hostile) && 0 == (this.ai & s.AiType.Fearless) && (this.ai |= s.AiType.Random,
                    this.ai &= ~s.AiType.Hostile)
                } else
                    a instanceof O && (a.damage({
                        amount: o,
                        type: e.damageType,
                        creature: this,
                        skipMilestones: !0
                    }),
                    a.enemy = this.id,
                    a.enemyIsPlayer = !1,
                    a.enemyAttempts = void 0);
            else
                a instanceof b.default && (a.defense.parrying > 0 && a.skillGain(d.SkillType.Parrying),
                this.queueSoundEffect(d.SfxType.Miss, 6),
                a.messages.source(v.Source.Combat, v.Source.Wellbeing, v.Source.Creature).type(M.MessageType.Miss).send(h.default.DealtNoDamageToYou, this.getName()));
            return a instanceof b.default && (a.defense.parrying > 0 ? a.staminaReduction(d.SkillType.Parrying) : a.staminaReduction(d.SkillType.Tactics),
            multiplayer.isConnected() || a.addDelay(13),
            a.setTamedCreatureEnemy(this)),
            this.checkForBurn(t),
            !0
        }
        processMovement(e, t, a, i) {
            if (!this.isInFov()) {
                const e = this.getStat(l.Stat.Health);
                return this.renamed || this.isTamed() || !(e.value >= e.max) || i && i.z !== this.z || !(0 === B.default.int(19e3) || this.type === d.CreatureType.Shark && 0 === B.default.int(1e4) || this.z !== d.WorldZ.Cave && game.time.getTime() < .65 && (this.type === d.CreatureType.VampireBat || this.type === d.CreatureType.Zombie)) || creatureManager.remove(this),
                !1
            }
            if (this.z === d.WorldZ.Cave || this.type !== d.CreatureType.VampireBat && this.type !== d.CreatureType.Zombie || (game.time.getTime() < .65 && 0 != (this.ai & s.AiType.Hostile) ? (this.ai |= s.AiType.Scared,
            this.ai &= ~s.AiType.Hostile) : game.time.getTime() >= .65 && 0 != (this.ai & s.AiType.Scared) && (this.ai |= s.AiType.Hostile,
            this.ai &= ~s.AiType.Scared)),
            this.stopNextMovement)
                return this.stopNextMovement = !1,
                !1;
            const n = this.getTile();
            if (!n)
                return !1;
            if (void 0 !== this.hitchedTo) {
                this.facingDirection = B.default.choice(d.Direction.North, d.Direction.East, d.Direction.South, d.Direction.West);
                const e = game.doodads[this.hitchedTo];
                return e && this.breakDoodad(e, t),
                n.doodad && n.doodad.checkForTrampling(this),
                this.processSpecialAbilities(a),
                this.checkUnder(),
                !1
            }
            if (t === d.MoveType.None)
                return !1;
            this.processAiChanges(i);
            let o = this.x, r = this.y, u = this.z, p;
            multiplayer.addSyncCheck(I.MultiplayerSyncCheck.CreatureNearestPlayer, i ? i.id : -1);
            let c = 0 != (this.ai & s.AiType.Hostile) && !game.getDifficultyOptions().peaceful;
            if (!c && 0 != (this.ai & s.AiType.Follower)) {
                let e = i;
                for (const t of game.getPlayers())
                    if (t.hasTamedCreature(this)) {
                        e = t;
                        break
                    }
                void 0 !== e && (Math.abs(o - e.x) > 2 || Math.abs(r - e.y) > 2) && (c = !0)
            }
            let m = !1;
            if (a && (a instanceof O || this.isTamed()) && !e.fishable) {
                const e = this.findPath(a);
                e && e.length >= 2 ? (m = !0,
                o = e[1].x,
                r = e[1].y,
                this.enemyAttempts = void 0) : this.enemy && (void 0 === this.enemyAttempts && (this.enemyAttempts = 0),
                this.enemyAttempts++,
                this.enemyAttempts >= 4 && (this.enemy = void 0,
                this.enemyAttempts = void 0))
            }
            const h = E.default.getType(n);
            let y;
            if (h && h === d.TerrainType.CaveEntrance && void 0 !== i && i.z !== this.z && (e.spawnReputation && game.getReputation() <= e.spawnReputation || this.isTamed()) && (m = !0,
            o = this.x,
            r = this.y,
            u = this.z === d.WorldZ.Cave ? d.WorldZ.Overworld : d.WorldZ.Cave),
            !m) {
                let a;
                if (a = ((t & d.MoveType.Flying) === d.MoveType.Flying || !tileEventManager.get(n, A.TileEventType.Fire) || 100 === e.defense.resist[d.DamageType.Fire]) && flowFieldManager.isInFlowField(this),
                multiplayer.addSyncCheck(I.MultiplayerSyncCheck.CreatureIsInFlowField, a),
                h === d.TerrainType.CaveEntrance && void 0 !== i && i.z !== this.z && (e.spawnReputation && game.getReputation() <= e.spawnReputation || this.isTamed()))
                    m = !0,
                    o = this.x,
                    r = this.y,
                    u = this.z === d.WorldZ.Cave ? d.WorldZ.Overworld : d.WorldZ.Cave;
                else if (c && a) {
                    const e = flowFieldManager.getMoveDirection(this.x, this.y, this.z, t);
                    switch (multiplayer.addSyncCheck(I.MultiplayerSyncCheck.CreatureMoveDirection, e),
                    e) {
                    case d.Direction.West:
                        o -= 1;
                        break;
                    case d.Direction.East:
                        o += 1;
                        break;
                    case d.Direction.North:
                        r -= 1;
                        break;
                    case d.Direction.South:
                        r += 1
                    }
                } else if (0 != (this.ai & s.AiType.Fleeing) && a && 0 !== B.default.int(8)) {
                    const e = flowFieldManager.getOpposingMoveDirection(this.x, this.y, this.z, t);
                    multiplayer.addSyncCheck(I.MultiplayerSyncCheck.CreatureMoveDirection, e),
                    e === d.Direction.West ? o += 1 : e === d.Direction.East ? o -= 1 : e === d.Direction.North ? r += 1 : e === d.Direction.South && (r -= 1)
                } else {
                    const a = B.default.shuffle([0, 1, 2, 3, 4]);
                    for (let i = 0; i < 4; i++) {
                        switch (a[i]) {
                        case 0:
                            o = this.x + 1,
                            r = this.y;
                            break;
                        case 1:
                            o = this.x,
                            r = this.y + 1;
                            break;
                        case 2:
                            o = this.x - 1,
                            r = this.y;
                            break;
                        case 3:
                            o = this.x,
                            r = this.y - 1;
                            break;
                        case 4:
                            o = this.x,
                            r = this.y
                        }
                        if (this.type === d.CreatureType.TimeSkitter || this.type === d.CreatureType.SkeletalMage ? 0 === B.default.int(9) && (o = this.x + B.default.int(6) - 3,
                        r = this.y + B.default.int(6) - 3) : e.fishable && 0 === B.default.int(4) && (o = this.x + B.default.int(3) - 1,
                        r = this.y + B.default.int(3) - 1),
                        o = game.getWrappedCoord(o),
                        r = game.getWrappedCoord(r),
                        y = game.getTile(o, r, u),
                        0 === this.checkCreatureMove(o, r, u, y, t))
                            break
                    }
                }
            }
            this.facingDirection = Math.ceil((Math.atan2(r - this.fromY, this.fromX - o) + Math.PI) / (Math.PI / 2)) % 4;
            const g = e.speed || 1;
            let f, T;
            for (let e = 0; e < g && (0 === e || B.default.chance(.5)); e++) {
                f = o,
                T = r,
                e && (this.facingDirection === d.Direction.West ? o -= 1 : this.facingDirection === d.Direction.East ? o += 1 : this.facingDirection === d.Direction.North ? r -= 1 : this.facingDirection === d.Direction.South && (r += 1)),
                o = game.getWrappedCoord(o),
                r = game.getWrappedCoord(r);
                const a = (y = game.getTile(o, r, u)).doodad
                  , i = a && a.blocksMove() && (t & d.MoveType.Flying) !== d.MoveType.Flying;
                if (a && (this.type !== d.CreatureType.Hobgoblin || a.type !== d.DoodadType.WoodenDoor && a.type !== d.DoodadType.WoodenGate || (a.type === d.DoodadType.WoodenDoor ? a.changeType(d.DoodadType.WoodenDoorOpen) : a.type === d.DoodadType.WoodenGate && a.changeType(d.DoodadType.WoodenGateOpen),
                world.updateTile(a.x, a.y, a.z, y))),
                0 !== this.checkCreatureMove(o, r, u, y, t) || i) {
                    o = f,
                    r = T,
                    a && i && this.breakDoodad(a, t);
                    break
                }
                if (a && a.checkForTrampling(this),
                p = y,
                !this.checkUnder(o, r))
                    break
            }
            return game.creatures[this.id] !== this || (this.processSpecialAbilities(a),
            void 0 !== p && this.originalMoveType && 0 === this.checkCreatureMove(o, r, u, p, this.originalMoveType) && (this.setMoveType(this.originalMoveType),
            this.originalMoveType = void 0),
            void 0 !== p ? this.moveTo(o, r, u) : (this.checkUnder(),
            !0))
        }
        breakDoodad(e, t) {
            const a = e.description();
            if (a && a.canBreak && (t & d.MoveType.BreakDoodads) === d.MoveType.BreakDoodads && 0 === B.default.int(12)) {
                e.damage();
                const t = this.findPlayersWithinRadius(e.x, e.y, e.z, 0 === B.default.int(10) ? 5 : 0 === B.default.int(5) ? 4 : 3);
                for (const e of t)
                    e.cancelResting(d.RestCancelReason.NearbyCreatureDamagedDoodad);
                a.particles && game.particle.create(e.x, e.y, e.z, a.particles)
            }
        }
        processAiChanges(e) {
            const t = B.default.int(30);
            if (0 != (this.ai & s.AiType.Hostile) && t >= 0 && t <= 3 && 0 == (this.ai & s.AiType.Fearless) && (this.ai |= s.AiType.Random,
            this.ai &= ~s.AiType.Hostile),
            0 != (this.ai & s.AiType.Hostile) && 0 != (this.ai & s.AiType.Fearless) && 0 === t && (this.ai |= s.AiType.Random,
            this.ai &= ~s.AiType.Hostile),
            (0 != (this.ai & s.AiType.Random) && t >= 4 && t <= 15 || 0 != (this.ai & s.AiType.Random) && 0 != (this.ai & s.AiType.Fearless) && t >= 1 && t <= 15) && (this.ai |= s.AiType.Hostile,
            this.ai &= ~s.AiType.Random),
            void 0 !== e && 0 != (this.ai & s.AiType.Scared)) {
                const t = 0 != (this.ai & s.AiType.Fleeing)
                  , a = R.default.squaredDistance(this, e) < L;
                t && !a ? this.ai &= ~s.AiType.Fleeing : !t && a && (this.ai |= s.AiType.Fleeing)
            }
        }
        processSpecialAbilities(e) {
            switch (this.type) {
            case d.CreatureType.FireElemental:
                if (0 === B.default.int(40)) {
                    const e = this.x + B.default.int(6) - 3
                      , t = this.y + B.default.int(6) - 3
                      , a = game.getTile(e, t, this.z);
                    if (a) {
                        const i = P.default[E.default.getType(a)];
                        let n;
                        a.doodad && (n = a.doodad.description()),
                        (i && i.flammable && void 0 === a.doodad || n && (n.isFlammable || n.providesFire)) && void 0 === a.creature && !tileEventManager.get(a, A.TileEventType.Fire) && (tileEventManager.create(A.TileEventType.Fire, e, t, this.z),
                        game.particle.create(e, t, this.z, C.default[k.ParticleType.Fire]),
                        audio.queueEffect(d.SfxType.Throw, e, t, this.z),
                        M.default.toAll(a=>a.ifVisible(new x.default(e,t,this.z)).source(v.Source.Creature).send(h.default.YouSeeEngulfFire, this.getName())))
                    }
                }
                break;
            case d.CreatureType.AcidSpitterDemon:
                if (0 === B.default.int(30)) {
                    const e = this.x + B.default.int(6) - 3
                      , t = this.y + B.default.int(6) - 3;
                    multiplayer.addSyncCheck(I.MultiplayerSyncCheck.Random, `ASD:${e},${t}`),
                    game.isPositionEmpty(e, t, this.z) && (doodadManager.create(d.DoodadType.Acid, e, t, this.z),
                    audio.queueEffect(d.SfxType.Water, e, t, this.z),
                    M.default.toAll(a=>a.ifVisible(new x.default(e,t,this.z)).source(v.Source.Creature).send(h.default.YouSeeSpitAcid, this.getName())))
                }
                break;
            case d.CreatureType.SkeletalMage:
                if (void 0 !== e && 0 === B.default.int(80)) {
                    const t = e.x + B.default.int(3) - 1
                      , a = e.y + B.default.int(3) - 1;
                    if (multiplayer.addSyncCheck(I.MultiplayerSyncCheck.Random, `SM:${t},${a}`),
                    game.isPositionEmpty(t, a, this.z) && game.canASeeB(this.x, this.y, this.z, t, a, e.z)) {
                        doodadManager.create(d.DoodadType.SkeletalRemains, t, a, this.z);
                        const e = o.default[d.DoodadType.SkeletalRemains];
                        e && e.particles && game.particle.create(t, a, this.z, e.particles),
                        audio.queueEffect(d.SfxType.Bow, t, a, this.z),
                        M.default.toAll(e=>e.ifVisible(new x.default(t,a,this.z)).source(v.Source.Creature).send(h.default.YouSeeSummon, this.getName(), T.default.nameOf(m.Dictionary.Doodad, d.DoodadType.SkeletalRemains)))
                    }
                }
                break;
            case d.CreatureType.Bogling:
                if (0 === B.default.int(40)) {
                    const e = this.getTile();
                    if (e && E.default.getType(e) !== d.TerrainType.Swamp) {
                        game.changeTile(d.TerrainType.Swamp, this.x, this.y, this.z, !0);
                        const e = P.default[d.TerrainType.Swamp];
                        e && game.particle.create(this.x, this.y, this.z, e.particles),
                        audio.queueEffect(d.SfxType.Water, this.x, this.y, this.z),
                        M.default.toAll(e=>e.ifVisible(this).source(v.Source.Creature).send(h.default.YouSeeSwampFlood, this.getName()))
                    }
                }
                break;
            case d.CreatureType.Hobgoblin:
                if (0 === B.default.int(150)) {
                    const e = this.x + B.default.int(2) - 1
                      , t = this.y + B.default.int(2) - 1;
                    multiplayer.addSyncCheck(I.MultiplayerSyncCheck.Random, `HG:${e},${t}`),
                    game.isPositionEmpty(e, t, this.z) && (doodadManager.create(d.DoodadType.SetHobgoblinSnare, e, t, this.z),
                    audio.queueEffect(d.SfxType.PickUp, e, t, this.z),
                    M.default.toAll(a=>a.ifVisible(new x.default(e,t,this.z)).source(v.Source.Combat, v.Source.Creature).send(h.default.YouSeeLayingTrap, this.getName())))
                }
                break;
            case d.CreatureType.Chicken:
            case d.CreatureType.Harpy:
                0 !== B.default.int(750) || game.isPositionFull(this.x, this.y, this.z) || (itemManager.create(d.ItemType.Feather, itemManager.getTileContainer(this.x, this.y, this.z), d.ItemQuality.Random),
                M.default.toAll(e=>e.ifVisible(this).source(v.Source.Creature, v.Source.Item).send(h.default.YouSeeDrop, T.default.nameOf(m.Dictionary.Item, d.ItemType.Feather), this.getName())));
                const t = this.getStat(l.Stat.Produce, !0);
                this.isTamed() && t && t.value <= 0 && !game.isPositionFull(this.x, this.y, this.z) && (itemManager.create(d.ItemType.Egg, itemManager.getTileContainer(this.x, this.y, this.z), d.ItemQuality.Random),
                M.default.toAll(e=>e.ifVisible(this).source(v.Source.Creature, v.Source.Item).send(h.default.YouSeeLay, this.getName(), T.default.nameOf(m.Dictionary.Item, d.ItemType.Egg))),
                this.setStat(l.Stat.Produce, 5e3 + B.default.int(1e3)))
            }
        }
    }
    __decorate([Override], O.prototype, "entityType", void 0),
    __decorate([D.SaveProperty()], O.prototype, "aberrant", void 0),
    __decorate([D.SaveProperty()], O.prototype, "ai", void 0),
    __decorate([D.SaveProperty()], O.prototype, "enemy", void 0),
    __decorate([D.SaveProperty()], O.prototype, "enemyAttempts", void 0),
    __decorate([D.SaveProperty()], O.prototype, "enemyIsPlayer", void 0),
    __decorate([D.SaveProperty()], O.prototype, "loot", void 0),
    __decorate([D.SaveProperty()], O.prototype, "respawned", void 0),
    __decorate([D.SaveProperty()], O.prototype, "shouldSkipNextUpdate", void 0),
    __decorate([D.SaveProperty()], O.prototype, "type", void 0),
    __decorate([D.SaveProperty()], O.prototype, "originalMoveType", void 0),
    __decorate([D.SaveProperty()], O.prototype, "hitchedTo", void 0),
    __decorate([Override], O.prototype, "getName", null),
    __decorate([Override], O.prototype, "getMoveType", null),
    __decorate([Override], O.prototype, "queueSoundEffect", null),
    t.default = O
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("npc/npcs/IMerchant", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("ui/functional/IFunctionalSortable", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("ui/screens/BaseScreen", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor() {
            this.element = $(this.selector()),
            this.visible = !1,
            this.bindElements()
        }
        selector() {
            throw new Error("Not implemented")
        }
        bindElements() {}
        unbindElements() {}
        isVisible() {
            return this.visible
        }
        show(e) {
            this.visible || (this.visible = !0,
            ui.hideContextMenu(),
            this.doShow(),
            this.onShow(e))
        }
        doShow() {
            this.element.quickShow()
        }
        hide() {
            this.visible && (this.visible = !1,
            this.doHide(),
            this.onHide())
        }
        doHide() {
            this.element.quickHide()
        }
        onMouseDown(e) {}
        onMouseUpOrLeave(e) {}
        onMouseMove(e) {}
        onMouseScroll(e) {}
        onKeyDown(e, t, a) {}
        onKeyUp(e, t, a) {}
        onShow(e) {}
        onHide() {}
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("ui/screens/InGameScreen", ["require", "exports", "action/ActionExecutor", "action/IAction", "creature/Creature", "doodad/Doodads", "doodad/doodads/Doodad", "entity/IEntity", "entity/IStats", "Enums", "item/IItem", "item/ItemRecipeRequirementChecker", "item/Items", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/UiTranslation", "language/Messages", "language/Translation", "mod/IHookManager", "newui/BindingManager", "newui/INewUi", "newui/screen/IScreen", "newui/screen/screens/game/component/Dialog", "player/IMessageManager", "player/Skills", "steamworks/ISteamworks", "tile/Terrains", "ui/screens/BaseScreen", "utilities/Arrays", "utilities/Async", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/Log", "utilities/math/Math2", "utilities/Objects", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L) {
    var O;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Weight = 0] = "Weight",
        e[e.Attack = 1] = "Attack",
        e[e.Defense = 2] = "Defense",
        e[e.Reputation = 3] = "Reputation"
    }(O = t.TextElementId || (t.TextElementId = {}));
    const F = [u.Bindable.GameContextMenu1, u.Bindable.GameContextMenu2, u.Bindable.GameContextMenu3, u.Bindable.GameContextMenu4, u.Bindable.GameContextMenu5, u.Bindable.GameContextMenu6, u.Bindable.GameContextMenu7, u.Bindable.GameContextMenu8, u.Bindable.GameContextMenu9, u.Bindable.GameContextMenu10, u.Bindable.GameContextMenu11, u.Bindable.GameContextMenu12, u.Bindable.GameContextMenu13, u.Bindable.GameContextMenu14, u.Bindable.GameContextMenu15, u.Bindable.GameContextMenu16, u.Bindable.GameContextMenu17, u.Bindable.GameContextMenu18, u.Bindable.GameContextMenu19, u.Bindable.GameContextMenu20, u.Bindable.GameContextMenu21, u.Bindable.GameContextMenu22, u.Bindable.GameContextMenu23, u.Bindable.GameContextMenu24];
    var _;
    !function(e) {
        e[e.WaitingForDelay = 0] = "WaitingForDelay",
        e[e.HasDelay = 1] = "HasDelay",
        e[e.NoDelay = 2] = "NoDelay"
    }(_ || (_ = {}));
    class H extends D.default {
        constructor() {
            super(...arguments),
            this.shouldResetMovement = !1,
            this.shouldCancelSorting = !1,
            this.isQuickmoving = !1,
            this.blockedByNewUi = !1,
            this.elementContainerDialogs = [],
            this.elementOtherDialogs = [],
            this.sortingCancelled = !1,
            this.onInterrupt = ((e,t)=>{
                x.default.info(x.LogSource.Ui)("Interrupt opened"),
                game.paused || !game.playing || !game.isRealTimeMode() || multiplayer.isConnected() || localPlayer.isResting() || game.setPaused(!0),
                game.playing && localPlayer && (this.shouldResetMovement = !0,
                this.shouldCancelSorting = !0)
            }
            ),
            this.onInterruptClosed = ((e,t)=>{
                x.default.info(x.LogSource.Ui)("Interrupt closed"),
                this.element[0].focus();
                const a = newui.getScreen(v.ScreenId.Interrupt);
                a && a.visibleMenu || !game.paused || this.isOverlayVisible() || multiplayer.isConnected() || game.setPaused(!1, game.getTurnMode() === u.TurnMode.RealTime),
                S.bindingManager.removeAllPressStates()
            }
            )
        }
        selector() {
            return "#screen-in-game"
        }
        bindElements() {
            this.elementCanvas = $("canvas#game"),
            this.elementVisibleInGame = $(".visible-in-game"),
            this.elementStats = $("#stats"),
            this.elementStatHealth = $("[data-stat='Health']").children(".bar"),
            this.elementStatStamina = $("[data-stat='Stamina']").children(".bar"),
            this.elementStatHunger = $("[data-stat='Hunger']").children(".bar"),
            this.elementStatThirst = $("[data-stat='Thirst']").children(".bar"),
            this.elementStatBurn = $(".status-effects").find(".burn"),
            this.elementStatBleed = $(".status-effects").find(".bleed"),
            this.elementStatPoison = $(".status-effects").find(".poison"),
            this.elementAttributeWeight = $("[data-attribute='Weight']").children(".attribute"),
            this.elementAttributeAttack = $("[data-attribute='Attack']").children(".attribute"),
            this.elementAttributeDefense = $("[data-attribute='Defense']").children(".attribute"),
            this.elementAttributeReputation = $("[data-attribute='Reputation']").children(".attribute"),
            this.elementReputationBenignity = $("[data-attribute='Reputation']").find(".benignity"),
            this.elementReputationMalignity = $("[data-attribute='Reputation']").find(".malignity"),
            this.elementQuickSlotsContainer = $("#quick-slots");
            const e = this;
            this.elementActions = $("#actions"),
            this.elementDialogs = $("#dialogs"),
            this.elementDialogInventory = $("#inventory"),
            this.elementDialogInventoryContainer = this.elementDialogInventory.children("#container-inventory"),
            this.elementDialogCrafting = $("#crafting"),
            this.elementDialogCraftingContainer = this.elementDialogCrafting.find("#container-crafting"),
            this.elementDialogCraftingContainer.on("click", ".item", function(t) {
                localPlayer.hasDelay() || (e.onCraftingItemClick($(this)),
                e.unSelectElements()),
                t.preventDefault(),
                t.stopPropagation()
            }),
            this.elementDialogDismantleContainer = this.elementDialogCrafting.find("#container-dismantle"),
            this.elementDialogDismantleContainer.on("click", ".item", function(t) {
                if (!localPlayer.hasDelay()) {
                    const t = itemManager.getItemForHuman(localPlayer, parseInt($(this).data("item-type"), 10));
                    e.onDismantleItemClick(t),
                    e.unSelectElements()
                }
                t.preventDefault(),
                t.stopPropagation()
            }),
            this.elementDialogCraftingButton = this.elementDialogCrafting.find(".tabs .crafting-tab"),
            this.elementDialogDismantleButton = this.elementDialogCrafting.find(".tabs .dismantle-tab"),
            this.elementDialogCraftingButton.click(this.toggleCraftingTab.bind(this, "crafting", !1)),
            this.elementDialogDismantleButton.click(this.toggleCraftingTab.bind(this, "dismantle", !1)),
            this.toggleCraftingTabElements("crafting"),
            this.elementDialogEquipment = $("#equipment"),
            this.elementDialogEquipmentContainer = this.elementDialogEquipment.children("#container-equipment"),
            this.elementDialogEquipment.on("mouseup", "div[data-checkbox-id]", function(t) {
                e.changeEquipmentOption($(this).data("checkbox-id"))
            });
            const t = (e,t)=>{
                const a = e.data("checkbox-id")
                  , i = this.elementDialogEquipmentContainer.find(`ul[data-equip-slot="${a}"]`);
                t ? i.addClass("highlight") : i.removeClass("highlight")
            }
            ;
            this.elementDialogEquipment.on({
                mouseenter: function() {
                    t($(this), !0)
                },
                mouseleave: function() {
                    t($(this), !1)
                }
            }, "div[data-checkbox-id]"),
            this.element.on("input change", ".filter", function() {
                e.onFilterInput($(this).parent().find(".container"))
            }),
            $(document).functionalTooltip({
                selector: ".item:not(.sortable-helper),[data-tooltip],.container[data-attribute='Reputation'],.container[data-attribute='Attack'],.container[data-attribute='Defense']",
                trackMouse: !0,
                position: {
                    topOffset: 15,
                    leftOffset: 20
                },
                onClose() {
                    e.unSelectElements()
                },
                content() {
                    return e.getTooltipHtml(this)
                }
            }),
            this.elementVersion = $("#version"),
            $(".ui-helper-hidden-accessible").remove(),
            $(document).contextmenu(this.setupContextMenu()),
            this.bindSortable($(".sortable, #game, .quick-slot"))
        }
        changeEquipmentOption(e) {
            const t = "leftHand" === e
              , a = t ? !saveDataGlobal.options.leftHand : !saveDataGlobal.options.rightHand;
            game.updateOption(localPlayer, e, a),
            ui.setCheckboxValue(this.elementDialogEquipment, e, a),
            localPlayer.messages.source(M.Source.Meta).send(h.default.YouHaveEnabledDisabled, f.default.message(a ? h.default.Enabled : h.default.Disabled), f.default.message(t ? h.default.LeftHand : h.default.RightHand))
        }
        toggleCraftingTab(e, t=!0) {
            if (this.elementDialogCrafting.isVisible()) {
                if (t) {
                    const t = this.elementDialogCraftingContainer.isVisible();
                    if (t && "crafting" === e || !t && "dismantle" === e)
                        return void this.toggleDialog(this.elementDialogCrafting)
                }
            } else
                this.toggleDialog(this.elementDialogCrafting);
            this.toggleCraftingTabElements(e)
        }
        toggleCraftingTabElements(e) {
            "crafting" === e ? (this.elementDialogDismantleButton.removeClass("active"),
            this.elementDialogCraftingButton.addClass("active"),
            this.elementDialogCraftingContainer.show(),
            this.elementDialogDismantleContainer.hide()) : (this.elementDialogDismantleButton.addClass("active"),
            this.elementDialogCraftingButton.removeClass("active"),
            this.elementDialogCraftingContainer.hide(),
            this.elementDialogDismantleContainer.show())
        }
        unbindElements() {}
        bindSortable(e) {
            const t = (e,t,a=!1)=>{
                this.highlightItemElementByItemId(e, t, a)
            }
            ;
            e.functionalSortable({
                connectWith: ".sortable, #game, .quick-slot",
                appendTo: $("#screen-in-game"),
                zIndex: 999999,
                distance: 10,
                cursorAt: {
                    top: 18,
                    left: 18
                },
                onlyReceive: !0,
                onStart: e=>{
                    window.getSelection().removeAllRanges(),
                    this.tooltipDisable(),
                    this.sortableElement = e.item ? e.item.get(0) : void 0,
                    this.sortableElementPosition = void 0,
                    this.sortableElementTargetContainer = void 0,
                    this.sortingCancelled = !1,
                    this.onSortableAction = void 0,
                    ui.getBody().addClass("dragging"),
                    $(".item[data-selected-count]").each(function() {
                        t($(this).data("item-id"), !1, !0)
                    }),
                    this.blurInputs()
                }
                ,
                onOver: e=>{
                    e.targetContainer && (this.sortableElementTargetContainer = e.targetContainer)
                }
                ,
                onChange: e=>{
                    e.placeholder && (this.sortableElementPosition = e.placeholder.index() - 1)
                }
                ,
                onOut: e=>{
                    this.sortableElementTargetContainer = void 0
                }
                ,
                onReceive: e=>{
                    this.onSortableItemReceive(e)
                }
                ,
                onStop: e=>{
                    const t = e.initialContainer;
                    this.sortingCancelled || (this.onSortableAction ? this.onSortableAction() : e.item && this.insertItemStringToContainer(e.item, t),
                    this.saveItemOrder(t)),
                    this.tooltipEnable(),
                    this.sortableElement = void 0,
                    this.sortableElementPosition = void 0,
                    this.sortableElementTargetContainer = void 0,
                    this.sortingCancelled = !1,
                    this.onSortableAction = void 0,
                    ui.getBody().removeClass("dragging")
                }
            })
        }
        pressHotKey(e) {
            if (this.contextMenuOpen && this.contextMenu && this.contextMenuTarget) {
                let t = !1;
                for (let a = 0; a < this.contextMenu.actions.length; a++)
                    if (void 0 !== this.contextMenu.actions[a].keybind && (t = !0,
                    this.contextMenu.actions[a].keybind === e))
                        return this.onContextMenuAction(this.contextMenuTarget, this.contextMenu.actions[a]),
                        $(document).contextmenu("close"),
                        !0;
                if (!t && this.contextMenu.actions.length > e)
                    return this.onContextMenuAction(this.contextMenuTarget, this.contextMenu.actions[e]),
                    $(document).contextmenu("close"),
                    !0
            }
            return !1
        }
        useQuickSlot(e) {
            const t = this.getQuickSlotItemElement(e);
            if (t.hasClass("disabled"))
                return !1;
            const a = t.children("li").first();
            if (a && 1 === a.length) {
                const t = a.getItemType();
                if (t) {
                    let n = game.items[a.data("item-id")];
                    if (!n || !itemManager.isInInventory(n)) {
                        const e = itemManager.getItemsInContainerByType(localPlayer.inventory, t, !0);
                        if (!(e.length > 0))
                            return !1;
                        n = e[0]
                    }
                    const o = c.itemDescriptions[t];
                    if (!o)
                        return !1;
                    if (this.cancelSorting(),
                    !localPlayer.hasDelay()) {
                        const t = localPlayer.quickSlotInfo[e];
                        if (t && t.action)
                            return this.runContextMenuAction(n.id, t.action, !0);
                        {
                            const e = o.use ? o.use[0] : i.ActionType.Throw
                              , t = {
                                action: o.use ? "Use" : "Throw",
                                text: new f.default(m.Dictionary.Action,e).getString(),
                                data: {
                                    actionType: e
                                }
                            };
                            return this.runContextMenuAction(n.id, t, !0)
                        }
                    }
                }
            }
            return !1
        }
        isSorting() {
            return $(document).find(".sortable-helper").length > 0
        }
        runSortableAction(e, t, ...a) {
            e.functionalSortable(t, ...a)
        }
        runGlobalSortableAction(e, ...t) {
            $(".sortable").functionalSortable(e, ...t)
        }
        cancelSorting() {
            this.isSorting() && (this.sortingCancelled = !0,
            this.runGlobalSortableAction("cancel"),
            this.sortingCancelled = !1)
        }
        setupContextMenu() {
            const e = (e,t,a)=>this.onContextMenuAction(e, t, a);
            return {
                delegate: ".item,.sort,#actions",
                autoFocus: !0,
                autoTrigger: !1,
                preventContextMenuForPopup: !0,
                preventSelect: !0,
                taphold: !0,
                show: !1,
                hide: !1,
                position: (e,t)=>{
                    let a;
                    return this.actionsMenuOpen ? a = t.target : this.touchEvent ? ((a = this.touchEvent).pageX = a.originalEvent.touches[0].pageX,
                    a.pageY = a.originalEvent.touches[0].pageY) : a = {
                        pageX: this.mouseX,
                        pageY: this.mouseY,
                        preventDefault: !0
                    },
                    this.lastContextMenuPosition = {
                        my: "left-5 top-5",
                        at: "center bottom",
                        of: a,
                        collision: "fit fit"
                    },
                    this.lastContextMenuPosition
                }
                ,
                menu: [],
                select: (t,a)=>e(a.target, a.item.data(), $(t.toElement)),
                beforeOpen: (e,t)=>{
                    this.contextMenuTarget = t.target,
                    this.updateContextMenu(t.extraData),
                    this.lastContextMenuPosition && (t.menu.position(this.lastContextMenuPosition),
                    this.lastContextMenuPosition = void 0),
                    this.contextMenuOpen = !0,
                    this.contextMenuBlocking = !0,
                    this.tooltipDisable()
                }
                ,
                close: ()=>{
                    this.contextMenuOpen && (this.contextMenuOpen = !1,
                    this.contextMenuBlocking = !0,
                    this.tooltipEnable(),
                    this.hideActionsMenu())
                }
            }
        }
        hasDelay() {
            return localPlayer.hasDelay() ? (this.delayState = _.HasDelay,
            !0) : (this.delayState === _.HasDelay && (this.delayState = _.NoDelay),
            this.delayState === _.WaitingForDelay)
        }
        onShow() {
            this.canUseQuickslot = !0,
            this.elementVisibleInGame.quickShow(),
            this.elementDialogInventory.dialog(this.setupDialog(u.DialogId.Inventory)),
            this.elementDialogCrafting.dialog(this.setupDialog(u.DialogId.Crafting)),
            this.elementDialogEquipment.dialog(this.setupDialog(u.DialogId.Equipment)),
            [this.elementDialogInventory, this.elementDialogCrafting, this.elementDialogEquipment].forEach(this.makeTopDialog);
            const e = this.elementDialogCrafting.closest("[aria-describedby='crafting']");
            e.find(".ui-dialog-title").remove(),
            $("#crafting-tab-buttons").prependTo(e.find(".ui-dialog-titlebar")),
            modManager.getHook(T.Hook.OnGameScreenVisible).call(),
            this.clampDialogs(),
            this.blurInputs(),
            this.tooltipEnable(),
            newui.on(I.UiApiEvent.Interrupt, this.onInterrupt),
            newui.on(I.UiApiEvent.InterruptClose, this.onInterruptClosed),
            steamworks.on(k.SteamworksEvent.OverlayShown, this.onInterrupt),
            steamworks.on(k.SteamworksEvent.OverlayHidden, this.onInterruptClosed),
            this.element[0].addEventListener("click", e=>{
                e.target !== this.elementCanvas[0] && e.target !== this.element[0] || this.element[0].focus()
            }
            )
        }
        makeTopDialog(e) {
            const t = e[0].parentElement;
            t && t.matches(".ui-dialog") && (w.default.makeTopDialog(t),
            t.addEventListener("click", ()=>{
                w.default.makeTopDialog(t)
            }
            ))
        }
        onHide() {
            newui.cancel(I.UiApiEvent.Interrupt, this.onInterrupt),
            newui.cancel(I.UiApiEvent.InterruptClose, this.onInterruptClosed),
            steamworks.cancel(k.SteamworksEvent.OverlayShown, this.onInterrupt),
            steamworks.cancel(k.SteamworksEvent.OverlayHidden, this.onInterruptClosed),
            this.initializeGameState(),
            $("#crafting-tab-buttons").prependTo("#crafting"),
            this.elementVisibleInGame.quickHide(),
            this.elementDialogInventory.dialog("destroy"),
            this.elementDialogCrafting.dialog("destroy"),
            this.elementDialogEquipment.dialog("destroy"),
            this.closeAllContainers();
            for (let e = 0; e < this.elementOtherDialogs.length; e++) {
                try {
                    this.elementOtherDialogs[e].dialog("destroy")
                } catch (e) {}
                try {
                    this.elementOtherDialogs[e].remove()
                } catch (e) {}
            }
            this.elementOtherDialogs = [],
            this.onGameEnd()
        }
        initializeGameState() {
            $(".item").remove(),
            $(".in-use").removeClass("in-use"),
            $("#screen-in-game .disabled").removeClass("disabled"),
            $("input[type='search']").val(""),
            this.elementCanvas.removeClass("death respawn-on-death"),
            this.cancelSorting(),
            this.craftableItemTypes = void 0,
            this.nonCraftableItemTypes = void 0,
            this.lastStats = [],
            languageManager.refreshUiTranslations()
        }
        onGameEnd() {
            this.tooltipHide(),
            this.hideContextMenu(),
            this.hideActionsMenu(),
            this.cancelSorting()
        }
        getDialogIndex(e, t) {
            return e === u.DialogId.Custom && t ? `Custom_${t.id}` : e.toString()
        }
        setupDialog(e, t, n) {
            let o = this.getDialogIndex(e, n)
              , r = localPlayer.getDialogInfo(o)
              , s = !1;
            if (e === u.DialogId.Container && void 0 !== t) {
                const e = game.items[t];
                e && itemManager.isContainer(e) && (s = !0,
                o = t,
                r = localPlayer.dialogContainerInfo[o])
            }
            if (r)
                e === u.DialogId.Custom && n && (r.title = n.title,
                r.width = n.width,
                r.height = n.height,
                r.minWidth = n.minWidth,
                r.minHeight = n.minHeight,
                r.open = n.open,
                r.onOpen = n.onOpen,
                r.onClose = n.onClose,
                r.onResizeStop = n.onResizeStop,
                r.resizable = n.resizable);
            else
                switch (r = s && void 0 !== t ? localPlayer.dialogContainerInfo[o] = {} : e === u.DialogId.Custom && n ? localPlayer.dialogInfo[o] = n : localPlayer.dialogInfo[o] = {},
                e) {
                case u.DialogId.Inventory:
                    r.open = !0,
                    r.width = 440,
                    r.height = 210,
                    r.x = ui.getWidth() - r.width - 20,
                    r.y = 80;
                    break;
                case u.DialogId.Container:
                    r.open = !0,
                    r.width = 340,
                    r.height = 310,
                    r.x = ui.getWidth() - r.width - 20 - 440 - 10,
                    r.y = 80;
                    let a = !1;
                    for (; this.isContainerDialogOver(r.x, r.y); )
                        if (a ? (r.x += r.width + 10,
                        r.x + r.width + 10 > ui.getWidth() && (a = !a,
                        r.x = ui.getWidth() - r.width - 10,
                        r.y += r.height + 10)) : (r.x -= r.width + 10,
                        r.x < 10 && (a = !a,
                        r.x = 10,
                        r.y += r.height + 10)),
                        r.y + r.height + 10 > ui.getHeight()) {
                            r.y = ui.getHeight() - r.height - 10;
                            break
                        }
                    break;
                case u.DialogId.Crafting:
                    r.width = 440,
                    r.height = 205,
                    r.x = ui.getWidth() - r.width - 20,
                    r.y = 445;
                    break;
                case u.DialogId.Equipment:
                    r.width = 440,
                    r.height = 135,
                    r.x = ui.getWidth() - r.width - 20,
                    r.y = 300
                }
            const l = (e,t,a=!1)=>{
                this.highlightItemElementByItemId(e, t, a)
            }
              , d = {
                position: {
                    my: `left+${r.x} top+${r.y}`,
                    at: "left top"
                },
                width: r.width,
                height: r.height,
                minWidth: 210,
                appendTo: "#screen-in-game",
                autoOpen: !1,
                closeOnEscape: !1,
                open() {
                    r.open = !0,
                    r.onOpen && r.onOpen.apply(this),
                    $(this).parent().find(".ui-dialog-titlebar-close").removeAttr("title"),
                    localPlayer.updateDialogInfo(o)
                },
                close() {
                    r.open = !1,
                    r.onClose && r.onClose.apply(this),
                    void 0 !== t && l(t, !1, !0),
                    localPlayer.updateDialogInfo(o)
                },
                dragStart() {
                    w.default.makeTopDialog(this.closest(".ui-dialog")),
                    void 0 !== t && l(t, !0)
                },
                dragStop() {
                    void 0 !== t && l(t, !1),
                    r.x = $(this).parent().offset().left,
                    r.y = $(this).parent().offset().top,
                    localPlayer.updateDialogInfo(o)
                },
                resizeStart() {
                    w.default.makeTopDialog(this.closest(".ui-dialog"))
                },
                resizeStop() {
                    r.onResizeStop && r.onResizeStop.apply(this),
                    r.x = $(this).parent().offset().left,
                    r.y = $(this).parent().offset().top,
                    r.width = $(this).parent().width(),
                    r.height = $(this).parent().height(),
                    localPlayer.updateDialogInfo(o),
                    ui.getBody().removeAttr("style")
                }
            };
            r.title && (d.title = r.title),
            !1 === r.resizable ? d.resizable = !1 : d.resizable = !0,
            r.minWidth && (d.minWidth = r.minWidth),
            r.minHeight && (d.minHeight = r.minHeight);
            const p = d.open
              , c = d.close
              , m = (e,t)=>{
                this.showSortContextMenu(e, t === h.default.Inventory ? this.elementDialogInventoryContainer : t === h.default.Container ? e.parent().parent().parent().find(".sortable") : this.elementDialogCraftingContainer, t)
            }
              , y = e=>{
                this.closeContainerDialog(e)
            }
            ;
            switch (e) {
            case u.DialogId.Container:
                d.autoOpen = !0,
                d.minWidth = 300,
                d.buttons = [{
                    text: f.default.message(h.default.Sort).getString(),
                    click() {
                        m($(this).parent().find(".sort"), h.default.Container)
                    },
                    class: "sort clickable"
                }, {
                    text: f.default.message(h.default.GrabAll).getString(),
                    click() {
                        a.default.get(i.ActionType.MoveItem).execute(localPlayer, void 0, $(this).data("container"), localPlayer.inventory)
                    },
                    class: "grab-all clickable"
                }],
                d.close = function(e, t) {
                    c && c(e, ui),
                    y($(this))
                }
                ;
                break;
            case u.DialogId.Inventory:
                d.buttons = [{
                    text: f.default.message(h.default.Sort).getString(),
                    click() {
                        m($(this).parent().find(".sort"), h.default.Inventory)
                    },
                    class: "sort clickable"
                }];
                break;
            case u.DialogId.Crafting:
                d.buttons = [{
                    text: f.default.message(h.default.Sort).getString(),
                    click() {
                        m($(this).parent().find(".sort"), h.default.Crafts)
                    },
                    class: "sort clickable"
                }];
                break;
            case u.DialogId.Equipment:
                d.resizable = !1,
                d.width = d.minWidth = d.maxWidth = 440,
                d.height = d.minHeight = d.maxHeight = 135,
                d.buttons = [{
                    text: f.default.message(h.default.UnEquipAll).getString(),
                    click() {
                        a.default.get(i.ActionType.Unequip).execute(localPlayer)
                    },
                    class: "unequip-all clickable"
                }],
                d.open = ((e,t)=>{
                    p && p(e, t),
                    ui.setCheckboxValue(this.elementDialogEquipment, "leftHand", saveDataGlobal.options.leftHand),
                    ui.setCheckboxValue(this.elementDialogEquipment, "rightHand", saveDataGlobal.options.rightHand)
                }
                )
            }
            return d
        }
        onMouseMove(e) {
            "touchmove" === e.type && e.preventDefault();
            let t = e.pageX
              , a = e.pageY;
            "touchmove" === e.type && (t = e.originalEvent.touches[0].pageX,
            a = e.originalEvent.touches[0].pageY),
            this.mouseX = t,
            this.mouseY = a,
            game.playing
        }
        highlightItemElementByItemId(e, t, a=!1, i=!1) {
            this.highlightItemElementBySelector(`.item[data-item-id="${e}"]`, t, a, i)
        }
        highlightItemElementByItemType(e, t, a=!1, i=!1) {
            this.highlightItemElementBySelector(`.item[data-item-type="${e}"]`, t, a, i)
        }
        highlightItemElementByItemTypeWithNoItemId(e, t, a=!1, i=!1) {
            this.highlightItemElementBySelector(`.item[data-item-type="${e}"]:not([data-item-id])`, t, a, i)
        }
        highlightItemElementBySelector(e, t, a=!1, i=!1) {
            $(e).each(function() {
                if (i)
                    return void (t ? ($(this).addClass("selected"),
                    $(this).hasClass("damaged") && $(this).addClass("highlighted")) : ($(this).removeClass("selected"),
                    $(this).removeClass("highlighted")));
                let e = parseInt($(this).attr("data-selected-count"), 10);
                if ((void 0 === e || isNaN(e)) && (e = 0),
                t ? e++ : e--,
                t)
                    e > 0 && ($(this).addClass("selected"),
                    $(this).hasClass("damaged") && $(this).addClass("highlighted"));
                else if (e <= 0 || a)
                    return $(this).removeClass("selected"),
                    $(this).removeClass("highlighted"),
                    void $(this).removeAttr("data-selected-count");
                $(this).attr("data-selected-count", e)
            })
        }
        getMovementDirection(e, t) {
            let a = u.Direction.None;
            const i = renderer.screenToTile(e, t);
            if (localPlayer.x === i.x && localPlayer.y === i.y)
                return a;
            const n = (270 - 180 * Math.atan2(localPlayer.y - i.y, localPlayer.x - i.x) / Math.PI) % 360;
            switch (n) {
            case 315:
                localPlayer.facingDirection !== u.Direction.South && localPlayer.facingDirection !== u.Direction.West || (a = localPlayer.facingDirection);
                break;
            case 225:
                localPlayer.facingDirection !== u.Direction.West && localPlayer.facingDirection !== u.Direction.North || (a = localPlayer.facingDirection);
                break;
            case 135:
                localPlayer.facingDirection !== u.Direction.North && localPlayer.facingDirection !== u.Direction.East || (a = localPlayer.facingDirection);
                break;
            case 45:
                localPlayer.facingDirection !== u.Direction.East && localPlayer.facingDirection !== u.Direction.South || (a = localPlayer.facingDirection)
            }
            return a === u.Direction.None && (a = 225 >= n && n >= 135 ? u.Direction.North : 135 >= n && n >= 45 ? u.Direction.East : 45 >= n || n >= 315 ? u.Direction.South : u.Direction.West),
            a
        }
        canUseHotkeys() {
            if (this.contextMenuBlocking) {
                this.contextMenuBlocking = !1;
                for (let e = 0; e < F.length; e++) {
                    const t = F[e];
                    if (S.bindingManager.isPressed(t))
                        return this.contextMenuBlocking = !0,
                        !1
                }
            }
            return !localPlayer.isMovingClientside
        }
        refreshStats() {
            const e = localPlayer.getStat(l.Stat.Stamina)
              , t = localPlayer.getStat(l.Stat.Health)
              , a = localPlayer.getStat(l.Stat.Hunger)
              , i = localPlayer.getStat(l.Stat.Thirst)
              , n = [{
                element: this.elementStatHealth,
                value: t.value,
                max: localPlayer.getMaxHealth()
            }, {
                element: this.elementStatStamina,
                value: e.value,
                max: e.max
            }, {
                element: this.elementStatThirst,
                value: i.value,
                max: i.max
            }, {
                element: this.elementStatHunger,
                value: a.value,
                max: a.max
            }];
            for (let e = 0; e < n.length; e++) {
                const t = n[e];
                let a = B.default.roundNumber(t.value / t.max * 100, 0);
                a <= 0 && (a = 0);
                const i = `${t.value}/${t.max} (${a}%)`;
                if (this.lastStats[e] === i)
                    continue;
                this.lastStats[e] = i,
                t.element.find(".stat").text(i),
                t.element.find(".fill").width(`${a}%`);
                const o = t.element.parent();
                a <= 10 ? o.addClass("flash") : o.removeClass("flash")
            }
            localPlayer.hasStatus(u.StatusType.Burned) ? this.elementStatBurn.quickShow() : this.elementStatBurn.quickHide(),
            localPlayer.hasStatus(u.StatusType.Bleeding) ? this.elementStatBleed.quickShow() : this.elementStatBleed.quickHide(),
            localPlayer.hasStatus(u.StatusType.Poisoned) ? this.elementStatPoison.quickShow() : this.elementStatPoison.quickHide()
        }
        blurInputs() {
            $(".dialog-input, input[type='text'], input[type='number']").trigger("blur")
        }
        toggleDialog(e) {
            return !!this.openDialog(e) || (this.closeDialog(e),
            !1)
        }
        openDialog(e) {
            return !e.isVisible() && (e.dialog("open"),
            this.onOpenDialog(e),
            !0)
        }
        onOpenDialog(e) {
            this.blurInputs(),
            $(".ui-dialog").attr("intercept", "all").click(e=>{
                e.target.matches("select") || (this.focus(),
                setTimeout(this.focus, 5))
            }
            );
            const t = ()=>{
                this.focus(),
                setTimeout(()=>{
                    this.focus()
                }
                , 10)
            }
            ;
            $(".ui-dialog").removeAttr("tabindex"),
            $(".ui-dialog button").attr("tabindex", "-1").blur().click(t).focus(t),
            this.focus(),
            e.find("input[type='search'], input[type='text']").click(function() {
                this.classList.add("can-focus"),
                setTimeout(()=>{
                    this.focus()
                }
                , 10)
            }).blur(function() {
                this.classList.remove("can-focus")
            }),
            this.makeTopDialog(e)
        }
        focus() {
            document.activeElement !== this.element[0] && this.element[0].focus()
        }
        closeDialog(e) {
            return !!e.isVisible() && (e.dialog("close"),
            this.blurInputs(),
            !0)
        }
        closeAllDialogs() {
            let e = !1;
            e = this.closeDialog(this.elementDialogInventory) || e,
            e = this.closeDialog(this.elementDialogCrafting) || e,
            e = this.closeDialog(this.elementDialogEquipment) || e,
            e = this.closeAllContainers() || e;
            for (let t = 0; t < this.elementOtherDialogs.length; t++)
                e = this.closeDialog(this.elementOtherDialogs[t]) || e;
            return e
        }
        autoOpenDialog(e, t) {
            const a = localPlayer.getDialogInfo(e);
            return !(!a || !a.open) && this.openDialog(t)
        }
        openDialogs() {
            this.autoOpenDialog(u.DialogId.Inventory, this.elementDialogInventory),
            this.autoOpenDialog(u.DialogId.Crafting, this.elementDialogCrafting),
            this.autoOpenDialog(u.DialogId.Equipment, this.elementDialogEquipment);
            for (const e of this.elementOtherDialogs) {
                const t = e.data("dialog-index");
                t && this.autoOpenDialog(t, e) && e.css("height", "")
            }
        }
        clampDialogs() {
            const e = ui.getBody()
              , t = ui.getWidth()
              , a = ui.getHeight();
            $(".ui-dialog-content").each(function() {
                const i = $(this).parent().position()
                  , n = i.left
                  , o = i.top
                  , r = $(this).dialog("option", "width")
                  , s = $(this).dialog("option", "height");
                n + r > t && ($(this).dialog("option", "position", {
                    my: "right top",
                    at: `right top+${o}`,
                    of: e,
                    collision: "fit fit"
                }),
                r > t && $(this).dialog("option", "width", t)),
                o + s > a && ($(this).dialog("option", "position", {
                    my: "left bottom",
                    at: `left+${n} bottom`,
                    of: e,
                    collision: "fit fit"
                }),
                s > a && $(this).dialog("option", "height", a))
            })
        }
        getItemClass(e, t) {
            if (e && !t && (t = e.type),
            !t)
                return "";
            let a = "";
            e && e.quality && (a = ` ${u.ItemQuality[e.quality].toLowerCase()}`);
            let i = "";
            for (const e of itemManager.getGroups(t))
                i += ` group-${u.ItemTypeGroup[e]}`;
            return `item-${t}${a}${i}`
        }
        createItemString(e, t, a="") {
            return `<li class="tooltip item ${this.getItemClass(t, e)} ${a}" data-item-type="${e}"${t ? ` data-item-id="${t.id}"` : ""}></li>`
        }
        syncItemElements(e, t) {
            const a = game.items[e];
            if (!a)
                return;
            const i = t || $(`.item[data-item-id="${e}"]`);
            let n = !1;
            i.each((e,t)=>{
                const i = $(t);
                a.type !== i.getItemType() && (n = !0,
                a.quickSlot && this.removeItemFromQuickSlot(a.id, !0),
                i.attr("data-item-type", a.type),
                i.removeClass((e,t)=>(t.match(/\bitem-\S+/g) || []).join(" ")),
                i.removeClass((e,t)=>(t.match(/\bgroup-\S+/g) || []).join(" ")),
                i.get(0).className += ` ${this.getItemClass(a, a.type)}`),
                a.quickSlot ? i.getQuickSlot() && 0 !== i.children("span.number").length || (i.attr("data-quick-slot", a.quickSlot),
                i.append(`<span class="number">${a.quickSlot}</span>`)) : (i.getQuickSlot() || i.children("span.number").length > 0) && (i.removeAttr("data-quick-slot"),
                i.children("span.number").remove());
                const o = a.getEquipSlot();
                void 0 !== o ? i.getEquipSlot() && 0 !== i.children("span.equipped").length || (i.attr("data-equip-slot", u.EquipType[o].toString()),
                i.prepend('<span class="equipped">E</span>')) : (i.getEquipSlot() || i.children("span.equipped").length > 0) && (i.removeAttr("data-equip-slot"),
                i.children("span.equipped").remove()),
                a.legendary ? i.addClass("legendary") : i.removeClass("legendary"),
                this.syncDamagedDecayed(a, i)
            }
            ),
            n && this.refreshQuickSlots()
        }
        syncDamagedDecayed(e, t) {
            const a = !!e && e.isDamaged()
              , i = !!e && e.isDecayed();
            a || i ? t.addClass("damaged") : t.removeClass("damaged")
        }
        addItemToContainer(e, t, a=!1, i=!1) {
            let n, o;
            const r = t === localPlayer.inventory;
            r ? n = this.elementDialogInventoryContainer : (o = this.getDialogElementForContainer(t)) && (n = o.find(".container")),
            void 0 !== n && (void 0 !== e ? (this.insertItemStringToContainer(this.createItemString(e.type, e), n),
            this.syncItemElements(e.id),
            i || (this.saveItemOrder(n),
            this.onAddItemsToContainer(n, o, r))) : x.default.info(x.LogSource.Ui)("Attempted to add invalid item to container", t, t.itemOrders))
        }
        insertItemStringToContainer(e, t) {
            if (void 0 !== this.sortableElementPosition) {
                if (-1 === this.sortableElementPosition)
                    t.prepend(e);
                else {
                    const a = t.children()
                      , i = a.eq(this.sortableElementPosition);
                    0 === i.length ? t.append(e) : i.after(e)
                }
                this.sortableElementPosition = void 0
            } else
                t.append(e)
        }
        onAddItemsToContainer(e, t, a) {
            !a && t && this.updateContainerName(t),
            this.onUpdateContainer(e, !0),
            localPlayer.updateTables(),
            this.isSorting() && this.runGlobalSortableAction("refreshItems"),
            this.refreshQuickSlots()
        }
        afterAddingMultipleItemsToContainer(e) {
            let t, a;
            const i = e === localPlayer.inventory;
            i ? t = this.elementDialogInventoryContainer : (a = this.getDialogElementForContainer(e)) && (t = a.find(".container")),
            void 0 !== t && (this.saveItemOrder(t),
            this.onAddItemsToContainer(t, a, i))
        }
        removeItemFromContainer(e, t) {
            const a = e.id;
            let i, n;
            const o = t === localPlayer.inventory;
            o ? i = this.elementDialogInventoryContainer : (n = this.getDialogElementForContainer(t)) && (i = n.find(".container")),
            void 0 !== i && (i.children(`[data-item-id="${a}"]`).first().trigger("remove").remove(),
            n && this.updateContainerName(n))
        }
        refreshContainerName(e) {
            const t = this.getDialogElementForContainer(e);
            void 0 !== t && this.updateContainerName(t)
        }
        refreshQuickSlots() {
            let e = !1;
            for (let t = 1; t < 10; t++)
                this.updateQuickSlotItem(t) && (e = !0);
            e && this.onUpdateQuickSlotsOrEquips()
        }
        getInventoryItemsInOrder() {
            const e = [];
            return this.elementDialogInventoryContainer.children().each(function() {
                const t = $(this).data("item-id")
                  , a = game.items[t];
                e.push({
                    type: a.type,
                    id: t,
                    quality: a.quality,
                    minDur: a.minDur,
                    maxDur: a.maxDur
                })
            }),
            e
        }
        loadQuickSlots() {
            for (let e = 1; e < 10; e++) {
                const t = localPlayer.quickSlotInfo[e];
                if (t && t.itemType) {
                    const a = this.getItemIdInQuickSlot(e);
                    void 0 === a && this.setQuickSlotByItemType(e, t.itemType, !0)
                }
            }
            this.refreshQuickSlots()
        }
        saveItemOrder(e) {
            if (!game.playing)
                return;
            let t = e.parent().data("container");
            if (!t) {
                if (!e.is("#container-inventory"))
                    return;
                t = localPlayer.inventory
            }
            const a = [];
            e.children().each(function() {
                const e = $(this).data("item-id");
                void 0 !== e && a.push(e)
            });
            let i = !1;
            for (let e = 0; e < a.length; e++)
                if (t.containedItems[e] !== game.items[a[e]]) {
                    i = !0;
                    break
                }
            let n = !1, o;
            if (i)
                if (void 0 === t.itemOrders)
                    n = !0,
                    o = a;
                else {
                    if (!(n = a.length !== t.itemOrders.length))
                        for (let e = 0; e < a.length; e++)
                            if (a[e] !== t.itemOrders[e]) {
                                n = !0;
                                break
                            }
                    o = a
                }
            else
                n = !0;
            n && (localPlayer.queueSoundEffect(u.SfxType.PickUp),
            multiplayer.isConnected() ? setTimeout(()=>{
                itemManager.updateItemOrder(t, o)
            }
            , 1) : itemManager.updateItemOrder(t, o))
        }
        showItemContextMenu(e) {
            if (this.isSorting())
                return;
            const t = e.data("item-id")
              , a = e.getItemType()
              , n = e.getQuickSlot()
              , o = e.parent().parent().data("container")
              , r = []
              , s = game.items[t];
            if (!s)
                return;
            const l = s.isInTradeContainer()
              , p = c.itemDescriptions[a];
            let y;
            const T = itemManager.getItemsInContainerByType(o || localPlayer.inventory, a)
              , S = T.length;
            let I = 0
              , v = !1;
            for (y = 0; y < S; y++) {
                const e = T[y];
                e.quality === s.quality ? I++ : v = !0
            }
            if (!l && p && p.use)
                for (y = 0; y < p.use.length; y++) {
                    const e = p.use[y];
                    p.use[y] === i.ActionType.OpenContainer && ui.isContainerOpen(s) || r.push({
                        action: "Use",
                        text: new f.default(m.Dictionary.Action,e).getString(),
                        data: {
                            actionType: e
                        }
                    })
                }
            if (ui.isContainerOpen(s) && r.push({
                action: "CloseContainer",
                text: f.default.message(h.default.CloseContainer).getString()
            }),
            !l)
                if (p && p.equip && (s.isEquipped() ? r.push({
                    action: "EquipOrUnEquip",
                    text: f.default.message(h.default.UnEquip).getString()
                }) : p.equip === u.EquipType.Held ? (r.push({
                    action: "EquipLeftHand",
                    text: f.default.message(h.default.EquipTo).getString() + f.default.message(g.equipTypeToMessage[u.EquipType.LeftHand]).getString()
                }),
                r.push({
                    action: "EquipRightHand",
                    text: f.default.message(h.default.EquipTo).getString() + f.default.message(g.equipTypeToMessage[u.EquipType.RightHand]).getString()
                })) : r.push({
                    action: "EquipOrUnEquip",
                    text: f.default.message(h.default.EquipTo).getString() + f.default.message(g.equipTypeToMessage[p.equip]).getString()
                })),
                n)
                    r.push({
                        action: "QuickSlotRemove",
                        text: f.default.message(h.default.RemoveFromQuickslot).getString()
                    });
                else {
                    const e = this.getFreeQuickSlots();
                    e.length > 0 && r.push({
                        action: "QuickSlotAdd",
                        text: f.default.message(h.default.AddToQuickslot).getString()
                    })
                }
            if (o ? (o.containerType === d.ContainerType.Trade ? r.push({
                action: "MoveToInventory",
                text: f.default.message(h.default.TradeBarterCreditForItem).getString()
            }) : r.push({
                action: "MoveToInventory",
                text: f.default.message(h.default.MoveToInventory).getString()
            }),
            l || (S > 1 && r.push({
                action: "MoveAllToInventory",
                text: f.default.message(h.default.MoveAllToInventory).getString()
            }),
            v && I > 1 && r.push({
                action: "MoveAllOfSameQualityToInventory",
                text: f.default.message(h.default.MoveAllOfSameQualityToInventory).getString()
            }))) : void 0 !== this.activeContainer && (this.activeContainer.containerType === d.ContainerType.Trade ? r.push({
                action: "MoveToOpenedContainer",
                text: f.default.message(h.default.TradeItemForBarterCredit).getString()
            }) : (r.push({
                action: "MoveToOpenedContainer",
                text: f.default.message(this.multipleContainersOpened ? h.default.MoveToLastOpenedContainer : h.default.MoveToOpenedContainer).getString()
            }),
            S > 1 && r.push({
                action: "MoveAllToOpenedContainer",
                text: f.default.message(this.multipleContainersOpened ? h.default.MoveAllToLastOpenedContainer : h.default.MoveAllToOpenedContainer).getString()
            }),
            v && I > 1 && r.push({
                action: "MoveAllOfSameQualityToOpenedContainer",
                text: f.default.message(this.multipleContainersOpened ? h.default.MoveAllOfSameQualityToLastOpenedContainer : h.default.MoveAllOfSameQualityToOpenedContainer).getString()
            }))),
            !o) {
                const e = localPlayer.getFacingTile().doodad;
                if (e) {
                    const t = e;
                    itemManager.isContainer(e) && t !== this.activeContainer && (r.push({
                        action: "MoveToFacingContainer",
                        text: f.default.message(h.default.MoveToFacingContainer).getString(),
                        data: {
                            facingContainer: !0
                        }
                    }),
                    S > 1 && r.push({
                        action: "MoveAllToFacingContainer",
                        text: f.default.message(h.default.MoveAllToFacingContainer).getString(),
                        data: {
                            facingContainer: !0
                        }
                    }),
                    v && I > 1 && r.push({
                        action: "MoveAllOfSameQualityToFacingContainer",
                        text: f.default.message(h.default.MoveAllOfSameQualityToFacingContainer).getString(),
                        data: {
                            facingContainer: !0
                        }
                    }))
                }
            }
            if (!l && (r.push({
                action: "Throw",
                text: f.default.message(h.default.Throw).getString()
            }),
            r.push({
                action: "Rename",
                text: new f.default(m.Dictionary.Action,i.ActionType.Rename).getString()
            }),
            r.push({
                action: "Offer",
                text: f.default.message(h.default.Offer).getString()
            }),
            r.push({
                action: "Drop",
                text: f.default.message(h.default.Drop).getString()
            }),
            S > 1 && r.push({
                action: "DropAll",
                text: f.default.message(h.default.DropAll).getString()
            }),
            v && I > 1 && r.push({
                action: "DropAllOfSameQuality",
                text: f.default.message(h.default.DropAllOfSameQuality).getString()
            }),
            p)) {
                if (p.durability && void 0 !== s.minDur && void 0 !== s.maxDur && s.minDur < s.maxDur && !1 !== p.repairable) {
                    const e = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.Repair, t);
                    e && r.push({
                        action: "Repair",
                        text: `${f.default.nameOf(m.Dictionary.ItemGroup, u.ItemTypeGroup.Repair, !1).inContext(3).getString()} ${f.default.message(h.default.With).getString()} ${e.getName().inContext(3).getString()}`
                    })
                }
                const e = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.Transmogrify);
                if (e && r.push({
                    action: "Transmogrify",
                    text: `${f.default.nameOf(m.Dictionary.ItemGroup, u.ItemTypeGroup.Transmogrify, !1).inContext(3).getString()} ${f.default.message(h.default.With).getString()} ${e.getName().inContext(3).getString()}`
                }),
                p.durability) {
                    const e = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.Reinforce);
                    e && r.push({
                        action: "Reinforce",
                        text: `${f.default.nameOf(m.Dictionary.ItemGroup, u.ItemTypeGroup.Reinforce, !1).inContext(3).getString()} ${f.default.message(h.default.With).getString()} ${e.getName().inContext(3).getString()}`
                    })
                }
                if (p.decayMax && p.use && p.use.indexOf(i.ActionType.Eat) > -1 && -1 === p.use.indexOf(i.ActionType.Preserve)) {
                    const e = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.Preservative);
                    e && r.push({
                        action: "Preserve",
                        text: `${f.default.message(h.default.Preserve).getString()} ${f.default.message(h.default.With).getString()} ${e.getName().inContext(3).getString()}`
                    })
                }
                if (p.revert) {
                    const e = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.Fuel);
                    e && r.push({
                        action: "Add-Fuel",
                        text: `${f.default.message(h.default.AddFuel).getString()} ${f.default.message(h.default.With).getString()} ${e.getName().inContext(3).getString()}`
                    })
                }
                if (p.lit) {
                    const e = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.FireStarter);
                    e && r.push({
                        action: "Ignite",
                        text: `${f.default.message(h.default.Ignite).getString()} ${f.default.message(h.default.With).getString()} ${e.getName().inContext(3).getString()}`
                    })
                }
                p.disassemble && r.push({
                    action: "Disassemble",
                    text: f.default.message(h.default.DisassembleAction).getString()
                }),
                p.dismantle && r.push({
                    action: "Dismantle",
                    text: f.default.message(h.default.DismantleAction).getString()
                })
            }
            const w = {
                actions: r,
                quickSlot: n
            };
            ui.playClickSound(),
            $(document).contextmenu("open", e, w),
            $(".ui-contextmenu").removeAttr("tabindex")
        }
        onContextMenuAction(e, t, a) {
            const i = e.data("item-id")
              , n = e.getQuickSlot();
            return a && a.is(".quick-slot-action-select") ? (a.parent().parent().parent().find(".selected").removeClass("selected"),
            a.addClass("selected"),
            localPlayer.updateQuickSlotInfo(n, void 0, t),
            ui.playClickSound(),
            !1) : this.runContextMenuAction(i, t)
        }
        runContextMenuAction(e, t, a) {
            return this.runAction(e, t, a)
        }
        onCraftingItemClick(e) {
            const t = c.itemDescriptions[e.data("item-type")];
            if (!t || !t.recipe)
                return;
            const n = new p.default(localPlayer,t.recipe,!0);
            if (n.process(),
            n && n.requirementsMet()) {
                if (saveDataGlobal.options.warnWhenBreakingItemsOnCraft) {
                    let t = !1;
                    for (const e of n.itemComponentsRequired)
                        if (void 0 !== e.minDur && e.minDur <= 0) {
                            t = !0;
                            break
                        }
                    if (!t)
                        for (const e of n.itemComponentsConsumed)
                            if (void 0 !== e.minDur && e.minDur <= 0) {
                                t = !0;
                                break
                            }
                    if (t)
                        return void newui.interruptWithConfirmation(y.default.GameInterruptItemMayBeDestroyedInCraft, y.default.GameInterruptItemMayBeDestroyedInCraftDescription).then(t=>{
                            t && (a.default.get(i.ActionType.Craft).execute(localPlayer, e.getItemType(), n.itemComponentsRequired, n.itemComponentsConsumed, n.itemBaseComponent, n.itemComponentsCanBurn),
                            this.tooltipHide())
                        }
                        )
                }
                a.default.get(i.ActionType.Craft).execute(localPlayer, e.getItemType(), n.itemComponentsRequired, n.itemComponentsConsumed, n.itemBaseComponent, n.itemComponentsCanBurn),
                this.tooltipHide()
            }
        }
        onDismantleItemClick(e) {
            if (e) {
                if (saveDataGlobal.options.warnWhenBreakingItemsOnCraft) {
                    let t;
                    const n = c.itemDescriptions[e.type];
                    if (n) {
                        const e = n.dismantle;
                        if (e) {
                            const a = e.required;
                            a && (t = itemManager.getItemForHuman(localPlayer, a))
                        }
                    }
                    if (t && void 0 !== t.minDur && t.minDur <= 0)
                        return void newui.interruptWithConfirmation(y.default.GameInterruptItemMayBeDestroyedInCraft, y.default.GameInterruptItemMayBeDestroyedInCraftDescription).then(t=>{
                            t && (a.default.get(i.ActionType.Dismantle).execute(localPlayer, e),
                            this.tooltipHide())
                        }
                        )
                }
                a.default.get(i.ActionType.Dismantle).execute(localPlayer, e)
            }
            this.tooltipHide()
        }
        getTooltipHtml(e) {
            const t = e.attr("data-tooltip")
              , a = e.data("attribute");
            if (void 0 !== t) {
                if (void 0 !== e.getEquipSlot()) {
                    const t = e.children();
                    if (t.length > 0) {
                        const a = t.first()
                          , i = game.items[a.data("item-id")]
                          , n = i && i.quality ? ` class="${u.ItemQuality[i.quality].toLowerCase()}"` : "";
                        return `<div${n}>${this.getTooltipHtmlForItem(i, a.getItemType(), a.hasClass("is-quick-slot"), e.hasClass("is-dismantle"), e.parent().hasClass("is-npc"))}</div>`
                    }
                }
                return `<div>${t}</div>`
            }
            if (e.hasClass("item")) {
                const t = e.getItemType()
                  , a = c.itemDescriptions[t]
                  , i = game.items[e.data("item-id")];
                if (!i && a && a.recipe) {
                    const a = !game.isChallenge && game.crafted[t];
                    a && a.newUnlock && (a.newUnlock = !1,
                    e.removeClass("highlighted"))
                }
                const n = i && i.quality ? ` class="${u.ItemQuality[i.quality].toLowerCase()}"` : "";
                return `<div${n}>${this.getTooltipHtmlForItem(i, t, e.hasClass("is-quick-slot"), e.hasClass("is-dismantle"), e.parent().hasClass("is-npc"))}</div>`
            }
            return `<div>${f.default.message(h.default.NotAvailable).getString()}</div>`
        }
        tooltipEnable() {
            $(document).functionalTooltip("enable")
        }
        tooltipRefresh() {
            $(document).functionalTooltip("refresh")
        }
        tooltipDisable() {
            $(document).functionalTooltip("disable")
        }
        tooltipHide() {
            $(document).functionalTooltip("hide")
        }
        unSelectElements() {
            $(".selected").each(function() {
                void 0 !== $(this).data("selected-count") || $(this).hasClass("quick-slot-action-select") || ($(this).removeClass("selected"),
                $(this).parent("#container-crafting").length || $(this).parent("#container-dismantle").length || $(this).removeClass("highlighted"))
            })
        }
        getTooltipHtmlForItem(e, t, a, n, r) {
            const s = c.itemDescriptions[t];
            if (!s)
                return f.default.message(h.default.AnUnknownItem).inContext(3).getString();
            const d = e ? e.getName() : f.default.nameOf(m.Dictionary.Item, t);
            d.inContext(3);
            let T = `<h3>${d.getString()}</h3>`;
            if (e) {
                if (r) {
                    const t = e.getWorth();
                    void 0 !== t && (T += `<p><strong>${f.default.ui(y.default.GameItemBarterCreditTrade).getString()}</strong>${Math.round(1.5 * t)}`,
                    e.legendary && e.legendary.type === u.LegendaryType.Worth && (T += ` <span class="legendary">+${e.legendary.value}</span>`),
                    T += "</p>")
                }
                if (e.quality) {
                    if ((e.renamed || e.legendary) && (T += `<p><span class="${u.ItemQuality[e.quality].toLowerCase()}"> ${new f.default(m.Dictionary.ItemQuality,e.quality).inContext(3).getString()}`),
                    e.legendary) {
                        const {type: t, skill: a, stat: i} = e.legendary
                          , n = void 0 !== a ? new f.default(m.Dictionary.Skill,a) : void 0 !== i ? new f.default(m.Dictionary.Stat,i) : void 0;
                        T += ` (${new f.default(m.Dictionary.LegendaryType,t).inContext(3).getString(n)})`
                    }
                    T += "</span></p>"
                }
                saveDataGlobal.options.protectedCraftingItems && (e.isEquipped() || e.quickSlot) && (T += `<p><span class="protected">${f.default.message(h.default.LabelProtected).getString()}</span></p>`),
                T += `<p><strong>${f.default.message(h.default.LabelDurability).getString()}</strong><span`,
                void 0 !== e.minDur && e.minDur <= 2 && (T += ' class="damaged"'),
                T += `>${e.minDur}</span>/`,
                T += "<span",
                e.quality && (T += ` class="${u.ItemQuality[e.quality].toLowerCase()}"`),
                T += ">",
                T += `${e.maxDur}</span>`,
                s.decayMax && (T += ` <strong>${f.default.message(h.default.LabelDecay).getString()}</strong> ${e.decay}`),
                T += "</p>",
                T += "<p><strong>";
                let t = e && itemManager.isContainer(e);
                if (t) {
                    const a = itemManager.computeContainerWeight(e);
                    a > 0 ? (T += `${f.default.message(h.default.LabelWeight).getString()}</strong> ${e.weight} + `,
                    itemManager.isInInventory(e) ? T += `<span class="strikethrough">${B.default.roundNumber(a, 1)}</span> ${B.default.roundNumber(a * e.getContainerWeightReduction(), 1)}` : T += `${B.default.roundNumber(a, 1)}`) : t = !1
                }
                if (t || (T += `${f.default.message(h.default.LabelWeight).getString()}</strong> ${e.weight}`,
                e.legendary && e.legendary.type === u.LegendaryType.ItemWeight && (T += ` <span class="legendary">-${e.legendary.value}</span>`)),
                s.doodadContainer) {
                    const e = o.doodadDescriptions[s.doodadContainer];
                    e && (T += ` <strong>${f.default.message(h.default.LabelWeightCapacity).getString()}</strong> ${e.weightCapacity}`)
                }
                T += "</p>"
            }
            T += `<p><strong>${new f.default(m.Dictionary.Item,t,1).getString()}</strong></p>`;
            let I = "";
            if (s.use) {
                I += "<strong>",
                s.use.length > 1 ? I += f.default.message(h.default.LabelUses).getString() : I += f.default.message(h.default.LabelUse).getString(),
                I += "</strong><span>";
                for (const e of s.use)
                    I += `${new f.default(m.Dictionary.Action,e).getString()}, `;
                I = `${I.slice(0, -2)}</span>`
            }
            const v = [i.ActionType.Eat, i.ActionType.Heal, i.ActionType.HealOther, i.ActionType.DrinkItem, i.ActionType.DrinkCure];
            if (s.onUse && localPlayer.revealedItems[t])
                for (const t of v) {
                    let a = s.onUse[t];
                    Array.isArray(a) || void 0 === a || (a = [a]);
                    const n = s.skillUse;
                    let o = "";
                    const r = localPlayer.getConsumeBonus(e, n);
                    if (r >= 1 && (o = ` +(0-${r})`),
                    a) {
                        let n = h.default.None;
                        switch (t) {
                        case i.ActionType.Eat:
                            n = h.default.LabelOnEat;
                            break;
                        case i.ActionType.Heal:
                            n = h.default.LabelOnHeal;
                            break;
                        case i.ActionType.HealOther:
                            n = h.default.LabelOnOtherHeal;
                            break;
                        case i.ActionType.DrinkItem:
                            n = h.default.LabelOnDrink;
                            break;
                        case i.ActionType.DrinkCure:
                            n = h.default.LabelOnCure
                        }
                        I += `<span class="consume"><strong>${f.default.message(n).getString()}</strong>`;
                        const r = ["health"];
                        t !== i.ActionType.HealOther && r.push("stamina", "hunger", "thirst");
                        let s = 0;
                        for (const t of r)
                            0 !== a[s] && (I += `<span class="stat ${t}">${a[s] > 0 ? "+" : ""}${a[s]}${a[s] >= 1 ? o : ""}</span>`,
                            a[s] >= 1 && e && e.legendary && e.legendary.type === u.LegendaryType.UseBenefits && (I += ` <span class="legendary">+${e.legendary.value}</span>`),
                            I += ", "),
                            s++;
                        I = `${I.slice(0, -2)}</span>`
                    }
                }
            const [w,M] = itemManager.getGroups(t).collect(R.default.hasAny);
            if (w && (I += `<strong>${f.default.message(h.default.LabelGrouping).getString()}</strong>`,
            I += `<span>${M.map(e=>f.default.nameOf(m.Dictionary.ItemGroup, e, !1).inContext(3)).collect(f.default.formatList, !1).getString()}</span>`),
            s.onUse && s.onUse[i.ActionType.StokeFire]) {
                let t = "";
                if (e) {
                    const a = e.getOnUseBonus();
                    a && e.quality && (t = ` <span class="${u.ItemQuality[e.quality].toLowerCase()}">+${a}</span>`)
                }
                I += `<strong>${f.default.message(h.default.LabelStokeFireStrength).getString()}</strong><span>${s.onUse[i.ActionType.StokeFire]}${t}</span>`
            }
            if (s.lit) {
                const t = c.itemDescriptions[s.lit];
                if (t) {
                    const a = t.onEquipEffect;
                    a && (I += `<strong>${f.default.message(h.default.LabelLightSourceWhenLit).getString()}</strong><span>+${a[1]}`,
                    e && e.legendary && e.legendary.type === u.LegendaryType.Illumination && (I += ` <span class="legendary">+${e.legendary.value}</span>`),
                    I += "</span>")
                }
            }
            if (s.onUse && !s.lit) {
                const e = s.onUse[i.ActionType.Build]
                  , t = o.doodadDescriptions[e];
                if (e && t) {
                    const e = t.lit;
                    if (e) {
                        const t = o.doodadDescriptions[e];
                        t && t.providesLight && (I += `<strong>${f.default.message(h.default.LabelLightSourceWhenLit).getString()}</strong><span>+${t.providesLight}</span>`)
                    }
                }
            }
            if (s.weightCapacity && (I += `<strong>${f.default.message(h.default.LabelWeightCapacity).getString()}</strong><span>${s.weightCapacity}`,
            e && e.legendary && e.legendary.type === u.LegendaryType.WeightCapacity && (I += ` <span class="legendary">+${e.legendary.value}</span>`),
            I += `</span><strong>${f.default.message(h.default.LabelWeightReduction).getString()}</strong><span>-50%`,
            e && e.legendary && e.legendary.type === u.LegendaryType.ContainerWeight && (I += ` <span class="legendary">-${e.legendary.value}%</span>`),
            I += "</span>"),
            s.recipe && s.recipe.reputation) {
                if (I += `<strong>${f.default.message(h.default.LabelCraftingReputation).getString()}</strong><span>${s.recipe.reputation}`,
                s.recipe.skill) {
                    const e = b.skillDescriptions[s.recipe.skill];
                    e && e.reputation && (I += ` (${f.default.message(h.default.LabelCraftingSkillReputation).getString(e.reputation, new f.default(m.Dictionary.Skill,s.recipe.skill).inContext(3).getString())})`)
                }
                I += "</span>"
            }
            if (s.worth && void 0 !== e) {
                const t = e.getWorth();
                void 0 !== t && (I += `<strong>${f.default.message(h.default.LabelWorth).getString()}</strong><span>${t}`,
                e.legendary && e.legendary.type === u.LegendaryType.Worth && (I += ` <span class="legendary">+${e.legendary.value}</span>`),
                I += "</span>")
            }
            I && (T += `<p class="info-line">${I}</p>`);
            let k = "";
            if (s.equip) {
                const e = g.equipTypeToMessage[s.equip];
                k += `<strong>${f.default.message(h.default.LabelEquip).getString()}</strong> <span>${f.default.message(e).getString()}</span>`
            }
            if (s.attack ? (s.equip || (k += `<strong>${f.default.message(h.default.LabelRangedDamage).getString()}</strong> `),
            k += `<span>(+${s.attack} `,
            e && e.legendary && e.legendary.type === u.LegendaryType.Attack && (k += `<span class="legendary">+${e.legendary.value}</span> `),
            s.damageType && (k += g.fullDamageType([s.damageType]).getString()),
            k += ` ${f.default.message(h.default.Attack).getString()})</span>`) : k += `<strong>${f.default.message(h.default.LabelThrowDamageType).getString()}</strong><span>${g.fullDamageType([s.damageType ? s.damageType : u.DamageType.Blunt]).getString()}</span>`,
            s.onUse) {
                const t = s.onUse[i.ActionType.Build]
                  , a = o.doodadDescriptions[t];
                t && a && a.trapDamage && (k += `<strong>${f.default.message(h.default.LabelTrapDamage).getString()}</strong> <span>${a.trapDamage}`,
                e && e.legendary && e.legendary.type === u.LegendaryType.TrapDamage && (k += ` <span class="legendary">+${e.legendary.value}</span>`),
                k += "</span>")
            }
            k && (T += `<p class="info-line">${k}</p>`);
            let C = "", D;
            if (s.onEquipEffect && (C += `+${s.onEquipEffect[1]} `,
            e && e.legendary && e.legendary.type === u.LegendaryType.Illumination && (C += `<span class="legendary">+${e.legendary.value}</span> `),
            C += new f.default(m.Dictionary.OnEquip,s.onEquipEffect[0]).getString()),
            s.equip && e && e.legendary && e.legendary.type !== u.LegendaryType.Worth && e.legendary.type !== u.LegendaryType.ItemWeight && e.legendary.type !== u.LegendaryType.Illumination && e.legendary.type !== u.LegendaryType.WeightCapacity && e.legendary.type !== u.LegendaryType.Range && e.legendary.type !== u.LegendaryType.UseBenefits && e.legendary.type !== u.LegendaryType.ContainerWeight) {
                if (C && (C += ", "),
                C += `<span class="legendary">+${e.legendary.value}`,
                void 0 !== e.legendary.skill) {
                    const t = b.skillDescriptions[e.legendary.skill];
                    t && (C += `% ${new f.default(m.Dictionary.Skill,e.legendary.skill).inContext(3).getString()}`)
                } else if (void 0 !== e.legendary.stat)
                    C += ` ${new f.default(m.Dictionary.Stat,e.legendary.stat).inContext(3).getString()}`;
                else if (e.legendary.type === u.LegendaryType.MaxWeight)
                    C += ` ${f.default.ui(y.default.GameTooltipLegendaryMaxWeightLabel).getString()}`;
                else {
                    let t;
                    switch (e.legendary.type) {
                    case u.LegendaryType.Benignity:
                        t = l.Stat.Benignity;
                        break;
                    case u.LegendaryType.Malignity:
                        t = l.Stat.Malignity;
                        break;
                    case u.LegendaryType.Attack:
                        t = l.Stat.Attack;
                        break;
                    case u.LegendaryType.Defense:
                        t = l.Stat.Defense
                    }
                    void 0 !== t && (C += ` ${new f.default(m.Dictionary.Stat,t).inContext(3).getString()}`)
                }
                C += "</span>"
            }
            if (C && (T += `<p><strong>${f.default.message(h.default.LabelOnEquip).getString()}</strong> ${C}</p>`),
            s.defense) {
                let t = `<ul><li><strong>${f.default.message(h.default.LabelBase).getString()}</strong>${s.defense.base}`;
                if (e && e.legendary && e.legendary.type === u.LegendaryType.Defense && (t += ` <span class="legendary">+${e.legendary.value}</span>`),
                t += "</li>",
                Object.keys(s.defense.resist).length > 0) {
                    t += `<li><strong>${f.default.message(h.default.LabelResists).getString()}</strong>`;
                    for (const e in s.defense.resist)
                        t += `${new f.default(m.Dictionary.DamageType,e).inContext(3).getString()} (${s.defense.resist[e]}), `;
                    t = t.substr(0, t.length - 2),
                    t += "</li>"
                }
                if (Object.keys(s.defense.vulnerable).length > 0) {
                    t += `<li><strong>${f.default.message(h.default.LabelVulnerabilities).getString()}</strong>`;
                    for (const e in s.defense.vulnerable)
                        t += `${new f.default(m.Dictionary.DamageType,e).inContext(3).getString()} (${s.defense.vulnerable[e]}), `;
                    t = t.substr(0, t.length - 2),
                    t += "</li>"
                }
                t += "</ul>",
                T += `<p class="no-space"><strong>${f.default.message(h.default.LabelDefense).getString()}</strong></p>${t}`
            }
            if (s.ranged) {
                let t = "";
                t = `+${s.ranged.attack}`,
                0 === s.ranged.attack && (t = f.default.message(h.default.NotAvailable).getString()),
                T += `<p><strong>${f.default.message(h.default.LabelRanged).getString()}</strong> (${f.default.message(h.default.LabelRange).getString()} ${s.ranged.range}`,
                e && e.legendary && e.legendary.type === u.LegendaryType.Range && (T += ` <span class="legendary">+${e.legendary.value}</span>`),
                T += `, ${f.default.message(h.default.LabelRangedAttack).getString()} ${t}`,
                e && e.legendary && e.legendary.type === u.LegendaryType.Attack && (T += ` <span class="legendary">+${e.legendary.value}</span>`),
                T += ")</p>"
            }
            if (s.dismantle) {
                let e = '<ul class="dismantle"><li>';
                for (const t of s.dismantle.items)
                    e += `<span class="item item-preview item-${t[0]}"></span>${f.default.nameOf(m.Dictionary.Item, t[0]).inContext(3).getString()} x${t[1]}, `;
                if (e = e.substr(0, e.length - 2),
                e += "</li>",
                s.dismantle.required) {
                    e += `<li><strong>${f.default.message(h.default.LabelRequires).getString()}</strong>`;
                    const t = f.default.nameOf(m.Dictionary.ItemGroup, s.dismantle.required).inContext(3).getString()
                      , a = itemManager.getItemForHuman(localPlayer, s.dismantle.required);
                    e += a ? t : `<span class="recipe-missing-items">${t}</span>`,
                    e += "</li>"
                }
                e += "</ul>",
                T += `<p class="no-space"><strong>${f.default.message(h.default.DismantleLabel).getString()}</strong></p>${e}`
            }
            if (e) {
                if ((s.recipe || s.requiredForDisassembly) && (T += '<p class="info-line">'),
                s.requiredForDisassembly) {
                    let e = ""
                      , a = 0;
                    for (const t of s.requiredForDisassembly) {
                        a++;
                        const i = !!itemManager.getItemForHuman(localPlayer, t);
                        let n = "";
                        a >= s.requiredForDisassembly.length && (n = " last"),
                        e += '<span class="disassembly',
                        i || (e += " recipe-missing-items"),
                        e += `${n}">${itemManager.getItemTypeGroupName(t).inContext(3).getString()}`,
                        e += "</span>",
                        a < s.requiredForDisassembly.length && (e += ", ")
                    }
                    T += `<strong>${f.default.message(h.default.RequiredForDisassembleLabel).getString()}</strong>${e}`,
                    s.recipe && (s.recipe.requiredDoodad || s.recipe.requiresFire) && (T += `${this.additionalRequirements(t, s.recipe, !0)}`)
                }
                (s.recipe || s.requiredForDisassembly) && (T += "</p>")
            }
            if (e && this.craftableItemTypes && this.nonCraftableItemTypes) {
                const a = this.craftableItemTypes.concat(this.nonCraftableItemTypes);
                for (const i of a) {
                    const a = c.itemDescriptions[i];
                    if (!a)
                        continue;
                    if (!(D = a.recipe))
                        continue;
                    let n = !1;
                    if (void 0 !== D.baseComponent && itemManager.isGroup(D.baseComponent) ? itemManager.isInGroup(t, D.baseComponent) && (n = !0) : D.baseComponent === e.type && (n = !0),
                    !n)
                        for (const t of D.components) {
                            const a = t.type;
                            if (itemManager.isGroup(a) && itemManager.isInGroup(e.type, a) || e.type === a) {
                                n = !0;
                                break
                            }
                        }
                    n && this.highlightItemElementByItemTypeWithNoItemId(i, !0, !1, !0)
                }
            }
            if (D = s.recipe,
            !e && D && !a && !n) {
                let e = "<ul>";
                const a = new p.default(localPlayer,D,!0);
                a.process();
                const i = a.itemBaseComponent
                  , n = a.itemComponentsRequired
                  , o = a.itemComponentsConsumed;
                for (let e = 0; e < n.length; e++)
                    this.highlightItemElementByItemId(n[e].id, !0, !1, !0);
                for (let e = 0; e < o.length; e++)
                    this.highlightItemElementByItemId(o[e].id, !0, !1, !0);
                D.baseComponent && (i ? this.highlightItemElementByItemId(i.id, !0, !1, !0) : e += '<span class="recipe-missing-items">',
                e += `<li>x1 ${itemManager.getItemTypeGroupName(D.baseComponent).inContext(3).getString()}</li>`,
                i || (e += "</span>"));
                const r = itemManager.getAdjacentContainers(localPlayer)
                  , s = [localPlayer.inventory, ...r]
                  , l = D.components;
                for (let t = 0; t < l.length; t++) {
                    const i = l[t]
                      , n = i.type
                      , o = i.requiredAmount
                      , r = i.consumedAmount
                      , u = itemManager.isGroup(n) ? itemManager.countItemsInContainerByGroup(s, n) : itemManager.countItemsInContainer(s, n)
                      , d = a.amountNeededForComponent(t);
                    d > 0 && (e += '<span class="recipe-missing-items">'),
                    e += `<li>x${o} ${itemManager.getItemTypeGroupName(n, !1).inContext(3).getString()}`,
                    r > 0 && (e += ` (x${r} ${f.default.message(h.default.Consumed).getString()})`);
                    const p = d > 0 ? o - d : u;
                    e += ` (${f.default.message(h.default.LabelHave).getString()} ${p}/${o})</li>`,
                    d > 0 && (e += "</span>")
                }
                (D.requiredDoodad || D.requiresFire) && (e += `<li>${this.additionalRequirements(t, D)}</li>`),
                e += "</ul>";
                const u = g.recipeLevelToMessage[D.level];
                let d = "";
                d = localPlayer.getSkill(D.skill) <= b.skillChance(D.level) - 40 ? `<span class="skill-warning">${f.default.message(u).getString()}</span>` : f.default.message(u).getString();
                const c = b.skillDescriptions[D.skill];
                T += `<p><strong>${f.default.message(h.default.LabelSkill).getString()}</strong> ${c ? new f.default(m.Dictionary.Skill,D.skill).inContext(3).getString() : f.default.message(h.default.Unknown).getString()} <strong>${f.default.message(h.default.LabelLevel).getString()}</strong> ${d}</p>\n\t\t\t\t<p class="no-space"><strong>${f.default.message(h.default.LabelRequires).inContext(3).getString()}</strong> ${e}</p>`
            }
            if (n) {
                const e = itemManager.getItemForHuman(localPlayer, t);
                if (e && this.highlightItemElementByItemId(e.id, !0, !1, !0),
                s.dismantle && s.dismantle.required) {
                    const e = itemManager.getItemForHuman(localPlayer, s.dismantle.required);
                    e && this.highlightItemElementByItemId(e.id, !0, !1, !0)
                }
            }
            if (S.bindingManager.isPressed(u.Bindable.GameMoreInformation) || saveDataGlobal.options.alwaysShowMoreInformation) {
                if (s.use)
                    for (const e of s.use)
                        T += `<p><strong>${new f.default(m.Dictionary.Action,e).getString()}:</strong> ${new f.default(m.Dictionary.Action,e,1).getString()}</p>`
            } else
                s.use && (T += `<p><em>${f.default.message(h.default.MoreInformation).getString(S.bindingManager.getBindingsTranslation(u.Bindable.GameMoreInformation))}</em></p>`);
            return T
        }
        createDialog(e, t) {
            const a = e.dialog(this.setupDialog(u.DialogId.Custom, void 0, t));
            return a.data("dialog-index", this.getDialogIndex(u.DialogId.Custom, t)),
            this.elementOtherDialogs.push(a),
            a
        }
        getUsedQuickSlots() {
            const e = [];
            return this.elementQuickSlotsContainer.children(".in-use").each(function() {
                e.push($(this).getQuickSlot())
            }),
            e
        }
        getFreeQuickSlots() {
            const e = [];
            return this.elementQuickSlotsContainer.children().not(".in-use, #numbers").each(function() {
                e.push($(this).getQuickSlot())
            }),
            e
        }
        getQuickSlotItemElement(e) {
            return this.elementQuickSlotsContainer.children(`[data-quick-slot="${e}"]`).first()
        }
        getItemIdInQuickSlot(e) {
            const t = this.getQuickSlotItemElement(e);
            if (t.hasClass("in-use") && !t.hasClass("disabled"))
                return t.children("li").data("item-id")
        }
        setQuickSlot(e, t, n=!1) {
            if (void 0 === t)
                return !1;
            const o = game.items[t];
            if (!o || o.isInTradeContainer())
                return !1;
            if (!itemManager.isInInventory(o)) {
                let t = !1;
                for (let e = 0; e < this.elementContainerDialogs.length; e++) {
                    const a = this.elementContainerDialogs[e].data("container");
                    if (itemManager.isContainableInContainer(o, a)) {
                        t = !0;
                        break
                    }
                }
                if (!t)
                    return this.setQuickSlotByItemType(e, o.type, !0),
                    !1;
                a.default.get(i.ActionType.MoveItem).execute(localPlayer, o, void 0, localPlayer.inventory)
            }
            let r;
            const s = localPlayer.quickSlotInfo[e];
            return s && s.itemType === o.type && (r = s.action),
            o.quickSlot && (localPlayer.quickSlotInfo[o.quickSlot] && (r = localPlayer.quickSlotInfo[o.quickSlot].action),
            this.clearQuickSlot(o.quickSlot, !0)),
            this.setItemQuickslot(o, e),
            localPlayer.updateQuickSlotInfo(e, o.type, r),
            this.setQuickSlotByItemType(e, o.type, !1, o),
            this.syncItemElements(t),
            n || (localPlayer.queueSoundEffect(u.SfxType.PickUp),
            this.onUpdateQuickSlotsOrEquips()),
            !0
        }
        setQuickSlotByItemType(e, t, a, i) {
            let n;
            const o = localPlayer.quickSlotInfo[e];
            o && o.itemType === t && (n = o.action),
            this.clearQuickSlot(e, !0),
            localPlayer.updateQuickSlotInfo(e, t, n);
            const r = this.getQuickSlotItemElement(e);
            r.attr("data-item-type", t),
            r.addClass("in-use"),
            a ? r.addClass("disabled") : r.removeClass("disabled"),
            r.prepend(this.createItemString(t, i, "is-quick-slot"))
        }
        addItemToFreeQuickSlot(e) {
            const t = this.getFreeQuickSlots();
            0 !== t.length && this.setQuickSlot(t[0], e)
        }
        clearQuickSlot(e, t=!1) {
            const a = this.getQuickSlotItemElement(e);
            if (!a.hasClass("in-use"))
                return;
            const i = this.getItemIdInQuickSlot(e);
            this.removeItemFromQuickSlot(i),
            localPlayer.updateQuickSlotInfo(e),
            a.removeClass("in-use"),
            a.removeClass("disabled"),
            a.removeAttr("data-item-type"),
            a.children("li").trigger("remove").remove(),
            t || localPlayer.queueSoundEffect(u.SfxType.PickUp)
        }
        removeItemFromQuickSlot(e, t) {
            if (void 0 === e)
                return;
            const a = game.items[e];
            a && a.quickSlot && (this.getQuickSlotItemElement(a.quickSlot).children("li").removeAttr("data-item-id").removeData("item-id"),
            this.setItemQuickslot(a, void 0),
            t || this.syncItemElements(e),
            this.onUpdateQuickSlotsOrEquips())
        }
        setItemQuickslot(e, t) {
            multiplayer.isConnected() ? setTimeout(()=>{
                e.isValid() && e.setQuickSlot(localPlayer, t)
            }
            , 1) : e.setQuickSlot(localPlayer, t)
        }
        updateQuickSlotItem(e) {
            const t = this.getQuickSlotItemElement(e);
            if (!t.hasClass("in-use"))
                return !1;
            const a = this.getItemIdInQuickSlot(e);
            if (void 0 !== a) {
                const i = game.items[a];
                if (i && itemManager.isInInventory(i) && i.quickSlot === e)
                    return t.removeClass("disabled"),
                    !1
            }
            let i = !1;
            const n = t.getItemType()
              , o = itemManager.getItemsInContainerByType(localPlayer.inventory, n, !0);
            if (o.length > 0)
                for (let n = 0; n < o.length; n++) {
                    const r = o[n];
                    if (r && r.id !== a) {
                        if (!r.quickSlot)
                            return this.setQuickSlot(e, r.id, !0);
                        {
                            i = !0;
                            const e = t.children("li").attr("data-item-id", r.id).addClass(this.getItemClass(r));
                            this.syncItemElements(r.id, e)
                        }
                    }
                }
            return void 0 !== a ? this.setQuickSlotByItemType(e, n, !i) : i ? t.removeClass("disabled") : t.addClass("disabled"),
            !1
        }
        onUpdateQuickSlotsOrEquips() {
            game.playing && saveDataGlobal.options.protectedCraftingItems && localPlayer.updateTables()
        }
        onSortableItemReceive(e) {
            if (!e.item || !e.targetContainer)
                return;
            const t = e.item
              , n = t.data("item-id")
              , o = t.getQuickSlot()
              , r = parseInt(u.EquipType[t.getEquipSlot()], 10)
              , s = e.initialContainer.data("sortable")
              , l = e.targetContainer
              , d = l.getQuickSlot()
              , p = parseInt(u.EquipType[l.getEquipSlot()], 10)
              , c = l.data("sortable")
              , m = l.parent().data("container")
              , h = game.items[n];
            this.onSortableAction = (()=>{
                switch (c) {
                case "quick-slot":
                    switch (s) {
                    case "quick-slot":
                        l.hasClass("in-use") && this.setQuickSlot(o, this.getItemIdInQuickSlot(d))
                    }
                    if (void 0 !== n)
                        this.setQuickSlot(d, n);
                    else {
                        const e = t.getItemType();
                        this.clearQuickSlot(t.parent().getQuickSlot()),
                        this.setQuickSlotByItemType(d, e, !0),
                        this.updateQuickSlotItem(d)
                    }
                    break;
                case "equip-slot":
                    if (h.isInTradeContainer())
                        break;
                    if ("equip-slot" === s && l.hasClass("in-use")) {
                        const e = this.getItemIdInEquipSlot(p);
                        if (void 0 !== e) {
                            const t = !(p !== u.EquipType.Held && p !== u.EquipType.LeftHand && p !== u.EquipType.RightHand || r !== u.EquipType.Held && r !== u.EquipType.LeftHand && r !== u.EquipType.RightHand);
                            a.default.get(i.ActionType.Equip).execute(localPlayer, game.items[e], r, !0, !!t || void 0)
                        }
                    }
                    a.default.get(i.ActionType.Equip).execute(localPlayer, h, p);
                    break;
                case "inventory":
                    switch (s) {
                    case "quick-slot":
                        this.clearQuickSlot(o);
                        break;
                    case "equip-slot":
                        a.default.get(i.ActionType.Unequip).execute(localPlayer, game.items[n]);
                        break;
                    case "container":
                        h && (h.containedWithin && S.bindingManager.isPressed(u.Bindable.GameItemQuickMoveAll) ? a.default.get(i.ActionType.MoveItem).execute(localPlayer, void 0, h.containedWithin, localPlayer.inventory, h.type) : a.default.get(i.ActionType.MoveItem).execute(localPlayer, h, void 0, localPlayer.inventory));
                        break;
                    default:
                        this.setQuickSlot(d, n)
                    }
                    break;
                case "container":
                    switch (s) {
                    case "inventory":
                    case "container":
                        h && m && (h.containedWithin && S.bindingManager.isPressed(u.Bindable.GameItemQuickMoveAll) ? a.default.get(i.ActionType.MoveItem).execute(localPlayer, void 0, h.containedWithin, m, h.type) : a.default.get(i.ActionType.MoveItem).execute(localPlayer, h, void 0, m))
                    }
                    break;
                case void 0:
                    h && !h.isInTradeContainer() ? a.default.get(i.ActionType.Drop).execute(localPlayer, h, S.bindingManager.isPressed(u.Bindable.GameItemDropAll)) : "quick-slot" === s && this.clearQuickSlot(o)
                }
                this.blurInputs()
            }
            )
        }
        getEquipSlotItemElement(e) {
            return this.elementDialogEquipmentContainer.children(`[data-equip-slot="${u.EquipType[e].toString()}"]`).first()
        }
        getItemIdInEquipSlot(e) {
            const t = this.getEquipSlotItemElement(e);
            if (t.hasClass("in-use"))
                return t.children("li").data("item-id")
        }
        setEquipSlot(e, t, a=!1) {
            if (void 0 === t)
                return;
            const i = game.items[t];
            if (!i)
                return;
            const n = this.getEquipSlotItemElement(e);
            n.addClass("in-use"),
            n.prepend(this.createItemString(i.type, i)),
            this.syncItemElements(t),
            !a && this.isVisible() && this.openDialog(this.elementDialogEquipment),
            this.onUpdateQuickSlotsOrEquips()
        }
        removeItemFromEquipSlot(e) {
            if (!e)
                return;
            const t = this.getItemIdInEquipSlot(e);
            if (void 0 === t)
                return;
            const a = this.getEquipSlotItemElement(e);
            a.hasClass("in-use") && (a.removeClass("in-use"),
            a.children("li").trigger("remove").remove(),
            this.syncItemElements(t),
            this.onUpdateQuickSlotsOrEquips())
        }
        sortSkills(e) {
            return e.sort((e,t)=>new f.default(m.Dictionary.Skill,e).getString().localeCompare(new f.default(m.Dictionary.Skill,t).getString()))
        }
        updateCraftingDialog(e, t) {
            this.craftableItemTypes && this.nonCraftableItemTypes && A.default.equals(this.craftableItemTypes, e) && A.default.equals(this.nonCraftableItemTypes, t) || (this.craftableItemTypes = e,
            this.nonCraftableItemTypes = t,
            this.onUpdateContainer(this.elementDialogCraftingContainer, !1))
        }
        updateDismantleTab(e) {
            let t = "";
            for (const a in e)
                t += `<li class="tooltip is-dismantle item item-${a}" data-item-type="${a}"></li>`;
            this.elementDialogDismantleContainer.html(t),
            this.onFilterInput(this.elementDialogDismantleContainer)
        }
        createCraftItemElements(e) {
            let t = "";
            const a = this.craftableItemTypes ? this.craftableItemTypes.slice() : void 0
              , i = this.nonCraftableItemTypes ? this.nonCraftableItemTypes.slice() : void 0;
            if (a && a.sort((t,a)=>this.determineSort(e, void 0, t, void 0, a)),
            i && i.sort((t,a)=>this.determineSort(e, void 0, t, void 0, a)),
            e.sortType === u.SortType.Category || e.sortType === u.SortType.Skill) {
                const n = [];
                switch (e.sortType) {
                case u.SortType.Category:
                    const t = G.default.values(u.ItemTypeGroup).filter(e=>e !== u.ItemTypeGroup.Invalid && e !== u.ItemTypeGroup.Last).collect(R.default.toArray);
                    t.sort((e,t)=>new f.default(m.Dictionary.ItemGroup,e).getString().localeCompare(new f.default(m.Dictionary.ItemGroup,t).getString())),
                    e.reverse && t.reverse();
                    for (const e of t) {
                        const t = (t,a)=>!!itemManager.isInGroup(t, e) || e === u.ItemTypeGroup.Other && !itemManager.getGroups(t).collect(R.default.first())
                          , a = c.itemGroupDescriptions[e];
                        a && n.push({
                            name: f.default.nameOf(m.Dictionary.ItemGroup, e, !1).inContext(3).getString(),
                            matcher: t
                        })
                    }
                    break;
                case u.SortType.Skill:
                    let a = G.default.values(u.SkillType).collect(R.default.toArray);
                    a = this.sortSkills(a),
                    e.reverse && a.reverse();
                    for (const e of a) {
                        const t = (t,a)=>{
                            const i = a.recipe;
                            return i ? i.skill === e : -1 === e
                        }
                        ;
                        n.push({
                            name: (-1 === e ? f.default.message(h.default.NotAvailable) : new f.default(m.Dictionary.Skill,e).inContext(3)).getString(),
                            matcher: t
                        })
                    }
                }
                for (const e of n) {
                    let n = !1;
                    const o = ()=>{
                        n || (n = !0,
                        t += `<div data-section="${e.name}">${e.name}</div>`)
                    }
                    ;
                    if (a)
                        for (let i = 0; i < a.length; i++) {
                            const n = a[i]
                              , r = c.itemDescriptions[n];
                            if (r && e.matcher(n, r)) {
                                o();
                                const e = !game.isChallenge && game.crafted[n];
                                t += this.createItemString(n, void 0, e && e.newUnlock ? "highlighted" : "")
                            }
                        }
                    if (i)
                        for (let a = 0; a < i.length; a++) {
                            const n = i[a]
                              , r = c.itemDescriptions[n];
                            if (r && e.matcher(n, r)) {
                                o();
                                const e = !game.isChallenge && game.crafted[n];
                                t += this.createItemString(n, void 0, e && e.newUnlock ? "highlighted non-craftable" : "non-craftable")
                            }
                        }
                    n && (t += '<div class="clear-fix"></div>')
                }
            } else {
                if (a)
                    for (const e of a) {
                        const a = !game.isChallenge && game.crafted[e];
                        t += this.createItemString(e, void 0, a && a.newUnlock ? "highlighted" : "")
                    }
                if (t += '<div class="clear-fix clear-fix-bordered"></div>',
                i)
                    for (const e of i) {
                        const a = !game.isChallenge && game.crafted[e];
                        t += this.createItemString(e, void 0, a && a.newUnlock ? "highlighted non-craftable" : "non-craftable")
                    }
            }
            const n = this.elementDialogCraftingContainer.get(0);
            n.innerHTML = t,
            this.onFilterInput(this.elementDialogCraftingContainer)
        }
        updateItem(e) {
            this.syncItemElements(e.id);
            const t = e.containedWithin;
            void 0 !== t && void 0 !== t.weightCapacity && this.refreshContainerName(t)
        }
        onMove() {
            this.hideActionsMenu(),
            this.closeStaticContainers()
        }
        refreshWorldTooltips() {}
        getDialogElementForContainer(e) {
            for (let t = 0; t < this.elementContainerDialogs.length; t++) {
                const a = this.elementContainerDialogs[t];
                if (a.data("container") === e)
                    return a
            }
        }
        isContainerOpen(e) {
            return void 0 !== this.getDialogElementForContainer(e)
        }
        openContainer(e, t) {
            let a = this.getDialogElementForContainer(e);
            if (void 0 !== a)
                return void (void 0 !== t && (a.data("container-name", t),
                this.refreshContainerName(e)));
            const i = $("#container").clone().removeAttr("id");
            let n;
            i.appendTo(this.elementDialogs);
            const o = itemManager.getContainerReference(e);
            o && o.type === d.ContainerReferenceType.Item && (n = o.id),
            (a = i.dialog(this.setupDialog(u.DialogId.Container, n)).data("container", e).data("container-name", t).data("cloned", i)).parent().hover(()=>{
                !this.isSorting() && n && this.highlightItemElementByItemId(n, !0)
            }
            , ()=>{
                n && this.highlightItemElementByItemId(n, !1, !0)
            }
            ),
            e.containerType === d.ContainerType.Trade && (a.parent().find(".grab-all").remove(),
            a.find(".container").addClass("is-npc")),
            this.elementContainerDialogs.push(a),
            a.find(".filter").val("");
            const r = a.find(".container").addClass("is-container-container");
            for (const t of itemManager.getOrderedContainerItems(e))
                e.containerType === d.ContainerType.Trade && t.isEquipped() || this.addItemToContainer(t, e, !0, !0);
            this.onAddItemsToContainer(r, a, !1),
            this.bindSortable(r),
            this.updateActiveContainer(),
            this.onOpenDialog(a),
            this.clampDialogs()
        }
        closeContainer(e) {
            this.closeContainerDialog(this.getDialogElementForContainer(e))
        }
        closeContainerDialog(e) {
            if (void 0 === e)
                return;
            const t = e.data("container");
            if (t) {
                const t = e.find(".container");
                this.sortableElementTargetContainer && this.sortableElementTargetContainer.get(0) === t.get(0) && this.cancelSorting();
                const a = this.sortableElement
                  , i = ()=>{
                    this.cancelSorting()
                }
                ;
                e.find(".item").each(function() {
                    a && this === a && i(),
                    $(this).trigger("remove").remove()
                })
            }
            for (let t = 0; t < this.elementContainerDialogs.length; t++) {
                const a = this.elementContainerDialogs[t];
                a.get(0) === e.get(0) && (this.elementContainerDialogs.splice(t, 1),
                this.updateActiveContainer())
            }
            e.dialog("close").remove()
        }
        closeStaticContainers() {
            for (let e = 0; e < this.elementContainerDialogs.length; e++) {
                const t = this.elementContainerDialogs[e].data("container");
                if (!itemManager.isInInventory(t))
                    return this.closeContainer(t),
                    void this.closeStaticContainers()
            }
        }
        closeAllContainers() {
            return this.elementContainerDialogs.length > 0 && (this.closeContainerDialog(this.elementContainerDialogs[0]),
            this.closeAllContainers(),
            !0)
        }
        updateContainerName(e) {
            const t = e.data("container");
            if (t) {
                let a = e.data("container-name");
                if (a) {
                    if (t.containerType === d.ContainerType.Trade) {
                        const e = itemManager.getNPCFromInventoryContainer(t);
                        if (void 0 !== e) {
                            const t = e.getProperty(s.Property.Credit);
                            if (void 0 !== t) {
                                const e = t.get(localPlayer.identifier) || 0;
                                a += ` [${f.default.ui(y.default.GameItemBarterCredit).getString()}${e}]`
                            }
                        }
                    }
                    if (void 0 !== t.weightCapacity) {
                        a += ` (${B.default.roundNumber(itemManager.computeContainerWeight(t), 1)}/${t.weightCapacity}`;
                        const e = itemManager.getContainerReference(t, void 0, !1);
                        if (e.type === d.ContainerReferenceType.Item) {
                            const e = t;
                            e.legendary && e.legendary.type === u.LegendaryType.WeightCapacity && (a += ` +${e.legendary.value}`)
                        }
                        a += ")"
                    }
                    e.dialog("option", "title", a)
                }
                t.containedWithin && t.containedWithin !== localPlayer.inventory && this.refreshContainerName(t.containedWithin)
            }
        }
        updateActiveContainer() {
            this.elementContainerDialogs.length > 0 ? (this.activeContainer = this.elementContainerDialogs[this.elementContainerDialogs.length - 1].data("container"),
            this.multipleContainersOpened = this.elementContainerDialogs.length > 1) : this.activeContainer = void 0
        }
        hideContextMenu() {
            return !(!$(document).contextmenu("instance") || !$(document).contextmenu("isOpen")) && ($(document).contextmenu("close"),
            !0)
        }
        hideActionsMenu() {
            this.actionsMenuOpen && (this.hideContextMenu(),
            this.elementActions.quickHide(),
            this.actionsMenuOpen = !1)
        }
        toggleActionsMenu(e=!1) {
            this.actionsMenuOpen ? this.hideActionsMenu() : this.showActionsMenu(e),
            this.actionsMenuCentered = e
        }
        showActionsMenu(e=!1, t=!0, a) {
            if (localPlayer.isResting())
                return;
            const n = []
              , o = localPlayer.getFacingTile();
            if (!o)
                return;
            const r = localPlayer.getTile();
            if (!o)
                return;
            t && (e || this.actionsMenuCentered ? (this.elementActions.css("left", ui.getWidth() / 2),
            this.elementActions.css("top", ui.getHeight() / 2)) : (this.elementActions.css("left", this.mouseX),
            this.elementActions.css("top", this.mouseY))),
            this.elementActions.quickShow(),
            this.actionsMenuOpen = !0;
            const s = C.default[L.default.getType(o)];
            if (void 0 !== o.doodad && o.doodad.canPickup(localPlayer) && n.push({
                action: "CollectObjectWithHands",
                text: f.default.message(h.default.CollectObjectWithHands).getString(),
                keybind: 0
            }),
            localPlayer.isFacingCarvableTile() && void 0 !== localPlayer.getDefaultCarveTool() && n.push({
                action: "CarveWithTool",
                text: f.default.message(h.default.CarveWithTool).getString(),
                keybind: 1
            }),
            void 0 !== o.containedItems) {
                const e = o.containedItems.length;
                e > 0 && n.push({
                    action: "PickUpItem",
                    text: f.default.message(h.default.PickupItem).getString(),
                    keybind: 2
                }),
                e > 1 && n.push({
                    action: "PickUpAllItems",
                    text: f.default.message(h.default.PickupAllItems).getString(),
                    keybind: 3
                })
            }
            void 0 !== o.doodad && o.doodad.canHarvest() ? n.push({
                action: "HarvestWithHands",
                text: f.default.message(h.default.HarvestWithHands).getString(),
                keybind: 4
            }) : s && s.gather || void 0 !== o.doodad && o.doodad.isGatherable() || tileEventManager.canGather(o) ? n.push({
                action: "GatherWithHands",
                text: f.default.message(h.default.GatherWithHands).getString(),
                keybind: 4
            }) : !s || !s.passable || s.water || void 0 !== o.doodad || void 0 !== o.containedItems && 0 !== o.containedItems.length || void 0 !== o.corpses || void 0 !== o.events || n.push({
                action: "DigWithHands",
                text: f.default.message(h.default.DigWithHands).getString(),
                keybind: 4
            });
            const l = o.doodad;
            l && (l.type === u.DoodadType.WoodenDoor || l.type === u.DoodadType.WoodenGate ? n.push({
                action: "OpenDoor",
                text: f.default.message(h.default.OpenDoor).getString(),
                keybind: 5
            }) : l.type !== u.DoodadType.WoodenDoorOpen && l.type !== u.DoodadType.WoodenGateOpen || n.push({
                action: "CloseDoor",
                text: f.default.message(h.default.CloseDoor).getString(),
                keybind: 5
            }));
            const d = localPlayer.getTile()
              , p = C.default[L.default.getType(d)];
            if (p && p.passable) {
                const e = d.doodad && d.doodad.getActions()
                  , t = e && e.some(e=>e === i.ActionType.Rest || e === i.ActionType.Sleep);
                t || n.push({
                    action: "RestOnGround",
                    text: f.default.message(h.default.RestOnGround).getString(),
                    keybind: 6
                })
            }
            localPlayer.canJump() && n.push({
                action: "Jump",
                text: f.default.message(h.default.Jump).getString(),
                keybind: 7
            });
            const c = o.creature;
            if (c && (c.isTamed() ? localPlayer.hasTamedCreature(c) && n.push({
                action: "Release",
                text: f.default.message(h.default.Release).getString(),
                keybind: 8
            }) : n.push({
                action: "Tame",
                text: f.default.message(h.default.Tame).getString(),
                keybind: 8
            })),
            c && void 0 !== c.hitchedTo)
                n.push({
                    action: "Unhitch",
                    text: f.default.message(h.default.Unhitch).getString(),
                    keybind: 9
                });
            else if (c) {
                const e = [[c.x + 1, c.y], [c.x - 1, c.y], [c.x, c.y + 1], [c.x, c.y - 1]];
                for (let t = 0; t < e.length; t++) {
                    const a = game.getTile(e[t][0], e[t][1], c.z);
                    if (a && a.doodad) {
                        const e = a.doodad.description();
                        if (e && e.group === u.DoodadTypeGroup.Hitch) {
                            n.push({
                                action: "Hitch",
                                text: f.default.message(h.default.Hitch).getString(),
                                keybind: 9
                            });
                            break
                        }
                    }
                }
            }
            s && (s.water || s.shallowWater || L.default.getType(o) === u.TerrainType.Snow) && n.push({
                action: "Drink",
                text: f.default.message(h.default.Drink).getString(),
                keybind: 10
            }),
            void 0 !== o.creature && o.creature.isTamed() ? n.push({
                action: "Rename",
                text: new f.default(m.Dictionary.Action,i.ActionType.Rename).getString(),
                data: o.creature,
                keybind: 11
            }) : void 0 !== o.doodad && n.push({
                action: "Rename",
                text: new f.default(m.Dictionary.Action,i.ActionType.Rename).getString(),
                data: o.doodad,
                keybind: 11
            });
            let y = 12;
            if (void 0 !== o.npc) {
                const e = o.npc.getActions();
                if (void 0 !== e)
                    for (const t of e)
                        n.push({
                            action: t.toString(),
                            text: new f.default(m.Dictionary.Action,t).getString(),
                            data: o.npc,
                            keybind: y++
                        });
                o.npc.isHostile() || n.push({
                    action: "Attack",
                    text: f.default.message(h.default.Attack).getString(),
                    keybind: y++
                })
            } else {
                if (void 0 !== o.doodad) {
                    const e = o.doodad.getActions();
                    if (void 0 !== e)
                        for (const t of e)
                            n.push({
                                action: t.toString(),
                                text: new f.default(m.Dictionary.Action,t).getString(),
                                data: o.doodad,
                                keybind: y++
                            })
                }
                if (void 0 !== r.doodad) {
                    const e = r.doodad.getActions();
                    if (void 0 !== e)
                        for (const t of e)
                            n.push({
                                action: t.toString(),
                                text: new f.default(m.Dictionary.Action,t).getString(),
                                data: r.doodad,
                                keybind: y++
                            })
                }
            }
            const g = {
                actions: n
            };
            a || ui.playClickSound(),
            $(document).contextmenu("open", this.elementActions, g),
            $(".ui-contextmenu").removeAttr("tabindex")
        }
        onCopySelectedText() {
            document.execCommand("copy"),
            window.getSelection().removeAllRanges()
        }
        onFilterInput(e) {
            const t = 2 === e.length || e === this.elementDialogDismantleContainer || e === this.elementDialogCraftingContainer ? e.parent().parent().parent().find(".filter") : e.parent().parent().find(".filter")
              , a = t.val()
              , i = e.children();
            if (a.length > 0)
                t.addClass("filtering"),
                t.parent().addClass("filtered");
            else {
                if (!t.hasClass("filtering"))
                    return;
                t.removeClass("filtering"),
                t.parent().removeClass("filtered")
            }
            let n = !1;
            if ($.each(i, function() {
                const e = $(this).data("section");
                void 0 !== e && (n = !0);
                const t = $(this).getItemType();
                if (!t)
                    return;
                const i = c.itemDescriptions[t];
                if (!i)
                    return;
                const o = [f.default.nameOf(m.Dictionary.Item, t, !1).getString()];
                for (const e of itemManager.getGroups(t))
                    o.push(new f.default(m.Dictionary.ItemGroup,e).getString());
                if (i.recipe && void 0 !== i.recipe.skill && o.push(new f.default(m.Dictionary.Skill,i.recipe.skill).inContext(3).getString()),
                i.dismantle && i.dismantle.items)
                    for (const [e] of i.dismantle.items)
                        o.push(new f.default(m.Dictionary.Item,e).getString());
                const r = o.reduce((e,t)=>e || t.toLocaleLowerCase().indexOf(a.toLocaleLowerCase()) > -1, !1);
                $(this).toggle(r)
            }),
            n)
                $.each(i, function() {
                    const e = $(this).data("section");
                    if (void 0 === e)
                        return;
                    let t = !1
                      , a = $(this).next();
                    for (; a.is("li"); ) {
                        if (a.isVisible()) {
                            t = !0,
                            a = a.nextAll(".clear-fix:first");
                            break
                        }
                        a = a.next()
                    }
                    $(this).add(a).toggle(t)
                });
            else if (e.is("#container-crafting")) {
                const t = e.find(".clear-fix-bordered")
                  , a = t.prevAll(":not([style*='display: none'])")
                  , i = t.nextAll(":not([style*='display: none'])");
                t.toggle(a.length > 0 && i.length > 0)
            }
        }
        showSortContextMenu(e, t, a) {
            const i = [];
            i.push({
                action: "SortName",
                text: f.default.message(h.default.Name).getString(),
                data: {
                    sortType: u.SortType.Name,
                    container: t,
                    messageType: a
                }
            }),
            a === h.default.Crafts ? (i.push({
                action: "SortSkill",
                text: f.default.message(h.default.Skill).getString(),
                data: {
                    sortType: u.SortType.Skill,
                    container: t,
                    messageType: a
                }
            }),
            i.push({
                action: "SortCategory",
                text: f.default.message(h.default.Category).getString(),
                data: {
                    sortType: u.SortType.Category,
                    container: t,
                    messageType: a
                }
            }),
            i.push({
                action: "SortUnlockedTime",
                text: f.default.message(h.default.UnlockedTime).getString(),
                data: {
                    sortType: u.SortType.DiscoveredTime,
                    container: t,
                    messageType: a
                }
            })) : (i.push({
                action: "SortDecay",
                text: f.default.message(h.default.Decay).getString(),
                data: {
                    sortType: u.SortType.Decay,
                    container: t,
                    messageType: a
                }
            }),
            i.push({
                action: "SortDurability",
                text: f.default.message(h.default.Durability).getString(),
                data: {
                    sortType: u.SortType.Durability,
                    container: t,
                    messageType: a
                }
            }),
            i.push({
                action: "SortGroup",
                text: f.default.message(h.default.Group).getString(),
                data: {
                    sortType: u.SortType.Group,
                    container: t,
                    messageType: a
                }
            }),
            i.push({
                action: "SortRecent",
                text: f.default.message(h.default.Recent).getString(),
                data: {
                    sortType: u.SortType.Recent,
                    container: t,
                    messageType: a
                }
            }),
            i.push({
                action: "SortQuality",
                text: f.default.message(h.default.Quality).getString(),
                data: {
                    sortType: u.SortType.Quality,
                    container: t,
                    messageType: a
                }
            }),
            i.push({
                action: "SortWeight",
                text: f.default.message(h.default.Weight).getString(),
                data: {
                    sortType: u.SortType.Weight,
                    container: t,
                    messageType: a
                }
            }),
            i.push({
                action: "SortBest",
                text: f.default.message(h.default.Best).getString(),
                data: {
                    sortType: u.SortType.Best,
                    container: t,
                    messageType: a
                }
            }));
            const n = {
                actions: i
            };
            $(document).contextmenu("open", e, n),
            $(".ui-contextmenu").removeAttr("tabindex")
        }
        getContainerId(e) {
            const t = e.parent()
              , a = t.data("container");
            return a ? JSON.stringify(itemManager.getContainerReference(a)) : t.attr("id")
        }
        sortItems(e, t, a, i=!0) {
            const n = this.getContainerId(e);
            let o = localPlayer.containerSortInfo[n];
            if (o && o.sortType === t ? i && void 0 !== a && (o.reverse = !o.reverse) : (o = localPlayer.containerSortInfo[n] = {
                sortType: t
            },
            t !== u.SortType.Quality && t !== u.SortType.Decay || (o.reverse = !0)),
            e === this.elementDialogCraftingContainer)
                this.createCraftItemElements(o);
            else {
                let t;
                const a = e.children(".clear-fix");
                if (0 === a.length)
                    t = [e.children()];
                else {
                    if (1 !== a.length)
                        return;
                    t = [a.prevAll(), a.nextAll()]
                }
                for (let i = 0; i < t.length; i++) {
                    let n = t[i];
                    this.sortItemElements(n, o),
                    n = n.detach(),
                    2 === t.length ? 0 === i ? n.insertBefore(a) : n.insertAfter(a) : n.appendTo(e)
                }
                0 === a.length && this.saveItemOrder(e)
            }
            if (void 0 === a)
                return;
            let r = h.default.None;
            switch (t) {
            case u.SortType.Name:
                r = h.default.SortedByName;
                break;
            case u.SortType.Group:
                r = h.default.SortedByGroup;
                break;
            case u.SortType.Weight:
                r = h.default.SortedByWeight;
                break;
            case u.SortType.Recent:
                r = h.default.SortedByRecent;
                break;
            case u.SortType.Skill:
                r = h.default.SortedBySkill;
                break;
            case u.SortType.Decay:
                r = h.default.SortedByDecay;
                break;
            case u.SortType.Quality:
                r = h.default.SortedByQuality;
                break;
            case u.SortType.Durability:
                r = h.default.SortedByDurability;
                break;
            case u.SortType.Category:
                r = h.default.SortedByCategory;
                break;
            case u.SortType.DiscoveredTime:
                r = h.default.SortedByUnlockedTime;
                break;
            case u.SortType.Best:
                r = h.default.SortedByBest
            }
            localPlayer.messages.send(r, f.default.message(a))
        }
        sortItemElements(e, t) {
            e.sort((e,a)=>{
                const i = $(e).getItemType()
                  , n = $(a).getItemType();
                return this.determineSort(t, $(e).data("item-id"), i, $(a).data("item-id"), n)
            }
            )
        }
        updateInventorySort() {
            this.onUpdateContainer(this.elementDialogInventoryContainer, !0)
        }
        onUpdateContainer(e, t) {
            this.updateSort(e, t),
            this.onFilterInput(e)
        }
        updateSort(e, t) {
            if (t && !saveDataGlobal.options.keepSortActive)
                return;
            const a = this.getContainerId(e);
            let i;
            const n = localPlayer.containerSortInfo[a];
            i = n && void 0 !== n.sortType ? n.sortType : e === this.elementDialogCraftingContainer ? u.SortType.Name : u.SortType.Recent,
            this.sortItems(e, i, void 0, !1)
        }
        isContainerDialogOver(e, t) {
            for (let a = 0; a < this.elementContainerDialogs.length; a++) {
                const i = this.elementContainerDialogs[a]
                  , n = i.parent().offset().left
                  , o = i.parent().offset().top
                  , r = i.parent().width()
                  , s = i.parent().height();
                if (!(e < n || t < o) && !(e > n + r || t > o + s))
                    return !0
            }
            return !1
        }
        onUpdateDirection() {
            this.actionsMenuOpen ? (this.hideActionsMenu(),
            this.showActionsMenu(!1, !0, !0)) : this.contextMenuOpen && this.contextMenuTarget && this.showItemContextMenu(this.contextMenuTarget)
        }
        onBindLoop(e, t) {
            function n() {
                return !1 !== t
            }
            let o;
            document.activeElement && "INPUT" === document.activeElement.tagName && document.activeElement.matches(".ui-dialog input") && !document.activeElement.classList.contains("can-focus") && this.element[0].focus(),
            this.mouseX = e.mouseX,
            this.mouseY = e.mouseY,
            t = t || void 0 !== this.isCurrentlySorting || this.isOverlayVisible();
            const r = ()=>(void 0 === o && (o = this.getHoveredItem(e)),
            o);
            if (e.wasPressed(u.Bindable.GameItemMenu) && !n() && r() && (this.showItemContextMenu($(r())),
            t = u.Bindable.GameItemMenu,
            P.sleep(50).then(()=>{
                e.removePressState(u.Bindable.GameItemMenu)
            }
            )),
            !e.wasPressed(u.Bindable.GameItemQuickMove) && !e.wasPressed(u.Bindable.GameItemQuickMoveAll) || n())
                (e.wasReleased(u.Bindable.GameItemQuickMove) || e.wasReleased(u.Bindable.GameItemQuickMoveAll)) && (this.isQuickmoving = !1);
            else if (r()) {
                const n = game.items[$(r()).data("item-id")];
                if (n) {
                    const o = e.wasPressed(u.Bindable.GameItemQuickMoveAll);
                    let r;
                    if (t = o ? u.Bindable.GameItemQuickMoveAll : u.Bindable.GameItemQuickMove,
                    n.containedWithin === localPlayer.inventory)
                        if (this.activeContainer)
                            r = this.activeContainer;
                        else {
                            const e = localPlayer.getFacingTile().doodad;
                            e && itemManager.isContainer(e) && (r = e)
                        }
                    else
                        r = localPlayer.inventory;
                    r && (o ? a.default.get(i.ActionType.MoveItem).execute(localPlayer, void 0, n.containedWithin, r, n.type) : a.default.get(i.ActionType.MoveItem).execute(localPlayer, n, void 0, r))
                }
                this.isQuickmoving = !0
            }
            if (e.wasPressed(u.Bindable.GameItemMove) && !n() && r() && (this.isCurrentlySorting = r(),
            this.runSortableAction($([r().parentElement]), "mouseDown", {
                type: "mousedown",
                which: 1,
                target: r(),
                pageX: e.mouseX,
                pageY: e.mouseY,
                stopPropagation() {},
                preventDefault() {}
            }),
            t = u.Bindable.GameItemMove),
            this.shouldCancelSorting && (this.shouldCancelSorting = !1,
            e.removePressState(u.Bindable.GameItemMove)),
            e.wasReleased(u.Bindable.GameItemMove) && this.isCurrentlySorting && (this.runSortableAction($([this.isCurrentlySorting.parentElement]), "mouseUp", {
                type: "mouseup",
                which: 1,
                target: this.isCurrentlySorting,
                pageX: e.mouseX,
                pageY: e.mouseY,
                stopPropagation() {},
                preventDefault() {}
            }),
            this.isCurrentlySorting = void 0),
            e.wasPressed(u.Bindable.GameItemEquipToggle) && !n() && r()) {
                const e = game.items[$(r()).data("item-id")];
                if (e) {
                    if (e.isEquipped())
                        a.default.get(i.ActionType.Unequip).execute(localPlayer, e);
                    else if (!e.isInTradeContainer()) {
                        const t = c.itemDescriptions[e.type];
                        t && t.equip && a.default.get(i.ActionType.Equip).execute(localPlayer, e, t.equip)
                    }
                    t = u.Bindable.GameItemEquipToggle
                }
            }
            if (this.contextMenuOpen)
                for (let a = 1; a < 25; a++) {
                    const i = u.Bindable[`GameContextMenu${a}`];
                    e.wasPressed(i) && !n() && (this.pressHotKey(a - 1) && (t = i),
                    this.canUseQuickslot = !1)
                }
            for (let a = 1; a < 10; a++) {
                const i = u.Bindable[`GameQuickSlotToggle${a}`]
                  , o = e.wasPressed(i);
                this.contextMenuOpen || !o && !e.isDown(i) || n() || !r() || this.quickSlotToggleBindPressed(e, r(), a, i, o) && (t = i),
                e.wasReleased(i) && (this.canUseQuickslot = !0)
            }
            for (let a = 1; a < 10; a++) {
                const i = u.Bindable[`GameQuickSlot${a}`]
                  , o = e.wasPressed(i);
                this.contextMenuOpen || !(o || !this.hasDelay() && e.isDown(i)) || n() || this.quickSlotBindPressed(e, a, i) && (t = i),
                e.wasReleased(i) && (this.canUseQuickslot = !0),
                (this.contextMenuOpen || this.isOverlayVisible() || !this.canUseQuickslot) && e.removePressState(i)
            }
            if (e.wasPressed(u.Bindable.GameQuickSlotClear) && !n()) {
                let a = !1;
                if ($("#quick-slots > .quick-slot").each((t,i)=>{
                    const n = i;
                    return !e.isMouseWithin(n) || (this.clearQuickSlot(+n.dataset.quickSlot),
                    a = !0,
                    !1)
                }
                ),
                !a && r()) {
                    const e = game.items[$(r()).data("item-id")];
                    e && e.quickSlot && (this.clearQuickSlot(e.quickSlot, !0),
                    a = !0)
                }
                a && (t = u.Bindable.GameQuickSlotClear)
            }
            if ((e.wasPressed(u.Bindable.GameItemDrop) || e.wasPressed(u.Bindable.GameItemDropAll)) && !n()) {
                const n = r() ? game.items[$(r()).data("item-id")] : void 0;
                if (n && !n.isInTradeContainer()) {
                    const o = e.wasPressed(u.Bindable.GameItemDropAll);
                    a.default.get(i.ActionType.Drop).execute(localPlayer, n, o),
                    t = o ? u.Bindable.GameItemDropAll : u.Bindable.GameItemDrop
                }
            }
            return e.wasPressed(u.Bindable.MenuCancel) && !n() && this.contextMenuOpen && (t = u.Bindable.MenuCancel),
            e.wasPressed(u.Bindable.DialogCloseAll) && !n() && this.closeAllDialogs() && (t = u.Bindable.DialogCloseAll),
            !e.wasPressed(u.Bindable.GameMoreInformation) && !e.wasReleased(u.Bindable.GameMoreInformation) || n() || ui.tooltipRefresh(),
            e.wasPressed(u.Bindable.DialogDismantle) && !n() && (this.toggleCraftingTab("dismantle"),
            t = u.Bindable.DialogDismantle),
            e.wasPressed(u.Bindable.GameHandToggleLeft) && !n() && (this.changeEquipmentOption("leftHand"),
            t = u.Bindable.GameHandToggleLeft),
            e.wasPressed(u.Bindable.GameHandToggleRight) && !n() && (this.changeEquipmentOption("rightHand"),
            t = u.Bindable.GameHandToggleRight),
            !this.contextMenuOpen || !t && !e.isDown("Mouse0") || e.isDown(u.Bindable.GameActions) || e.isDown(u.Bindable.GameItemMenu) || e.isMouseWithin(document.getElementsByClassName("ui-contextmenu")[0], !1) || (this.hideActionsMenu(),
            this.hideContextMenu()),
            t
        }
        additionalRequirements(e, t, a) {
            const i = c.itemDescriptions[e];
            let n = `<strong>${f.default.message(h.default.LabelAdditionalRequirements).getString()}</strong> `;
            const o = itemManager.hasAdditionalRequirements(localPlayer, e, void 0, void 0, a);
            if ((t.requiresFire || a && i && i.repairAndDisassemblyRequiresFire) && (o.fireRequirementMet || (n += '<span class="recipe-missing-items">'),
            n += f.default.message(h.default.FireSource).getString(),
            o.fireRequirementMet || (n += "</span>")),
            t.requiredDoodad) {
                (t.requiresFire || a && i && i.repairAndDisassemblyRequiresFire) && (n += ", "),
                o.doodadRequirementMet || (n += '<span class="recipe-missing-items">');
                const e = doodadManager.isDoodadTypeGroup(t.requiredDoodad);
                n += f.default.nameOf(e ? m.Dictionary.DoodadGroup : m.Dictionary.ItemGroup, t.requiredDoodad).inContext(3).getString(),
                o.doodadRequirementMet || (n += "</span>")
            }
            return n
        }
        runAction(e, t, o) {
            let s, l, d, p, m;
            if (void 0 !== e && (d = game.items[e]) && (s = d.type,
            l = d.quickSlot),
            t.data && t.data.facingContainer) {
                const e = localPlayer.getFacingTile().doodad;
                e && (m = e)
            }
            switch (t.action) {
            case "Attack":
                a.default.get(i.ActionType.Attack).execute(localPlayer);
                break;
            case "CollectObjectWithHands":
                a.default.get(i.ActionType.Pickup).execute(localPlayer, void 0);
                break;
            case "CarveWithTool":
                const o = localPlayer.getDefaultCarveTool();
                o && a.default.get(i.ActionType.Carve).execute(localPlayer, o);
                break;
            case "PickUpItem":
                a.default.get(i.ActionType.PickupItem).execute(localPlayer);
                break;
            case "PickUpAllItems":
                a.default.get(i.ActionType.PickupAllItems).execute(localPlayer);
                break;
            case "OpenDoor":
                a.default.get(i.ActionType.OpenDoor).execute(localPlayer);
                break;
            case "CloseDoor":
                a.default.get(i.ActionType.CloseDoor).execute(localPlayer);
                break;
            case "Drink":
                a.default.get(i.ActionType.DrinkInFront).execute(localPlayer);
                break;
            case "GatherWithHands":
                this.confirmAction(i.ActionType.Gather, [void 0, !0], !1);
                break;
            case "HarvestWithHands":
                this.confirmAction(i.ActionType.Harvest, [void 0, !0], !1);
                break;
            case "DigWithHands":
                a.default.get(i.ActionType.Dig).execute(localPlayer);
                break;
            case "RestOnGround":
                a.default.get(i.ActionType.Rest).execute(localPlayer);
                break;
            case "Jump":
                a.default.get(i.ActionType.Jump).execute(localPlayer);
                break;
            case "Tame":
                a.default.get(i.ActionType.Tame).execute(localPlayer);
                break;
            case "Release":
                const h = localPlayer.getFacingTile();
                if (h && (p = h.creature)) {
                    const e = p.getName();
                    newui.interrupt(()=>f.default.ui(y.default.GameInterruptReleaseCreature).get(e)).withDescription(()=>f.default.ui(y.default.GameInterruptReleaseCreatureDescription).get(e)).withConfirmation().then(e=>{
                        e && a.default.get(i.ActionType.Release).execute(localPlayer)
                    }
                    )
                }
                break;
            case "Use":
                if (d) {
                    const e = t.data.actionType;
                    this.confirmAction(e, [d, e])
                }
                break;
            case "EquipLeftHand":
                if (d && s) {
                    const e = c.itemDescriptions[s];
                    e && e.equip && a.default.get(i.ActionType.Equip).execute(localPlayer, d, u.EquipType.LeftHand)
                }
                break;
            case "EquipRightHand":
                if (d && s) {
                    const e = c.itemDescriptions[s];
                    e && e.equip && a.default.get(i.ActionType.Equip).execute(localPlayer, d, u.EquipType.RightHand)
                }
                break;
            case "EquipOrUnEquip":
                if (d)
                    if (d.isEquipped())
                        a.default.get(i.ActionType.Unequip).execute(localPlayer, d);
                    else if (s) {
                        const e = c.itemDescriptions[s];
                        e && e.equip && a.default.get(i.ActionType.Equip).execute(localPlayer, d, e.equip)
                    }
                break;
            case "QuickSlotAdd":
                this.addItemToFreeQuickSlot(e);
                break;
            case "QuickSlotRemove":
                void 0 !== l && this.clearQuickSlot(l);
                break;
            case "Throw":
                d && a.default.get(i.ActionType.Throw).execute(localPlayer, d);
                break;
            case "Offer":
                d && a.default.get(i.ActionType.Offer).execute(localPlayer, d);
                break;
            case "Drop":
                d && a.default.get(i.ActionType.Drop).execute(localPlayer, d);
                break;
            case "DropAll":
                d && a.default.get(i.ActionType.Drop).execute(localPlayer, d, !0);
                break;
            case "DropAllOfSameQuality":
                d && a.default.get(i.ActionType.Drop).execute(localPlayer, d, !0, !0);
                break;
            case "MoveToOpenedContainer":
                d && this.activeContainer && a.default.get(i.ActionType.MoveItem).execute(localPlayer, d, void 0, this.activeContainer);
                break;
            case "MoveAllToOpenedContainer":
                d && this.activeContainer && a.default.get(i.ActionType.MoveItem).execute(localPlayer, void 0, localPlayer.inventory, this.activeContainer, d.type);
                break;
            case "MoveAllOfSameQualityToOpenedContainer":
                d && this.activeContainer && a.default.get(i.ActionType.MoveItem).execute(localPlayer, void 0, localPlayer.inventory, this.activeContainer, d.type, d.quality);
                break;
            case "MoveToFacingContainer":
                d && m && a.default.get(i.ActionType.MoveItem).execute(localPlayer, d, void 0, m);
                break;
            case "MoveAllToFacingContainer":
                d && m && a.default.get(i.ActionType.MoveItem).execute(localPlayer, void 0, localPlayer.inventory, m, d.type);
                break;
            case "MoveAllOfSameQualityToFacingContainer":
                d && m && a.default.get(i.ActionType.MoveItem).execute(localPlayer, void 0, localPlayer.inventory, m, d.type, d.quality);
                break;
            case "MoveToInventory":
                d && a.default.get(i.ActionType.MoveItem).execute(localPlayer, d, void 0, localPlayer.inventory);
                break;
            case "MoveAllToInventory":
                d && d.containedWithin && a.default.get(i.ActionType.MoveItem).execute(localPlayer, void 0, d.containedWithin, localPlayer.inventory, d.type);
                break;
            case "MoveAllOfSameQualityToInventory":
                d && d.containedWithin && a.default.get(i.ActionType.MoveItem).execute(localPlayer, void 0, d.containedWithin, localPlayer.inventory, d.type, d.quality);
                break;
            case "Repair":
                const g = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.Repair, e);
                g && a.default.get(i.ActionType.Repair).execute(localPlayer, g, d);
                break;
            case "Transmogrify":
                const T = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.Transmogrify);
                T && a.default.get(i.ActionType.Transmogrify).execute(localPlayer, T, d);
                break;
            case "Reinforce":
                const S = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.Reinforce);
                S && a.default.get(i.ActionType.Reinforce).execute(localPlayer, S, d);
                break;
            case "Preserve":
                const I = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.Preservative);
                I && a.default.get(i.ActionType.Preserve).execute(localPlayer, I, d);
                break;
            case "Add-Fuel":
                const v = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.Fuel);
                v && d && a.default.get(i.ActionType.AddFuel).execute(localPlayer, v, d);
                break;
            case "Ignite":
                const w = itemManager.getItemInInventoryByGroup(localPlayer, u.ItemTypeGroup.FireStarter);
                w && d && a.default.get(i.ActionType.StartFire).execute(localPlayer, w, d);
                break;
            case "Rename":
                let M, b, k, C, D, A;
                if (ui.hideActionsMenu(),
                d) {
                    M = d.renamed || "";
                    const e = d.renamed;
                    delete d.renamed,
                    b = d.getName().inContext(3),
                    k = d.getName(!1).inContext(3),
                    d.renamed = e,
                    D = y.default.GameInterruptRenameItem,
                    A = y.default.GameInterruptRenameItemDescription
                } else {
                    const e = t.data;
                    if (e instanceof r.default) {
                        M = (C = e).renamed || "";
                        const t = C.renamed;
                        delete C.renamed,
                        b = C.getName().inContext(3),
                        k = C.getName(!1).inContext(3),
                        C.renamed = t,
                        D = y.default.GameInterruptRenameDoodad,
                        A = y.default.GameInterruptRenameDoodadDescription
                    } else if (e instanceof n.default) {
                        M = (p = e).renamed || "";
                        const t = p.renamed;
                        delete p.renamed,
                        b = p.getName().inContext(3),
                        k = p.getName(!1).inContext(3),
                        p.renamed = t,
                        D = y.default.GameInterruptRenameCreature,
                        A = y.default.GameInterruptRenameCreatureDescription
                    }
                }
                const P = d || C || p;
                if (void 0 === M || void 0 === b || void 0 === A || void 0 === P)
                    break;
                newui.interrupt(()=>f.default.ui(D).get(k)).withDescription(A).setCanCancel().withInput(e=>e.setMaxLength(64).setClearTo(()=>b && b.getString() || "").setPlaceholder(f.default.generator(b && b.getString() || "")).setDefault(()=>(f.default.isSerializedTranslation(M) ? f.default.deserialize(M).getString() : M) || "")).then(e=>{
                    void 0 !== e && (e === (b && b.getString() || "") && (e = ""),
                    a.default.get(i.ActionType.Rename).execute(localPlayer, P, e))
                }
                );
                break;
            case "Disassemble":
                a.default.get(i.ActionType.Disassemble).execute(localPlayer, d);
                break;
            case "Dismantle":
                this.onDismantleItemClick(d);
                break;
            case "CloseContainer":
                a.default.get(i.ActionType.CloseContainer).execute(localPlayer, d);
                break;
            case "Hitch":
                a.default.get(i.ActionType.Hitch).execute(localPlayer);
                break;
            case "Unhitch":
                a.default.get(i.ActionType.Unhitch).execute(localPlayer);
                break;
            case "SortName":
                this.sortItems(t.data.container, u.SortType.Name, t.data.messageType);
                break;
            case "SortGroup":
                this.sortItems(t.data.container, u.SortType.Group, t.data.messageType);
                break;
            case "SortWeight":
                this.sortItems(t.data.container, u.SortType.Weight, t.data.messageType);
                break;
            case "SortRecent":
                this.sortItems(t.data.container, u.SortType.Recent, t.data.messageType);
                break;
            case "SortSkill":
                this.sortItems(t.data.container, u.SortType.Skill, t.data.messageType);
                break;
            case "SortDecay":
                this.sortItems(t.data.container, u.SortType.Decay, t.data.messageType);
                break;
            case "SortQuality":
                this.sortItems(t.data.container, u.SortType.Quality, t.data.messageType);
                break;
            case "SortDurability":
                this.sortItems(t.data.container, u.SortType.Durability, t.data.messageType);
                break;
            case "SortCategory":
                this.sortItems(t.data.container, u.SortType.Category, t.data.messageType);
                break;
            case "SortUnlockedTime":
                this.sortItems(t.data.container, u.SortType.DiscoveredTime, t.data.messageType);
                break;
            case "SortBest":
                this.sortItems(t.data.container, u.SortType.Best, t.data.messageType);
                break;
            default:
                const G = parseInt(t.action, 10);
                if (isNaN(G))
                    return x.default.warn(x.LogSource.Ui)(`Missing case for action ${t.action}`),
                    !1;
                {
                    const e = a.default.get(G);
                    if (e) {
                        const a = [localPlayer];
                        for (const n of e.action.argumentTypes)
                            switch (Array.isArray(n) ? n[0] : n) {
                            case i.ActionArgument.Doodad:
                            case i.ActionArgument.NPC:
                                a.push(t.data);
                                break;
                            default:
                                a.push(void 0)
                            }
                        e.execute.call(e, ...a)
                    } else
                        x.default.warn(x.LogSource.Ui)(`Missing action executor for ${G}`)
                }
            }
            return o || ui.playClickSound(),
            !0
        }
        updateContextMenu(e) {
            const t = [];
            for (let a = 0; a < e.actions.length; a++) {
                const i = e.actions[a];
                let n = "";
                F[a] && (n = void 0 !== i.keybind ? S.bindingManager.getBindingsTranslation(F[i.keybind]) : S.bindingManager.getBindingsTranslation(F[a]));
                let o = `<span class="context-menu-title">${n} ${i.text}</span>`;
                if (void 0 !== e.quickSlot && !isNaN(e.quickSlot)) {
                    const t = localPlayer.quickSlotInfo[e.quickSlot];
                    if (t) {
                        let e = "";
                        const n = c.itemDescriptions[t.itemType];
                        n && (!t.action && !n.use && "Throw" === i.action || !t.action && n.use && 0 === a || t.action && t.action.action === i.action && (!t.action.data || t.action.data.actionType === i.data.actionType)) && (e = " selected"),
                        o = `<span class="quick-slot-action-select${e}"></span> ${o}`
                    }
                }
                t.push({
                    title: o,
                    cmd: i.action,
                    data: i
                })
            }
            this.contextMenu = e,
            this.contextMenuOpen = !1,
            $(document).contextmenu("replaceMenu", t),
            this.contextMenuOpen = !0
        }
        async confirmAction(e, t, n=!0) {
            let o, r;
            switch (e) {
            case i.ActionType.Gather:
            case i.ActionType.Harvest:
                {
                    const t = localPlayer.options.warnOnDangerousActions ? localPlayer.checkForGatherFire() : void 0
                      , a = localPlayer.checkForGather();
                    void 0 !== t ? (o = f.default.ui(y.default.GameInterruptConfirmationActionOnFire).addArgs(t, f.default.message(e === i.ActionType.Harvest ? h.default.Harvest : h.default.Gather)),
                    r = f.default.ui(y.default.GameInterruptConfirmationActionOnFireDescription).addArgs(t, f.default.message(e === i.ActionType.Harvest ? h.default.Harvest : h.default.Gather))) : void 0 !== a && (o = f.default.ui(y.default.GameInterruptConfirmationDestroyOnGather).inContext(4).addArgs(f.default.message(h.default.The).addArgs(a.getName(!1))),
                    r = f.default.ui(y.default.GameInterruptConfirmationDestroyOnGatherDescription).inContext(4).addArgs(f.default.message(h.default.The).addArgs(a.getName(!1))));
                    break
                }
            case i.ActionType.Pour:
                {
                    const e = t[0];
                    !itemManager.isInGroup(e.type, u.ItemTypeGroup.ContainerOfSeawater) && localPlayer.checkForStill() && (o = y.default.GameInterruptDesalinationNoNeed,
                    r = y.default.GameInterruptDesalinationNoNeedDescription),
                    itemManager.isInGroup(e.type, u.ItemTypeGroup.ContainerOfSeawater) && localPlayer.checkForWell() && (o = y.default.GameInterruptWellConvert,
                    r = y.default.GameInterruptWellConvertDescription);
                    break
                }
            case i.ActionType.Heal:
            case i.ActionType.HealOther:
                {
                    let t, a;
                    if (e === i.ActionType.Heal)
                        t = localPlayer.getStat(l.Stat.Health),
                        a = localPlayer;
                    else {
                        const e = localPlayer.getFacingTile();
                        if (!e)
                            break;
                        const i = e.creature
                          , n = e.npc
                          , o = game.getPlayersAtTile(e);
                        if (!(a = o && o.length > 0 ? o[0] : i || n))
                            break;
                        t = a.getStat(l.Stat.Health)
                    }
                    if (t.value < t.max || a.hasStatus(u.StatusType.Bleeding))
                        break;
                    o = y.default.GameInterruptNoHealingRequired,
                    r = y.default.GameInterruptNoHealingRequiredDescription;
                    break
                }
            }
            if (o) {
                const e = await newui.interrupt(o).withDescription(r).withConfirmation();
                if (!e)
                    return
            }
            n && e !== i.ActionType.Sling && e !== i.ActionType.Shoot && e !== i.ActionType.Fire && (n = !1,
            t.pop()),
            a.default.get(n ? i.ActionType.UseItem : e).execute(localPlayer, ...t)
        }
        isOverlayVisible() {
            return newui.isScreenVisible(v.ScreenId.Interrupt)
        }
        getHoveredItem(e) {
            const t = document.elementFromPoint(e.mouseX, e.mouseY);
            return t && t.matches("\n\t\t\t\t.ui-dialog:not([style*='display: none']):not([aria-describedby='crafting']) li.item,\n\t\t\t\t.quick-slot li.item\n\t\t\t") ? t : null
        }
        quickSlotBindPressed(e, t, a) {
            return this.delayState = _.WaitingForDelay,
            this.useQuickSlot(t)
        }
        quickSlotToggleBindPressed(e, t, a, i, n) {
            if (t && n) {
                const e = game.items[$(t).data("item-id")];
                return e && e.quickSlot !== a ? (this.setQuickSlot(a, e.id),
                this.canUseQuickslot = !1) : this.clearQuickSlot(a, !0),
                !0
            }
            return !1
        }
        determineSort(e, t, a, i, n) {
            if (void 0 === a || void 0 === n)
                return 0;
            let o = 0
              , r = 0;
            const s = void 0 !== t ? game.items[t] : void 0
              , l = void 0 !== i ? game.items[i] : void 0;
            switch (e.sortType) {
            case u.SortType.Name:
                o = s && s.renamed ? s.renamed : (u.ItemType[a] || f.default.message(h.default.Unknown).getString()).toString(),
                r = l && l.renamed ? l.renamed : (u.ItemType[n] || f.default.message(h.default.Unknown).getString()).toString();
                break;
            case u.SortType.Group:
                const t = itemManager.getGroups(a).collect(R.default.first());
                o = t ? new f.default(m.Dictionary.ItemGroup,t).getString() : "z";
                const i = itemManager.getGroups(n).collect(R.default.first());
                r = i ? new f.default(m.Dictionary.ItemGroup,i).getString() : "z";
                break;
            case u.SortType.Weight:
                s && (o = s.legendary && s.legendary.type === u.LegendaryType.ItemWeight ? s.weight - s.legendary.value : s.weight),
                l && (r = l.legendary && l.legendary.type === u.LegendaryType.ItemWeight ? l.weight - l.legendary.value : l.weight);
                break;
            case u.SortType.Recent:
                s && s.containedWithin && (o = s.containedWithin.containedItems.indexOf(s)),
                l && l.containedWithin && (r = l.containedWithin.containedItems.indexOf(l));
                break;
            case u.SortType.Decay:
                if (o = 0,
                r = 0,
                s && void 0 !== s.decay) {
                    const e = c.itemDescriptions[s.type];
                    e && e.decayMax && (o = s.decay)
                }
                if (l && void 0 !== l.decay) {
                    const e = c.itemDescriptions[l.type];
                    e && e.decayMax && (r = l.decay)
                }
                break;
            case u.SortType.Quality:
                s && (o = u.itemQualitySortOrder[s.quality || u.ItemQuality.None]),
                l && (r = u.itemQualitySortOrder[l.quality || u.ItemQuality.None]);
                break;
            case u.SortType.Durability:
                s && (o = s.minDur),
                l && (r = l.minDur);
                break;
            case u.SortType.DiscoveredTime:
                const d = game.crafted[a];
                d && (o = d.unlockTime);
                const p = game.crafted[n];
                p && (r = p.unlockTime);
                break;
            case u.SortType.Best:
                s && (o = 4 * u.itemQualitySortOrder[s.quality || u.ItemQuality.None] + (s.minDur ? s.minDur / 4 : 0) - 10 * (s.legendary && s.legendary.type === u.LegendaryType.ItemWeight ? s.weight - s.legendary.value : s.weight)),
                l && (r = 4 * u.itemQualitySortOrder[l.quality || u.ItemQuality.None] + (l.minDur ? l.minDur / 4 : 0) - 10 * (l.legendary && l.legendary.type === u.LegendaryType.ItemWeight ? l.weight - l.legendary.value : l.weight))
            }
            o === r && e.sortType !== u.SortType.Name && (o = s && s.renamed ? s.renamed : (u.ItemType[a] || f.default.message(h.default.Unknown).getString()).toString(),
            r = l && l.renamed ? l.renamed : (u.ItemType[n] || f.default.message(h.default.Unknown).getString()).toString()),
            o === r && (o = t,
            r = i);
            let d = e.reverse;
            return e.sortType !== u.SortType.Skill && e.sortType !== u.SortType.Category || (d = !1),
            (d ? r > o : o > r) ? 1 : -1
        }
    }
    __decorate([Override], H.prototype, "selector", null),
    __decorate([Override], H.prototype, "bindElements", null),
    __decorate([Override], H.prototype, "unbindElements", null),
    __decorate([Override], H.prototype, "onShow", null),
    __decorate([E.Bound], H.prototype, "makeTopDialog", null),
    __decorate([Override], H.prototype, "onHide", null),
    __decorate([Override], H.prototype, "onMouseMove", null),
    __decorate([E.Bound], H.prototype, "focus", null),
    t.default = H
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/BindingManager", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/UiTranslation", "language/Translation", "mod/IHookManager", "utilities/Async", "utilities/Emitter", "utilities/enum/Enums", "utilities/Log", "utilities/math/Vector2"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    var c;
    function m(e) {
        return e.preventDefault(),
        e.stopPropagation(),
        !1
    }
    function h(e, t) {
        const a = e.modifiers || []
          , i = t.modifiers || [];
        return e.key === t.key && e.mouseButton === t.mouseButton && e.gamepadButton === t.gamepadButton && typeof a == typeof i && (!a || a.length === i.length && void 0 === a.find(e=>!i.includes(e)))
    }
    function y(e) {
        if (e instanceof KeyboardEvent)
            return isEdge && void 0 === e.code && e.key && 1 === e.key.length ? `Key${e.key.toLocaleUpperCase()}` : e.code || e.key;
        if (e instanceof WheelEvent)
            return `Mouse${e.deltaY < 0 ? "Up" : "Down"}`;
        if (e instanceof MouseEvent)
            return `Mouse${e.button}`;
        if (e instanceof TouchEvent)
            return "Mouse0";
        if (e instanceof Event)
            return "Unknown";
        if ("number" != typeof e)
            return e.key || void 0 !== e.mouseButton && `Mouse${e.mouseButton}` || "Unknown";
        switch (e) {
        case c.Alt:
            return "Alt";
        case c.Shift:
            return "Shift";
        case c.Control:
            return "Control";
        default:
            return "Unknown"
        }
    }
    function g(e, t) {
        for (let a = t; a; a = a.parentElement)
            if (e === a)
                return !0;
        return !1
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Shift = 0] = "Shift",
        e[e.Alt = 1] = "Alt",
        e[e.Control = 2] = "Control"
    }(c = t.KeyModifier || (t.KeyModifier = {}));
    class f extends l.default {
        constructor() {
            super(),
            this.bindCatchers = {},
            document.body.addEventListener("contextmenu", e=>{
                if (!saveDataGlobal.options.developerMode || !saveDataGlobal.options.developerModeContextMenu)
                    return m(e)
            }
            ),
            document.body.addEventListener("onselectstart", m)
        }
        registerBindable(e, t) {
            f.defaultBinds[e] = t
        }
        deregisterBindable(e) {
            delete f.defaultBinds[e]
        }
        getBindableType(e) {
            const t = a.Bindable[e];
            for (const e of u.default.keys(a.BindableType))
                if (t.startsWith(e))
                    return a.BindableType[e]
        }
        getBinding(e) {
            return a.Bindable[e]in saveDataGlobal.options.bindings ? saveDataGlobal.options.bindings[a.Bindable[e]] : f.defaultBinds[e]
        }
        getBindings(e) {
            const t = this.getBinding(e);
            return Array.isArray(t) ? t : [t]
        }
        addBinding(e, t) {
            if (!(a.Bindable[e]in saveDataGlobal.options.bindings)) {
                const t = f.defaultBinds[e];
                saveDataGlobal.options.bindings[a.Bindable[e]] = Array.isArray(t) ? [...t] : t
            }
            Array.isArray(saveDataGlobal.options.bindings[a.Bindable[e]]) || (saveDataGlobal.options.bindings[a.Bindable[e]] = [saveDataGlobal.options.bindings[a.Bindable[e]]]);
            const i = saveDataGlobal.options.bindings[a.Bindable[e]];
            void 0 === i.find(e=>h(t, e)) && i.push(t)
        }
        setBinding(e, t) {
            saveDataGlobal.options.bindings[a.Bindable[e]] = t
        }
        deleteBinding(e) {
            saveDataGlobal.options.bindings[a.Bindable[e]] = []
        }
        resetBinding(e) {
            delete saveDataGlobal.options.bindings[a.Bindable[e]]
        }
        doBindsIntersect(e, t) {
            const a = this.getBindings(e)
              , i = this.getBindings(t);
            return a.some(e=>i.some(t=>h(e, t)))
        }
        getBindingsTranslation(e, t=!1) {
            "number" == typeof e && (e = this.getBinding(e)),
            Array.isArray(e) || (e = [e]);
            const a = [];
            for (const t of e) {
                let e = "";
                for (const a of t.modifiers || [])
                    e += o.default.ui(n.default.MenuOptionsBindLabelModifier).getString(this.getBindPressTranslation(`Modifier${c[a]}`));
                if ("key"in t) {
                    const a = this.getBindPressTranslation(t.key);
                    e += a.isValid ? a.getString() : t.key
                } else
                    "mouseButton"in t ? e += this.getBindPressTranslation(`Mouse${t.mouseButton}`).getString() : d.default.warn(d.LogSource.NewUi)("Unknown button");
                a.push(e)
            }
            return t ? a : a ? a.length <= 1 ? a.length ? a[0] : o.default.ui(n.default.MiscBindableNoBindings).getString() : a.reduce((e,t)=>`${o.default.ui(n.default.MiscBindableOr).getString(e)}${t}`) : ""
        }
        registerBindCatcher(e, t=!1) {
            const a = {}
              , i = p.default.ZERO;
            let n = 0;
            const o = {
                enabled: !0,
                element: e,
                states: a,
                mouse: i,
                mouseStart: void 0,
                mouseStartElement: void 0,
                async handler(o) {
                    if ("visibilitychange" === o.type || "blur" === o.type) {
                        if ("hidden" === document.visibilityState || "blur" === o.type)
                            for (const e of Object.keys(a))
                                delete a[e];
                        return
                    }
                    const r = o.target;
                    if ("mousemove" !== o.type && "mouseup" !== o.type && "keyup" !== o.type && "touchmove" !== o.type && "touchend" !== o.type && r.matches("[intercept='all'], [intercept='all'] *") && !r.matches("[intercept='none'], [intercept='none'] *, [intercept-children='none'] *"))
                        return !0;
                    const l = y(o);
                    switch (o.type) {
                    case "keydown":
                    case "mousedown":
                    case "touchstart":
                        if (t && e.focus(),
                        a[l] = Date.now(),
                        "F12" === l && saveDataGlobal.options.developerMode && !steamworks.isElectron())
                            return;
                        if ("F11" === l && !steamworks.isElectron())
                            return;
                        if ("mousedown" === o.type) {
                            const e = o;
                            this.mouseStart = new p.default(e.clientX,e.clientY),
                            this.mouseStartElement = o.target
                        } else if ("touchstart" === o.type) {
                            const e = o;
                            this.mouseStart = new p.default(e.touches[0].clientX,e.touches[0].clientY),
                            this.mouseStartElement = o.target
                        }
                        break;
                    case "keyup":
                        delete a[l];
                        break;
                    case "mouseup":
                    case "touchend":
                        return delete a[l],
                        this.mouseStart = void 0,
                        void (this.mouseStartElement = void 0);
                    case "mouseleave":
                        return delete a.Mouse0,
                        delete a.Mouse1,
                        void delete a.Mouse2;
                    case "wheel":
                        let r = o.deltaY;
                        if (0 === o.deltaMode && (r /= -120),
                        n += r,
                        Math.abs(n) > .8) {
                            n = 0;
                            const e = a[l] = Date.now();
                            s.sleep(50).then(()=>{
                                a[l] === e && delete a[l]
                            }
                            )
                        }
                        return;
                    case "mousemove":
                        {
                            const e = o;
                            return i.x = e.clientX,
                            void (i.y = e.clientY)
                        }
                    case "touchmove":
                        {
                            const e = o;
                            return i.x = e.touches[0].clientX,
                            void (i.y = e.touches[0].clientY)
                        }
                    default:
                        d.default.warn(d.LogSource.NewUi)("Unknown event", o.type)
                    }
                    return o.preventDefault(),
                    o.stopPropagation(),
                    !1
                }
            };
            let r;
            o.handler = o.handler.bind(o),
            e.addEventListener("mousemove", o.handler),
            e.addEventListener("mouseleave", o.handler),
            e.addEventListener("mousedown", o.handler),
            e.addEventListener("mouseup", o.handler),
            e.addEventListener("keydown", o.handler),
            e.addEventListener("keyup", o.handler),
            e.addEventListener("wheel", o.handler),
            e.addEventListener("touchstart", o.handler),
            e.addEventListener("touchend", o.handler),
            e.addEventListener("touchmove", o.handler),
            document.addEventListener("visibilitychange", o.handler),
            window.addEventListener("blur", o.handler);
            do {
                r = Math.random()
            } while (r in this.bindCatchers);return this.bindCatchers[r] = o,
            this.setDefaultBindCatcher(r),
            this.startLoop(),
            r
        }
        deregisterBindCatcher(e) {
            const t = this.bindCatchers[e];
            t && (t.element.removeEventListener("mousemove", t.handler),
            t.element.removeEventListener("mouseleave", t.handler),
            t.element.removeEventListener("mousedown", t.handler),
            t.element.removeEventListener("mouseup", t.handler),
            t.element.removeEventListener("keydown", t.handler),
            t.element.removeEventListener("keyup", t.handler),
            t.element.removeEventListener("wheel", t.handler),
            t.element.removeEventListener("touchstart", t.handler),
            t.element.removeEventListener("touchend", t.handler),
            t.element.removeEventListener("touchmove", t.handler),
            document.removeEventListener("visibilitychange", t.handler),
            window.removeEventListener("blur", t.handler),
            delete this.bindCatchers[e])
        }
        disableBindsUntil(e, t=this.defaultBindCatcher) {
            this.bindCatchers[t].enabled = !1,
            "number" == typeof e && (e = s.sleep(e)),
            e.then(()=>{
                this.bindCatchers[t].enabled = !0,
                this.emit("BindsEnabled")
            }
            )
        }
        areBindsDisabled(e=this.defaultBindCatcher) {
            return !this.bindCatchers[e].enabled
        }
        setDefaultBindCatcher(e) {
            this.defaultBindCatcher = e
        }
        getPressTime(e, t=this.defaultBindCatcher) {
            if (void 0 === t || !this.bindCatchers[t].enabled)
                return -1;
            const a = this.bindCatchers[t].states
              , i = "string" == typeof e ? void 0 : this.getBindings(e);
            for (const n in a)
                if (i)
                    for (const e of i)
                        try {
                            if (n === y(e) && this.checkModifiers(e.modifiers || [], n, t))
                                return a[n]
                        } catch (t) {
                            throw d.default.error(d.LogSource.BindingManager)(n, e, i),
                            t
                        }
                else if (n === e)
                    return a[n];
            return -1
        }
        removePressState(e, t=this.defaultBindCatcher) {
            if (void 0 !== t) {
                const a = this.bindCatchers[t].states
                  , i = "string" == typeof e ? void 0 : this.getBindings(e);
                for (const n in a)
                    if (i)
                        for (const e of i)
                            n === y(e) && this.checkModifiers(e.modifiers || [], n, t) && delete a[n];
                    else
                        n === e && delete a[n]
            }
        }
        removeAllPressStates(e=this.defaultBindCatcher) {
            if (void 0 !== e) {
                const t = this.bindCatchers[e].states;
                for (const e in t)
                    delete t[e]
            }
        }
        checkModifiers(e, t, a=this.defaultBindCatcher) {
            if (void 0 !== a) {
                const i = this.bindCatchers[a].states;
                for (const a of u.default.values(c)) {
                    const n = e.includes(a)
                      , o = y(a);
                    let r = !1;
                    for (const e of [`${o}Left`, `${o}Right`])
                        t !== e && !r && i[e] && (r = !0);
                    if (n !== r)
                        return !1
                }
            }
            return !0
        }
        isPressed(e, t=this.defaultBindCatcher) {
            return -1 !== this.getPressTime(e, t)
        }
        isAnythingPressed(e=this.defaultBindCatcher) {
            const t = this.bindCatchers[e];
            if (!t)
                return !1;
            if (!t.enabled)
                return !1;
            for (const e in t.states)
                if (t.states[e])
                    return !0;
            return !1
        }
        getMouse(e=this.defaultBindCatcher) {
            return this.bindCatchers[e].mouse
        }
        isMouseWithin(e, t=!1, a=this.defaultBindCatcher) {
            const i = this.bindCatchers[a];
            if (!i)
                return !1;
            const n = document.elementFromPoint(i.mouse.x, i.mouse.y);
            return "element"in e && (e = e.element),
            e === n || !t && g(e, n)
        }
        mouseStartWasWithin(e, t=!1, a=this.defaultBindCatcher) {
            const i = this.bindCatchers[a];
            if (!i)
                return !1;
            const n = i.mouseStartElement;
            return "element"in e && (e = e.element),
            e === n || !t && g(e, n)
        }
        manualLoop(e) {
            const t = {}
              , i = {}
              , n = this.bindCatchers
              , o = {
                time: 0,
                wasPressed: a=>{
                    if (t[a] === o.time)
                        return !0;
                    const n = this.getPressTime(a, e);
                    if (-1 === n)
                        t[a] && (i[a] = o.time,
                        delete t[a]);
                    else if (!t[a])
                        return t[a] = o.time,
                        delete i[a],
                        !0;
                    return !1
                }
                ,
                wasReleased: e=>i[e] === o.time,
                removePressState: (a,n=!0)=>{
                    i[a] = o.time,
                    delete t[a],
                    n && this.removePressState(a, e)
                }
                ,
                removeAllPressStates: (e=!0)=>{
                    for (const a in t)
                        o.removePressState(a, e)
                }
                ,
                isDown: t=>this.isPressed(t, e),
                isAnythingDown: ()=>this.isAnythingPressed(e),
                timeDown: t=>this.getPressTime(t, e),
                get mouseX() {
                    return n[e].mouse.x
                },
                get mouseY() {
                    return n[e].mouse.y
                },
                get mousePosition() {
                    return new p.default(n[e].mouse)
                },
                isMouseWithin: (t,a)=>this.isMouseWithin(t, a, e),
                mouseStartWasWithin: (t,a)=>this.mouseStartWasWithin(t, a, e)
            };
            return ()=>((!document.activeElement || document.activeElement.classList.contains("hidden") || null === document.activeElement.offsetParent && !document.activeElement.classList.contains("no-offset-parent")) && n[e].element.focus(),
            o.time = Date.now(),
            o.wasPressed(a.Bindable.GameFullscreen) && steamworks.isElectron() ? newui.toggleFullscreen() : o.wasPressed(a.Bindable.DeveloperToggleDeveloperMode) ? saveDataGlobal.options.developerMode = !saveDataGlobal.options.developerMode : saveDataGlobal.options.developerMode && (o.wasPressed(a.Bindable.DeveloperReloadGame) || o.wasPressed(a.Bindable.DeveloperReloadAndContinueGame) ? (o.wasPressed(a.Bindable.DeveloperReloadAndContinueGame) && (saveDataGlobal.options.shouldLoadLastSave = !0),
            steamworks.reload()) : o.wasPressed(a.Bindable.DeveloperToggleDeveloperTools) && steamworks.isElectron() && steamworks.toggleDeveloperTools()),
            o)
        }
        startLoop() {
            const e = this.defaultBindCatcher;
            this.bindCatchers[e].loop = this.manualLoop(e);
            const t = this.bindCatchers[e];
            if (t) {
                const i = ()=>{
                    if (t.loop) {
                        const n = t.loop();
                        try {
                            const t = modManager.getHook(r.Hook.OnBindLoop).call(a.Bindable.None, n);
                            ui.isInGameScreenShown() && ui.screenInGame.onBindLoop(n, t)
                        } catch (t) {
                            d.default.error(d.LogSource.BindingManager)(`An error occured in bind loop '${e}'`, t)
                        }
                        requestAnimationFrame(i)
                    }
                }
                ;
                i()
            }
        }
        getBindPressTranslation(e) {
            return new o.default(i.Dictionary.BindPress,e).setFailWith(e)
        }
    }
    f.defaultBinds = {
        [a.Bindable.GameMoveDirection]: {
            mouseButton: 0
        },
        [a.Bindable.GameMoveToTile]: [{
            mouseButton: 0,
            modifiers: [c.Control]
        }, {
            mouseButton: 1
        }],
        [a.Bindable.GameMoveToTilePreview]: {
            key: "ControlLeft"
        },
        [a.Bindable.GameMoveUp]: {
            key: "KeyW"
        },
        [a.Bindable.GameMoveLeft]: {
            key: "KeyA"
        },
        [a.Bindable.GameMoveDown]: {
            key: "KeyS"
        },
        [a.Bindable.GameMoveRight]: {
            key: "KeyD"
        },
        [a.Bindable.GameFaceDirection]: {
            mouseButton: 0,
            modifiers: [c.Shift]
        },
        [a.Bindable.GameFaceUp]: {
            key: "KeyW",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameFaceLeft]: {
            key: "KeyA",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameFaceDown]: {
            key: "KeyS",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameFaceRight]: {
            key: "KeyD",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameIdle]: {
            key: "Space"
        },
        [a.Bindable.GameHandToggleLeft]: {
            key: "BracketLeft"
        },
        [a.Bindable.GameHandToggleRight]: {
            key: "BracketRight"
        },
        [a.Bindable.GameQuickSlot1]: {
            key: "Digit1"
        },
        [a.Bindable.GameQuickSlot2]: {
            key: "Digit2"
        },
        [a.Bindable.GameQuickSlot3]: {
            key: "Digit3"
        },
        [a.Bindable.GameQuickSlot4]: {
            key: "Digit4"
        },
        [a.Bindable.GameQuickSlot5]: {
            key: "Digit5"
        },
        [a.Bindable.GameQuickSlot6]: {
            key: "Digit6"
        },
        [a.Bindable.GameQuickSlot7]: {
            key: "Digit7"
        },
        [a.Bindable.GameQuickSlot8]: {
            key: "Digit8"
        },
        [a.Bindable.GameQuickSlot9]: {
            key: "Digit9"
        },
        [a.Bindable.GameQuickSlotToggle1]: {
            key: "Digit1",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameQuickSlotToggle2]: {
            key: "Digit2",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameQuickSlotToggle3]: {
            key: "Digit3",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameQuickSlotToggle4]: {
            key: "Digit4",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameQuickSlotToggle5]: {
            key: "Digit5",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameQuickSlotToggle6]: {
            key: "Digit6",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameQuickSlotToggle7]: {
            key: "Digit7",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameQuickSlotToggle8]: {
            key: "Digit8",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameQuickSlotToggle9]: {
            key: "Digit9",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameQuickSlot9]: {
            key: "Digit9"
        },
        [a.Bindable.GameQuickSlotClear]: {
            key: "KeyX"
        },
        [a.Bindable.GameContextMenu1]: {
            key: "Digit1"
        },
        [a.Bindable.GameContextMenu2]: {
            key: "Digit2"
        },
        [a.Bindable.GameContextMenu3]: {
            key: "Digit3"
        },
        [a.Bindable.GameContextMenu4]: {
            key: "Digit4"
        },
        [a.Bindable.GameContextMenu5]: {
            key: "Digit5"
        },
        [a.Bindable.GameContextMenu6]: {
            key: "Digit6"
        },
        [a.Bindable.GameContextMenu7]: {
            key: "Digit7"
        },
        [a.Bindable.GameContextMenu8]: {
            key: "Digit8"
        },
        [a.Bindable.GameContextMenu9]: {
            key: "Digit9"
        },
        [a.Bindable.GameContextMenu10]: {
            key: "Digit0"
        },
        [a.Bindable.GameContextMenu11]: {
            key: "Minus"
        },
        [a.Bindable.GameContextMenu12]: {
            key: "Equal"
        },
        [a.Bindable.GameContextMenu13]: {
            key: "Digit1",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu14]: {
            key: "Digit2",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu15]: {
            key: "Digit3",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu16]: {
            key: "Digit4",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu17]: {
            key: "Digit5",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu18]: {
            key: "Digit6",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu19]: {
            key: "Digit7",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu20]: {
            key: "Digit8",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu21]: {
            key: "Digit9",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu22]: {
            key: "Digit0",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu23]: {
            key: "Minus",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameContextMenu24]: {
            key: "Equal",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameActions]: [{
            key: "KeyQ"
        }, {
            mouseButton: 2
        }],
        [a.Bindable.GameZoomIn]: {
            mouseButton: "Up"
        },
        [a.Bindable.GameZoomOut]: {
            mouseButton: "Down"
        },
        [a.Bindable.GameItemMove]: {
            mouseButton: 0
        },
        [a.Bindable.GameItemQuickMove]: {
            mouseButton: 0,
            modifiers: [c.Shift]
        },
        [a.Bindable.GameItemQuickMoveAll]: {
            mouseButton: 0,
            modifiers: [c.Shift, c.Control]
        },
        [a.Bindable.GameItemMenu]: {
            mouseButton: 2
        },
        [a.Bindable.GameItemDrop]: [{
            mouseButton: 2,
            modifiers: [c.Shift]
        }, {
            key: "KeyQ"
        }],
        [a.Bindable.GameItemDropAll]: {
            key: "KeyQ",
            modifiers: [c.Shift]
        },
        [a.Bindable.GameItemEquipToggle]: {
            key: "KeyE"
        },
        [a.Bindable.GameInspect]: {
            mouseButton: 2,
            modifiers: [c.Shift]
        },
        [a.Bindable.GameMoreInformation]: [{
            key: "ShiftLeft"
        }, {
            key: "ShiftRight"
        }],
        [a.Bindable.GameScreenshotMode]: {
            key: "F2"
        },
        [a.Bindable.GamePause]: {
            key: "Escape"
        },
        [a.Bindable.GameSave]: {
            key: "KeyS",
            modifiers: [c.Control]
        },
        [a.Bindable.GameFullscreen]: {
            key: "F11"
        },
        [a.Bindable.DialogCloseAll]: {
            key: "Backquote"
        },
        [a.Bindable.DialogInventory]: {
            key: "KeyI"
        },
        [a.Bindable.DialogNotes]: {
            key: "KeyN"
        },
        [a.Bindable.DialogHelp]: [{
            key: "Slash"
        }, {
            key: "F1"
        }],
        [a.Bindable.DialogSkills]: {
            key: "KeyV"
        },
        [a.Bindable.DialogMessages]: {
            key: "KeyM"
        },
        [a.Bindable.DialogOptions]: {
            key: "KeyO"
        },
        [a.Bindable.DialogEquipment]: {
            key: "KeyE"
        },
        [a.Bindable.DialogCrafting]: {
            key: "KeyC"
        },
        [a.Bindable.DialogDismantle]: {
            key: "KeyX"
        },
        [a.Bindable.DialogMilestones]: {
            key: "KeyZ"
        },
        [a.Bindable.DialogQuests]: {
            key: "KeyU"
        },
        [a.Bindable.DialogMessagesChatFocus]: {
            key: "Enter"
        },
        [a.Bindable.MenuEnter]: [{
            key: "Enter"
        }, {
            key: "Space"
        }],
        [a.Bindable.MenuCancel]: [{
            key: "Escape"
        }, {
            key: "Backspace"
        }],
        [a.Bindable.MenuNext]: {
            key: "Tab"
        },
        [a.Bindable.MenuPrevious]: {
            key: "Tab",
            modifiers: [c.Shift]
        },
        [a.Bindable.MenuLeft]: {
            key: "ArrowLeft"
        },
        [a.Bindable.MenuRight]: {
            key: "ArrowRight"
        },
        [a.Bindable.MenuUp]: {
            key: "ArrowUp"
        },
        [a.Bindable.MenuDown]: {
            key: "ArrowDown"
        },
        [a.Bindable.MenuContextMenu]: {
            mouseButton: 2
        },
        [a.Bindable.DeveloperToggleDeveloperMode]: {
            key: "F9"
        },
        [a.Bindable.DeveloperReloadGame]: {
            key: "F5"
        },
        [a.Bindable.DeveloperReloadAndContinueGame]: {
            key: "F5",
            modifiers: [c.Control]
        },
        [a.Bindable.DeveloperToggleDeveloperTools]: {
            key: "F10"
        }
    },
    t.BindingManager = f,
    t.bindingManager = new f,
    window.bindingManager = t.bindingManager
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/component/SelectionHandler", ["require", "exports", "Enums", "newui/component/IComponent", "newui/INewUi", "newui/screen/screens/menu/component/Menu"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r {
        constructor(e, t) {
            this.api = e,
            this.menu = t
        }
        select(e) {
            e.classList.contains("selectable") && (this.selection = e,
            e.focus())
        }
        getSelection() {
            return this.selection
        }
        selectNext(e=!0) {
            this.changeSelection(1, void 0, e)
        }
        selectPrevious(e=!0) {
            this.changeSelection(-1, void 0, e)
        }
        handleBindLoop(e, t) {
            if (this.selection && (this.selection.classList.contains("hidden") || null === this.selection.offsetParent) && this.selectNext(!1),
            t.wasPressed(a.Bindable.MenuNext) && !e && (this.selectNext(),
            e = a.Bindable.MenuNext),
            t.wasPressed(a.Bindable.MenuPrevious) && !e && (this.selectPrevious(),
            e = a.Bindable.MenuPrevious),
            t.wasPressed(a.Bindable.MenuUp) && !e && (this.selectUp(),
            e = a.Bindable.MenuUp),
            t.wasPressed(a.Bindable.MenuDown) && !e && (this.selectDown(),
            e = a.Bindable.MenuDown),
            t.wasPressed(a.Bindable.MenuLeft) && !e && (this.selectLeft(),
            e = a.Bindable.MenuLeft),
            t.wasPressed(a.Bindable.MenuRight) && !e && (this.selectRight(),
            e = a.Bindable.MenuRight),
            t.wasPressed(a.Bindable.MenuEnter) && !e && (e = a.Bindable.MenuEnter,
            t.removePressState(a.Bindable.MenuEnter),
            this.selectEnter() || this.menu.emit(o.MenuEvent.EnterBind)),
            t.wasPressed(a.Bindable.MenuCancel) && (!0 === this.menu.canCancel || !1 !== this.menu.canCancel && this.menu.isSubmenu && (!this.selection || +this.selection.dataset.selectableLayer < i.SelectableLayer.Quaternary)) && !e && !steamworks.isDedicatedServer()) {
                const i = this.menu.emit(o.MenuEvent.CancelBind);
                i.includes(!1) || this.api.getVisibleScreen().backOneMenu(),
                this.api.playActivateSound(),
                e = a.Bindable.MenuCancel,
                t.removePressState(a.Bindable.MenuCancel)
            }
            return e
        }
        getSelectables() {
            return [...this.menu.element.getElementsByClassName("selectable")]
        }
        changeSelection(e, t=!1, a=!0) {
            if (a && this.api.playSelectSound(),
            !t && this.selection && !this.selection.classList.contains("hidden") && null !== this.selection.offsetParent && !this.selection.matches(".nonselectable *") && document.activeElement !== this.selection)
                return void this.selection.focus();
            const i = !this.selection || this.selection.classList.contains("selectable-primary")
              , n = this.getSelectables();
            let o = n.indexOf(this.selection)
              , r = 0;
            do {
                r++,
                (o += e) < 0 ? o += n.length : o > n.length - 1 && (o -= n.length),
                this.selection = n[o]
            } while ((this.selection.classList.contains("disabled") || null === this.selection.offsetParent || this.selection.classList.contains(i ? "selectable-secondary" : "selectable-primary")) && r < 1e4);this.selection.focus()
        }
        selectUp() {
            this.selectDirection(n.SelectDirection.Up)
        }
        selectDown() {
            this.selectDirection(n.SelectDirection.Down)
        }
        selectLeft() {
            this.selectDirection(n.SelectDirection.Left, 100, !0, 7)
        }
        selectRight() {
            this.selectDirection(n.SelectDirection.Right, 100, !0, 7)
        }
        selectDirection(e, t=1e3, a=!1, i=.15) {
            if (this.api.playSelectSound(),
            this.selection && !this.selection.classList.contains("hidden") && null !== this.selection.offsetParent && !this.selection.matches(".nonselectable *") && document.activeElement !== this.selection)
                return void this.selection.focus();
            if ((!this.selection && e === n.SelectDirection.Left || e === n.SelectDirection.Right) && (this.selectNext(!1),
            e === n.SelectDirection.Right))
                return;
            const o = this.selection ? this.selection.getBoundingClientRect() : {
                top: 0,
                left: 0
            }
              , r = this.selection ? +this.selection.dataset.selectableLayer : 0;
            let s;
            !a && this.selection && (a = this.selection.classList.contains("selectable-escapeable"));
            let l = 0, u = 0, d, p = 0, c = 0;
            for (const n of this.getSelectables()) {
                if (null === n.offsetParent || n.classList.contains("disabled") || n === this.selection || n.matches(".nonselectable *"))
                    continue;
                if (!a && +n.dataset.selectableLayer !== r)
                    continue;
                const m = n.getBoundingClientRect();
                let h = m.top - o.top
                  , y = m.left - o.left;
                2 === Math.abs(e) && ([h,y] = [y, h]);
                const g = Math.abs(h) + Math.abs(y) * i;
                Math.abs(y) > t || (Math.sign(h) !== Math.sign(e) || void 0 !== s && !(0 !== i ? g < l : Math.abs(h) < l || Math.abs(h) === l && Math.abs(y) < u) || (s = n,
                l = 0 !== i ? g : Math.abs(h),
                u = Math.abs(y)),
                Math.sign(h) !== -1 * Math.sign(e) || void 0 !== d && !(0 !== i ? g > p : Math.abs(h) > p || Math.abs(h) === p && Math.abs(y) < c) || (d = n,
                p = 0 !== i ? g : Math.abs(h),
                c = Math.abs(y)))
            }
            this.selection = s || d || this.selection,
            this.selection && this.selection.focus()
        }
        selectEnter() {
            return !(!this.selection || document.activeElement !== this.selection) && (this.selection.dispatchEvent(new Event("activate")),
            !0)
        }
    }
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/menu/component/Menu", ["require", "exports", "mod/IHookHost", "newui/BindingManager", "newui/component/BlockRow", "newui/component/Button", "newui/component/Component", "newui/component/Text", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/SelectionHandler", "newui/util/Misc", "utilities/iterable/Collectors", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    var h, y;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e.Tab = "Tab",
        e.GoBackFrom = "GoBackFrom",
        e.CancelBind = "CancelBind",
        e.EnterBind = "EnterBind"
    }(h = t.MenuEvent || (t.MenuEvent = {}));
    class g extends r.default {
        constructor(e, t) {
            super(e),
            this.tabs = new Map,
            this.classes.add("menu", "hidden"),
            this.menuId = t,
            this.dataset.menuId = "string" == typeof t ? t : l.MenuId[t],
            new n.BlockRow(this.api).classes.add("menu-clearbg", "menu-title-row").append(new o.default(this.api).classes.add("button-back", "has-icon-before", "icon-center", "icon-no-scale").on(o.ButtonEvent.Activate, d.menuSwitcher(l.MenuId.BACK)), new r.default(this.api).append(this.title = new s.Heading(this.api).classes.add("menu-title"), this.description = new s.default(this.api))).schedule(e=>{
                e.element.addEventListener("click", ()=>{
                    this.scrollToTop()
                }
                )
            }
            ).appendTo(this),
            new r.default(this.api).classes.add("menu-separator").appendTo(this),
            this.content = new r.default(this.api).classes.add("menu-content", "scrollable").appendTo(this),
            this.on("Show", this.onShowMenu),
            this.selection = new u.default(this.api,this)
        }
        get isSubmenu() {
            return this.classes.has("submenu")
        }
        set isSubmenu(e) {
            this.classes.toggle(e, "submenu")
        }
        setTitle(e) {
            this.title.schedule(e)
        }
        setDescription(e) {
            this.description.schedule(e)
        }
        setOnBeforeShow(e) {
            this.onBeforeShow = e
        }
        show() {
            const e = this.onBeforeShow();
            return e ? (this.classes.until(800).add("insta-animation-out"),
            e.then(()=>{
                super.show(),
                this.classes.has("insta-animation-in") || this.api.getVisibleScreen().classes.has("insta-animation-in") || i.bindingManager.disableBindsUntil(500)
            }
            ),
            this) : (super.show(),
            this.classes.has("insta-animation-in") || this.api.getVisibleScreen().classes.has("insta-animation-in") || i.bindingManager.disableBindsUntil(500),
            this)
        }
        scrollToTop() {
            this.content.scrollTo(this.content.getNthChild(0))
        }
        scrollToTabSection(e) {
            const t = this.tabs.get(e);
            return t && t.section && this.content.scrollTo(t.section),
            this
        }
        addTabs(...e) {
            this.classes.has("menu-hastabs") || (this.classes.add("menu-hastabs"),
            this.tabContainer = new r.default(this.api).classes.add("menu-tabs").appendTo(new r.default(this.api).classes.add("menu-tabs-wrapper").appendTo(this)));
            for (const t of e.values().flatMap())
                t && (void 0 !== t.id && this.tabs.set(t.id, t),
                this.tabContainer.append(t),
                t.section && (this.content.append(t.section),
                t.on(o.ButtonEvent.Activate, ()=>{
                    this.content.scrollTo(t.section)
                }
                )),
                this.addSubtabs(t),
                t.on(y.EditSubtabs, this.addSubtabs))
        }
        getTabs() {
            return this.tabs.values()
        }
        addSubtabs(e) {
            let t = e
              , a = e.section;
            for (const i of e.subtabs)
                i && (void 0 !== i.id && this.tabs.set(i.id, i),
                i.appendTo(this.tabContainer, {
                    after: t
                }),
                i.section && (e.section ? (i.section.appendTo(this.content, {
                    after: a
                }),
                i.on(o.ButtonEvent.Activate, ()=>{
                    this.content.scrollTo(i.section)
                }
                ),
                a = i.section) : c.default.warn(c.LogSource.NewUi, `Menu:${this.dataset.menuId}`)("Subtabs cannot have a section if their parent tab does not have a section.")),
                t = i);
            return this
        }
        onBindLoop(e, t) {
            return this.api.getVisibleScreen().contains(this) ? this.selection.handleBindLoop(e, t) : e
        }
        wentBackTo() {
            return this.classes.has("left")
        }
        onBeforeShow() {}
        onShowMenu() {
            hookManager.register(this, `Menu:${this.dataset.menuId}`).until("Hide")
        }
    }
    __decorate([Override], g.prototype, "show", null),
    __decorate([m.Bound], g.prototype, "addTabs", null),
    __decorate([m.Bound], g.prototype, "addSubtabs", null),
    __decorate([a.HookMethod, Override], g.prototype, "onBindLoop", null),
    __decorate([m.Bound], g.prototype, "onShowMenu", null),
    t.default = g,
    function(e) {
        e.EditSubtabs = "EditSubtabs"
    }(y = t.TabEvent || (t.TabEvent = {}));
    class f extends o.default {
        constructor(e, t) {
            super(e),
            this._subtabs = [],
            this.id = t,
            this.classes.add("menu-tab", "menu-option")
        }
        get subtabs() {
            return this._subtabs
        }
        setSection(e) {
            return this.section = e,
            this
        }
        setSubTabs(...e) {
            for (const e of this._subtabs)
                e.section && e.section.remove(),
                e.remove();
            this._subtabs = e.values().flatMap().map(e=>(e.section && e.section.classes.add("menu-subsection"),
            e.classes.add("menu-subtab"))).collect(p.default.toArray),
            this.emit(y.EditSubtabs)
        }
    }
    __decorate([m.Bound], f.prototype, "setSection", null),
    __decorate([m.Bound], f.prototype, "setSubTabs", null),
    t.Tab = f;
    class T extends r.default {
        constructor(e) {
            super(e),
            this.classes.add("menu-section"),
            this.append(this.heading = new s.Heading(this.api).classes.add("menu-section-heading"), this.content = new r.default(this.api).classes.add("menu-section-content"))
        }
        setTitle(e) {
            return this.heading.schedule(e),
            this
        }
        addContent(...e) {
            return this.content.append(...e),
            this
        }
        dumpContent() {
            return this.content.dump(),
            this
        }
    }
    t.MenuSection = T
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("ui/IUi", ["require", "exports"], function(e, t) {
    var a;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.HelpShow = 0] = "HelpShow",
        e[e.HelpHide = 1] = "HelpHide"
    }(a = t.UiEvent || (t.UiEvent = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/server/UpdateDialogInfoPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedServerPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            "string" == typeof this.index ? this.player.dialogInfo[this.index] = this.info : this.player.dialogContainerInfo[this.index] = this.info
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Generic)], n.prototype, "index", void 0),
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Generic)], n.prototype, "info", void 0),
    __decorate([Override], n.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/EntityTargetedSharedPacket", ["require", "exports", "entity/IEntity", "multiplayer/packets/SharedPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        preProcess() {}
        preWriteData() {
            this.writeUint8(this.entity.id),
            this.writeUint8(this.entity.entityType)
        }
        preReadData() {
            const e = this.readUint8();
            switch (this.readUint8()) {
            case a.EntityType.Player:
                this.entity = players[e];
                break;
            case a.EntityType.NPC:
                this.entity = game.npcs[e];
                break;
            case a.EntityType.Creature:
                this.entity = game.creatures[e]
            }
        }
    }
    __decorate([Override], n.prototype, "preProcess", null),
    __decorate([Override], n.prototype, "preWriteData", null),
    __decorate([Override], n.prototype, "preReadData", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/packets/shared/ActionPacket", ["require", "exports", "action/ActionExecutor", "action/Actions", "action/IAction", "multiplayer/packets/EntityTargetedSharedPacket"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends o.default {
        constructor() {
            super(...arguments),
            this.arguments = [],
            this.items = []
        }
        getDebugInfo() {
            return `Action:${n.ActionType[this.action]}. Entity: ${this.entity.id}. Argument types: ${this.argumentTypes.join(",")}. Items: ${this.items.map(e=>e.id).join(",")}`
        }
        process() {
            a.default.executeMultiplayer(this)
        }
        writeData() {
            this.writeUint16(this.action);
            const e = i.default[this.action];
            for (let t = 0; t < e.argumentTypes.length; t++) {
                let a = e.argumentTypes[t];
                Array.isArray(a) && (a = this.argumentTypes[t],
                this.writeUint8(a)),
                this.writeArgument(a, this.arguments[t])
            }
            e.preExecutionHandler && this.writeItems(this.items)
        }
        readData() {
            this.action = this.readUint16(),
            this.argumentTypes = [];
            const e = i.default[this.action];
            for (let t = 0; t < e.argumentTypes.length; t++) {
                let a = e.argumentTypes[t];
                Array.isArray(a) && (a = this.readUint8(),
                this.argumentTypes[t] = a),
                this.arguments[t] = this.readArgument(a)
            }
            e.preExecutionHandler && (this.items = this.readItems())
        }
        writeArgument(e, t) {
            switch (e) {
            case n.ActionArgument.Undefined:
            case n.ActionArgument.Null:
                return;
            case n.ActionArgument.Boolean:
                return void this.writeBool(t);
            case n.ActionArgument.Number:
                return void this.writeFloat64(t);
            case n.ActionArgument.String:
                return void this.writeString(t);
            case n.ActionArgument.Array:
            case n.ActionArgument.Object:
                return void this.writeObject(t);
            case n.ActionArgument.AttackType:
                return void this.writeUint8(t);
            case n.ActionArgument.Container:
                return void this.writeContainer(t);
            case n.ActionArgument.Doodad:
                return void this.writeDoodad(t);
            case n.ActionArgument.Corpse:
                return void this.writeCorpse(t);
            case n.ActionArgument.Creature:
                return void this.writeCreature(t);
            case n.ActionArgument.NPC:
                return void this.writeNPC(t);
            case n.ActionArgument.Player:
                return void this.writePlayer(t);
            case n.ActionArgument.Human:
                return void this.writeHuman(t);
            case n.ActionArgument.EquipType:
                return void this.writeUint8(t);
            case n.ActionArgument.Direction:
                return void this.writeInt8(t);
            case n.ActionArgument.ItemQuality:
                return void this.writeUint8(t);
            case n.ActionArgument.ItemType:
                return void this.writeUint16(t);
            case n.ActionArgument.Vector2:
                return void this.writeVector2(t);
            case n.ActionArgument.Vector3:
                return void this.writeVector3(t);
            case n.ActionArgument.RestType:
                return void this.writeUint8(t);
            case n.ActionArgument.ActionType:
                return void this.writeUint16(t);
            case n.ActionArgument.DoodadType:
                return void this.writeDoodad(t);
            case n.ActionArgument.Entity:
                return void this.writeEntity(t);
            case n.ActionArgument.Item:
            case n.ActionArgument.ItemNearby:
            case n.ActionArgument.ItemInventory:
                return void this.writeItem(t);
            case n.ActionArgument.ItemArray:
            case n.ActionArgument.ItemArrayNearby:
            case n.ActionArgument.ItemArrayInventory:
                return void this.writeItems(t);
            case n.ActionArgument.TileEvent:
                return void this.writeTileEvent(t);
            default:
                throw new Error(`Unable to write argument for ${n.ActionArgument[e]}. ${e}. ${this.getDebugInfo()}.`)
            }
        }
        readArgument(e) {
            switch (e) {
            case n.ActionArgument.Undefined:
                return;
            case n.ActionArgument.Null:
                return null;
            case n.ActionArgument.Boolean:
                return this.readBool();
            case n.ActionArgument.Number:
                return this.readFloat64();
            case n.ActionArgument.String:
                return this.readString();
            case n.ActionArgument.Array:
            case n.ActionArgument.Object:
                return this.readObject();
            case n.ActionArgument.AttackType:
                return this.readUint8();
            case n.ActionArgument.Container:
                return this.readContainer();
            case n.ActionArgument.Doodad:
                return this.readDoodad();
            case n.ActionArgument.Corpse:
                return this.readCorpse();
            case n.ActionArgument.Creature:
                return this.readCreature();
            case n.ActionArgument.NPC:
                return this.readNPC();
            case n.ActionArgument.Player:
                return this.readPlayer();
            case n.ActionArgument.Human:
                return this.readHuman();
            case n.ActionArgument.EquipType:
                return this.readUint8();
            case n.ActionArgument.Direction:
                return this.readInt8();
            case n.ActionArgument.ItemQuality:
                return this.readUint8();
            case n.ActionArgument.ItemType:
                return this.readUint16();
            case n.ActionArgument.Vector2:
                return this.readVector2();
            case n.ActionArgument.Vector3:
                return this.readVector3();
            case n.ActionArgument.RestType:
                return this.readUint8();
            case n.ActionArgument.ActionType:
                return this.readUint16();
            case n.ActionArgument.DoodadType:
                return this.readDoodad();
            case n.ActionArgument.Entity:
                return this.readEntity();
            case n.ActionArgument.Item:
            case n.ActionArgument.ItemNearby:
            case n.ActionArgument.ItemInventory:
                return this.readItem();
            case n.ActionArgument.ItemArray:
            case n.ActionArgument.ItemArrayNearby:
            case n.ActionArgument.ItemArrayInventory:
                return this.readItems();
            case n.ActionArgument.TileEvent:
                return this.readTileEvent();
            default:
                throw new Error(`Unable to read argument for ${n.ActionArgument[e]}. ${e}. ${this.getDebugInfo()}.`)
            }
        }
    }
    __decorate([Override], r.prototype, "getDebugInfo", null),
    __decorate([Override], r.prototype, "process", null),
    __decorate([Override], r.prototype, "writeData", null),
    __decorate([Override], r.prototype, "readData", null),
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/shared/UpdateItemOrderPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/SharedPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            const e = this.container;
            e && e.containedItems ? itemManager.updateItemOrder(e, this.itemOrder) : steamworks.multiplayerLogError("Failed to update item order", this.container, this.itemOrder)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Container)], n.prototype, "container", void 0),
    __decorate([a.OptionalNetworkProperty(a.NetworkPropertyType.Uint32NumberArray)], n.prototype, "itemOrder", void 0),
    __decorate([Override], n.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/shared/UpdateItemQuickSlotPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedSharedPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        isSyncCheckEnabled() {
            return !1
        }
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            this.item ? this.item.setQuickSlot(this.player, this.quickSlot) : steamworks.multiplayerLogError("Failed to update item quick slot", this.item, this.quickSlot)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Item)], n.prototype, "item", void 0),
    __decorate([a.OptionalNetworkProperty(a.NetworkPropertyType.Uint8)], n.prototype, "quickSlot", void 0),
    __decorate([Override], n.prototype, "isSyncCheckEnabled", null),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/shared/UpdateMultiplayerOptionsPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/SharedPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            multiplayer.setOptions(this.options)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Generic)], n.prototype, "options", void 0),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/shared/UpdateOptionPacket", ["require", "exports", "multiplayer/packets/IPacket", "multiplayer/packets/PlayerTargetedSharedPacket"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends i.default {
        isAllowedWhenPaused() {
            return !0
        }
        process() {
            game.updateOption(this.player, this.id, this.value)
        }
    }
    __decorate([a.NetworkProperty(a.NetworkPropertyType.String)], n.prototype, "id", void 0),
    __decorate([a.NetworkProperty(a.NetworkPropertyType.Generic)], n.prototype, "value", void 0),
    __decorate([Override], n.prototype, "isAllowedWhenPaused", null),
    __decorate([Override], n.prototype, "process", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/packets/Packets", ["require", "exports", "game/Registrar", "multiplayer/packets/client/AddPlayerPacket", "multiplayer/packets/client/CaughtUpPacket", "multiplayer/packets/client/ClearSyncPacketWaitingPacket", "multiplayer/packets/client/DisconnectPacket", "multiplayer/packets/client/DisplayInterruptPacket", "multiplayer/packets/client/HideLoadingScreenPacket", "multiplayer/packets/client/PausePacket", "multiplayer/packets/client/PongPacket", "multiplayer/packets/client/ReadyPlayerPacket", "multiplayer/packets/client/RemovePlayerPacket", "multiplayer/packets/client/SetPlayerZPacket", "multiplayer/packets/client/ShowLoadingScreenPacket", "multiplayer/packets/client/SynchronizeFlowFieldsPacket", "multiplayer/packets/client/SynchronizeGameStatePacket", "multiplayer/packets/client/TickPacket", "multiplayer/packets/client/WorldPacket", "multiplayer/packets/server/AddMessageHistoryPacket", "multiplayer/packets/server/ConfirmInterruptSelectionPacket", "multiplayer/packets/server/ConnectedPacket", "multiplayer/packets/server/ConnectPacket", "multiplayer/packets/server/DesyncPacket", "multiplayer/packets/server/KeepAlivePacket", "multiplayer/packets/server/LogsPacket", "multiplayer/packets/server/NewUiDataUpdatePacket", "multiplayer/packets/server/PingPacket", "multiplayer/packets/server/ReadyPacket", "multiplayer/packets/server/UpdateDialogInfoPacket", "multiplayer/packets/server/UpdateQuickSlotInfoPacket", "multiplayer/packets/shared/ActionPacket", "multiplayer/packets/shared/ChatMessagePacket", "multiplayer/packets/shared/UpdateItemOrderPacket", "multiplayer/packets/shared/UpdateItemQuickSlotPacket", "multiplayer/packets/shared/UpdateMovementIntentPacket", "multiplayer/packets/shared/UpdateMultiplayerOptionsPacket", "multiplayer/packets/shared/UpdateOptionPacket", "multiplayer/packets/shared/UpdateWalkPathPacket"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L, O, F, _) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.registrar = new a.default,
    t.registrar.register(R.default),
    t.registrar.register(S.default),
    t.registrar.register(i.default),
    t.registrar.register(n.default),
    t.registrar.register(x.default),
    t.registrar.register(o.default),
    t.registrar.register(I.default),
    t.registrar.register(v.default),
    t.registrar.register(w.default),
    t.registrar.register(M.default),
    t.registrar.register(r.default),
    t.registrar.register(s.default),
    t.registrar.register(l.default),
    t.registrar.register(b.default),
    t.registrar.register(k.default),
    t.registrar.register(C.default),
    t.registrar.register(u.default),
    t.registrar.register(D.default),
    t.registrar.register(d.default),
    t.registrar.register(A.default),
    t.registrar.register(p.default),
    t.registrar.register(c.default),
    t.registrar.register(m.default),
    t.registrar.register(h.default),
    t.registrar.register(y.default),
    t.registrar.register(g.default),
    t.registrar.register(f.default),
    t.registrar.register(P.default),
    t.registrar.register(B.default),
    t.registrar.register(E.default),
    t.registrar.register(L.default),
    t.registrar.register(O.default),
    t.registrar.register(F.default),
    t.registrar.register(G.default),
    t.registrar.register(_.default),
    t.registrar.register(T.default)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("npc/BaseNPC", ["require", "exports", "action/ActionExecutor", "action/IAction", "entity/Human", "entity/IEntity", "entity/IStats", "Enums", "flowfield/IFlowFieldManager", "mod/IHookManager", "player/MessageManager", "player/note/NoteManager", "save/ISerializer", "tile/ITileEvent", "utilities/enum/Enums", "utilities/Random", "utilities/TileHelpers", "utilities/UUID"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class T extends n.default {
        constructor(e, t=0, a=0, i=0) {
            if (super(),
            this.entityType = o.EntityType.NPC,
            void 0 === e)
                return;
            this.id = e,
            this.x = t,
            this.y = a,
            this.z = i,
            this.ai = this.getDefaultAiType(),
            this.seen = 2 * game.time.dayLength,
            this.notes = new p.default({
                onWriteNote: ()=>{}
                ,
                canWriteInHours: ()=>!1,
                canWriteNote: ()=>!1
            }),
            this.messages = d.default.get(),
            this.identifier = f.default.create(),
            this.renamed = this.getDefaultName(),
            this.customization = this.getDefaultCustomization();
            const n = this.getDefaultInventory();
            for (const e of n)
                "number" == typeof e ? itemManager.create(e, this.inventory) : itemManager.moveToContainer(void 0, e, this.inventory);
            for (const e of h.default.values(s.EquipType))
                if (e !== s.EquipType.Held) {
                    const t = this.getDefaultEquipment(e);
                    if (void 0 !== t) {
                        const a = "number" == typeof t ? itemManager.create(t, this.inventory) : t;
                        this.equip(a, e)
                    }
                }
            this.initializeStats(),
            this.autoScaleStats()
        }
        static getRegistrarId() {
            return this.registrarId
        }
        static setRegistrarId(e) {
            this.registrarId = e
        }
        getRegistrarId() {
            return this.constructor.registrarId
        }
        update() {
            if (super.update(),
            this.getStat(r.Stat.Health).value <= 0 && this.kill())
                return;
            this.fromX = this.x,
            this.fromY = this.y;
            const e = game.npcs.filter(e=>e).length;
            if (e <= 10 && !this.isInFov()) {
                if (this.seen > 0 && this.seen--,
                !this.seen && 0 === y.default.int(1e4)) {
                    npcManager.remove(this);
                    const e = y.default.int(2) + 1;
                    for (let t = 0; t < e; t++) {
                        const e = g.default.getSuitableSpawnPoint();
                        npcManager.spawn(this.getRegistrarId(), e.x, e.y, e.z)
                    }
                }
                return
            }
            this.seen = 2 * game.time.dayLength;
            let t = !1;
            this.isHostile() && this.attack() ? t = !0 : this.move() && (t = !0),
            this.isGhost() || this.swimCheck(),
            t && (this.anim = 1 - this.anim);
            const a = this.getTile()
              , i = g.default.getType(a);
            if (tileEventManager.get(a, m.TileEventType.Fire) || i === s.TerrainType.Lava) {
                const e = y.default.intInRange(4, 8);
                this.damage({
                    amount: e,
                    type: s.DamageType.Fire
                })
            }
        }
        moveTo(e, t, a) {
            if (this.x === e && this.y === t && this.z === a)
                return !1;
            const i = this.getTile();
            delete i.npc,
            game.updateFlowFieldTile(i, this.x, this.y, this.z);
            const n = game.getTile(e, t, a);
            return n.npc = this,
            this.x = e,
            this.y = t,
            this.z = a,
            game.updateFlowFieldTile(n, this.x, this.y, this.z),
            this._movementFinishTime = game.getMovementFinishTime(),
            this.checkUnder(),
            !0
        }
        kill() {
            if (!1 === modManager.getHook(u.Hook.OnNPCDeath).call(this))
                return !1;
            for (const e of this.inventory.containedItems)
                delete e.equippedId,
                delete e.equippedType;
            itemManager.placeItemsAroundLocation(this.inventory, this.x, this.y, this.z),
            corpseManager.createBlood(this.x, this.y, this.z),
            this.queueSoundEffect(s.SfxType.Death);
            const e = this.getReputationChangeOnDeath();
            return 0 !== e && game.updateReputation(e),
            npcManager.remove(this),
            !0
        }
        isHostile() {
            return 0 != (this.ai & o.AiType.Hostile)
        }
        isWaiting() {
            return 0 != (this.ai & o.AiType.Waiting)
        }
        getDamageModifier() {
            return multiplayer.isConnected() ? Math.max(.75 * game.getPlayers().length, 1) : 1
        }
        makeHostile() {
            this.isHostile() || (this.ai = o.AiType.Hostile,
            this.setMoveType(s.MoveType.Land | s.MoveType.Water | s.MoveType.ShallowWater),
            ui.closeContainer(this.inventory))
        }
        getActions() {}
        addAiType(e) {
            this.ai |= e
        }
        updateDirection(e, t) {
            this.facingDirection = Math.ceil((Math.atan2(t - this.fromY, this.fromX - e) + Math.PI) / (Math.PI / 2)) % 4,
            this.direction = game.directionToMovement(this.facingDirection)
        }
        getReputationChangeOnDeath() {
            return 0
        }
        attack() {
            const e = game.getNearestPlayer(this.x, this.y)
              , t = e;
            return !(!t || this.z !== t.z || Math.abs(this.x - t.x) + Math.abs(this.y - t.y) !== 1) && (this.updateDirection(t.x, t.y),
            a.default.get(i.ActionType.Attack).execute(this),
            !0)
        }
        move() {
            let e = this.x
              , t = this.y;
            if (void 0 === this.ai)
                return !1;
            const a = this.getMoveType();
            if (this.isHostile() && flowFieldManager.isInFlowField(this))
                if (y.default.percent() > 10) {
                    const i = flowFieldManager.getMoveDirection(this.x, this.y, this.z, a);
                    switch (i) {
                    case s.Direction.West:
                        e -= 1;
                        break;
                    case s.Direction.East:
                        e += 1;
                        break;
                    case s.Direction.North:
                        t -= 1;
                        break;
                    case s.Direction.South:
                        t += 1
                    }
                } else {
                    const i = y.default.shuffle([0, 1, 2, 3, 4]);
                    for (let n = 0; n < 4; n++) {
                        switch (i[n]) {
                        case 0:
                            e = this.x + 1,
                            t = this.y;
                            break;
                        case 1:
                            e = this.x,
                            t = this.y + 1;
                            break;
                        case 2:
                            e = this.x - 1,
                            t = this.y;
                            break;
                        case 3:
                            e = this.x,
                            t = this.y - 1;
                            break;
                        case 4:
                            e = this.x,
                            t = this.y
                        }
                        if (0 === this.checkMove(a, e, t, this.z))
                            break
                    }
                }
            else if (this.isWaiting()) {
                let e = !1;
                const t = g.default.getTilesAround(this);
                for (const a of game.getPlayers())
                    if (-1 !== t.indexOf(a.getTile())) {
                        e = !0;
                        break
                    }
                if (e)
                    return !1;
                this.ai &= ~o.AiType.Waiting
            } else {
                if (y.default.int(5) < 3)
                    return !0;
                {
                    const i = y.default.shuffle([0, 1, 2, 3, 4]);
                    for (let n = 0; n < 4; n++) {
                        switch (i[n]) {
                        case 0:
                            e = this.x + 1,
                            t = this.y;
                            break;
                        case 1:
                            e = this.x,
                            t = this.y + 1;
                            break;
                        case 2:
                            e = this.x - 1,
                            t = this.y;
                            break;
                        case 3:
                            e = this.x,
                            t = this.y - 1;
                            break;
                        case 4:
                            e = this.x,
                            t = this.y
                        }
                        if (0 === this.checkMove(a, e, t, this.z))
                            break
                    }
                }
            }
            return this.updateDirection(e, t),
            e = game.getWrappedCoord(e),
            t = game.getWrappedCoord(t),
            0 === this.checkMove(a, e, t, this.z) && this.moveTo(e, t, this.z)
        }
        autoScaleStats() {
            if (!multiplayer.isConnected())
                return;
            const e = game.getPlayers().length
              , t = t=>{
                if (this.hasStat(t)) {
                    const a = this.getStat(t);
                    this.setStatAndMax(a, Math.ceil(a.max * Math.max(e / 3, 1.5)), Math.ceil(a.value * Math.max(e / 3, 1.5)))
                }
            }
            ;
            for (const e of h.default.values(r.Stat))
                t(e)
        }
        checkMove(e, t, a, i) {
            const n = game.getTile(game.getWrappedCoord(t), game.getWrappedCoord(a), i);
            if (!n)
                return -1;
            const o = modManager.getHook(u.Hook.CanNPCMove).call(this, n, t, a, i, e);
            if (!1 === o)
                return 1;
            if (!0 === o)
                return 0;
            if (game.getPlayersAtTile(n).length > 0)
                return -2;
            const r = creatureManager.getMovePenalty(e, n, !1);
            return r >= l.blockedPenalty ? -3 : 0
        }
    }
    __decorate([Override], T.prototype, "entityType", void 0),
    __decorate([c.SaveProperty()], T.prototype, "ai", void 0),
    __decorate([c.SaveProperty()], T.prototype, "seen", void 0),
    __decorate([Override], T.prototype, "update", null),
    __decorate([Override], T.prototype, "getDamageModifier", null),
    t.default = T
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("npc/npcs/DeathKnight", ["require", "exports", "entity/IEntity", "entity/IStats", "Enums", "npc/BaseNPC", "player/Customizations", "utilities/Random"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l extends o.default {
        constructor(e, t=0, a=0, i=0) {
            super(e, t, a, i)
        }
        getDefaultName() {
            return "Deathy"
        }
        initializeStats() {
            const e = s.default.int(10) + 70
              , t = s.default.int(5) + 45
              , a = s.default.int(5) + 15
              , n = s.default.int(5) + 15;
            this.setStatAndMax(i.Stat.Stamina, e, e - s.default.int(10)),
            this.setStatAndMax(i.Stat.Health, t, t - s.default.int(5)),
            this.setStatAndMax(i.Stat.Hunger, a, a - s.default.int(2)),
            this.setStatAndMax(i.Stat.Thirst, n, n - s.default.int(2))
        }
        getDefaultCustomization() {
            return r.generateRandomCustomization()
        }
        getDefaultEquipment(e) {
            switch (e) {
            case n.EquipType.Head:
                return n.ItemType.BlackplateHelmet;
            case n.EquipType.Neck:
                return n.ItemType.BlackplateGorget;
            case n.EquipType.Chest:
                return n.ItemType.BlackplateBreastplate;
            case n.EquipType.Hands:
                return n.ItemType.BlackplateGauntlets;
            case n.EquipType.Legs:
                return n.ItemType.BlackplateGreaves;
            case n.EquipType.Feet:
                return n.ItemType.BlackplateBoots;
            case n.EquipType.RightHand:
                return n.ItemType.DeathKnightAxe
            }
        }
        getDefaultAiType() {
            return a.AiType.Hostile
        }
        getDefaultInventory() {
            return []
        }
    }
    __decorate([Override], l.prototype, "getDefaultName", null),
    __decorate([Override], l.prototype, "initializeStats", null),
    __decorate([Override], l.prototype, "getDefaultCustomization", null),
    __decorate([Override], l.prototype, "getDefaultEquipment", null),
    __decorate([Override], l.prototype, "getDefaultAiType", null),
    __decorate([Override], l.prototype, "getDefaultInventory", null),
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("npc/npcs/Merchant", ["require", "exports", "action/IAction", "entity/IEntity", "entity/IStats", "Enums", "item/IItem", "item/Items", "language/Dictionaries", "language/dictionary/HumanName", "language/Translation", "npc/BaseNPC", "player/Customizations", "utilities/enum/Enums", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class y extends p.default {
        constructor(e, t=0, a=0, n=0) {
            super(e, t, a, n),
            void 0 !== e && (this.inventory.weightCapacity = Math.max(Math.round(1.5 * itemManager.computeContainerWeight(this.inventory)), h.default.intInRange(85, 125)),
            this.inventory.containerType = r.ContainerType.Trade,
            this.addProperty(i.Property.Credit, new Map),
            this.addProperty(i.Property.Talked, new Map))
        }
        update() {
            if (!this.isInFov())
                if (0 === h.default.int(1e3)) {
                    const e = m.default.getRandom(o.ItemType)
                      , t = itemManager.getWeight(e);
                    itemManager.computeContainerWeight(this.inventory) + t < .75 * this.inventory.weightCapacity && itemManager.create(e, this.inventory)
                } else if (0 === h.default.int(2e3)) {
                    const e = this.inventory.containedItems.filter(e=>!e.isEquipped());
                    e.length > 3 && itemManager.remove(h.default.getElement(e))
                }
            super.update()
        }
        getActions() {
            return this.isHostile() ? void 0 : [a.ActionType.Trade]
        }
        getReputationChangeOnDeath() {
            return -5e3
        }
        getDefaultName() {
            return new d.default(l.Dictionary.HumanName,u.default.Full).setRandom(h.default).getString()
        }
        initializeStats() {
            const e = h.default.int(10) + 70
              , t = h.default.int(5) + 45
              , a = h.default.int(5) + 15
              , i = h.default.int(5) + 15;
            this.setStatAndMax(n.Stat.Stamina, e, e - h.default.int(10)),
            this.setStatAndMax(n.Stat.Health, t, t - h.default.int(5)),
            this.setStatAndMax(n.Stat.Hunger, a, a - h.default.int(2)),
            this.setStatAndMax(n.Stat.Thirst, i, i - h.default.int(2)),
            this.skillGain(o.SkillType.Tactics, h.default.int(25) + 25),
            this.skillGain(o.SkillType.Parrying, h.default.int(25) + 25)
        }
        getDefaultCustomization() {
            return c.generateRandomCustomization()
        }
        getDefaultEquipment(e) {
            switch (e) {
            case o.EquipType.Head:
                switch (h.default.int(10)) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    return o.ItemType.StrawHat;
                case 5:
                    return o.ItemType.Skullcap;
                case 6:
                    return o.ItemType.LeatherCap
                }
                break;
            case o.EquipType.Chest:
                switch (h.default.int(10)) {
                case 0:
                case 1:
                case 2:
                    return o.ItemType.TatteredShirt;
                case 3:
                    return o.ItemType.BarkTunic;
                case 4:
                    return o.ItemType.LeatherTunic
                }
                break;
            case o.EquipType.Legs:
                switch (h.default.int(7)) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    return o.ItemType.TatteredPants;
                case 5:
                    return o.ItemType.BarkLeggings;
                case 6:
                    return o.ItemType.LeatherPants
                }
                break;
            case o.EquipType.Feet:
                switch (h.default.int(8)) {
                case 0:
                    return o.ItemType.LeatherBoots
                }
                break;
            case o.EquipType.Hands:
                switch (h.default.int(8)) {
                case 0:
                    return o.ItemType.LeatherGloves
                }
                break;
            case o.EquipType.LeftHand:
            case o.EquipType.RightHand:
                switch (h.default.int(14)) {
                case 0:
                    return o.ItemType.FishingRod;
                case 1:
                    return o.ItemType.StoneKnife;
                case 2:
                    return o.ItemType.StoneSpear;
                case 3:
                    return o.ItemType.WoodenSword;
                case 4:
                    return o.ItemType.WoodenSpear;
                case 5:
                    return o.ItemType.VineWhip;
                case 6:
                    return o.ItemType.StoneAxe;
                case 7:
                    return o.ItemType.BarkShield
                }
                break;
            case o.EquipType.Back:
                switch (h.default.int(8)) {
                case 0:
                    return o.ItemType.Cloak
                }
            }
        }
        getDefaultInventory() {
            const e = []
              , t = h.default.intInRange(5, 10);
            for (; e.length < t; ) {
                const t = m.default.getRandom(o.ItemType)
                  , a = s.itemDescriptions[t];
                void 0 === a || void 0 === a.worth || itemManager.isInGroup(t, o.ItemTypeGroup.Untradable) || e.push(t)
            }
            return e
        }
        getDefaultAiType() {
            return i.AiType.Neutral
        }
    }
    __decorate([Override], y.prototype, "update", null),
    __decorate([Override], y.prototype, "getActions", null),
    __decorate([Override], y.prototype, "getReputationChangeOnDeath", null),
    __decorate([Override], y.prototype, "getDefaultName", null),
    __decorate([Override], y.prototype, "initializeStats", null),
    __decorate([Override], y.prototype, "getDefaultCustomization", null),
    __decorate([Override], y.prototype, "getDefaultEquipment", null),
    __decorate([Override], y.prototype, "getDefaultInventory", null),
    __decorate([Override], y.prototype, "getDefaultAiType", null),
    t.default = y
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("npc/NPCS", ["require", "exports", "Enums", "game/Registrar", "npc/npcs/DeathKnight", "npc/npcs/Merchant"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.registrar = new i.default,
    t.registrar.register(o.default, a.NPCType.Merchant),
    t.registrar.register(n.default, a.NPCType.DeathKnight)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/ModRegistry", ["require", "exports"], function(e, t) {
    var a, i;
    function n() {
        return {
            get: e=>new n.Registered(e,0),
            getAction: e=>new n.Registered(e,1),
            getCommand: e=>new n.Registered(e,1)
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.SYMBOL_MOD_REGISTRATIONS = Symbol("SYMBOL_MOD_REGISTRATIONS"),
    function(e) {
        e[e.Action = 0] = "Action",
        e[e.Bindable = 1] = "Bindable",
        e[e.Command = 2] = "Command",
        e[e.Creature = 3] = "Creature",
        e[e.DailyChallengeModifier = 4] = "DailyChallengeModifier",
        e[e.Dialog = 5] = "Dialog",
        e[e.Dictionary = 6] = "Dictionary",
        e[e.Doodad = 7] = "Doodad",
        e[e.HelpArticle = 8] = "HelpArticle",
        e[e.InspectionType = 9] = "InspectionType",
        e[e.InterModRegistration = 10] = "InterModRegistration",
        e[e.InterModRegistry = 11] = "InterModRegistry",
        e[e.InterruptChoice = 12] = "InterruptChoice",
        e[e.Item = 13] = "Item",
        e[e.ItemGroup = 14] = "ItemGroup",
        e[e.Language = 15] = "Language",
        e[e.LanguageExtension = 16] = "LanguageExtension",
        e[e.MenuBarButton = 17] = "MenuBarButton",
        e[e.Message = 18] = "Message",
        e[e.MessageSource = 19] = "MessageSource",
        e[e.MusicTrack = 20] = "MusicTrack",
        e[e.Note = 21] = "Note",
        e[e.NPC = 22] = "NPC",
        e[e.OptionsSection = 23] = "OptionsSection",
        e[e.Overlay = 24] = "Overlay",
        e[e.Packet = 25] = "Packet",
        e[e.Quest = 26] = "Quest",
        e[e.QuestRequirement = 27] = "QuestRequirement",
        e[e.Registry = 28] = "Registry",
        e[e.Skill = 29] = "Skill",
        e[e.SoundEffect = 30] = "SoundEffect",
        e[e.Terrain = 31] = "Terrain",
        e[e.TileEvent = 32] = "TileEvent"
    }(a = t.ModRegistrationType || (t.ModRegistrationType = {})),
    function(e) {
        function i(e) {
            return function(t, i) {
                O(t, i, a.Registry, {
                    class: e
                })
            }
        }
        function n(e) {
            return function(t, i) {
                O(t, i, a.Language, {
                    instance: e
                })
            }
        }
        function o(e) {
            return function(t, i) {
                O(t, i, a.LanguageExtension, {
                    instance: e
                })
            }
        }
        function r(e) {
            return function(t, i) {
                O(t, i, a.MusicTrack, {
                    name: e
                })
            }
        }
        function s(e, t) {
            return function(i, n) {
                O(i, n, a.SoundEffect, {
                    name: e,
                    variations: t
                })
            }
        }
        function l(e) {
            return function(t, i) {
                O(t, i, a.Packet, {
                    class: e
                })
            }
        }
        function u(e, t) {
            return function(i, n) {
                O(i, n, a.NPC, {
                    name: e,
                    class: t
                })
            }
        }
        function d(e, t) {
            return function(i, n) {
                O(i, n, a.HelpArticle, {
                    name: e,
                    description: t
                })
            }
        }
        function p(e, t) {
            return function(i, n) {
                O(i, n, a.Note, {
                    name: e,
                    description: t
                })
            }
        }
        function c(e, t) {
            return function(i, n) {
                O(i, n, a.Skill, {
                    name: e,
                    description: t
                })
            }
        }
        function m(e, t) {
            return function(i, n) {
                O(i, n, a.Item, {
                    name: e,
                    description: t
                })
            }
        }
        function h(e, t, i) {
            return function(n, o) {
                O(n, o, a.Creature, {
                    name: e,
                    description: t,
                    corpseDescription: i
                })
            }
        }
        function y(e, t) {
            return function(i, n) {
                O(i, n, a.Terrain, {
                    name: e,
                    description: t
                })
            }
        }
        function g(e, t) {
            return function(i, n) {
                O(i, n, a.Doodad, {
                    name: e,
                    description: t
                })
            }
        }
        function f(e, t) {
            return function(i, n) {
                O(i, n, a.TileEvent, {
                    name: e,
                    description: t
                })
            }
        }
        function T(e, t, i) {
            return function(n, o) {
                O(n, o, a.Dialog, {
                    name: e,
                    description: t,
                    class: i
                })
            }
        }
        function S(e, ...t) {
            return function(i, n) {
                O(i, n, a.Bindable, {
                    name: e,
                    defaultBindings: t
                })
            }
        }
        function I(e, t) {
            return function(i, n) {
                O(i, n, a.Dictionary, {
                    name: e,
                    dictionaryEnum: t
                })
            }
        }
        function v(e) {
            return function(t, i) {
                O(t, i, a.Message, {
                    name: e
                })
            }
        }
        function w(e) {
            return function(t, i) {
                O(t, i, a.InterruptChoice, {
                    name: e
                })
            }
        }
        function M(e) {
            return function(t, i) {
                O(t, i, a.MessageSource, {
                    name: e
                })
            }
        }
        function b(e, t) {
            return function(i, n) {
                O(i, n, a.Overlay, {
                    name: e,
                    description: t
                })
            }
        }
        function k(e, t) {
            return function(i, n) {
                O(i, n, a.InspectionType, {
                    name: e,
                    description: t
                })
            }
        }
        function C(e, t) {
            return function(i, n) {
                O(i, n, a.DailyChallengeModifier, {
                    name: e,
                    description: t
                })
            }
        }
        function D(e, t) {
            return function(i, n) {
                O(i, n, a.MenuBarButton, {
                    name: e,
                    description: t
                })
            }
        }
        function A(e, t) {
            return function(i, n) {
                O(i, n, a.ItemGroup, {
                    name: e,
                    description: t
                })
            }
        }
        function P(e, t) {
            return function(i, n) {
                O(i, n, a.Quest, {
                    name: e,
                    description: t
                })
            }
        }
        function G(e, t) {
            return function(i, n) {
                O(i, n, a.QuestRequirement, {
                    name: e,
                    description: t
                })
            }
        }
        function R(e, t) {
            return function(i, n) {
                O(i, n, a.Action, {
                    name: e,
                    description: t
                })
            }
        }
        function x(e) {
            return function(t, i) {
                O(t, i, a.InterModRegistry, {
                    name: e
                })
            }
        }
        function B(e, t, i) {
            return function(n, o) {
                O(n, o, a.InterModRegistration, {
                    modName: e,
                    registryName: t,
                    value: i
                })
            }
        }
        function E(e) {
            return function(t, i, n) {
                O(t, i, a.Command, {
                    name: e
                })
            }
        }
        function L(e, t, i) {
            O(e, t, a.OptionsSection)
        }
        function O(e, a, i, n={}) {
            const o = e[t.SYMBOL_MOD_REGISTRATIONS] = e[t.SYMBOL_MOD_REGISTRATIONS] || [];
            o.push(Object.assign({
                type: i,
                key: a,
                registrationId: -1
            }, n))
        }
        e.registry = i,
        e.language = n,
        e.languageExtension = o,
        e.musicTrack = r,
        e.soundEffect = s,
        e.packet = l,
        e.npc = u,
        e.helpArticle = d,
        e.note = p,
        e.skill = c,
        e.item = m,
        e.creature = h,
        e.terrain = y,
        e.doodad = g,
        e.tileEvent = f,
        e.dialog = T,
        e.bindable = S,
        e.dictionary = I,
        e.message = v,
        e.interruptChoice = w,
        e.messageSource = M,
        e.overlay = b,
        e.inspectionType = k,
        e.dailyChallengeModifier = C,
        e.menuBarButton = D,
        e.itemGroup = A,
        e.quest = P,
        e.questRequirement = G,
        e.action = R,
        e.interModRegistry = x,
        e.interModRegistration = B,
        e.command = E,
        e.optionsSection = L
    }(i || (i = {})),
    t.default = i,
    t.SYMBOL_REGISTRATION_ID = Symbol("SYMBOL_REGISTRATION_ID"),
    t.Registry = n,
    function(e) {
        function a(e) {
            return e[t.SYMBOL_REGISTRATION_ID]
        }
        e.id = a;
        class i {
            constructor(e, t) {
                this.key = e,
                this.type = t
            }
        }
        e.Registered = i
    }(n = t.Registry || (t.Registry = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("tile/TerrainResources", ["require", "exports", "Enums"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.resource = {},
    t.default = t.resource,
    t.resource[a.TerrainType.Rocks] = {
        items: [{
            type: a.ItemType.LargeRock
        }, {
            type: a.ItemType.SmoothRock,
            chance: 20
        }, {
            type: a.ItemType.LargeRock
        }, {
            type: a.ItemType.Stones,
            chance: 40
        }, {
            type: a.ItemType.LargeRock,
            chance: 50
        }, {
            type: a.ItemType.SharpRock,
            chance: 50
        }, {
            type: a.ItemType.LargeRock
        }]
    },
    t.resource[a.TerrainType.RocksWithIron] = {
        items: [{
            type: a.ItemType.LargeRock
        }, {
            type: a.ItemType.IronOre
        }, {
            type: a.ItemType.Stones,
            chance: 25
        }, {
            type: a.ItemType.IronOre
        }, {
            type: a.ItemType.LargeRock,
            chance: 25
        }, {
            type: a.ItemType.IronOre
        }, {
            type: a.ItemType.IronOre
        }, {
            type: a.ItemType.IronOre,
            chance: 50
        }, {
            type: a.ItemType.IronOre
        }, {
            type: a.ItemType.LargeRock
        }]
    },
    t.resource[a.TerrainType.RocksWithTalc] = {
        items: [{
            type: a.ItemType.LargeRock
        }, {
            type: a.ItemType.Stones,
            chance: 25
        }, {
            type: a.ItemType.Talc
        }, {
            type: a.ItemType.LargeRock,
            chance: 25
        }, {
            type: a.ItemType.Talc,
            chance: 10
        }, {
            type: a.ItemType.Talc
        }, {
            type: a.ItemType.LargeRock
        }]
    },
    t.resource[a.TerrainType.RocksWithLimestone] = {
        items: [{
            type: a.ItemType.LargeRock
        }, {
            type: a.ItemType.Stones,
            chance: 25
        }, {
            type: a.ItemType.Limestone
        }, {
            type: a.ItemType.LargeRock,
            chance: 25
        }, {
            type: a.ItemType.Limestone
        }, {
            type: a.ItemType.Limestone
        }, {
            type: a.ItemType.Limestone
        }, {
            type: a.ItemType.Limestone,
            chance: 10
        }, {
            type: a.ItemType.LargeRock
        }]
    },
    t.resource[a.TerrainType.RocksWithCoal] = {
        items: [{
            type: a.ItemType.LargeRock
        }, {
            type: a.ItemType.Coal
        }, {
            type: a.ItemType.Stones,
            chance: 25
        }, {
            type: a.ItemType.Coal
        }, {
            type: a.ItemType.LargeRock,
            chance: 25
        }, {
            type: a.ItemType.Coal,
            chance: 10
        }, {
            type: a.ItemType.LargeRock
        }]
    },
    t.resource[a.TerrainType.Sandstone] = {
        items: [{
            type: a.ItemType.Sandstone
        }, {
            type: a.ItemType.Shale,
            chance: 5
        }, {
            type: a.ItemType.Sandstone
        }, {
            type: a.ItemType.Stones,
            chance: 10
        }, {
            type: a.ItemType.PileOfGravel,
            chance: 15
        }, {
            type: a.ItemType.Sandstone,
            chance: 50
        }, {
            type: a.ItemType.Sandstone
        }]
    },
    t.resource[a.TerrainType.SandstoneWithIron] = {
        items: [{
            type: a.ItemType.IronOre
        }, {
            type: a.ItemType.PileOfGravel,
            chance: 10
        }, {
            type: a.ItemType.IronOre
        }, {
            type: a.ItemType.Sandstone,
            chance: 25
        }, {
            type: a.ItemType.IronOre
        }, {
            type: a.ItemType.Sandstone
        }, {
            type: a.ItemType.IronOre
        }, {
            type: a.ItemType.IronOre,
            chance: 50
        }, {
            type: a.ItemType.IronOre
        }, {
            type: a.ItemType.Sandstone
        }]
    },
    t.resource[a.TerrainType.SandstoneWithNiter] = {
        items: [{
            type: a.ItemType.Sandstone
        }, {
            type: a.ItemType.Niter
        }, {
            type: a.ItemType.PileOfGravel,
            chance: 10
        }, {
            type: a.ItemType.Niter
        }, {
            type: a.ItemType.Sandstone,
            chance: 25
        }, {
            type: a.ItemType.Niter,
            chance: 10
        }, {
            type: a.ItemType.Sandstone
        }]
    },
    t.resource[a.TerrainType.WoodenFlooring] = {
        items: [{
            type: a.ItemType.WoodenFlooring,
            chance: 70,
            tileChange: a.TerrainType.Dirt
        }],
        defaultItem: a.ItemType.WoodenFlooring,
        disableWaterRouting: !0
    },
    t.resource[a.TerrainType.Dirt] = {
        items: [{
            type: a.ItemType.Soil,
            chance: 2,
            tileChange: a.TerrainType.ShallowFreshWater
        }, {
            type: a.ItemType.Earthworm,
            chance: 4
        }, {
            type: a.ItemType.Soil,
            chance: 60,
            tileChange: a.TerrainType.Dirt
        }],
        defaultItem: a.ItemType.Soil
    },
    t.resource[a.TerrainType.Clay] = {
        items: [{
            type: a.ItemType.RawClay,
            chance: 55,
            tileChange: a.TerrainType.Dirt,
            tileChangeChance: 10
        }],
        defaultItem: a.ItemType.RawClay
    },
    t.resource[a.TerrainType.Grass] = {
        items: [{
            type: a.ItemType.PlantRoots,
            chance: 3,
            tileChange: a.TerrainType.Dirt,
            tileChangeChance: 20
        }, {
            type: a.ItemType.GrassSeeds,
            chance: 45,
            tileChange: a.TerrainType.Dirt,
            tileChangeChance: 90
        }],
        disableWaterRouting: !0
    },
    t.resource[a.TerrainType.BeachSand] = {
        items: [{
            type: a.ItemType.PileOfBeachSand,
            chance: 65,
            tileChange: a.TerrainType.Clay,
            tileChangeChance: 15
        }],
        defaultItem: a.ItemType.PileOfBeachSand
    },
    t.resource[a.TerrainType.Gravel] = {
        items: [{
            type: a.ItemType.PileOfGravel,
            chance: 2,
            tileChange: a.TerrainType.ShallowFreshWater
        }, {
            type: a.ItemType.Stones,
            chance: 5
        }, {
            type: a.ItemType.Shale,
            chance: 10
        }, {
            type: a.ItemType.PileOfGravel,
            chance: 50,
            tileChange: a.TerrainType.Clay,
            tileChangeChance: 10
        }],
        defaultItem: a.ItemType.PileOfGravel
    },
    t.resource[a.TerrainType.Swamp] = {
        items: [{
            type: a.ItemType.Peat,
            chance: 2,
            tileChange: a.TerrainType.ShallowFreshWater
        }, {
            type: a.ItemType.PlantRoots,
            chance: 5
        }, {
            type: a.ItemType.Peat,
            chance: 45,
            tileChange: a.TerrainType.Dirt,
            tileChangeChance: 50
        }],
        defaultItem: a.ItemType.Peat
    },
    t.resource[a.TerrainType.CobblestoneFlooring] = {
        items: [{
            type: a.ItemType.CobblestoneFlooring,
            chance: 70,
            tileChange: a.TerrainType.Dirt
        }],
        defaultItem: a.ItemType.CobblestoneFlooring,
        disableWaterRouting: !0
    },
    t.resource[a.TerrainType.SandstoneFlooring] = {
        items: [{
            type: a.ItemType.SandstoneFlooring,
            chance: 70,
            tileChange: a.TerrainType.Gravel
        }],
        defaultItem: a.ItemType.SandstoneFlooring,
        disableWaterRouting: !0
    },
    t.resource[a.TerrainType.Snow] = {
        items: [{
            type: a.ItemType.PileOfSnow,
            chance: 80,
            tileChange: a.TerrainType.Dirt
        }]
    },
    t.resource[a.TerrainType.Ash] = {
        items: [{
            type: a.ItemType.PileOfAsh,
            chance: 70,
            tileChange: a.TerrainType.Dirt,
            tileChangeChance: 50
        }],
        defaultItem: a.ItemType.PileOfAsh
    },
    t.resource[a.TerrainType.ShallowSeawater] = {
        items: [{
            type: a.ItemType.PileOfBeachSand,
            chance: 30,
            tileChange: a.TerrainType.Seawater,
            tileChangeChance: 75
        }]
    },
    t.resource[a.TerrainType.ShallowFreshWater] = {
        items: [{
            type: a.ItemType.Soil,
            chance: 30,
            tileChange: a.TerrainType.FreshWater,
            tileChangeChance: 75
        }]
    },
    t.resource[a.TerrainType.CaveEntrance] = {
        items: [{
            type: a.ItemType.Soil,
            chance: 45,
            tileChange: a.TerrainType.Dirt
        }]
    },
    t.resource[a.TerrainType.ClayBrickFlooring] = {
        items: [{
            type: a.ItemType.ClayBrickFlooring,
            chance: 70,
            tileChange: a.TerrainType.DesertSand
        }],
        defaultItem: a.ItemType.ClayBrickFlooring,
        disableWaterRouting: !0
    },
    t.resource[a.TerrainType.RedCarpet] = {
        items: [{
            type: a.ItemType.RollOfRedCarpet,
            chance: 80,
            tileChange: a.TerrainType.Dirt
        }],
        defaultItem: a.ItemType.RollOfRedCarpet,
        disableWaterRouting: !0
    },
    t.resource[a.TerrainType.Lava] = {
        items: [{
            type: a.ItemType.Obsidian,
            chance: 45,
            tileChange: a.TerrainType.CoolingLava,
            tileChangeChance: 85
        }],
        disableWaterRouting: !0
    },
    t.resource[a.TerrainType.FertileSoil] = {
        items: [{
            type: a.ItemType.FertileSoil,
            chance: 65,
            tileChange: a.TerrainType.Dirt
        }],
        defaultItem: a.ItemType.FertileSoil
    },
    t.resource[a.TerrainType.RocksWithCopper] = {
        items: [{
            type: a.ItemType.LargeRock
        }, {
            type: a.ItemType.CopperOre
        }, {
            type: a.ItemType.Stones,
            chance: 25
        }, {
            type: a.ItemType.CopperOre
        }, {
            type: a.ItemType.LargeRock,
            chance: 25
        }, {
            type: a.ItemType.CopperOre
        }, {
            type: a.ItemType.CopperOre
        }, {
            type: a.ItemType.CopperOre,
            chance: 50
        }, {
            type: a.ItemType.CopperOre
        }, {
            type: a.ItemType.LargeRock
        }]
    },
    t.resource[a.TerrainType.SandstoneWithCopper] = {
        items: [{
            type: a.ItemType.Sandstone
        }, {
            type: a.ItemType.CopperOre
        }, {
            type: a.ItemType.PileOfGravel,
            chance: 10
        }, {
            type: a.ItemType.CopperOre
        }, {
            type: a.ItemType.Sandstone,
            chance: 25
        }, {
            type: a.ItemType.CopperOre
        }, {
            type: a.ItemType.CopperOre
        }, {
            type: a.ItemType.CopperOre,
            chance: 50
        }, {
            type: a.ItemType.CopperOre
        }, {
            type: a.ItemType.Sandstone
        }]
    },
    t.resource[a.TerrainType.CoolingLava] = {
        items: [{
            type: a.ItemType.Obsidian,
            chance: 2,
            tileChange: a.TerrainType.Lava
        }, {
            type: a.ItemType.Obsidian,
            chance: 45,
            tileChange: a.TerrainType.Obsidian,
            tileChangeChance: 85
        }],
        disableWaterRouting: !0
    },
    t.resource[a.TerrainType.Obsidian] = {
        items: [{
            type: a.ItemType.Obsidian,
            chance: 45,
            tileChange: a.TerrainType.Dirt,
            tileChangeChance: 50
        }]
    },
    t.resource[a.TerrainType.DesertSand] = {
        items: [{
            type: a.ItemType.PileOfDesertSand,
            chance: 65,
            tileChange: a.TerrainType.Clay,
            tileChangeChance: 15
        }],
        defaultItem: a.ItemType.PileOfDesertSand
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/quest/Challenge", ["require", "exports", "creature/Creatures", "creature/ICreature", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "player/quest/quest/IQuest", "player/quest/quest/Quest", "player/quest/requirement/IRequirement", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Objects", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class y extends u.Quest {
        constructor() {
            super(l.QuestType.Challenge),
            this.existingRequirements = new Map,
            this.possibleRequirements = [...y.possibleRequirements],
            this.on(0, this.onUpdate),
            this.on(1, this.onRequirementComplete)
        }
        static getCreaturesOfRequirements() {
            return players.values().flatMap(e=>e.quests.getQuests(l.QuestType.Challenge).values().flatMap(e=>e.getRequirements()).filter(e=>!e.data.completed && (e.data.type === d.RequirementType.KillCreature || e.data.type === d.RequirementType.TameCreature)).map(e=>e.data.options[0]))
        }
        createRequirements() {
            return this.existingRequirements.clear(),
            this.possibleRequirements.splice(0, 1 / 0),
            this.possibleRequirements.push(...y.possibleRequirements),
            super.createRequirements().include(c.range(3).map(this.createRandomRequirement).flatMap()).include([Object.assign({}, this.createRequirement(d.RequirementType.SailToCivilization), {
                hidden: !0
            })])
        }
        createRandomRequirement() {
            const e = h.default.choice(...this.possibleRequirements)
              , t = (...t)=>{
                t.length || t.push(e);
                for (const e of t)
                    this.possibleRequirements.splice(this.possibleRequirements.indexOf(e), 1)
            }
              , i = this.existingRequirements.get(e) || [];
            switch (this.existingRequirements.set(e, i),
            e) {
            case d.RequirementType.LearnSkill:
                {
                    const a = h.default.choice(...y.skillLearnWhitelist.filter(e=>!i.includes(e)));
                    return i.push(a),
                    t(d.RequirementType.LearnAnySkill),
                    this.createRequirement(e, a, h.default.intInRange(10, 20))
                }
            case d.RequirementType.LearnSkills:
                return t(),
                this.createRequirement(e, h.default.intInRange(90, 120));
            case d.RequirementType.LearnAnySkill:
                return t(d.RequirementType.LearnSkill, d.RequirementType.LearnAnySkill),
                this.createRequirement(e, h.default.intInRange(15, 25));
            case d.RequirementType.KillCreature:
                {
                    const t = this.getSpawnableCreatures()
                      , a = h.default.choice(...t.filter(e=>!y.creatureKillBlacklist.includes(e)&&!i.includes(e)));
                    i.push(a);
                    const n = this.existingRequirements.get(d.RequirementType.TameCreature) || [];
                    return this.existingRequirements.set(d.RequirementType.TameCreature, n),
                    n.push(a),
                    [this.createRequirement(e, a, h.default.intInRange(2, 3))]
                }
            case d.RequirementType.KillCreatures:
                return t(),
                [this.createRequirement(e, h.default.intInRange(8, 14))];
            case d.RequirementType.TameCreature:
                {
                    const t = this.getSpawnableCreatures()
                      , n = h.default.choice(...t.filter(e=>!y.creatureTameBlacklist.includes(e)&&!i.includes(e)&&a.default [e].tamingDifficulty));
                    i.push(n);
                    const o = this.existingRequirements.get(d.RequirementType.KillCreature) || [];
                    return this.existingRequirements.set(d.RequirementType.KillCreature, o),
                    o.push(n),
                    [this.createRequirement(e, n, h.default.intInRange(2, 3))]
                }
            case d.RequirementType.TameCreatures:
                return t(),
                [this.createRequirement(e, h.default.intInRange(8, 14))];
            case d.RequirementType.CollectItem:
                {
                    const t = h.default.choice(...y.itemCollectWhitelist.filter(e=>!i.includes(e)));
                    return i.push(t),
                    [this.createRequirement(e, [t], h.default.intInRange(4, 6))]
                }
            }
            throw new Error
        }
        onUpdate(e, t) {
            t.getRequirements().any(e=>e.data.type !== d.RequirementType.SailToCivilization && !e.data.completed) || t.getRequirements().filter(e=>e.data.type === d.RequirementType.SailToCivilization).forEach(e=>e.setVisible())
        }
        onRequirementComplete(e, t, a) {
            t.host.score += 1e4;
            const i = t.getRequirements().filter(e=>!e.data.completed).collect(p.default.toArray).length;
            if (0 !== i)
                for (const e of players)
                    e.messages.type(e === t.host ? s.MessageType.Good : s.MessageType.Bad).source(r.Source.Multiplayer, r.Source.Meta).send(o.default.PlayerHasCompletedChallengeRequirement, e !== t.host && t.host.getName(), a.getTranslation(), i)
        }
        getSpawnableCreatures() {
            const e = game.getDifficultyOptions()
              , t = e.player.reputation
              , a = t.initialBenignity - t.initialMalignity
              , o = e.time.initial
              , {pool: r} = creatureManager.getSpawnableCreatures(i.SpawnGroup.Any, n.WorldZ.Overworld, a, o);
            return r
        }
    }
    y.possibleRequirements = [d.RequirementType.CollectItem, d.RequirementType.KillCreature, d.RequirementType.KillCreatures, d.RequirementType.LearnSkill, d.RequirementType.LearnSkills, d.RequirementType.LearnAnySkill, d.RequirementType.TameCreature, d.RequirementType.TameCreatures],
    y.itemCollectWhitelist = [n.ItemType.AnimalSkull, n.ItemType.StoneArrow, n.ItemType.StoneArrowhead, n.ItemType.PileOfAsh, n.ItemType.BarkLeggings, n.ItemType.BarkShield, n.ItemType.BarkTunic, n.ItemType.Bone, n.ItemType.Branch, n.ItemType.Charcoal, n.ItemType.CobblestoneFlooring, n.ItemType.CookedMeat, n.ItemType.Earthworm, n.ItemType.Feather, n.ItemType.Fertilizer, n.ItemType.FirePlough, n.ItemType.GrassSeeds, n.ItemType.IronOre, n.ItemType.WoodenDowels, n.ItemType.LargeRock, n.ItemType.LeafBedroll, n.ItemType.LeatherHide, n.ItemType.Leaves, n.ItemType.Limestone, n.ItemType.Log, n.ItemType.StoneMortarAndPestle, n.ItemType.Sandstone, n.ItemType.PileOfGravel, n.ItemType.PileOfBeachSand, n.ItemType.WoodenArrow, n.ItemType.StoneAxe, n.ItemType.Bandage, n.ItemType.WovenFabric, n.ItemType.StoneShovel, n.ItemType.WoodenSpear, n.ItemType.Suture, n.ItemType.Raft, n.ItemType.RawMeat, n.ItemType.Rope, n.ItemType.MapleSeeds, n.ItemType.SharpGlass, n.ItemType.SharpRock, n.ItemType.Skullcap, n.ItemType.SmoothRock, n.ItemType.Soil, n.ItemType.StoneSpear, n.ItemType.Stones, n.ItemType.StoneWall, n.ItemType.String, n.ItemType.StrippedBark, n.ItemType.TannedLeather, n.ItemType.Tannin, n.ItemType.TreeBark, n.ItemType.Twigs, n.ItemType.Waterskin, n.ItemType.WoodenPole, n.ItemType.Bow, n.ItemType.BowDrill, n.ItemType.FishingNet, n.ItemType.RawCod, n.ItemType.CookedCod, n.ItemType.StoneCampfire, n.ItemType.BarkTorch, n.ItemType.HandDrill, n.ItemType.SmallBag, n.ItemType.Shale, n.ItemType.SharpenedBone, n.ItemType.Grindstone, n.ItemType.RawFishSteak, n.ItemType.CookedFishSteak, n.ItemType.BoatPaddle, n.ItemType.BullBoat, n.ItemType.RefinedSand, n.ItemType.RawClay, n.ItemType.RawClayBlowpipe, n.ItemType.ClayBlowpipe, n.ItemType.LeatherBelt, n.ItemType.LeatherTunic, n.ItemType.LeatherBoots, n.ItemType.LeatherCap, n.ItemType.LeatherGorget, n.ItemType.LeatherPants, n.ItemType.LeatherGloves, n.ItemType.StoneFurnace, n.ItemType.SandstoneKiln, n.ItemType.Talc, n.ItemType.TalcumPowder, n.ItemType.WoodenSandCastFlask, n.ItemType.PlantRoots, n.ItemType.LockPick, n.ItemType.BoneNeedle, n.ItemType.Coal, n.ItemType.WroughtIron, n.ItemType.LimestonePowder, n.ItemType.IronIngot, n.ItemType.Backpack, n.ItemType.RottenMeat, n.ItemType.StoneHammer, n.ItemType.StoneAnvil, n.ItemType.WoodenChest, n.ItemType.SandstoneWall, n.ItemType.SandstoneFlooring, n.ItemType.SpiderSilk, n.ItemType.AnimalFat, n.ItemType.AnimalFatTorch, n.ItemType.ClayFlakes, n.ItemType.GreenSand, n.ItemType.SlimeGelatin, n.ItemType.SlimeGlue, n.ItemType.CookedSpiderMeat, n.ItemType.SpiderMeat, n.ItemType.RottingVegetation, n.ItemType.PalmLeaf, n.ItemType.Offal, n.ItemType.BoneFragments, n.ItemType.BonePole, n.ItemType.Tourniquet, n.ItemType.WoodenWall, n.ItemType.WoodenFlooring, n.ItemType.WoodenDoor, n.ItemType.FishingRod, n.ItemType.CarbonPowder, n.ItemType.PileOfCompost, n.ItemType.WoodenShavings, n.ItemType.Deadfall, n.ItemType.Snare, n.ItemType.WoodenTongs, n.ItemType.Sundial, n.ItemType.Sinew, n.ItemType.ShortBow, n.ItemType.LongBow, n.ItemType.CompositeBow, n.ItemType.Cork, n.ItemType.StoneBullet, n.ItemType.LeatherQuiver, n.ItemType.WoodenFence, n.ItemType.CordedSling, n.ItemType.LeatherSling, n.ItemType.Hammock, n.ItemType.StoneKnife, n.ItemType.Pemmican, n.ItemType.PreparedPemmican, n.ItemType.Giblets, n.ItemType.RawClayJug, n.ItemType.ClayJug, n.ItemType.RawClayBrick, n.ItemType.ClayBrick, n.ItemType.ClayBrickWall, n.ItemType.ClayBrickFlooring, n.ItemType.WoodenGate, n.ItemType.Apple, n.ItemType.WoodenSword, n.ItemType.ClayKiln, n.ItemType.ClayCampfire, n.ItemType.ClayFurnace, n.ItemType.ClayWaterStill, n.ItemType.SandstoneCampfire, n.ItemType.SandstoneFurnace, n.ItemType.SandstoneWaterStill, n.ItemType.StoneKiln, n.ItemType.AnimalClaw, n.ItemType.AnimalPelt, n.ItemType.AnimalFur, n.ItemType.Scales, n.ItemType.SharkFin, n.ItemType.RawReptileMeat, n.ItemType.CookedReptileMeat, n.ItemType.StonePickaxe, n.ItemType.FertileSoil, n.ItemType.StoneHoe, n.ItemType.SpruceCone, n.ItemType.SpruceSeeds, n.ItemType.SpruceNeedles, n.ItemType.CypressCone, n.ItemType.CypressSeeds, n.ItemType.CypressLeaves, n.ItemType.WoodenMortarAndPestle, n.ItemType.SandstoneMortarAndPestle, n.ItemType.RawClayMortarAndPestle, n.ItemType.ClayMortarAndPestle, n.ItemType.CopperOre, n.ItemType.CopperIngot, n.ItemType.ArrowShaft, n.ItemType.StrippedLeather, n.ItemType.ClaySandCastFlask, n.ItemType.SandstoneSandCastFlask, n.ItemType.StoneSandCastFlask, n.ItemType.AnimalGlue, n.ItemType.BoneMeal, n.ItemType.PileOfDesertSand, n.ItemType.HitchingPost],
    y.skillLearnWhitelist = [n.SkillType.Anatomy, n.SkillType.Marksmanship, n.SkillType.Botany, n.SkillType.Camping, n.SkillType.Claythrowing, n.SkillType.Cooking, n.SkillType.Fishing, n.SkillType.Fletching, n.SkillType.Leatherworking, n.SkillType.Lumberjacking, n.SkillType.Mining, n.SkillType.Parrying, n.SkillType.Stonecrafting, n.SkillType.Swimming, n.SkillType.Tactics, n.SkillType.Tailoring, n.SkillType.Throwing, n.SkillType.Tinkering, n.SkillType.Trapping, n.SkillType.Woodworking, n.SkillType.Taming, n.SkillType.Gardening],
    y.creatureKillBlacklist = [],
    y.creatureTameBlacklist = [],
    __decorate([Override], y.prototype, "createRequirements", null),
    __decorate([m.Bound], y.prototype, "createRandomRequirement", null),
    __decorate([m.Bound], y.prototype, "onUpdate", null),
    __decorate([m.Bound], y.prototype, "onRequirementComplete", null),
    t.default = y
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/Quests", ["require", "exports", "player/quest/quest/Challenge", "player/quest/quest/IQuest"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const n = {
        [i.QuestType.Challenge]: new a.default
    };
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/enum/EnumManager", ["require", "exports", "action/Actions", "action/IAction", "audio/Music", "audio/SoundEffects", "creature/Creatures", "doodad/Doodads", "entity/IStats", "entity/StatusEffects", "Enums", "game/Challenge", "game/inspection/IInspection", "game/inspection/Inspections", "item/Items", "language/Dictionaries", "language/dictionary/InterruptChoice", "language/dictionary/Message", "language/dictionary/Note", "mod/IModInfo", "newui/screen/screens/game/Dialogs", "newui/screen/screens/game/static/menubar/MenuBarButtonDescriptions", "newui/screen/screens/game/static/stats/StatDisplayDescriptions", "newui/screen/screens/menu/menus/help/HelpArticleDescriptions", "player/Customizations", "player/IMessageManager", "player/note/NoteManager", "player/quest/quest/IQuest", "player/quest/Quests", "player/quest/requirement/IRequirement", "player/quest/Requirements", "player/Skills", "renderer/Overlays", "tile/ITileEvent", "tile/Terrains", "tile/TileEvents", "utilities/enum/Enums", "utilities/enum/IEnum", "utilities/Log"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L, O, F, _) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const H = new _.default(_.LogSource.EnumManager);
    var W;
    !function(e) {
        const t = {}
          , W = {};
        function N() {
            for (const e in saveDataGlobal.utilitiesEnumsAllocated)
                saveDataGlobal.utilitiesEnumsAllocated[e].modIndex = void 0;
            U(F.EnumId.CreatureType, d.CreatureType, r.default),
            U(F.EnumId.Bindable, d.Bindable, void 0),
            U(F.EnumId.ActionType, i.ActionType, a.default),
            U(F.EnumId.ItemType, d.ItemType, h.itemDescriptions),
            U(F.EnumId.TerrainType, d.TerrainType, E.default, 50),
            U(F.EnumId.DoodadType, d.DoodadType, s.default),
            U(F.EnumId.Message, f.default, void 0),
            U(F.EnumId.SkillType, d.SkillType, R.skillDescriptions),
            U(F.EnumId.HairStyle, d.HairStyle, b.hairstyleDescriptions),
            U(F.EnumId.HairColor, d.HairColor, b.hairColorDescriptions),
            U(F.EnumId.SkinColor, d.SkinColor, b.skinColorDescriptions),
            U(F.EnumId.Dictionary, y.Dictionary, void 0),
            U(F.EnumId.Music, d.Music, n.musicDescriptions),
            U(F.EnumId.SoundEffect, d.SfxType, o.soundEffectDescriptions),
            U(F.EnumId.Command, d.Command, void 0),
            U(F.EnumId.Stat, l.Stat, w.default),
            U(F.EnumId.StatusEffect, d.StatusType, u.default),
            U(F.EnumId.MenuBarButton, v.MenuBarButtonType, v.default),
            U(F.EnumId.TileEventType, B.TileEventType, L.default),
            U(F.EnumId.OverlayType, d.OverlayType, x.overlayDescriptions),
            U(F.EnumId.MessageSource, k.Source, void 0),
            U(F.EnumId.NPCType, d.NPCType, void 0, 100),
            U(F.EnumId.HelpArticle, M.HelpArticle, M.default),
            U(F.EnumId.Note, T.default, C.noteDescriptions),
            U(F.EnumId.Dialog, I.DialogId, I.default),
            U(F.EnumId.InterruptChoice, g.default, void 0),
            U(F.EnumId.ItemTypeGroup, d.ItemTypeGroup, h.itemGroupDescriptions, 4e3),
            U(F.EnumId.InspectType, c.InspectType, m.default, 100),
            U(F.EnumId.DailyChallengeModifier, p.ChallengeModifier, p.default),
            U(F.EnumId.Quest, D.QuestType, A.default),
            U(F.EnumId.QuestRequirement, P.RequirementType, G.default)
        }
        function q() {
            saveData.utilitiesEnumsAllocated = {}
        }
        function U(e, a, i, n=1e4) {
            t[e] = a,
            W[e] = i,
            a[F.EnumProperty.NAME] = F.EnumId[e],
            a[F.EnumProperty.OFFICIAL_MAX] = O.default.keys(a).reduce((e,t)=>t + 1, 0),
            a[F.EnumProperty.MOD_START] = n
        }
        function z() {
            H.info("Restoring enums");
            for (const e in saveData.utilitiesEnumsAllocated)
                delete saveData.utilitiesEnumsAllocated[e].modIndex,
                Q(saveData.utilitiesEnumsAllocated[e], void 0, "restore")
        }
        function V() {
            H.info("Resetting enums");
            for (const e in saveData.utilitiesEnumsAllocated)
                Y(saveData.utilitiesEnumsAllocated[e]);
            saveData.utilitiesEnumsAllocated = {}
        }
        function j(e, a, i, n, o, r) {
            const s = t[a];
            if (!s)
                return void $(e).error(`Invalid enumeration object [${a}.${i}]`);
            if (!O.default.isModdable(s))
                return void $(e).error(`Enumeration is not moddable [${a}.${i}]`);
            let l = -1;
            i = i.replace(/(?!#)\W/g, "");
            const u = F.EnumId[a].toString()
              , d = `${u},`
              , p = `${d}${i}`
              , c = modManager.getState(e)
              , m = c === S.ModState.ChangingState
              , h = m ? saveDataGlobal.utilitiesEnumsAllocated : saveData.utilitiesEnumsAllocated
              , y = h[p];
            let g;
            if (y)
                g = "existing",
                l = y.enumNumber;
            else {
                g = "new",
                l = parseInt(s[F.EnumProperty.MOD_START], 10);
                for (const e in h)
                    if (e.startsWith(d)) {
                        const t = h[e].enumNumber;
                        l < t && (l = t)
                    }
                l++
            }
            const f = {
                enumId: a,
                enumName: u,
                enumNumber: l,
                name: i,
                modIndex: e,
                modName: modManager.getName(e),
                onUnallocate: r
            };
            return Q(f, n, g),
            o && o(l),
            h[p] = f,
            f
        }
        function Q(e, a, i) {
            const n = t[e.enumId];
            if (!n)
                return;
            const o = e.name.replace(/(?!#)\W/g, "");
            n[o] = e.enumNumber,
            n[e.enumNumber] = o,
            delete n[F.EnumProperty.LENGTH];
            const r = W[e.enumId];
            r && a && (r[e.enumNumber] = "function" == typeof a ? a(e.enumNumber) : a),
            $(e.modIndex, e).info(`Allocate [${F.EnumId[e.enumId]}.${e.name}]: ${e.enumNumber} (${i})`)
        }
        function $(e, t) {
            const a = void 0 === e ? t && t.modName || "Unknown" : modManager.getName(e);
            return new _.default(_.LogSource.EnumManager,a)
        }
        function Y(e) {
            const a = t[e.enumId];
            if (!a)
                return;
            const i = e.name.replace(/(?!#)\W/g, "");
            if (void 0 === a[i] && void 0 === a[e.enumNumber] && void 0 === e.onUnallocate)
                return;
            delete a[i],
            delete a[e.enumNumber],
            delete a[F.EnumProperty.LENGTH];
            const n = W[e.enumId];
            n && e.enumNumber in n && delete n[e.enumNumber],
            $(e.modIndex, e).info(`Unallocate [${F.EnumId[e.enumId]}.${e.name}]: ${e.enumNumber}`),
            e.onUnallocate && (e.onUnallocate(e.enumNumber),
            delete e.onUnallocate),
            delete e.modIndex
        }
        function J(e) {
            for (const t in saveDataGlobal.utilitiesEnumsAllocated) {
                const a = saveDataGlobal.utilitiesEnumsAllocated[t];
                a.modIndex === e && Y(a)
            }
        }
        e.initialize = N,
        e.initializeGameState = q,
        e.restore = z,
        e.reset = V,
        e.allocate = j,
        e.unallocate = Y,
        e.unallocateMod = J
    }(W || (W = {})),
    t.default = W
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/BaseMod", ["require", "exports", "creature/corpse/Corpses", "Enums", "item/Items", "language/Dictionaries", "mod/IMod", "mod/IModInfo", "mod/InterModRegistry", "mod/InterModRegistryManager", "mod/ModRegistry", "multiplayer/packets/Packets", "newui/BindingManager", "newui/screen/screens/game/DialogMap", "newui/screen/screens/menu/menus/options/TabMods", "npc/NPCS", "tile/TerrainResources", "utilities/Emitter", "utilities/enum/EnumManager", "utilities/enum/IEnum", "utilities/Objects", "utilities/string/Strings"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v) {
    var w;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Setup = 0] = "Setup",
        e[e.Initialize = 1] = "Initialize",
        e[e.Load = 2] = "Load"
    }(w || (w = {}));
    const M = {
        [d.ModRegistrationType.Action]: w.Load,
        [d.ModRegistrationType.Bindable]: w.Initialize,
        [d.ModRegistrationType.Command]: w.Load,
        [d.ModRegistrationType.Creature]: w.Load,
        [d.ModRegistrationType.DailyChallengeModifier]: w.Initialize,
        [d.ModRegistrationType.Dialog]: w.Initialize,
        [d.ModRegistrationType.Dictionary]: w.Initialize,
        [d.ModRegistrationType.Doodad]: w.Load,
        [d.ModRegistrationType.HelpArticle]: w.Load,
        [d.ModRegistrationType.InspectionType]: w.Load,
        [d.ModRegistrationType.InterModRegistration]: w.Initialize,
        [d.ModRegistrationType.InterModRegistry]: w.Initialize,
        [d.ModRegistrationType.InterruptChoice]: w.Initialize,
        [d.ModRegistrationType.Item]: w.Load,
        [d.ModRegistrationType.ItemGroup]: w.Load,
        [d.ModRegistrationType.Language]: w.Setup,
        [d.ModRegistrationType.LanguageExtension]: w.Setup,
        [d.ModRegistrationType.MenuBarButton]: w.Load,
        [d.ModRegistrationType.Message]: w.Load,
        [d.ModRegistrationType.MessageSource]: w.Load,
        [d.ModRegistrationType.MusicTrack]: w.Initialize,
        [d.ModRegistrationType.Note]: w.Load,
        [d.ModRegistrationType.NPC]: w.Load,
        [d.ModRegistrationType.OptionsSection]: w.Initialize,
        [d.ModRegistrationType.Overlay]: w.Initialize,
        [d.ModRegistrationType.Packet]: w.Initialize,
        [d.ModRegistrationType.Quest]: w.Initialize,
        [d.ModRegistrationType.QuestRequirement]: w.Initialize,
        [d.ModRegistrationType.Registry]: w.Initialize,
        [d.ModRegistrationType.Skill]: w.Load,
        [d.ModRegistrationType.SoundEffect]: w.Initialize,
        [d.ModRegistrationType.Terrain]: w.Load,
        [d.ModRegistrationType.TileEvent]: w.Load
    };
    class b extends f.default {
        constructor(e) {
            super(),
            this.allocatedEnums = [],
            this.registeredPackets = [],
            this.subRegistries = [],
            this.index = e,
            this.on(r.ModEvent.Setup, ()=>{
                this.initializeRegistry(w.Setup, this)
            }
            ),
            this.on(r.ModEvent.PreInitialize, this.onBeforeInitialize),
            this.on(r.ModEvent.PreLoad, this.onBeforeLoad),
            this.on(r.ModEvent.Unallocate, this.onUnallocate)
        }
        getIndex() {
            return this.index
        }
        getName() {
            return modManager.getName(this.index)
        }
        getLog() {
            return modManager.getLog(this.index)
        }
        getPath() {
            return modManager.getPath(this.index)
        }
        loadFile(e, t) {
            return modManager.getFile(this.index, e, t),
            !0
        }
        initializeSaveData(e) {
            return e || {}
        }
        initializeGlobalData(e) {
            return e || {}
        }
        onUnallocate() {
            for (const e of this.allocatedEnums)
                T.default.unallocate(e);
            this.allocatedEnums = [];
            for (const e of this.registeredPackets)
                p.registrar.unregister(e);
            this.registeredPackets = []
        }
        async onBeforeInitialize(e) {
            e[d.SYMBOL_MOD_REGISTRATIONS] && this.initializeRegistry(w.Initialize, e)
        }
        onBeforeLoad(e) {
            if (e[d.SYMBOL_MOD_REGISTRATIONS]) {
                this.initializeRegistry(w.Load, e);
                for (const e of this.subRegistries)
                    this.initializeRegistry(w.Load, e)
            }
        }
        initializeRegistry(e, t) {
            const a = t[d.SYMBOL_MOD_REGISTRATIONS];
            if (a)
                for (const i of a)
                    if (M[i.type] === e)
                        try {
                            this.register(t, i)
                        } catch (e) {
                            this.getLog().warn(`Unable to register ${d.ModRegistrationType[i.type]} "${"name"in i ? i.name : i.key}"`),
                            this.getLog().warn(e)
                        }
        }
        register(e, t) {
            this.validateRegistration(e, t);
            const s = t.description
              , f = "name"in t ? `Mod${this.getName()}${v.default.formatCaseStyle(t.name, i.CaseStyle.PascalCase)}`.replace(/\W/g, "") : ""
              , T = t;
            switch (T.description = T.description || {},
            T.description.modIndex = this.index,
            t.type) {
            case d.ModRegistrationType.LanguageExtension:
            case d.ModRegistrationType.Language:
                {
                    const a = modManager.getModFromIndex(this.index);
                    a.provides[t.type === d.ModRegistrationType.Language ? "languages" : "languageExtensions"]++,
                    a.languages = a.languages || [],
                    a.languages.some(e=>e.instance === t.instance) || a.languages.push({
                        instance: t.instance
                    }),
                    this.setRegistrationPropertyValue(e, t.key, t.instance);
                    break
                }
            case d.ModRegistrationType.Command:
                {
                    const a = this.getRegistrationPropertyValue(e, t.key);
                    t.registrationId = a[d.SYMBOL_REGISTRATION_ID] = this.allocateEnum(S.EnumId.Command, f, void 0, t=>{
                        commandManager.add({
                            type: t,
                            callback: a.bind(e)
                        })
                    }
                    , e=>{
                        commandManager.remove(e)
                    }
                    );
                    break
                }
            case d.ModRegistrationType.Bindable:
                {
                    const a = t;
                    t.registrationId = this.allocateEnum(S.EnumId.Bindable, f, void 0, e=>{
                        c.bindingManager.registerBindable(e, a.defaultBindings)
                    }
                    , e=>{
                        c.bindingManager.deregisterBindable(e)
                    }
                    ),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            case d.ModRegistrationType.Dictionary:
                {
                    const a = t.dictionaryEnum;
                    t.registrationId = this.allocateEnum(S.EnumId.Dictionary, f, a, e=>o.default[e] = a, e=>delete o.default[e]),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            case d.ModRegistrationType.OptionsSection:
                {
                    const a = this.getRegistrationPropertyValue(e, t.key);
                    h.default.registerModOptions(this.index, a.bind(e));
                    break
                }
            case d.ModRegistrationType.Registry:
                {
                    const a = new t.class(this);
                    this.setRegistrationPropertyValue(e, t.key, a),
                    a[d.SYMBOL_MOD_REGISTRATIONS] && (this.subRegistries.push(a),
                    this.onBeforeInitialize(a));
                    break
                }
            case d.ModRegistrationType.Dialog:
                {
                    const a = t;
                    t.registrationId = this.allocateEnum(S.EnumId.Dialog, f, t.description, e=>{
                        m.default[e] = a.class
                    }
                    , e=>{
                        delete m.default[e]
                    }
                    ),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            case d.ModRegistrationType.Creature:
                {
                    const i = t.corpseDescription || {};
                    i.modIndex = this.index,
                    t.registrationId = this.allocateEnum(S.EnumId.CreatureType, f, t.description, e=>a.corpseDescriptions[e] = i, e=>delete a.corpseDescriptions[e]),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            case d.ModRegistrationType.Terrain:
                {
                    const a = t.description
                      , {resources: i, defaultItem: n} = a;
                    t.registrationId = this.allocateEnum(S.EnumId.TerrainType, f, a, e=>{
                        Object.defineProperty(a, "terrainType", {
                            value: e,
                            configurable: !0
                        }),
                        i && this.addTerrainResource(e, i, n)
                    }
                    , e=>delete g.default[e]),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            case d.ModRegistrationType.MusicTrack:
                t.registrationId = this.allocateEnum(S.EnumId.Music, f, {
                    modIndex: this.index
                }),
                this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                break;
            case d.ModRegistrationType.SoundEffect:
                t.registrationId = this.allocateEnum(S.EnumId.SoundEffect, f, {
                    modIndex: this.index,
                    variations: t.variations
                }),
                this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                break;
            case d.ModRegistrationType.Packet:
                p.registrar.register(t.class),
                this.registeredPackets.push(t.class),
                this.setRegistrationPropertyValue(e, t.key, t.class);
                break;
            case d.ModRegistrationType.NPC:
                {
                    const e = t.class;
                    t.registrationId = this.allocateEnum(S.EnumId.NPCType, f, void 0, t=>{
                        y.registrar.register(e, t)
                    }
                    , ()=>{
                        y.registrar.unregister(e)
                    }
                    );
                    break
                }
            case d.ModRegistrationType.Action:
                {
                    const a = t.description = s;
                    a.modIndex = this.index,
                    t.registrationId = this.allocateEnum(S.EnumId.ActionType, f, a, e=>{
                        a.type = e
                    }
                    ),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            case d.ModRegistrationType.Quest:
                {
                    const a = t.description = s;
                    a.modIndex = this.index,
                    t.registrationId = this.allocateEnum(S.EnumId.Quest, f, a, e=>{
                        a.type = e
                    }
                    ),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            case d.ModRegistrationType.QuestRequirement:
                {
                    const a = t.description = s;
                    a.modIndex = this.index,
                    t.registrationId = this.allocateEnum(S.EnumId.QuestRequirement, f, a, e=>{
                        a.type = e
                    }
                    ),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            case d.ModRegistrationType.InspectionType:
                {
                    let a = t.description = s;
                    "function" == typeof a && (a = {
                        handle: a
                    }),
                    a.modIndex = this.index,
                    t.registrationId = this.allocateEnum(S.EnumId.InspectType, f, a, e=>{
                        a.type = e
                    }
                    ),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            case d.ModRegistrationType.InterModRegistry:
                {
                    const a = t.name
                      , i = new l.default(this.getName(),a);
                    this.setRegistrationPropertyValue(e, t.key, i),
                    u.default.registerRegistry(this.getName(), a, i),
                    this.once(r.ModEvent.Uninitialize, ()=>{
                        u.default.deregisterRegistry(this.getName(), a)
                    }
                    );
                    break
                }
            case d.ModRegistrationType.InterModRegistration:
                {
                    const a = t.registryName
                      , i = t.modName
                      , n = new l.InterModRegistration(this.getName(),t.value);
                    this.setRegistrationPropertyValue(e, t.key, n),
                    u.default.register(i, a, n),
                    this.once(r.ModEvent.Uninitialize, ()=>{
                        u.default.deregister(i, a, n)
                    }
                    );
                    break
                }
            case d.ModRegistrationType.Item:
                {
                    const a = "description"in t ? t.description : void 0
                      , i = a && a.groups;
                    t.registrationId = this.allocateEnum(S.EnumId.ItemType, f, a, i && i.length ? e=>{
                        for (const t of i)
                            n.itemGroupDescriptions[t].types.push(e)
                    }
                    : void 0, i && i.length ? e=>{
                        for (const t of i) {
                            const a = n.itemGroupDescriptions[t].types
                              , i = a.indexOf(e);
                            i >= 0 && a.splice(i, 1)
                        }
                    }
                    : void 0),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            default:
                {
                    const a = k[t.type];
                    if (void 0 === a) {
                        this.getLog().warn(`Unable to register a ${d.ModRegistrationType[t.type]} as it has no registration implementation. It can be implemented by mapping it to an "EnumId" via "registrationTypeToEnumMap", or adding a switch case in "BaseMod.register"`);
                        break
                    }
                    const i = "description"in t ? t.description : void 0;
                    t.registrationId = this.allocateEnum(a, f, i),
                    this.setRegistrationPropertyValue(e, t.key, t.registrationId);
                    break
                }
            }
        }
        validateRegistration(e, t) {
            for (const a in t) {
                const i = t[a];
                "object" == typeof i && (i instanceof d.Registry.Registered ? Object.defineProperty(t, a, {
                    configurable: !0,
                    get: ()=>(Object.defineProperty(t, a, {
                        configurable: !0,
                        value: this.getRegistrationId(e, i.key, i.type)
                    }),
                    t[a])
                }) : i && this.validateRegistration(e, i))
            }
        }
        getRegistrationId(e, t, a) {
            if (0 === a) {
                if (t in e)
                    return e[t]
            } else {
                const a = d.Registry.id(e[t]);
                if (a)
                    return a
            }
            throw new Error(`Property ${t} was never initialized`)
        }
        getRegistrationPropertyValue(e, t) {
            return e[t]
        }
        setRegistrationPropertyValue(e, t, a) {
            return e[t] = a
        }
        allocateEnum(e, t, a, i, n) {
            const o = T.default.allocate(this.index, e, t, a, i, n);
            if (o)
                return modManager.getState(this.index) === s.ModState.ChangingState || this.allocatedEnums.push(o),
                o.enumNumber;
            throw new Error(`Failed to allocate enum ${S.EnumId[e]} - ${t}`)
        }
        addTerrainResource(e, t, a) {
            const i = [];
            for (const e of t)
                i.push({
                    type: e.type,
                    chance: e.chance,
                    chanceOutOf: e.chanceOutOf,
                    tileChange: e.tileChange,
                    tileChangeChance: e.tileChangeChance
                });
            const n = {
                items: i
            };
            return a && (n.defaultItem = a),
            g.default[e] = n,
            e
        }
    }
    __decorate([I.Bound], b.prototype, "onUnallocate", null),
    __decorate([I.Bound], b.prototype, "onBeforeInitialize", null),
    __decorate([I.Bound], b.prototype, "onBeforeLoad", null),
    t.BaseMod = b,
    t.default = b;
    const k = {
        [d.ModRegistrationType.Action]: S.EnumId.ActionType,
        [d.ModRegistrationType.DailyChallengeModifier]: S.EnumId.DailyChallengeModifier,
        [d.ModRegistrationType.Doodad]: S.EnumId.DoodadType,
        [d.ModRegistrationType.HelpArticle]: S.EnumId.HelpArticle,
        [d.ModRegistrationType.InterruptChoice]: S.EnumId.InterruptChoice,
        [d.ModRegistrationType.Item]: S.EnumId.ItemType,
        [d.ModRegistrationType.ItemGroup]: S.EnumId.ItemTypeGroup,
        [d.ModRegistrationType.MenuBarButton]: S.EnumId.MenuBarButton,
        [d.ModRegistrationType.Message]: S.EnumId.Message,
        [d.ModRegistrationType.MessageSource]: S.EnumId.MessageSource,
        [d.ModRegistrationType.Note]: S.EnumId.Note,
        [d.ModRegistrationType.Overlay]: S.EnumId.OverlayType,
        [d.ModRegistrationType.Skill]: S.EnumId.SkillType,
        [d.ModRegistrationType.TileEvent]: S.EnumId.TileEventType
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/ISpriteBatch", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/IWorldLayer", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/IWorld", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/Mod", ["require", "exports", "mod/BaseMod"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i extends a.default {
        onInitialize() {}
        onUninitialize() {}
        onUninitialized() {}
        onLoad() {}
        onUnload() {}
        getAmbientColor(e) {}
        getAmbientColorCave() {}
        getAmbientColorDay() {}
        getAmbientColorNight() {}
        getFogColor(e) {}
        getAmbientLightLevel(e, t) {}
        canConsumeItem(e, t, a) {}
        canCreatureAttack(e, t) {}
        canCreatureMove(e, t, a, i, n, o) {}
        canCreatureSpawn(e, t, a, i, n) {}
        canDoodadSpawn(e, t, a, i, n) {}
        canDropItem(e, t, a, i, n) {}
        canNPCAttack(e, t, a) {}
        canNPCMove(e, t, a, i, n, o) {}
        canNPCSpawn(e, t, a, i) {}
        canPickupDoodad(e, t) {}
        canPlayerAttack(e, t, a) {}
        canClientMove(e) {}
        canSeeCreature(e, t) {}
        canSeeNPC(e, t) {}
        getCreatureSpriteBatchLayer(e, t) {}
        getMaxSpritesForLayer(e, t) {}
        getPlayerFieldOfViewRadius(e) {}
        getPlayerMaxHealth(e, t) {
            return e
        }
        getPlayerMaxWeight(e, t) {
            return e
        }
        getPlayerMovementIntent(e) {}
        getPlayerSpriteBatchLayer(e, t) {}
        getPlayerWeightMovementPenalty(e) {}
        getPlayerWeightStatus(e) {}
        getCameraPosition(e) {}
        getTileLightLevel(e, t, a, i) {}
        getTilePenalty(e, t) {
            return e
        }
        getZoomLevel() {}
        isHumanSwimming(e, t) {}
        isPlayerSwimming(e, t) {}
        isTileBlocked(e) {}
        onBuild(e, t, a, i) {}
        onButtonBarClick(e) {}
        onContainerItemAdd(e, t) {}
        onContainerItemRemove(e, t) {}
        onContainerItemUpdate(e, t, a) {}
        onCraft(e, t) {}
        onCreateWorld(e) {}
        onDisplayMessage(e, t) {}
        shouldDisplayMessage(e, t, a) {}
        onDoodadSpawn(e) {}
        onGameEnd(e) {}
        onGameStart(e, t) {}
        onGameTickStart() {}
        onGameTickEnd() {}
        onGetTranslation(e) {
            return e
        }
        onEntityKill(e, t) {}
        onHumanSkillChange(e, t, a) {}
        onInventoryItemAdd(e, t, a) {}
        onInventoryItemRemove(e, t, a) {}
        onInventoryItemUpdate(e, t, a) {}
        onItemDamage(e, t) {}
        onItemEquip(e, t, a) {}
        onItemQuickslot(e, t, a) {}
        onCreatureDamage(e, t) {}
        onCreatureDeath(e) {}
        onCreatureSpawn(e) {}
        onCreatureTamed(e, t) {}
        onBindLoop(e, t) {
            return e
        }
        onDigTreasure(e, t) {}
        onLanguageChange(e) {}
        onMove(e, t, a, i, n) {}
        onMoveComplete(e) {}
        onMoveDirectionUpdate(e, t) {}
        onNoInputReceived(e) {}
        onNPCDamage(e, t) {}
        onNPCDeath(e) {}
        onNPCSpawn(e) {}
        onOpenBook(e, t) {}
        onPickupDoodad(e, t) {}
        onPlayerDamage(e, t) {}
        onPlayerDeath(e) {}
        onPlayerJoin(e) {}
        onPlayerLeave(e) {}
        onPlayerTickEnd(e) {}
        onPlayerTickStart(e) {}
        onPlayerWalkToTilePath(e, t) {}
        onQueueSoundEffect(e, t, a, i) {}
        onGameScreenVisible() {}
        onReadMap(e, t) {}
        onRenderOverlay(e) {}
        onSailToCivilization(e) {}
        onSpawnCreatureFromGroup(e, t, a, i, n) {}
        onTileUpdate(e, t, a, i) {}
        onTurnEnd(e) {}
        onTurnStart(e) {}
        onUpdateWeight(e, t) {}
        onWriteNote(e, t) {}
        onWrittenNote(e, t) {}
        postExecuteAction(e, t, a) {}
        postFieldOfView() {}
        postGenerateWorld(e) {}
        postRender() {}
        postRenderPostProcess() {}
        postRenderWorld(e, t, a) {}
        postSaveGame() {}
        preExecuteAction(e, t, a) {}
        preLoadWorldDifferences(e) {}
        preExecuteCommand(e, t, a) {}
        preRender() {}
        preRenderPostProcess() {}
        preRenderWorld(e, t, a) {}
        preSaveGame() {}
        processInput(e) {}
        shouldRender() {}
        shouldStopWalkToTileMovement() {}
    }
    const n = ()=>saveData;
    !function(e) {
        function t(e) {
            return (t,a)=>{
                Object.defineProperty(t, a, {
                    get: ()=>{
                        for (const t of modManager.getIndexFromName(e)) {
                            const e = modManager.getModFromIndex(t);
                            if (e.instance && modManager.isValid(e.index))
                                return e.instance
                        }
                    }
                })
            }
        }
        function a(e) {
            return (t,a)=>{
                Object.defineProperty(t, a, {
                    get: ()=>{
                        for (const t of modManager.getIndexFromName(e)) {
                            const e = modManager.getModFromIndex(t);
                            if (e.instance && modManager.isValid(e.index))
                                return modManager.getLog(e.index)
                        }
                    }
                })
            }
        }
        function i(e) {
            return (t,a)=>{
                Object.defineProperty(t, a, {
                    get: ()=>{
                        for (const t of modManager.getIndexFromName(e)) {
                            const e = modManager.getModFromIndex(t);
                            if (!e.instance || !modManager.isValid(e.index))
                                continue;
                            const a = modManager.getIdentifier(e.index);
                            return n().modManagerSaveData[a] = e.instance.initializeSaveData(n().modManagerSaveData[a])
                        }
                    }
                })
            }
        }
        function o(e) {
            return (t,a)=>{
                Object.defineProperty(t, a, {
                    get: ()=>{
                        for (const t of modManager.getIndexFromName(e)) {
                            const e = modManager.getModFromIndex(t);
                            if (!e.instance || !e.initialized)
                                continue;
                            const a = modManager.getIdentifier(e.index);
                            return saveDataGlobal.modManagerSaveData[a] = e.instance.initializeGlobalData(saveDataGlobal.modManagerSaveData[a])
                        }
                    }
                })
            }
        }
        e.instance = t,
        e.log = a,
        e.saveData = i,
        e.globalData = o
    }(i || (i = {})),
    t.default = i
}),
/*!
* Copyright Unlok, Vaughn Royko 2011-2018
* http://www.unlok.ca
*
* Credits & Thanks:
* http://www.unlok.ca/credits-thanks/
*
* Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
* https://waywardgame.github.io/
*/
define("mod/IModInfo", ["require", "exports"], function(e, t) {
    var a, i, n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Undefined = 1] = "Undefined",
        e[e.Null = 2] = "Null",
        e[e.Number = 4] = "Number",
        e[e.Boolean = 8] = "Boolean",
        e[e.String = 16] = "String",
        e[e.Object = 32] = "Object",
        e[e.Array = 64] = "Array",
        e[e.Function = 128] = "Function",
        e[e.True = 256] = "True",
        e[e.False = 512] = "False"
    }(a = t.TypeFlag || (t.TypeFlag = {})),
    function(e) {
        e[e.Disabled = 0] = "Disabled",
        e[e.Enabled = 1] = "Enabled",
        e[e.Loaded = 2] = "Loaded",
        e[e.Error = 3] = "Error",
        e[e.ChangingState = 4] = "ChangingState",
        e[e.Temporary = 5] = "Temporary",
        e[e.LoadedInMultiplayer = 6] = "LoadedInMultiplayer"
    }(i = t.ModState || (t.ModState = {})),
    function(e) {
        e[e.Internal = 0] = "Internal",
        e[e.Local = 1] = "Local",
        e[e.Workshop = 2] = "Workshop"
    }(n = t.ModType || (t.ModType = {}))
}),
/*!
* Copyright Unlok, Vaughn Royko 2011-2018
* http://www.unlok.ca
*
* Credits & Thanks:
* http://www.unlok.ca/credits-thanks/
*
* Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
* https://waywardgame.github.io/
*/
define("utilities/enum/Enums", ["require", "exports", "utilities/enum/IEnum", "utilities/iterable/Collectors", "utilities/Random"], function(e, t, a, i, n) {
    var o;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        function t(e) {
            return void 0 !== e[a.EnumProperty.OFFICIAL_MAX]
        }
        function o(e) {
            return e[a.EnumProperty.MOD_START]
        }
        function r(e, t) {
            return t >= e[a.EnumProperty.MOD_START]
        }
        function s(e, t, i) {
            const n = `${e[a.EnumProperty.NAME]},${t}`
              , o = (i ? saveDataGlobal.utilitiesEnumsAllocated : saveData.utilitiesEnumsAllocated)[n];
            if (!o)
                return;
            const r = o.modIndex;
            return void 0 === r ? r : modManager.getModFromIndex(r)
        }
        function l(e, t) {
            for (const a of c(e))
                if (a.toUpperCase() === t.toUpperCase())
                    return e[a]
        }
        function u(e, t) {
            if (t >= 0 && t < d(e)) {
                let a = 0;
                for (const i of c(e))
                    if (a++ === t)
                        return e[i]
            }
        }
        function d(e) {
            return a.EnumProperty.LENGTH in e || (e[a.EnumProperty.LENGTH] = c(e).reduce((e,t)=>t + 1, 0)),
            e[a.EnumProperty.LENGTH]
        }
        function p(e, t) {
            if (t) {
                let a;
                for (; void 0 === a; )
                    t(a = p(e)) || (a = void 0);
                return a
            }
            return u(e, n.default.int(d(e)))
        }
        function *c(e) {
            for (const t in e)
                if (isNaN(+t)) {
                    const a = r(e, e[t]);
                    let i = !1;
                    const n = a && (s(e, t, !1) || s(e, t, i = !0));
                    if (a && (!n || !i && !modManager.isLoaded(n.index)))
                        continue;
                    yield t
                }
        }
        function *m(e) {
            for (const t of c(e))
                yield e[t]
        }
        function *h(e) {
            for (const t of c(e))
                yield[t, e[t]]
        }
        function y(e, n, o=!0) {
            return (!o || !("number" != typeof n || n < 0)) && (!!(o && t(e) && n < e[a.EnumProperty.OFFICIAL_MAX]) || void 0 !== m(e).filter(e=>e === n).collect(i.default.first()))
        }
        function g(e, t) {
            let a = "";
            for (const i of m(e))
                (t & i) === i && (a += 0 === a.length ? e[i] : ` | ${e[i]}`);
            return a
        }
        e.isModdable = t,
        e.getModStart = o,
        e.isModded = r,
        e.getMod = s,
        e.findByName = l,
        e.getNth = u,
        e.getLength = d,
        e.getRandom = p,
        e.keys = c,
        e.values = m,
        e.entries = h,
        e.isValid = y,
        e.toString = g
    }(o || (o = {})),
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("game/inspection/Inspect", ["require", "exports", "entity/Entity", "entity/IEntity", "entity/IStats", "Enums", "game/inspection/IInspection", "game/inspection/Inspections", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/iterable/Iterables", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class g {
        constructor(e, t, a, i) {
            this.inspector = e,
            this.context = t,
            this.tile = a,
            this.tilePosition = i
        }
        static inspect(e, t, a) {
            const i = game.getTile(...t.xyz)
              , n = new g(e,a,i,t);
            return p.default.entries(r.InspectType).filter(([,e])=>a !== r.InspectionContext.Tooltip || !1 !== saveDataGlobal.options.tooltips[e]).map(([e,t])=>m.tuple(e, s.default[t])).filter2(([e,t])=>t).map(([e,t])=>Object.assign({
                priority: r.BasicInspectionPriority[e] || 0
            }, "object" == typeof t ? t : {
                handle: t
            })).collect(c.default.toArray).sort((e,t)=>e.priority - t.priority).values().map(e=>(e.handle(n) || []).values()).flatMap().filter(e=>e).map(e=>{
                const t = h.isIterable(e) ? e : e.content;
                return (e = h.isIterable(e) ? {
                    content: t
                } : e).content = t.values().map(e=>e instanceof d.default ? {
                    text: e
                } : e).filter(e=>e),
                e
            }
            ).filter(e=>{
                const [t,a] = e.content.collect(c.default.hasAny);
                return e.content = a,
                t
            }
            )
        }
        inspectEntityHealth(e, t=e.getName() , r, s=this.inspector.getSkill(o.SkillType.Anatomy) , p=Math.floor(e.getStatValue(n.Stat.Health) /e.getStatMax(n.Stat.Health) *100) ) {
            if (a.default.is(e, i.EntityType.Player) && e.isGhost())
                return;
            const c = new d.default(l.Dictionary.Skill,o.SkillType.Anatomy);
            let m = u.default.None;
            if (s <= 25)
                r = d.default.message(u.default.BasedOnItSeems).addArgs(d.default.message(u.default.YourLowSkill).addArgs(c)),
                m = p >= 50 ? u.default.RevealsEntitySeemsUninjured : u.default.RevealsEntitySeemsInjured;
            else if (s <= 50)
                r = d.default.message(u.default.WithYouSee).addArgs(d.default.message(u.default.YourModerateSkill).addArgs(c)),
                m = p >= 66 ? u.default.RevealsEntityAppearsUnharmed : p >= 33 ? u.default.RevealsEntityAppearsHurt : u.default.RevealsEntityAppearsVeryHurt;
            else {
                if (!(s <= 75))
                    return r = d.default.message(u.default.Reveals).addArgs(d.default.message(u.default.YourHighSkill).addArgs(c)),
                    d.default.message(u.default.RevealsEntityIsAtPercentHealth).inContext(4).addArgs(r, t, p);
                r = d.default.message(u.default.Reveals).addArgs(d.default.message(u.default.YourHighSkill).addArgs(c)),
                m = p >= 75 ? u.default.RevealsEntityIsMostlyUninjured : p >= 50 ? u.default.RevealsEntityIsInjured : p >= 25 ? u.default.RevealsEntityIsSeverelyInjured : u.default.RevealsEntityIsOnTheVergeOfDeath
            }
            return d.default.message(m).inContext(4).addArgs(r, t)
        }
        inspectFire(e, t) {
            const a = g.ofFire(e, t);
            return a ? d.default.message(a) : void 0
        }
    }
    __decorate([y.Bound], g.prototype, "inspectEntityHealth", null),
    __decorate([y.Bound], g.prototype, "inspectFire", null),
    function(e) {
        function t(e, t) {
            return void 0 === e ? u.default.None : e <= 200 && !t ? u.default.FireReducedToEmbers : e <= 400 ? u.default.FireAlmostExtinguished : e <= 600 ? u.default.FireIsStruggling : e <= 800 ? u.default.FireIsHealthy : u.default.FireIsRaging
        }
        e.ofFire = t
    }(g || (g = {})),
    t.default = g
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("item/IItemManager", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("player/PlayerDefense", ["require", "exports", "Enums", "save/ISerializer"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.Defense {
        constructor(e, t, a, i) {
            super(e, a, i),
            this.parrying = t
        }
    }
    __decorate([i.SaveProperty()], n.prototype, "parrying", void 0),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/data/SaveDataGlobal", ["require", "exports", "Enums", "game/IGame", "game/inspection/IInspection", "newui/INewUi", "save/data/ISaveDataGlobal", "utilities/Objects"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l {
        constructor() {
            this.gameCrafted = {},
            this.gameHighscores = [],
            this.gamePlayedCount = 0,
            this.options = s.default.deepClone(l.defaultOptions),
            this.playerMilestoneData = {},
            this.modManagerModState = {},
            this.modManagerSaveData = {},
            this.languageManagerSaveData = {},
            this.utilitiesEnumsAllocated = {},
            this.savedDialogInfo = {},
            this.multiplayerBannedPlayers = [],
            this.multiplayerPreviousGames = {},
            this.characters = [],
            this.newui = {},
            this.lastServerJoined = void 0
        }
        resetOptions() {
            this.options = s.default.deepClone(l.defaultOptions)
        }
        resetMilestones() {
            this.playerMilestoneData = {}
        }
    }
    l.defaultOptions = {
        alternatingDirectionMovement: !1,
        alternateContextMenu: !1,
        alwaysShowMoreInformation: !1,
        autoGatherHarvest: !1,
        autoPickup: !0,
        bindings: {},
        consoleLogSourceFilter: {
            miscSourceFilter: "",
            disabledSources: []
        },
        currentGame: 0,
        defaultCursor: !1,
        developerMode: !1,
        developerModeContextMenu: !1,
        dialogOpacity: o.DIALOG_OPACITY_DEFAULT / 100,
        directionTurnDelay: i.defaultTurnDelay,
        mouseTurnDelay: i.defaultTurnDelay,
        dropLocation: a.DropLocation.Facing,
        dropOnGatherHarvest: !1,
        musicPlaylist: r.MusicPlaylist.Dynamic,
        enableAutoSave: !0,
        fallBackToEnglish: !0,
        fontStyle: !0,
        fullscreen: !0,
        hideEquippedHeadgear: !1,
        keepSortActive: !1,
        leftHand: !0,
        muteEffects: !1,
        muteMusic: !1,
        powerPreference: r.PowerMode.Default,
        protectedCraftingItems: !1,
        protectedCraftingItemContainers: !1,
        realTimeTickSpeed: a.TickSpeed.Default,
        rightClickInspect: !1,
        rightHand: !0,
        shouldLoadLastSave: !1,
        skipSplash: !1,
        tooltips: {
            [n.InspectType.Tile]: !0,
            [n.InspectType.Doodad]: !0,
            [n.InspectType.Creature]: !0,
            [n.InspectType.Items]: !0,
            [n.InspectType.Player]: !0,
            [n.InspectType.Corpses]: !0,
            [n.InspectType.TileEvents]: !0,
            [n.InspectType.NPC]: !0
        },
        uiScale: 1,
        useAdjacentContainers: !0,
        visionMode: !1,
        volumeEffects: .4,
        volumeMusic: .2,
        warnOnDangerousActions: !0,
        warnWhenBreakingItems: !1,
        warnWhenBreakingItemsOnCraft: !0,
        windowMode: !1,
        zoomLevel: 4
    },
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("entity/Human", ["require", "exports", "creature/corpse/Corpses", "entity/Entity", "entity/IEntity", "entity/IStats", "entity/StatFactory", "Enums", "game/IGame", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Misc", "language/Translation", "mod/IHookManager", "multiplayer/IMultiplayer", "player/IMessageManager", "player/IMilestone", "player/IPlayer", "player/MessageManager", "player/PlayerDefense", "player/Skills", "renderer/particle/IParticle", "renderer/particle/Particles", "save/data/SaveDataGlobal", "save/ISerializer", "tile/ITileEvent", "tile/Terrains", "tile/TileEvents", "utilities/enum/Enums", "utilities/iterable/Generators", "utilities/Log", "utilities/math/Math2", "utilities/Objects", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.REPUTATION_MAX = 64e3;
    const L = Symbol("NEXT_PROCESS_INPUT");
    class O extends i.default {
        constructor() {
            super(),
            this.attackFromEquip = {
                leftHand: 0,
                rightHand: 0
            },
            this.deathBy = c.default.message(d.default.Mysteriously).serialize(),
            this.defense = new S.default(0,0,new s.Resistances(s.DamageType.Blunt,0,s.DamageType.Piercing,0,s.DamageType.Fire,0,s.DamageType.Slashing,0),new s.Vulnerabilities(s.DamageType.Blunt,0,s.DamageType.Piercing,0,s.DamageType.Fire,0,s.DamageType.Slashing,0)),
            this.defenses = [],
            this.equipped = {},
            this.handToUse = s.EquipType.LeftHand,
            this.inventory = {
                containedItems: new Array
            },
            this.lightBonus = 0,
            this.options = x.default.deepClone(M.default.defaultOptions),
            this.score = 0,
            this.skills = I.skillSet(),
            this.state = s.PlayerState.None,
            this.swimming = !1,
            this.canSendMessage = !1,
            this._fovRadius = l.lineOfSightRadius,
            this._fovMaxRadius = l.lineOfSightMaxRadius,
            x.initializePrivateStore(this, [[L, 0]]),
            this.stats = r.default.getStats(new r.default(o.Stat.Health), new r.default(o.Stat.Stamina), new r.default(o.Stat.Hunger), new r.default(o.Stat.Thirst), new r.default(o.Stat.Weight).setMax(0, !0), new r.default(o.Stat.Attack), new r.default(o.Stat.Malignity), new r.default(o.Stat.Benignity), new r.default(o.Stat.Reputation), new r.default(o.Stat.Defense), new r.default(o.Stat.Strength).setBonus(f.STRENGTH_BONUS)),
            this.resetDefense(),
            this.resetStatTimers(),
            this.setMoveType(s.MoveType.Land)
        }
        resetStatTimers() {
            this.setStatChangeTimer(o.Stat.Health, 80, 1),
            this.setStatChangeTimer(o.Stat.Stamina, 10, 1),
            this.setStatChangeTimer(o.Stat.Hunger, 100, -1),
            this.setStatChangeTimer(o.Stat.Thirst, 80, -1),
            this.getStat(o.Stat.Stamina).changeAmount = 1
        }
        isLocalPlayer() {
            return this === localPlayer
        }
        setOptions(e) {
            this.options = e
        }
        getName() {
            return new c.default(u.Dictionary.Misc,p.MiscTranslation.HumanName).addArgs(this.renamed)
        }
        getProtectedItemsOptions() {
            return {
                protect: this.options.protectedCraftingItems,
                protectContainers: this.options.protectedCraftingItemContainers
            }
        }
        getReputation() {
            return this.getStat(o.Stat.Benignity).value - this.getStat(o.Stat.Malignity).value
        }
        getSkillCore(e) {
            const t = this.skills[e];
            return t ? t.core : 0
        }
        setSkillCore(e, t) {
            if (!this.skills[e])
                return void G.default.warn(G.LogSource.Game, "Human", this.getName().getString())(`Tried to set the base value of the skill ${s.SkillType[e]} but it did not exist.`);
            const a = this.skills[e];
            a.core = t;
            const i = this.getSkill(e);
            this.emit("SkillChange", e, i),
            modManager.getHook(m.Hook.OnHumanSkillChange).call(this, e, i)
        }
        getSkill(e) {
            const t = this.skills[e];
            return t ? t.core + t.bonus : 0
        }
        skillCheck(e, t) {
            return this.getSkill(e) >= B.default.float(t)
        }
        isResting() {
            return void 0 !== this.restData
        }
        isGhost() {
            return this.state === s.PlayerState.Ghost
        }
        isRestingCancelled() {
            return void 0 !== this.restData && void 0 !== this.restData.cancelReason
        }
        startResting(e) {
            this.restData = e,
            this.restData && (void 0 !== this.restData.itemId && game.items[this.restData.itemId] || void 0 !== this.restData.doodadId && game.doodads[this.restData.doodadId] ? game.updateRender(l.RenderSource.PlayerRestStart) : (this.restData.itemId = void 0,
            this.restData.doodadId = void 0))
        }
        cancelResting(e) {
            return void 0 !== this.restData && (this.restData.cancelReason = e,
            !0)
        }
        createItemInInventory(e, t) {
            return itemManager.create(e, this.inventory, t)
        }
        hasHandToUse() {
            return !0
        }
        getAndSwitchHandToUse() {
            return this.handToUse === s.EquipType.LeftHand ? (this.handToUse = s.EquipType.RightHand,
            s.EquipType.LeftHand) : (this.handToUse = s.EquipType.LeftHand,
            s.EquipType.RightHand)
        }
        damageRandomEquipment() {
            const e = this.getEquippedItems();
            e.length > 0 && B.default.getElement(e).damage("DE")
        }
        getDamageModifier() {
            return 1
        }
        damage(e, t, a=0, i=!0) {
            return "object" != typeof e && (e = {
                amount: Math.round(e),
                type: s.DamageType.True,
                damageMessage: t,
                soundDelay: a,
                legacy: !0
            }),
            game.damage(this, e, i)
        }
        getEquippedItems() {
            const e = []
              , t = Object.keys(this.equipped);
            for (const a of t) {
                const t = parseInt(a, 10);
                this.equipped[t] && e.push(game.items[this.equipped[t]])
            }
            return e
        }
        getEquippedItem(e) {
            const t = this.equipped[e];
            return void 0 !== t ? game.items[t] : void 0
        }
        getEquipSlotForItem(e) {
            const t = Object.keys(this.equipped);
            for (const a of t) {
                const t = parseInt(a, 10)
                  , i = this.equipped[t];
                if (void 0 !== i && game.items[i] === e)
                    return t
            }
        }
        getMaxHealth() {
            return this.getStat(o.Stat.Health).max
        }
        addMilestone(e, t) {}
        update() {
            this.calculateEquipmentStats()
        }
        updateStatsAndAttributes() {
            this.calculateStats(),
            this.calculateEquipmentStats()
        }
        staminaReduction(e) {
            this.getSkill(e) <= B.default.percent() + 25 && this.reduceStat(o.Stat.Stamina, 1)
        }
        updateReputation(e) {
            const a = this.getStat(o.Stat.Malignity)
              , i = this.getStat(o.Stat.Benignity);
            (e = e > 0 ? Math.round(e * game.getDifficultyOptions().player.reputation.benignityMultiplier) : Math.round(e * game.getDifficultyOptions().player.reputation.malignityMultiplier)) <= -1 ? this.increaseStat(a, -1 * e) : this.increaseStat(i, e),
            i.base.value > t.REPUTATION_MAX ? (this.reduceStat(o.Stat.Malignity, i.base.value - t.REPUTATION_MAX),
            this.setStat(o.Stat.Benignity, t.REPUTATION_MAX)) : a.base.value > t.REPUTATION_MAX && (this.reduceStat(o.Stat.Benignity, a.base.value - t.REPUTATION_MAX),
            this.setStat(o.Stat.Malignity, t.REPUTATION_MAX)),
            i.base.value < 0 ? this.setStat(o.Stat.Benignity, 0) : a.base.value < 0 && this.setStat(o.Stat.Malignity, 0)
        }
        setRaft(e) {
            return this.raft !== e && (this.raft = e,
            !0)
        }
        skillGain(e, t, a) {
            const i = I.skillDescriptions[e];
            if (i) {
                const e = i.reputation;
                e && this.updateReputation(e)
            }
            let n = this.skills[e];
            if (n || (n = this.skills[e] = new I.SkillLevel),
            a || n.core < 100 && n.core <= B.default.percent()) {
                void 0 === t && (t = n.core < 5 ? 1 : n.core < 10 ? .5 : n.core < 20 ? .4 : n.core < 40 ? .3 : n.core < 80 ? .2 : .1);
                const a = game.getDifficultyOptions().player.skills.get(e);
                a && void 0 !== a.gainMultiplier && (t *= a.gainMultiplier),
                t > 0 && (n.core = R.default.roundNumber(n.core + t, 2),
                n.core > 100 && (n.core = 100),
                this.setSkillCore(e, n.core),
                this.score += 100 * t,
                this.calculateEquipmentStats(),
                T.default.get(this).source(y.Source.Skill).type(T.MessageType.Skill).send(d.default.SkillHasRaised, new c.default(u.Dictionary.Skill,e), this.getSkill(e)),
                this.addMilestone(g.MilestoneType.Grandmaster, n.core))
            }
            if (i) {
                const e = i.attribute;
                void 0 !== e && this.statGain(e, !1)
            }
        }
        checkForTargetInRange(e, t) {
            const a = {
                x: this.x,
                y: this.y,
                z: this.z
            };
            let i = 0, n = 0, o;
            for (let r = 1; r <= e; r++) {
                if (i = this.x + this.direction.x * r,
                n = this.y + this.direction.y * r,
                i = game.getWrappedCoord(i),
                n = game.getWrappedCoord(n),
                a.x = i,
                a.y = n,
                a.z = this.z,
                !(o = game.getTile(i, n, this.z)))
                    return a;
                const e = C.default[E.default.getType(o)];
                if (e && !e.passable && !e.water)
                    return a.obstacle = !0,
                    a;
                if (void 0 !== o.doodad) {
                    const e = o.doodad.description()
                      , t = o.doodad.getGrowingStage();
                    if (e && (e.isTree && void 0 !== t && t >= s.GrowingStage.Budding || e.isWall || e.isClosedDoor))
                        return a.obstacle = !0,
                        a
                }
                if (void 0 !== o.creature)
                    return a.creature = o.creature,
                    a;
                if (void 0 !== o.npc)
                    return a.npc = o.npc,
                    a;
                if (t) {
                    const e = game.getPlayersAtTile(o);
                    if (e.length > 0)
                        return a.player = e[0],
                        a
                }
            }
            if (o) {
                const e = C.default[E.default.getType(o)];
                e && (e.water && (a.water = !0),
                e.freshWater && (a.freshWater = !0))
            }
            return a
        }
        checkAndRemoveBlood() {
            const e = this.getFacingTile();
            if (!e.corpses)
                return !0;
            let t = 0;
            for (const i of e.corpses) {
                const e = a.default[i.type];
                e && e.blood && t++
            }
            if (t >= e.corpses.length) {
                for (const t of e.corpses)
                    delete game.corpses[t.id];
                delete e.corpses;
                const {x: t, y: a, z: i} = this.getFacingPoint();
                return world.updateTile(t, a, i, e),
                game.particle.create(t, a, i, w.default[v.ParticleType.Blood]),
                game.updateView(l.RenderSource.RemoveBlood, !0),
                this.queueSoundEffect(s.SfxType.PickUp),
                T.default.get(this).source(y.Source.Action).send(d.default.RemovedBlood),
                !0
            }
            return !1
        }
        getBurnDamage(e, t) {
            let a = this.getMaxHealth() / 10;
            if (e || (a -= Math.floor(this.getSkill(s.SkillType.Parrying) / 35)),
            void 0 !== t) {
                const e = this.getEquippedItem(t);
                if (e) {
                    const t = e.description();
                    if (t && t.defense) {
                        const i = e.getBaseDefense()
                          , n = t.defense.resist[s.DamageType.Fire]
                          , o = t.defense.vulnerable[s.DamageType.Fire];
                        a -= (i || 0) + (n || 0) - (o || 0) + 2
                    }
                }
            } else
                a -= Math.floor(this.defense.base / 3 + this.defenses[s.DamageType.Fire]);
            return a
        }
        burn(e=!1, t, a, i) {
            let o = this.getBurnDamage(t, a);
            if (void 0 !== a) {
                const e = this.getEquippedItem(a);
                e && e.damage("PB")
            } else
                this.damageRandomEquipment();
            if (o >= 1) {
                const t = this.getMaxHealth();
                return o -= B.default.intInRange(0, t / 20),
                o = Math.max(1, Math.ceil(o)),
                this.damage(-1 * o, d.default.DeathByBurning, 0, !1),
                e || T.default.get(this).source(y.Source.Wellbeing, i && y.Source.Combat).type(T.MessageType.Bad).send(d.default.BadlyBurnedLostHealth, o),
                game.particle.create(this.x, this.y, this.z, w.default[v.ParticleType.Fire]),
                this.hasStatus(s.StatusType.Burned) || this.setStatus(s.StatusType.Burned, !0, n.StatusEffectChangeReason.Gained),
                o
            }
            T.default.get(this).source(y.Source.Equipment, y.Source.Wellbeing, i && y.Source.Combat).send(d.default.NearlyBurnedEquipmentProtectedYou)
        }
        setPosition(e) {
            const t = this.x
              , a = this.y
              , i = this.z;
            this.x = game.getWrappedCoord(e.x),
            this.y = game.getWrappedCoord(e.y),
            this.z !== e.z && this.setZ(e.z),
            modManager.getHook(m.Hook.OnTileUpdate).call(game.getTile(t, a, i), t, a, i),
            modManager.getHook(m.Hook.OnTileUpdate).call(this.getTile(), this.x, this.y, this.z),
            this.updateSwimming()
        }
        setZ(e) {
            const t = game.getTile(this.x, this.y, e)
              , a = t.creature;
            a && (a.stopNextMovement = !0,
            a.fromX = a.x,
            a.fromY = a.y,
            a.moveTo(this.x, this.y, this.z),
            a.checkUnder()),
            this.z = e,
            this.addDelay(25, !0),
            game.particle.clear(),
            game.updateView(l.RenderSource.MovementPlayerZPre, this.isLocalPlayer())
        }
        checkUnder(e, t, a=!0, o=!1, r=!1) {
            const l = e ? this.getFacingTile() : this.getTile();
            if (l && !r && !this.isGhost() && this.moveType !== s.MoveType.Flying) {
                let e = !1;
                const a = l.doodad;
                if (a) {
                    const o = a.description();
                    if (o) {
                        if (o.providesFire)
                            this.burn(!1, !0, s.EquipType.Feet),
                            e = !0;
                        else if (o.damage) {
                            const e = a.getGrowingStage();
                            if (!o.canGrow || o.canGrow && void 0 !== e && e >= s.GrowingStage.Budding) {
                                let e = a.getDamage(this, s.EquipType.Feet);
                                const t = this.getEquippedItem(s.EquipType.Feet);
                                t ? t.damage("HH") : this.damageRandomEquipment(),
                                e >= 1 ? (e -= B.default.intInRange(0, this.getMaxHealth() / 30),
                                e = Math.max(1, Math.ceil(e)),
                                this.damage(-1 * e, c.default.message(d.default.DeathBySteppingOn).addArgs(a.getName())),
                                T.default.get(this).source(y.Source.Wellbeing, y.Source.Action).type(T.MessageType.Bad).send(d.default.SteppingOnHasInjuredYouForDamage, a.getName(), e)) : T.default.get(this).source(y.Source.Equipment, y.Source.Action, y.Source.Wellbeing, y.Source.Item).send(d.default.ArmorProtectedFromInjuryAgainst, a.getName())
                            }
                        } else if (o.isTrap) {
                            const e = B.default.percent();
                            if (this.getSkill(s.SkillType.Trapping) <= e - 50) {
                                const e = o.trapDamage ? o.trapDamage : 0;
                                let r = B.default.int(e) + 2 - Math.floor(this.getSkill(s.SkillType.Trapping) / 25) - B.default.int(this.defense.base + this.defense.resist[s.DamageType.Blunt] - this.defense.vulnerable[s.DamageType.Blunt]);
                                if (a.legendary && a.legendary.type === s.LegendaryType.TrapDamage && (r += a.legendary.value),
                                this.damageRandomEquipment(),
                                r >= 1) {
                                    if (a.ownerIdentifier) {
                                        const e = game.getPlayerByIdentifier(a.ownerIdentifier);
                                        e && e.skillGain(s.SkillType.Trapping, .1)
                                    } else
                                        this.skillGain(s.SkillType.Trapping, .1);
                                    this.damage(-1 * r, d.default.DeathByTrap),
                                    T.default.get(this).source(y.Source.Combat, y.Source.Action, y.Source.Wellbeing).type(T.MessageType.Bad).send(d.default.InjuredFromTrap, r),
                                    a.ownerIdentifier && i.default.is(this, n.EntityType.NPC) && this.makeHostile()
                                } else
                                    T.default.get(this).source(y.Source.Combat, y.Source.Action).type(T.MessageType.Miss).send(d.default.SetTrapOffButNoDamage);
                                a.setOffTrap(),
                                this.stopNextMovement = !0,
                                t = !1
                            } else
                                T.default.get(this).source(y.Source.Combat, y.Source.Action).send(d.default.MoveOverTrapButDoNotSetOff)
                        } else
                            a.checkForTrampling(this);
                        o.causesStatus && a.causeStatus(this, s.EquipType.Feet)
                    }
                }
                const o = tileEventManager.get(l, k.TileEventType.Fire);
                if (o) {
                    e || (this.burn(!1, !1, s.EquipType.Feet),
                    e = !0);
                    const t = B.default.percent()
                      , a = Math.floor(this.getSkill(s.SkillType.Camping) / 4);
                    void 0 !== o.spread && (t + a >= 75 ? o.spread -= 5 : t + a >= 50 ? (T.default.get(this).source(y.Source.Action).send(d.default.TrampledFire),
                    tileEventManager.remove(o),
                    this.updateReputation(25)) : o.spread += 5)
                }
                e || E.default.getType(l) !== s.TerrainType.Lava || this.burn(!1, !0, s.EquipType.Feet)
            }
        }
        equip(e, t) {
            this.equipped[t] = e.id,
            e.equippedId = this.id,
            e.equippedType = this.entityType,
            this.calculateEquipmentStats();
            const a = e.description();
            a && (a.onEquip && a.onEquip(e),
            a.onEquipEffect && game.updateRender(l.RenderSource.ItemEquipEffect))
        }
        unequip(e) {
            const t = e.getEquipSlot();
            if (void 0 === t)
                return;
            delete e.equippedId,
            delete e.equippedType,
            delete this.equipped[t],
            this.calculateEquipmentStats();
            const a = e.description();
            a && a.onUnequip && a.onUnequip(e)
        }
        unequipAll() {
            let e = !1
              , t = !1;
            const a = this.getEquippedItems();
            for (const i of a) {
                e = !0,
                this.unequip(i);
                const a = i.description();
                a && a.onEquipEffect && (t = !0)
            }
            e && (this.calculateEquipmentStats(),
            this.queueSoundEffect(s.SfxType.PickUp),
            T.default.get(this).source(y.Source.Equipment, y.Source.Action, y.Source.Item).send(d.default.AllEquipmentUnEquipped),
            game.updateView(l.RenderSource.ItemUnequip, t))
        }
        canJump() {
            const e = game.getTile(this.x + 2 * this.direction.x, this.y + 2 * this.direction.y, this.z)
              , t = this.getTile()
              , a = this.getFacingTile()
              , i = C.default[E.default.getType(a)]
              , n = C.default[E.default.getType(e)]
              , o = C.default[E.default.getType(t)];
            let r, s;
            return !(!i || !i.passable && !i.water || !n || !n.passable && !n.water || o && o.water && n && n.water || e.doodad && (!(s = e.doodad.description()) || !s || s.blockMove) || e.creature || e.npc || a.npc || a.creature && !((r = a.creature.description()) && r && r.jumpOver) || a.doodad && (!(s = a.doodad.description()) || !s || s.blockJump) || game.isPlayerAtTile(e) || game.isPlayerAtTile(a))
        }
        hasDelay() {
            return game.absoluteTime < this.privateStore.get(L)
        }
        addDelay(e, t) {
            e = Math.max(e, 0),
            t ? (e = Math.max(this.privateStore.get(L), game.absoluteTime + e * game.interval),
            this.privateStore.set(L, e)) : game.absoluteTime >= this.privateStore.get(L) ? this.privateStore.set(L, game.absoluteTime + e * game.interval) : this.privateStore.set(L, this.privateStore.get(L) + e * game.interval)
        }
        getConsumeBonus(e, t) {
            return Math.floor((void 0 !== t ? this.getSkill(t) / 25 : 0) + (e ? e.getOnUseBonus() : 0))
        }
        checkForGatherFire() {
            const e = this.getFacingTile();
            if (!e || !tileEventManager.get(e, k.TileEventType.Fire))
                return;
            let t;
            const a = tileEventManager.canGather(e);
            if (void 0 !== a) {
                const e = D.default[a.type];
                if (!e)
                    return;
                t = c.default.nameOf(u.Dictionary.TileEvent, a)
            }
            if (void 0 === t && e.doodad) {
                const a = e.doodad.description();
                if (!a)
                    return;
                t = e.doodad.getName()
            }
            return t
        }
        calculateEquipmentStats() {
            const e = new Map;
            this.attackFromEquip = {
                leftHand: 0,
                rightHand: 0
            };
            const t = {
                [o.Stat.Health]: 0,
                [o.Stat.Stamina]: 0,
                [o.Stat.Hunger]: 0,
                [o.Stat.Thirst]: 0,
                [o.Stat.Benignity]: 0,
                [o.Stat.Malignity]: 0,
                [o.Stat.Strength]: f.STRENGTH_BONUS
            };
            let a = 0;
            this.lightBonus = 0,
            this._fovRadius = l.lineOfSightRadius,
            this._fovMaxRadius = l.lineOfSightMaxRadius;
            const i = this.defense.base + this.defense.parrying;
            this.resetDefense();
            const r = Object.keys(this.equipped);
            for (const i of r) {
                const n = parseInt(i, 10)
                  , r = this.equipped[n];
                if (void 0 === r)
                    return;
                const l = game.items[r];
                if (!l)
                    continue;
                const u = l.description();
                if (!u)
                    continue;
                if (u.defense) {
                    this.defense.base += u.defense.base;
                    const e = u.defense.resist
                      , t = Object.keys(e);
                    for (const a of t) {
                        const t = parseInt(a, 10);
                        switch (t) {
                        case s.DamageType.Slashing:
                            this.defense.resist[s.DamageType.Slashing] += e[t];
                            break;
                        case s.DamageType.Blunt:
                            this.defense.resist[s.DamageType.Blunt] += e[t];
                            break;
                        case s.DamageType.Piercing:
                            this.defense.resist[s.DamageType.Piercing] += e[t];
                            break;
                        case s.DamageType.Fire:
                            this.defense.resist[s.DamageType.Fire] += e[t]
                        }
                    }
                    const a = u.defense.vulnerable
                      , i = Object.keys(a);
                    for (const e of i) {
                        const t = parseInt(e, 10);
                        switch (t) {
                        case s.DamageType.Slashing:
                            this.defense.vulnerable[s.DamageType.Slashing] += a[t];
                            break;
                        case s.DamageType.Blunt:
                            this.defense.vulnerable[s.DamageType.Blunt] += a[t];
                            break;
                        case s.DamageType.Piercing:
                            this.defense.vulnerable[s.DamageType.Piercing] += a[t];
                            break;
                        case s.DamageType.Fire:
                            this.defense.vulnerable[s.DamageType.Fire] += a[t]
                        }
                    }
                }
                u.attack && (n === s.EquipType.LeftHand ? (this.attackFromEquip.leftHand += u.attack,
                l.legendary && l.legendary.type === s.LegendaryType.Attack && (this.attackFromEquip.leftHand += l.legendary.value)) : (this.attackFromEquip.rightHand += u.attack,
                l.legendary && l.legendary.type === s.LegendaryType.Attack && (this.attackFromEquip.rightHand += l.legendary.value))),
                n !== s.EquipType.LeftHand && n !== s.EquipType.RightHand || a++;
                const d = u.onEquipEffect;
                if (d)
                    switch (d[0]) {
                    case s.OnEquipType.LightSource:
                        if (void 0 !== l.decay) {
                            const e = (l.legendary && l.legendary.type === s.LegendaryType.Illumination ? l.legendary.value : 0) + 17 * d[1] + Math.min(Math.floor(l.decay / 100), 50);
                            e > this.lightBonus && (this.lightBonus = e)
                        }
                        break;
                    case s.OnEquipType.Telescopy:
                        this._fovRadius = d[1],
                        this._fovMaxRadius = d[2]
                    }
                if (l.legendary)
                    if (void 0 !== l.legendary.skill) {
                        let t = e.get(l.legendary.skill) || 0;
                        t += l.legendary.value,
                        e.set(l.legendary.skill, t)
                    } else if (void 0 !== l.legendary.stat)
                        switch (l.legendary.stat) {
                        case o.Stat.Health:
                            t[o.Stat.Health] += l.legendary.value;
                            break;
                        case o.Stat.Stamina:
                            t[o.Stat.Stamina] += l.legendary.value;
                            break;
                        case o.Stat.Metabolism:
                            t[o.Stat.Hunger] += l.legendary.value,
                            t[o.Stat.Thirst] += l.legendary.value
                        }
                    else
                        l.legendary.type === s.LegendaryType.Benignity ? t[o.Stat.Benignity] += l.legendary.value : l.legendary.type === s.LegendaryType.Malignity ? t[o.Stat.Malignity] += l.legendary.value : l.legendary.type === s.LegendaryType.Defense ? this.defense.base += l.legendary.value : l.legendary.type === s.LegendaryType.MaxWeight && (t[o.Stat.Strength] += l.legendary.value)
            }
            for (const t of A.default.values(s.SkillType)) {
                const a = this.skills[t];
                if (!a)
                    continue;
                const i = e.get(t) || 0;
                if (a.bonus !== i) {
                    a.bonus = i;
                    const e = this.getSkill(t);
                    this.emit("SkillChange", t, e),
                    modManager.getHook(m.Hook.OnHumanSkillChange).call(this, t, e)
                }
            }
            for (const [e,a] of x.default.entries(t).map(([e,t])=>P.tuple(+e, t)))
                this.setStatBonus(e, a, n.IStatChangeInfo.get(!0));
            a >= 2 && (this.defense.parrying += R.default.roundNumber(this.getSkill(s.SkillType.Parrying) / 10, 0) + 1);
            for (const e of A.default.values(s.DamageType))
                this.defenses[e] = this.defense.resist[e] - this.defense.vulnerable[e];
            this.setStat(o.Stat.Attack, R.default.roundNumber(this.getSkill(s.SkillType.Tactics) / 12.5, 0) + 1),
            this.emit(n.EntityEvent.StatChanged, this.getStat(o.Stat.Attack), 0, n.IStatChangeInfo.get(n.StatChangeReason.Normal)),
            this.emit(n.EntityEvent.StatChanged, this.getStat(o.Stat.Defense), 0, n.IStatChangeInfo.get(i !== this.defense.base + this.defense.parrying))
        }
        statGain(e, t) {
            switch (e) {
            case o.Stat.Stamina:
                const a = this.getStat(o.Stat.Stamina);
                if (!t && 0 !== B.default.int(30 + a.max))
                    return;
                this.updateReputation(-1 * Math.floor(2.5 * a.max)),
                this.setStatMax(a, a.max + 1),
                T.default.get(this).source(y.Source.Wellbeing, y.Source.Stat).type(T.MessageType.Stat).send(d.default.DexterityIncreasing);
                break;
            case o.Stat.Metabolism:
                const i = this.getStat(o.Stat.Hunger)
                  , n = this.getStat(o.Stat.Thirst);
                if (!t && 0 !== B.default.int(100 + i.max))
                    return;
                this.updateReputation(-1 * Math.floor(2.5 * (i.max + n.max))),
                this.setStatMax(i, i.max + 1),
                this.setStatMax(n, n.max + 1),
                T.default.get(this).source(y.Source.Wellbeing, y.Source.Stat).type(T.MessageType.Stat).send(d.default.MetabolismSlowed);
                break;
            case o.Stat.Strength:
                const r = this.getStatInternal(o.Stat.Strength);
                if (!t && 0 !== B.default.int(60 + r.value))
                    return;
                this.updateReputation(-1 * r.value * 20),
                this.setStat(o.Stat.Strength, r.value + 1),
                T.default.get(this).source(y.Source.Wellbeing, y.Source.Stat).type(T.MessageType.Stat).send(d.default.StrengthIncreasing)
            }
            this.score += 500,
            this.queueSoundEffect(s.SfxType.Exceptional),
            game.notifier.addStat(this.x, this.y, this.z, s.StatType.Stat, 1)
        }
        calculateStats() {
            const e = this.getMaxHealth()
              , t = this.getStat(o.Stat.Stamina)
              , a = this.getStat(o.Stat.Health)
              , i = this.getStat(o.Stat.Hunger)
              , n = this.getStat(o.Stat.Thirst);
            a.value > e && this.setStat(a, e),
            t.value > t.max && this.setStat(t, t.max),
            i.value > i.max && this.setStat(i, i.max),
            n.value > n.max && this.setStat(n, n.max),
            multiplayer.addSyncCheck(h.MultiplayerSyncCheck.Stats, `H${this.id}`),
            multiplayer.addSyncCheck(h.MultiplayerSyncCheck.Stats, a.value),
            multiplayer.addSyncCheck(h.MultiplayerSyncCheck.Stats, t.value),
            multiplayer.addSyncCheck(h.MultiplayerSyncCheck.Stats, i.value),
            multiplayer.addSyncCheck(h.MultiplayerSyncCheck.Stats, n.value),
            multiplayer.addSyncCheck(h.MultiplayerSyncCheck.Stats, e),
            multiplayer.addSyncCheck(h.MultiplayerSyncCheck.Stats, t.max),
            multiplayer.addSyncCheck(h.MultiplayerSyncCheck.Stats, i.max),
            multiplayer.addSyncCheck(h.MultiplayerSyncCheck.Stats, n.max)
        }
        resetDefense() {
            this.defense.base = 0,
            this.defense.parrying = 0;
            for (const e of A.default.values(s.DamageType))
                this.defenses[e] = 0,
                this.defense.resist[e] = 0,
                this.defense.vulnerable[e] = 0;
            this.emit(n.EntityEvent.StatChanged, this.getStat(o.Stat.Defense), 0, n.IStatChangeInfo.get(n.StatChangeReason.Normal))
        }
        updateSwimming() {
            const e = C.default[E.default.getType(this.getTile())];
            e && e.water && game.particle.create(this.x, this.y, this.z, e.particles),
            this.swimming = !(!e || !e.water || void 0 !== this.raft);
            const t = modManager.getHook(m.Hook.IsHumanSwimming).call(this, this.swimming);
            void 0 !== t && (this.swimming = t)
        }
        swimCheck() {
            this.updateSwimming(),
            this.swimming && (0 === B.default.int(7) && this.skillGain(s.SkillType.Swimming),
            0 === B.default.int(3) && this.hasStatus(s.StatusType.Burned) && (this.setStatus(s.StatusType.Burned, !1, n.StatusEffectChangeReason.Treated),
            this.hasStatus(s.StatusType.Burned) || (this.addMilestone(g.MilestoneType.Doctor, s.StatusType.Burned),
            T.default.get(this).source(y.Source.Wellbeing).send(d.default.NoLongerFeelPainOfBeingBurned))),
            this.staminaReduction(s.SkillType.Swimming))
        }
    }
    __decorate([b.SaveProperty()], O.prototype, "attackFromEquip", void 0),
    __decorate([b.SaveProperty()], O.prototype, "customization", void 0),
    __decorate([b.SaveProperty()], O.prototype, "deathBy", void 0),
    __decorate([b.SaveProperty()], O.prototype, "defense", void 0),
    __decorate([b.SaveProperty()], O.prototype, "defenses", void 0),
    __decorate([b.SaveProperty()], O.prototype, "equipped", void 0),
    __decorate([b.SaveProperty()], O.prototype, "handToUse", void 0),
    __decorate([b.SaveProperty()], O.prototype, "identifier", void 0),
    __decorate([b.SaveProperty()], O.prototype, "inventory", void 0),
    __decorate([b.SaveProperty()], O.prototype, "lightBonus", void 0),
    __decorate([b.SaveProperty()], O.prototype, "messages", void 0),
    __decorate([b.SaveProperty()], O.prototype, "notes", void 0),
    __decorate([b.SaveProperty()], O.prototype, "options", void 0),
    __decorate([b.SaveProperty()], O.prototype, "raft", void 0),
    __decorate([b.SaveProperty()], O.prototype, "restData", void 0),
    __decorate([b.SaveProperty()], O.prototype, "score", void 0),
    __decorate([b.SaveProperty()], O.prototype, "skills", void 0),
    __decorate([b.SaveProperty()], O.prototype, "state", void 0),
    __decorate([b.SaveProperty()], O.prototype, "swimming", void 0),
    __decorate([Override], O.prototype, "getName", null),
    __decorate([x.Final], O.prototype, "hasDelay", null),
    __decorate([x.Final], O.prototype, "addDelay", null),
    t.default = O
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("game/Challenge", ["require", "exports", "entity/Human", "entity/IStats", "Enums", "game/Difficulty", "newui/screen/screens/menu/menus/newgame/customgameoptions/Multiplier", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Log", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    var c;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.NoHealthRegeneration = 0] = "NoHealthRegeneration",
        e[e.NoStaminaRegeneration = 1] = "NoStaminaRegeneration",
        e[e.EternalNight = 2] = "EternalNight",
        e[e.ThirstRate = 3] = "ThirstRate",
        e[e.HungerRate = 4] = "HungerRate",
        e[e.PermanentlyBleeding = 5] = "PermanentlyBleeding",
        e[e.PermanentlyBurning = 6] = "PermanentlyBurning",
        e[e.PermanentlyPoisoned = 7] = "PermanentlyPoisoned",
        e[e.NoStartingItems = 8] = "NoStartingItems",
        e[e.StartingBenignity = 9] = "StartingBenignity",
        e[e.StartingMalignity = 10] = "StartingMalignity",
        e[e.BenignityRate = 11] = "BenignityRate",
        e[e.MalignityRate = 12] = "MalignityRate"
    }(c = t.ChallengeModifier || (t.ChallengeModifier = {}));
    const m = 300;
    function h(e, a=Date.now() ) {
        p.default.generator.pushSeed(a);
        let i = 0;
        const n = []
          , o = s.default.values(c).map(e=>u.tuple(e, y[e].weight)).collect(l.default.toArray);
        let r = o.reduce((e,[t])=>e + y[t].weight, 0);
        for (; i < m && o.length; ) {
            const a = p.default.float(r);
            let s = 0;
            for (let e = 0; e + o[s][1] < a; e += o[s][1],
            s++)
                ;
            const [l,u] = o[s];
            o.splice(s, 1),
            r -= u;
            for (const e of t.EXCLUSIVE_MODIFIERS)
                if (e.includes(l))
                    for (const t of e) {
                        const e = o.findIndex(([e])=>t === e);
                        e >= 0 && (r -= o[e][1],
                        o.splice(e, 1))
                    }
            n.push(l);
            const d = y[l];
            i += d.challenge || 0,
            i += d.apply(e) || 0
        }
        return d.default.info(d.LogSource.DailyChallenge)("Applied daily challenge modifiers:", n.map(e=>c[e])),
        d.default.info(d.LogSource.DailyChallenge)("Challenge Value:", i),
        d.default.info(d.LogSource.DailyChallenge)("Difficulty Options:", e),
        p.default.generator.popSeed(),
        e
    }
    t.EXCLUSIVE_MODIFIERS = [[c.PermanentlyBleeding, c.PermanentlyBurning, c.PermanentlyPoisoned]],
    t.applyChallengeModifiers = h,
    t.PERMANENT_STATUS_EFFECT_MULTIPLIER_RATE = 4,
    t.PERMANENT_STATUS_EFFECT_MULTIPLIER = .5;
    const y = {
        [c.NoHealthRegeneration]: {
            weight: 1,
            challenge: 100,
            apply: e=>{
                e.player.stats.set(i.Stat.Health, Object.assign({}, e.player.stats.get(i.Stat.Health), {
                    changeTimerMultiplier: 0
                }))
            }
        },
        [c.NoStaminaRegeneration]: {
            weight: 1,
            challenge: 150,
            apply: e=>{
                e.player.stats.set(i.Stat.Stamina, Object.assign({}, e.player.stats.get(i.Stat.Stamina), {
                    changeTimerMultiplier: 0
                }))
            }
        },
        [c.EternalNight]: {
            weight: .5,
            challenge: 150,
            apply: e=>{
                e.time.frozen = !0,
                e.time.initial = o.TIME_ETERNAL_NIGHT
            }
        },
        [c.ThirstRate]: {
            weight: 1,
            apply: e=>{
                const t = p.default.intInRange(-4, 4);
                return e.player.stats.set(i.Stat.Thirst, {
                    changeTimerMultiplier: r.convertRateModifierRangeToActual(t)
                }),
                T(t)
            }
        },
        [c.HungerRate]: {
            weight: 1,
            apply: e=>{
                const t = p.default.intInRange(-4, 4);
                return e.player.stats.set(i.Stat.Hunger, {
                    changeTimerMultiplier: r.convertRateModifierRangeToActual(t)
                }),
                T(t)
            }
        },
        [c.PermanentlyBleeding]: {
            weight: .5,
            challenge: 300,
            apply: e=>{
                e.player.statusEffects.set(n.StatusType.Bleeding, {
                    startWith: !0,
                    passChanceMultiplier: 0,
                    untreatable: !0,
                    effectMultiplier: t.PERMANENT_STATUS_EFFECT_MULTIPLIER,
                    effectRateMultiplier: t.PERMANENT_STATUS_EFFECT_MULTIPLIER_RATE
                }),
                e.player.stats.set(i.Stat.Health, Object.assign({}, e.player.stats.get(i.Stat.Health), {
                    changeTimerMultiplier: 1,
                    initialValue: p.default.intInRange(90, 99)
                })),
                e.player.stats.set(i.Stat.Strength, Object.assign({}, e.player.stats.get(i.Stat.Strength), {
                    changeTimerMultiplier: 1,
                    initialValue: p.default.intInRange(81, 99)
                }))
            }
        },
        [c.PermanentlyBurning]: {
            weight: .5,
            challenge: 250,
            apply: e=>{
                e.player.statusEffects.set(n.StatusType.Burned, {
                    startWith: !0,
                    passChanceMultiplier: 0,
                    untreatable: !0,
                    effectMultiplier: t.PERMANENT_STATUS_EFFECT_MULTIPLIER,
                    effectRateMultiplier: t.PERMANENT_STATUS_EFFECT_MULTIPLIER_RATE
                }),
                e.player.stats.set(i.Stat.Health, Object.assign({}, e.player.stats.get(i.Stat.Health), {
                    changeTimerMultiplier: 1,
                    initialValue: p.default.intInRange(80, 89)
                })),
                e.player.stats.set(i.Stat.Strength, Object.assign({}, e.player.stats.get(i.Stat.Strength), {
                    changeTimerMultiplier: 1,
                    initialValue: p.default.intInRange(71, 89)
                }))
            }
        },
        [c.PermanentlyPoisoned]: {
            weight: .5,
            challenge: 300,
            apply: e=>{
                e.player.statusEffects.set(n.StatusType.Poisoned, {
                    startWith: !0,
                    passChanceMultiplier: 0,
                    untreatable: !0,
                    effectMultiplier: t.PERMANENT_STATUS_EFFECT_MULTIPLIER,
                    effectRateMultiplier: t.PERMANENT_STATUS_EFFECT_MULTIPLIER_RATE
                }),
                e.player.stats.set(i.Stat.Health, Object.assign({}, e.player.stats.get(i.Stat.Health), {
                    changeTimerMultiplier: 1,
                    initialValue: p.default.intInRange(90, 99)
                })),
                e.player.stats.set(i.Stat.Strength, Object.assign({}, e.player.stats.get(i.Stat.Strength), {
                    changeTimerMultiplier: 1,
                    initialValue: p.default.intInRange(81, 99)
                }))
            }
        },
        [c.NoStartingItems]: {
            weight: .75,
            challenge: 50,
            apply: e=>{
                e.player.initialItems = !1
            }
        },
        [c.StartingBenignity]: {
            weight: .25,
            apply: e=>{
                const t = e.player.reputation.initialBenignity = p.default.intInRange(0, a.REPUTATION_MAX / 2);
                return t / a.REPUTATION_MAX * 300
            }
        },
        [c.StartingMalignity]: {
            weight: 1,
            apply: e=>{
                const t = e.player.reputation.initialMalignity = p.default.intInRange(0, a.REPUTATION_MAX / 2);
                return t / a.REPUTATION_MAX * 300
            }
        },
        [c.BenignityRate]: {
            weight: .25,
            apply: e=>{
                const t = p.default.intInRange(-4, 4);
                return e.player.reputation.benignityMultiplier = r.convertRateModifierRangeToActual(t),
                -1 * T(t)
            }
        },
        [c.MalignityRate]: {
            weight: 1,
            apply: e=>{
                const t = p.default.intInRange(-4, 4);
                return e.player.reputation.malignityMultiplier = r.convertRateModifierRangeToActual(t),
                T(t)
            }
        }
    };
    function g(e) {
        const a = game.getDifficultyOptions().player.statusEffects.get(e);
        return !!a && (a.untreatable && a.startWith && 0 === a.passChanceMultiplier && a.effectRateMultiplier === t.PERMANENT_STATUS_EFFECT_MULTIPLIER_RATE && a.effectMultiplier === t.PERMANENT_STATUS_EFFECT_MULTIPLIER)
    }
    function f(e=game.getDifficultyOptions() ) {
        return e.time.frozen && void 0 === e.time.dayLength && void 0 === e.time.dayPercent && e.time.initial === o.TIME_ETERNAL_NIGHT
    }
    function T(e, t=25) {
        return 1 === e ? 0 : (e < 1 && e--,
        t * e)
    }
    t.default = y,
    t.isPermanentEffect = g,
    t.isEternalNight = f
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("game/Difficulty", ["require", "exports", "game/Challenge"], function(e, t, a) {
    var i;
    function n(e, t) {
        switch (e) {
        case i.Hardcore:
        case i.Custom:
            return {
                peaceful: !1,
                respawn: !1,
                player: {
                    initialItems: !0,
                    reputation: {
                        benignityMultiplier: 1,
                        malignityMultiplier: 1,
                        initialMalignity: 0,
                        initialBenignity: 0
                    },
                    stats: new Map,
                    statusEffects: new Map,
                    randomSkills: !0,
                    skills: new Map
                },
                time: {
                    initial: 0,
                    frozen: !1
                },
                disableMods: !1
            };
        case i.Challenge:
            return a.applyChallengeModifiers(n(i.Hardcore), t);
        case i.Casual:
            return {
                peaceful: !0,
                respawn: !0,
                player: {
                    initialItems: !0,
                    reputation: {
                        benignityMultiplier: 1,
                        malignityMultiplier: 1,
                        initialMalignity: 0,
                        initialBenignity: 0
                    },
                    stats: new Map,
                    statusEffects: new Map,
                    randomSkills: !0,
                    skills: new Map
                },
                time: {
                    initial: 0,
                    frozen: !1
                },
                disableMods: !1
            }
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Hardcore = 0] = "Hardcore",
        e[e.Casual = 1] = "Casual",
        e[e.Challenge = 2] = "Challenge",
        e[e.Custom = 3] = "Custom"
    }(i = t.Difficulty || (t.Difficulty = {})),
    t.TIME_ETERNAL_NIGHT = .7,
    t.getDefaultDifficultyOptions = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/INotifier", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/ITextureDebugRenderer", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("game/IGame", ["require", "exports"], function(e, t) {
    var a, i, n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.GlobalSlotLoaded = 0] = "GlobalSlotLoaded",
        e[e.Pause = 1] = "Pause",
        e[e.Resume = 2] = "Resume"
    }(a = t.GameEvent || (t.GameEvent = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.FreshWater = 1] = "FreshWater",
        e[e.Seawater = 2] = "Seawater"
    }(i = t.WaterType || (t.WaterType = {})),
    function(e) {
        e[e.ActionManager = 0] = "ActionManager",
        e[e.FovTransition = 1] = "FovTransition",
        e[e.FovUpdate = 2] = "FovUpdate",
        e[e.GamePassTurn = 3] = "GamePassTurn",
        e[e.GameTick = 4] = "GameTick",
        e[e.HiddenMob = 5] = "HiddenMob",
        e[e.ItemEquip = 6] = "ItemEquip",
        e[e.ItemEquipEffect = 7] = "ItemEquipEffect",
        e[e.ItemUnequip = 8] = "ItemUnequip",
        e[e.Mod = 9] = "Mod",
        e[e.MovementCreature = 10] = "MovementCreature",
        e[e.MovementNPC = 11] = "MovementNPC",
        e[e.MovementPlayerPost = 12] = "MovementPlayerPost",
        e[e.MovementPlayerPre = 13] = "MovementPlayerPre",
        e[e.MovementPlayerZPost = 14] = "MovementPlayerZPost",
        e[e.MovementPlayerZPre = 15] = "MovementPlayerZPre",
        e[e.MovementTileEvent = 16] = "MovementTileEvent",
        e[e.MultiplayerDisconnect = 17] = "MultiplayerDisconnect",
        e[e.OptionHeadgear = 18] = "OptionHeadgear",
        e[e.OptionVisionMode = 19] = "OptionVisionMode",
        e[e.OptionZoomLevel = 20] = "OptionZoomLevel",
        e[e.PlayerKill = 21] = "PlayerKill",
        e[e.PlayerRemove = 22] = "PlayerRemove",
        e[e.PlayerRest = 23] = "PlayerRest",
        e[e.PlayerRestStart = 24] = "PlayerRestStart",
        e[e.PlayerRestStop = 25] = "PlayerRestStop",
        e[e.PlayerWalkToTilePath = 26] = "PlayerWalkToTilePath",
        e[e.PlayerWalkToTilePathOverburdened = 27] = "PlayerWalkToTilePathOverburdened",
        e[e.PlayerWalkToTilePathPreview = 28] = "PlayerWalkToTilePathPreview",
        e[e.PlayerWalkToTilePathReset = 29] = "PlayerWalkToTilePathReset",
        e[e.RemoveBlood = 30] = "RemoveBlood",
        e[e.Resize = 31] = "Resize",
        e[e.SetupGl = 32] = "SetupGl",
        e[e.StartGame = 33] = "StartGame",
        e[e.TileUpdate = 34] = "TileUpdate",
        e[e.WorldLayerRendererFlush = 35] = "WorldLayerRendererFlush"
    }(n = t.RenderSource || (t.RenderSource = {})),
    t.lineOfSightRadius = 15,
    t.lineOfSightMaxRadius = 20,
    t.lineOfSightDetail = 4,
    t.interval = 16.6666,
    t.maximumTurnDelay = 500 / t.interval,
    t.defaultTurnDelay = 200 / t.interval
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/IHookHost", ["require", "exports"], function(e, t) {
    function a(e, t) {
        if ("object" != typeof e)
            return (t,a)=>{
                i(t, a, e)
            }
            ;
        i(e, t)
    }
    function i(e, a, i) {
        e[t.SYMBOL_HOOKS] = Object.assign({}, t.SYMBOL_HOOKS in e ? e[t.SYMBOL_HOOKS] : {}),
        e[t.SYMBOL_HOOKS][a] = i
    }
    var n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.HookMethod = a,
    t.SYMBOL_HOOKS = Symbol("hooks"),
    t.SYMBOL_HOST_NAME = Symbol("name"),
    function(e) {
        function t(e) {
            for (const t in e)
                i(e, t);
            return e
        }
        e.createHost = t
    }(n = t.IHookHost || (t.IHookHost = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/quest/QuestManager", ["require", "exports", "mod/IHookHost", "mod/IHookManager", "player/quest/quest/IQuest", "player/quest/Quests", "save/ISerializer", "utilities/Emitter", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class p extends s.default {
        constructor(e, t) {
            super(),
            this.host = e,
            this.checkers = new Map,
            this.hookHost = a.IHookHost.createHost({
                [t]: (...e)=>{
                    for (const [t,a] of this.checkers.entries()) {
                        if (t.completed) {
                            this.removeRequirementChecker(t);
                            continue
                        }
                        const i = this.getApi(t)
                          , n = a(i, ...e);
                        (i.updated || n) && this.emit(0, t),
                        n && (this.emit(1, t),
                        this.removeRequirementChecker(t))
                    }
                }
            }),
            hookManager.register(this.hookHost, `Questing:${this.host.getName().getString()}`)
        }
        dispose() {
            hookManager.deregister(this.hookHost, `Questing:${this.host.getName().getString()}`),
            this.emit(2)
        }
        removeRequirementChecker(e) {
            this.checkers.delete(e),
            0 === this.checkers.size && this.dispose()
        }
        getApi(e) {
            return {
                host: this.host,
                requirement: e,
                updated: !1
            }
        }
    }
    class c extends s.default {
        constructor(e, t) {
            super(),
            this.host = e,
            this.event = t,
            this.checkers = new Map,
            this.handler = ((e,...t)=>{
                for (const [e,a] of this.checkers.entries()) {
                    if (e.completed) {
                        this.removeRequirementChecker(e);
                        continue
                    }
                    const i = this.getApi(e)
                      , n = a(i, ...t);
                    (i.updated || n) && this.emit(0, e),
                    n && (this.emit(1, e),
                    this.removeRequirementChecker(e))
                }
            }
            ),
            e.on(t, this.handler)
        }
        dispose() {
            this.host.cancel(this.event, this.handler),
            this.emit(2)
        }
        removeRequirementChecker(e) {
            this.checkers.delete(e),
            0 === this.checkers.size && this.dispose()
        }
        getApi(e) {
            return {
                host: this.host,
                requirement: e,
                updated: !1
            }
        }
    }
    class m extends s.default {
        constructor(e) {
            super(),
            this.host = e,
            this.quests = [],
            this.hookTriggers = new Map,
            this.hostTriggers = new Map,
            this.initializedQuests = new Map,
            hookManager.register(this, "QuestManager")
        }
        getQuests(e) {
            return this.quests.forEach(this.init),
            this.quests.filter(t=>l.default.isValid(n.QuestType, t.type) && (void 0 === e || t.type === e)).map(e=>this.initializedQuests.get(e))
        }
        add(e) {
            const t = o.default[e]
              , a = t.create();
            this.quests.push(a);
            const i = this.init(a);
            return this.emit(1, i),
            this
        }
        reset() {
            this.quests.splice(0, 1 / 0),
            this.initializedQuests.clear();
            for (const e of this.hostTriggers.values().collect(u.default.toArray))
                e.dispose();
            for (const e of this.hookTriggers.values().collect(u.default.toArray))
                e.dispose();
            return this
        }
        complete(e) {
            const t = e.data
              , a = o.default[t.type];
            return !!t.complete || !!t.requirements.every(e=>e.completed) && (t.complete = !0,
            a.getChildren().forEach(this.add),
            a.emit(2, t),
            e.emit(2),
            this.emit(0, e),
            !0)
        }
        onPlayerJoin(e) {
            e === this.host && this.quests.forEach(this.init)
        }
        onGameStart(e, t) {
            this.quests.forEach(this.init)
        }
        init(e) {
            if (!l.default.isValid(n.QuestType, e.type))
                return;
            const t = this.initializedQuests.get(e) || new h(this.host,e,this.quests.indexOf(e)).on("ManualCompletion", this.complete);
            if (this.initializedQuests.set(e, t),
            e.complete)
                return t;
            for (const a of t.getRequirements())
                a.triggerInitialization() && (this.onUpdateRequirement(e, a.data),
                this.onCompleteRequirement(e, a.data));
            const a = o.default[e.type].getTriggers(e);
            for (const [t,i] of a)
                if (!t.completed)
                    for (const [a,n] of i) {
                        const i = this.hookTriggers.get(a) || new p(this.host,a).on(2, ()=>this.hookTriggers.delete(a));
                        i.on(0, (a,i)=>t === i && this.onUpdateRequirement(e, i)).on(1, (a,i)=>t === i && this.onCompleteRequirement(e, i)),
                        this.hookTriggers.set(a, i),
                        i.checkers.set(t, n)
                    }
            const i = o.default[e.type].getHostTriggers(e);
            for (const [t,a] of i)
                if (!t.completed)
                    for (const [i,n] of a) {
                        const a = this.hostTriggers.get(i) || new c(this.host,i).on(2, ()=>this.hostTriggers.delete(i));
                        a.on(0, (a,i)=>t === i && this.onUpdateRequirement(e, i)).on(1, (a,i)=>t === i && this.onCompleteRequirement(e, i)),
                        this.hostTriggers.set(i, a),
                        a.checkers.set(t, n)
                    }
            return t
        }
        onUpdateRequirement(e, t) {
            const a = o.default[e.type]
              , i = this.initializedQuests.get(e)
              , n = a.getRequirement(this.host, e, t);
            return n ? (n.emit("Update", t),
            a.emit(0, i, n),
            i.emit(0),
            this.emit(2, i),
            this) : this
        }
        onCompleteRequirement(e, t) {
            if (e.complete || t.completed)
                return this;
            t.completed = !0;
            const a = o.default[e.type]
              , i = this.initializedQuests.get(e)
              , n = a.getRequirement(this.host, e, t);
            return n ? (n.emit("Met", t),
            a.emit(0, i, n),
            a.emit(1, i, n),
            i.emit(0),
            this.emit(3, i, n),
            a.needsManualCompletion() || this.complete(i),
            this) : this
        }
    }
    __decorate([r.SaveProperty()], m.prototype, "quests", void 0),
    __decorate([d.Bound], m.prototype, "add", null),
    __decorate([d.Bound], m.prototype, "complete", null),
    __decorate([a.HookMethod(i.HookPriority.High)], m.prototype, "onPlayerJoin", null),
    __decorate([a.HookMethod(i.HookPriority.High)], m.prototype, "onGameStart", null),
    __decorate([d.Bound], m.prototype, "init", null),
    t.default = m;
    class h extends s.default {
        constructor(e, t, a) {
            super(),
            this.host = e,
            this.data = t,
            this.id = a
        }
        getTitle() {
            const e = o.default[this.data.type];
            return e.getTitle(this.data)
        }
        getDescription() {
            const e = o.default[this.data.type];
            return e.getDescription(this.data)
        }
        getRequirements() {
            const e = o.default[this.data.type];
            return e.getRequirements(this.host, this.data)
        }
        needsManualCompletion() {
            const e = o.default[this.data.type];
            return e.needsManualCompletion() && !this.data.complete
        }
        complete() {
            return this.emit("ManualCompletion"),
            this
        }
        getChildren() {
            const e = o.default[this.data.type];
            return e.getChildren()
        }
        getCompletionAmount() {
            const e = this.getRequirements().collect(u.default.toArray);
            let t = 0;
            for (const a of e)
                t += a.getCompletionAmount() * (1 / e.length);
            return Math.round(100 * t) / 100
        }
    }
    __decorate([d.Bound], h.prototype, "getTitle", null),
    __decorate([d.Bound], h.prototype, "getDescription", null),
    __decorate([d.Bound], h.prototype, "getRequirements", null),
    __decorate([d.Bound], h.prototype, "getCompletionAmount", null),
    t.QuestInstance = h
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/IPlayer", ["require", "exports", "Enums", "utilities/enum/Enums", "utilities/iterable/Collectors"], function(e, t, a, i, n) {
    function o(e, t) {
        return -1 === e || e === game.mapSize - 1 ? a.Direction.West : 1 === e || e === -1 * (game.mapSize - 1) ? a.Direction.East : 1 === t || t === -1 * (game.mapSize - 1) ? a.Direction.South : a.Direction.North
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.setupSpawnItems = [a.ItemType.Raspberries, a.ItemType.ButtonMushrooms, a.ItemType.StrippedBark, a.ItemType.Branch, a.ItemType.LargeRock, a.ItemType.TreeBark, a.ItemType.String, a.ItemType.Twigs, a.ItemType.LargeRock, a.ItemType.Bone, a.ItemType.AnimalSkull, a.ItemType.Shale, a.ItemType.PlantRoots, a.ItemType.SharpRock, a.ItemType.SheafOfHay, a.ItemType.AnimalClaw, a.ItemType.MilkThistleSeeds, a.ItemType.CottonSeeds, a.ItemType.BeggartickSeeds, a.ItemType.ChiveSeeds, a.ItemType.PotatoSeeds],
    t.setupWaterItems = [a.ItemType.GlassBottleOfUnpurifiedFreshWater, a.ItemType.GlassBottleOfPurifiedFreshWater, a.ItemType.GlassBottleOfDesalinatedWater, a.ItemType.WaterskinOfUnpurifiedFreshWater, a.ItemType.WaterskinOfPurifiedFreshWater, a.ItemType.WaterskinOfDesalinatedWater, a.ItemType.ClayJugOfUnpurifiedFreshWater, a.ItemType.ClayJugOfPurifiedFreshWater, a.ItemType.ClayJugOfDesalinatedWater],
    t.setupToolItems = [a.ItemType.StoneAxe, a.ItemType.StoneKnife, a.ItemType.StoneShovel, a.ItemType.StonePickaxe, a.ItemType.StoneHoe, a.ItemType.StoneHammer, a.ItemType.StonePickaxe],
    t.setupMiscItems = [a.ItemType.WoodenMortarAndPestle, a.ItemType.Bandage, a.ItemType.Waterskin, a.ItemType.GlassBottle, a.ItemType.ClayJug, a.ItemType.FishingRod, a.ItemType.BarkTorch, a.ItemType.Bow, a.ItemType.CordedSling, a.ItemType.SmallBag],
    t.setupHealthItems = [a.ItemType.Tourniquet, a.ItemType.Suture, a.ItemType.Bandage, a.ItemType.CharcoalBandage, a.ItemType.PeatBandage],
    t.setupLightItems = [a.ItemType.LitAnimalFatTorch, a.ItemType.LitBarkTorch, a.ItemType.LitBarkTorch, a.ItemType.LitPoleTorch, a.ItemType.LitPoleTorch, a.ItemType.LitPoleTorch],
    t.setupBookItems = [a.ItemType.GildedRedBook, a.ItemType.MossCoveredBook, a.ItemType.OrnateBlueBook, a.ItemType.Journal],
    t.getDirectionFromMovement = o,
    t.gameMovement = [{
        moveBind: a.Direction.East,
        direction: a.Direction.East,
        x: 1,
        y: 0
    }, {
        moveBind: a.Direction.West,
        direction: a.Direction.West,
        x: -1,
        y: 0
    }, {
        moveBind: a.Direction.North,
        direction: a.Direction.North,
        x: 0,
        y: -1
    }, {
        moveBind: a.Direction.South,
        direction: a.Direction.South,
        x: 0,
        y: 1
    }],
    t.movementIntents = i.default.values(a.Direction).include(["idle", void 0]).collect(n.default.toArray).sort(),
    t.STRENGTH_BONUS = 25
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("entity/Entity", ["require", "exports", "entity/IEntity", "entity/IStats", "Enums", "save/ISerializer", "utilities/Emitter", "utilities/enum/Enums", "utilities/iterable/Generators", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const p = [];
    class c extends r.default {
        constructor() {
            super(),
            this.direction = {
                x: 0,
                y: 0
            },
            this.x = 0,
            this.y = 0,
            this.z = n.WorldZ.Overworld,
            this.fromX = 0,
            this.fromY = 0,
            this.anim = 0,
            this.stopNextMovement = !1,
            this.direction = {
                x: 0,
                y: 0
            },
            this.facingDirection = n.Direction.None,
            this._inFov = !1,
            this.properties = void 0,
            this.status = s.default.keys(n.StatusType).map(e=>l.tuple(e, !1)).collect(d.default.create)
        }
        static is(e, t) {
            return void 0 !== e && e.entityType === t
        }
        static isNot(e, t) {
            return void 0 !== e && e.entityType !== t
        }
        initStat(e) {
            const t = e.get();
            this.stats[i.Stat[t.type]] = t
        }
        hasStat(e) {
            return void 0 !== this.stats[i.Stat[e]]
        }
        removeStat(e) {
            delete this.stats[i.Stat[e]]
        }
        getStat(e, t=!1) {
            const a = this.getStatInternal(e, t);
            return a && new Proxy(a,{
                get: (e,t)=>{
                    switch (t) {
                    case "value":
                        return this.getStatValue(e);
                    case "max":
                        return this.getStatMax(e);
                    case "base":
                        return e;
                    default:
                        return e[t]
                    }
                }
            })
        }
        getStatInternal(e, t=!1) {
            const a = "number" == typeof e ? e : e.type
              , n = this.stats[i.Stat[a]];
            if (n)
                return n;
            if ("object" != typeof e) {
                if (t)
                    return;
                return p.includes(e) || (u.default.warn(u.LogSource.Game, "BaseEntity")(`Tried to get an invalid stat "${e}". This message will be suppressed from now on.`),
                p.push(e)),
                {
                    type: e,
                    value: NaN,
                    max: NaN,
                    changeTimer: NaN,
                    nextChangeTimer: NaN
                }
            }
            return e
        }
        getStatValue(e) {
            return (e = this.getStatInternal("number" == typeof e ? e : e.type)) && e.value + (e.bonus || 0)
        }
        setStat(e, t, i=a.StatChangeReason.Normal) {
            const n = e = this.getStatInternal("number" == typeof e ? e : e.type)
              , o = e.value;
            return n.value = t,
            !e.canExceedMax && void 0 !== e.max && e.value > e.max && (n.value = e.max),
            e.value !== o && (this.emit(a.EntityEvent.StatChanged, this.getStat(e.type), o, a.IStatChangeInfo.get(i)),
            !0)
        }
        reduceStat(e, t, a) {
            return this.increaseStat(e, -1 * t, a)
        }
        increaseStat(e, t, a) {
            return e = this.getStatInternal("number" == typeof e ? e : e.type),
            this.setStat(e, e.value + t, a)
        }
        setStatBonus(e, t, i) {
            if ((e = this.getStatInternal("number" == typeof e ? e : e.type)).bonus === t)
                return;
            const n = e.bonus;
            e.bonus = t,
            i = void 0 === i ? void 0 : a.IStatChangeInfo.get(i),
            this.emit(a.EntityEvent.StatBonusChanged, this.getStat(e.type), n, i),
            this.emit(a.EntityEvent.StatChanged, this.getStat(e.type), e.value + (n || 0), Object.assign({}, i, {
                reason: a.StatChangeReason.BonusChanged
            })),
            "number" == typeof e.max && this.emit(a.EntityEvent.StatMaxChanged, this.getStat(e.type), e.max + (n || 0), Object.assign({}, i, {
                reason: a.StatChangeReason.BonusChanged
            }))
        }
        getStatMax(e) {
            return (e = this.getStatInternal("number" == typeof e ? e : e.type)).max && e.max + (e.bonus || 0)
        }
        setStatMax(e, t) {
            const i = e = this.getStatInternal("number" == typeof e ? e : e.type)
              , n = e.max;
            i.max = t,
            this.emit(a.EntityEvent.StatMaxChanged, e, n)
        }
        setStatChangeTimer(e, t, i) {
            const n = "number" == typeof e ? e : e.type;
            if (e = this.getStatInternal(n),
            void 0 !== i && i !== e.changeAmount ? e.changeAmount = i : void 0 === i && void 0 === e.changeAmount && (e.changeAmount = 1),
            e.nextChangeTimer === t)
                return;
            const o = e
              , r = e.nextChangeTimer;
            o.nextChangeTimer = t,
            r ? e.changeTimer -= r - t : e.changeTimer = t,
            this.emit(a.EntityEvent.StatTimerChanged, e, r)
        }
        setStatAndMax(e, t, a) {
            this.setStatMax(e, t),
            this.setStat(e, a)
        }
        updateStats() {
            for (const e of Object.values(this.stats))
                if (void 0 !== e.changeTimer) {
                    const t = e;
                    t.changeTimer--,
                    t.changeTimer <= 0 && (this.setStat(t, t.value + t.changeAmount, a.StatChangeReason.ChangeTimer),
                    t.changeTimer = t.nextChangeTimer)
                }
        }
        hasStatus(e) {
            return this.status[n.StatusType[e]] || !1
        }
        setStatus(e, t, i) {
            this.status[n.StatusType[e]] = t,
            this.emit(a.EntityEvent.StatusChange, e, t, i)
        }
        *statuses() {
            for (const e in this.status)
                this.status[e] && (yield n.StatusType[e])
        }
        getTile() {
            return game.getTileFromPoint(this)
        }
        getPoint() {
            return {
                x: this.x,
                y: this.y,
                z: this.z
            }
        }
        getFacingPoint() {
            return {
                x: game.getWrappedCoord(this.x + this.direction.x),
                y: game.getWrappedCoord(this.y + this.direction.y),
                z: this.z
            }
        }
        getFacingTile() {
            return game.getTileFromPoint(this.getFacingPoint())
        }
        getMovementProgress() {
            if (void 0 === this._movementFinishTime)
                return 1;
            const e = 1 - Math.min(1, Math.max(0, (this._movementFinishTime - game.absoluteTime) / (10 * game.interval)));
            return 1 === e && (this._movementFinishTime = void 0),
            e
        }
        getMovementFinishTime() {
            return this._movementFinishTime
        }
        getMoveType() {
            return void 0 !== this.moveType ? this.moveType : n.MoveType.None
        }
        setMoveType(e) {
            this.moveType = e
        }
        isInFov() {
            return this._inFov
        }
        setInFov(e) {
            this._inFov = e
        }
        isOnFire() {
            return game.isOnFire(this.getTile())
        }
        canSeePosition(e, t, a, i) {
            return game.canASeeB(e, t, a, this.x, this.y, this.z, i)
        }
        queueSoundEffect(e, t=0, a=1, i=!1) {
            audio.queueEffect(e, this.x, this.y, this.z, t, a, i)
        }
        queueSoundEffectInFront(e, t=0, a=1, i=!1) {
            audio.queueEffect(e, this.x + this.direction.x, this.y + this.direction.y, this.z, t, a, i)
        }
        hasProperty(e) {
            return void 0 !== this.properties && this.properties.has(e)
        }
        addProperty(e, t) {
            void 0 === this.properties && (this.properties = new Map),
            this.properties.set(e, t)
        }
        getProperty(e) {
            return void 0 !== this.properties ? this.properties.get(e) : void 0
        }
        removeProperty(e) {
            return void 0 !== this.properties && this.properties.delete(e)
        }
    }
    __decorate([o.SaveProperty()], c.prototype, "id", void 0),
    __decorate([o.SaveProperty()], c.prototype, "renamed", void 0),
    __decorate([o.SaveProperty()], c.prototype, "z", void 0),
    __decorate([o.SaveProperty()], c.prototype, "x", void 0),
    __decorate([o.SaveProperty()], c.prototype, "y", void 0),
    __decorate([o.SaveProperty()], c.prototype, "fromX", void 0),
    __decorate([o.SaveProperty()], c.prototype, "fromY", void 0),
    __decorate([o.SaveProperty()], c.prototype, "moveType", void 0),
    __decorate([o.SaveProperty()], c.prototype, "anim", void 0),
    __decorate([o.SaveProperty()], c.prototype, "stopNextMovement", void 0),
    __decorate([o.SaveProperty()], c.prototype, "direction", void 0),
    __decorate([o.SaveProperty()], c.prototype, "facingDirection", void 0),
    __decorate([o.SaveProperty()], c.prototype, "stats", void 0),
    __decorate([o.SaveProperty()], c.prototype, "status", void 0),
    __decorate([o.SaveProperty()], c.prototype, "properties", void 0),
    t.default = c
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("player/MessageManager", ["require", "exports", "entity/Entity", "entity/IEntity", "language/Dictionaries", "language/dictionary/Misc", "language/Translation", "multiplayer/packets/server/AddMessageHistoryPacket", "player/IMessageManager", "save/ISerializer", "utilities/iterable/Generators"], function(e, t, a, i, n, o, r, s, l, u, d) {
    var p;
    function c(e) {
        return e.filter(e=>"number" == typeof e).map(e=>l.Source[e])
    }
    function m(e) {
        return "string" == typeof e ? [] : e.map(e=>l.Source[e])
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Bad = 1] = "Bad",
        e[e.Good = 2] = "Good",
        e[e.Miss = 3] = "Miss",
        e[e.Attack = 4] = "Attack",
        e[e.Stat = 5] = "Stat",
        e[e.Skill = 6] = "Skill"
    }(p = t.MessageType || (t.MessageType = {}));
    class h {
        constructor() {
            this.saveNoProperties = void 0
        }
        getMessageHistory() {
            return d.pipe()
        }
        clear() {
            return this
        }
        source() {
            return this
        }
        type() {
            return this
        }
        ifVisible() {
            return this
        }
        send() {
            return !1
        }
    }
    __decorate([u.SaveProperty()], h.prototype, "saveNoProperties", void 0);
    class y {
        constructor(e) {
            this.host = e,
            this.history = [],
            this.lastMessageId = 1,
            this._source = ["All"],
            this._type = p.None,
            this._sentToAll = !1,
            this.canSend = !0
        }
        static get(e) {
            return e && a.default.is(e, i.EntityType.Player) ? e.messages : this.noOpMessageManager
        }
        static toAll(e) {
            return multiplayer.isConnected() && multiplayer.isServer() ? players.map(t=>e(t.messages.sentToAll(!0), t)).some(e=>e) : e(localPlayer.messages.sentToAll(!0), localPlayer)
        }
        *getMessageHistory() {
            for (let e = this.history.length - 1; e >= 0; e--) {
                const t = this.history[e].message;
                yield{
                    id: this.history[e].id || this.lastMessageId++,
                    type: this.history[e].type,
                    time: this.history[e].time,
                    turn: this.history[e].turn,
                    message: Array.isArray(t) ? new r.default(n.Dictionary.Misc,o.MiscTranslation.Thing).addArgs(t).serialize() : t,
                    source: m(this.history[e].source)
                }
            }
        }
        pruneMessageHistory() {
            const e = this.host.getMessageStorageMax();
            return this.history.length > e && (this.history.splice(0, this.history.length - e),
            !0)
        }
        clear() {
            return this.history.splice(0, 1 / 0),
            this
        }
        source(e, ...t) {
            return !0 !== e && (t.includes(l.Source.Game) || t.push(l.Source.Game),
            t.push(e)),
            t.includes(l.Source.All) || t.push(l.Source.All),
            this._source = c(t),
            this
        }
        type(e=p.None) {
            return this._type = e,
            this
        }
        ifVisible(e) {
            return this.canSend = !e || this.host.canSeePosition(e.x, e.y, e.z),
            this
        }
        send(e, ...t) {
            if (!this.canSend)
                return this.source(),
                this.type(),
                this.ifVisible(),
                !1;
            const a = "number" == typeof e ? e : -1;
            "number" == typeof e && (e = r.default.message(e).addArgs(...t),
            this._source.includes(l.Source[l.Source.Chat]) || e.inContext(4));
            const i = m(this._source)
              , n = this.lastMessageId++
              , o = {
                source: i,
                message: e.serialize(),
                type: this._type === p.None ? void 0 : this._type,
                time: Date.now(),
                turn: localPlayer.turns,
                id: n
            };
            if (void 0 === o.type && delete o.type,
            !1 !== this.host.shouldDisplayMessage(o, a)) {
                this.host.onDisplayMessage(o);
                const e = Object.assign({}, o, {
                    source: this._source
                });
                if (this.addToHistory(e),
                !this._sentToAll && multiplayer.isConnected() && multiplayer.isClient()) {
                    const t = new s.default;
                    t.messageHistoryItem = e,
                    t.send()
                }
            }
            return this.source(),
            this.type(),
            this.ifVisible(),
            this.sentToAll(),
            !0
        }
        addToHistory(e) {
            this.history.push(e);
            const t = this.host.getMessageStorageMax();
            this.history.length > t && this.history.splice(0, this.history.length - t)
        }
        sentToAll(e=!1) {
            return this._sentToAll = e,
            this
        }
    }
    y.noOpMessageManager = new h,
    __decorate([u.SaveProperty()], y.prototype, "history", void 0),
    __decorate([u.SaveProperty()], y.prototype, "lastMessageId", void 0),
    t.default = y
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("game/inspection/IInspection", ["require", "exports"], function(e, t) {
    var a, i, n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Player = 0] = "Player",
        e[e.NPC = 1] = "NPC",
        e[e.Creature = 2] = "Creature",
        e[e.Doodad = 3] = "Doodad",
        e[e.TileEvents = 4] = "TileEvents",
        e[e.Items = 5] = "Items",
        e[e.Corpses = 6] = "Corpses",
        e[e.Tile = 7] = "Tile"
    }(a = t.InspectType || (t.InspectType = {})),
    function(e) {
        e[e.Player = 0] = "Player",
        e[e.NPC = 1e3] = "NPC",
        e[e.Creature = 2e3] = "Creature",
        e[e.Doodad = 3e3] = "Doodad",
        e[e.TileEvents = 4e3] = "TileEvents",
        e[e.Items = 5e3] = "Items",
        e[e.Corpses = 6e3] = "Corpses",
        e[e.Tile = 7e3] = "Tile"
    }(i = t.BasicInspectionPriority || (t.BasicInspectionPriority = {})),
    function(e) {
        e[e.Tooltip = 0] = "Tooltip",
        e[e.Message = 1] = "Message"
    }(n = t.InspectionContext || (t.InspectionContext = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("game/inspection/Inspections", ["require", "exports", "Enums", "game/inspection/IInspection", "language/Dictionaries", "language/dictionary/Misc", "language/Translation", "utilities/iterable/Iterables", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class u {
        constructor() {
            this.content = []
        }
        static get(e, t) {
            const a = new u;
            return t.inspect(e, a),
            [a]
        }
        add(...e) {
            for (const t of e)
                t && this.content.push(t instanceof r.default ? {
                    text: t
                } : t);
            return this
        }
        addExtra(...e) {
            for (const t of e)
                t && this.content.push(Object.assign({}, t instanceof r.default ? {} : t, {
                    extra: !0,
                    text: t instanceof r.default ? t : t.text
                }));
            return this
        }
        addIf(e, t) {
            if (e) {
                const e = t();
                this.add(...s.isIterable(e)?e:[e])
            }
            return this
        }
    }
    t.InspectionSection = u;
    const d = {
        [i.InspectType.Tile]: ({context: e, tile: t, tilePosition: s})=>[[{
            name: !0,
            text: r.default.nameOf(n.Dictionary.Terrain, l.default.getType(t), !1).inContext(e === i.InspectionContext.Tooltip ? 3 : 0).addReformatter(new r.default(n.Dictionary.Misc,o.MiscTranslation.ItemQualityColor).addArgs(()=>{
                const e = game.getTileData(...s.xyz);
                return e && e[0].quality && a.ItemQuality[e[0].quality].toLowerCase()
            }
            ))
        }]],
        [i.InspectType.Player]: ({inspector: e, tilePosition: t, inspectEntityHealth: a})=>game.getPlayersAtPosition(t, !0, !0).filter(t=>t.id !== e.id).map(e=>({
            border: "var(--text-color-player)",
            content: [{
                title: !0,
                name: !0,
                text: e.getName()
            }, a(e)]
        })),
        [i.InspectType.Doodad]: e=>e.tile.doodad && u.get(e, e.tile.doodad),
        [i.InspectType.NPC]: ({tile: e, inspectEntityHealth: t})=>e.npc && [{
            border: "var(--text-color-player)",
            content: [{
                title: !0,
                name: !0,
                text: e.npc.getName()
            }, t(e.npc)]
        }],
        [i.InspectType.Creature]: e=>e.tile.creature && u.get(e, e.tile.creature),
        [i.InspectType.TileEvents]: e=>e.tile.events && tileEventManager.inspect(e, ...e.tile.events),
        [i.InspectType.Corpses]: e=>e.tile.corpses && corpseManager.inspect(e, ...e.tile.corpses),
        [i.InspectType.Items]: e=>e.tile.containedItems && itemManager.inspect(e, ...e.tile.containedItems)
    };
    t.default = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("doodad/IDoodad", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("item/IItem", ["require", "exports"], function(e, t) {
    var a, i, n;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Invalid = 0] = "Invalid",
        e[e.PlayerInventory = 1] = "PlayerInventory",
        e[e.Doodad = 2] = "Doodad",
        e[e.World = 3] = "World",
        e[e.Tile = 4] = "Tile",
        e[e.Item = 5] = "Item",
        e[e.NPCInventory = 6] = "NPCInventory"
    }(a = t.ContainerReferenceType || (t.ContainerReferenceType = {})),
    function(e) {
        e[e.Fail = 0] = "Fail",
        e[e.Success = 1] = "Success",
        e[e.CritSuccess = 2] = "CritSuccess"
    }(i = t.CraftResult || (t.CraftResult = {})),
    function(e) {
        e[e.Default = 0] = "Default",
        e[e.Trade = 1] = "Trade"
    }(n = t.ContainerType || (t.ContainerType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("entity/IHuman", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("npc/INPC", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("entity/IEntity", ["require", "exports"], function(e, t) {
    var a, i, n, o, r, s, l;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.StatChanged = 0] = "StatChanged",
        e[e.StatTimerChanged = 1] = "StatTimerChanged",
        e[e.StatMaxChanged = 2] = "StatMaxChanged",
        e[e.StatBonusChanged = 3] = "StatBonusChanged",
        e[e.StatusChange = 4] = "StatusChange"
    }(a = t.EntityEvent || (t.EntityEvent = {})),
    function(e) {
        e[e.Gained = 0] = "Gained",
        e[e.Passed = 1] = "Passed",
        e[e.Treated = 2] = "Treated"
    }(i = t.StatusEffectChangeReason || (t.StatusEffectChangeReason = {})),
    function(e) {
        e[e.Normal = 0] = "Normal",
        e[e.ChangeTimer = 1] = "ChangeTimer",
        e[e.BonusChanged = 2] = "BonusChanged",
        e[e.Upgrade = 3] = "Upgrade"
    }(n = t.StatChangeReason || (t.StatChangeReason = {})),
    function(e) {
        function t(e, t) {
            let a = {};
            return "boolean" == typeof e ? (a.reason = n.Normal,
            a.important = e) : "object" == typeof e ? a = e : a.reason = e,
            void 0 !== t && (a.important = t),
            a
        }
        e.get = t
    }(o = t.IStatChangeInfo || (t.IStatChangeInfo = {})),
    function(e) {
        e[e.Credit = 0] = "Credit",
        e[e.Talked = 1] = "Talked"
    }(r = t.Property || (t.Property = {})),
    function(e) {
        e[e.Player = 0] = "Player",
        e[e.Creature = 1] = "Creature",
        e[e.NPC = 2] = "NPC"
    }(s = t.EntityType || (t.EntityType = {})),
    function(e) {
        e[e.Neutral = 0] = "Neutral",
        e[e.Hostile = 1] = "Hostile",
        e[e.Scared = 2] = "Scared",
        e[e.Random = 4] = "Random",
        e[e.Hidden = 8] = "Hidden",
        e[e.Fearless = 16] = "Fearless",
        e[e.Tamed = 32] = "Tamed",
        e[e.Follower = 64] = "Follower",
        e[e.Defender = 128] = "Defender",
        e[e.Fleeing = 256] = "Fleeing",
        e[e.Waiting = 512] = "Waiting"
    }(l = t.AiType || (t.AiType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("creature/ICreature", ["require", "exports"], function(e, t) {
    var a, i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Any = 0] = "Any",
        e[e.Guardians = 1] = "Guardians",
        e[e.Seawater = 2] = "Seawater",
        e[e.CaveWater = 3] = "CaveWater",
        e[e.Cave = 4] = "Cave",
        e[e.Night = 5] = "Night",
        e[e.StrongGuardians = 6] = "StrongGuardians",
        e[e.FreshWater = 7] = "FreshWater",
        e[e.EasyNight = 8] = "EasyNight"
    }(a = t.SpawnGroup || (t.SpawnGroup = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Default = 1] = "Default",
        e[e.DefaultWithLava = 2] = "DefaultWithLava",
        e[e.DefaultWithWater = 3] = "DefaultWithWater",
        e[e.DeepSeawater = 4] = "DeepSeawater",
        e[e.Water = 5] = "Water",
        e[e.Flying = 6] = "Flying",
        e[e.Ghost = 7] = "Ghost",
        e[e.Desert = 8] = "Desert",
        e[e.Lava = 9] = "Lava",
        e[e.Wet = 10] = "Wet",
        e[e.Ground = 11] = "Ground",
        e[e.All = 12] = "All",
        e[e.Seawater = 13] = "Seawater",
        e[e.FreshWater = 14] = "FreshWater"
    }(i = t.SpawnableTiles || (t.SpawnableTiles = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/Action", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor(...e) {
            this.usability = {},
            this.argumentTypes = e
        }
        setPreExecutionHandler(e) {
            return this.preExecutionHandler = e,
            this
        }
        setConfirmer(e) {
            return this.confirmer = e,
            this
        }
        setHandler(e) {
            return this.handler = e,
            this
        }
        setUsableWhen(...e) {
            for (const t of e)
                this.usability[t] = !0;
            return this
        }
        setUsableBy(...e) {
            return this.validExecutors = e,
            this
        }
        clone() {
            return new a(...this.argumentTypes).setUsableBy(...this.validExecutors).setUsableWhen(...Object.keys(this.usability).map(e=>parseInt(e, 10))).setPreExecutionHandler(this.preExecutionHandler).setConfirmer(this.confirmer).setHandler(this.handler)
        }
    }
    t.Action = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/AddFuel", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const u = o.SkillType.Camping;
    t.default = new a.Action(i.ActionArgument.ItemNearby,i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t,a)=>{
        if (!t || !a || void 0 === a.decay)
            return;
        e.setDelay(25).setPassTurn().setUpdateTablesAndWeight().setStaminaReduction(u).addSkillGains(u);
        let i = 0;
        const n = t.description();
        if (n) {
            const e = t.getStokeFireValue();
            e && (i = 20 * e)
        }
        const d = a.description();
        if (d && void 0 !== d.decayMax && i + a.decay >= 1.5 * d.decayMax)
            l.default.get(e.executor).source(s.Source.Action, s.Source.Item).send(r.default.CannotAddAnyMoreFuel, a.getName());
        else {
            if (e.setItemsUsed(),
            !e.executor.skillCheck(u, 35))
                return e.addSkillGains(u, .1),
                l.default.get(e.executor).source(s.Source.Action, s.Source.Item).type(l.MessageType.Bad).send(r.default.FailedToAddFuelToTorch),
                void e.setSoundEffect(o.SfxType.Fail, !0);
            a.decay += i,
            ui.updateItem(a),
            itemManager.remove(t),
            l.default.get(e.executor).source(s.Source.Action, s.Source.Item).send(r.default.AddedFuelToTorch),
            e.setSoundEffect(o.SfxType.Throw, !0)
        }
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Attack", ["require", "exports", "action/Action", "action/IAction", "entity/Entity", "entity/IEntity", "entity/IStats", "Enums", "item/Items", "language/dictionary/Message", "language/Translation", "mod/IHookManager", "multiplayer/IMultiplayer", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "player/Player", "tile/Terrains", "utilities/iterable/Generators", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.Item, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.AttackType, i.ActionArgument.Undefined)).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setPreExecutionHandler((e,t,a)=>e.addItems(t)).setHandler((e,t,a)=>{
        const v = e.executor;
        switch (e.type) {
        case i.ActionType.Fire:
            a = s.AttackType.Fire;
            break;
        case i.ActionType.Shoot:
            a = s.AttackType.Shoot;
            break;
        case i.ActionType.Sling:
            a = s.AttackType.Sling;
            break;
        case i.ActionType.Throw:
            a = s.AttackType.ThrowItem
        }
        if (void 0 === t || void 0 === a) {
            const e = v.getAndSwitchHandToUse();
            if (!e)
                return;
            a = (t = v.getEquippedItem(e)) ? s.AttackType.Melee : s.AttackType.HandToHand
        }
        const w = n.default.is(v, o.EntityType.Player) ? modManager.getHook(p.Hook.CanPlayerAttack).call(v, t, a) : modManager.getHook(p.Hook.CanNPCAttack).call(v, t, a);
        if (!1 === w)
            return;
        let M, b, k;
        multiplayer.addSyncCheck(c.MultiplayerSyncCheck.ActionAttack, t ? t.id : ""),
        e.setItemsUsed();
        let C = 0, D, A, P = s.SkillType.Tactics;
        const G = multiplayer.isConnected() && multiplayer.getOptions().pvp
          , R = t ? l.default[t.type] : void 0;
        let x = 0;
        if (t && (x = t.weight,
        itemManager.isContainer(t))) {
            const e = itemManager.computeContainerWeight(t);
            e > 0 && (x += e * t.getContainerWeightReduction())
        }
        switch (multiplayer.addSyncCheck(c.MultiplayerSyncCheck.ActionAttack, `WW:${x}`),
        a) {
        case s.AttackType.HandToHand:
        case s.AttackType.Melee:
            if (!(M = (A = v.getFacingTile()).creature)) {
                if (!(b = A.npc) && (G || !(v instanceof g.default))) {
                    const e = game.getPlayersAtTile(A);
                    b = e.length > 0 ? e[0] : void 0
                }
                A.npc && b === A.npc && A.npc.makeHostile()
            }
            break;
        case s.AttackType.Shoot:
        case s.AttackType.Sling:
        case s.AttackType.Fire:
            if (!t)
                return;
            let n;
            if (e.setDelay(25),
            a === s.AttackType.Shoot)
                k = itemManager.getItemInContainerByGroup(v.inventory, s.ItemTypeGroup.Arrow),
                P = s.SkillType.Marksmanship;
            else if (a === s.AttackType.Fire) {
                if (k = itemManager.getItemInContainerByGroup(v.inventory, s.ItemTypeGroup.Bullet),
                P = s.SkillType.Marksmanship,
                a = s.AttackType.Shoot,
                !(n = itemManager.getItemInContainer(v.inventory, s.ItemType.BlackPowder)))
                    return void y.default.get(v).source(m.Source.Action, m.Source.Equipment, m.Source.Item).send(u.default.NoAmmunitionForThatWeapon, t.getName())
            } else
                k = itemManager.getItemInContainerByGroup(v.inventory, s.ItemTypeGroup.Bullet),
                P = s.SkillType.Throwing,
                a = s.AttackType.Shoot;
            const o = k && R ? R.ranged : void 0;
            if (!k || !o)
                return void y.default.get(v).source(m.Source.Equipment, m.Source.Item).send(u.default.NoAmmunitionForThatWeapon, t.getName());
            let l = o.range;
            if (t.legendary && t.legendary.type === s.LegendaryType.Range && (l += t.legendary.value),
            C = game.rangeFinder(l, v.getSkill(s.SkillType.Marksmanship)),
            D = v.checkForTargetInRange(C, G),
            A = game.getTile(D.x, D.y, D.z),
            n && n.damage(i.ActionType[e.type], n.getDurabilityCharge()),
            D.player)
                b = D.player;
            else if (D.creature)
                M = D.creature;
            else if (D.npc)
                b = D.npc,
                D.npc.makeHostile();
            else {
                t = void 0;
                const a = A.doodad;
                if (a) {
                    const e = a.description();
                    e && e.isTrap ? a.setOffTrap(v, !0) : a.damage()
                }
                e.addSkillGains(P, .1),
                D.obstacle ? y.default.get(v).source(m.Source.Action, m.Source.Item).send(u.default.FiredIntoObstacle, k.getName()) : y.default.get(v).source(m.Source.Action, m.Source.Item).send(u.default.YouFire, k.getName());
                const i = f.default[I.default.getType(A)];
                i && game.particle.createMultiple(D.x, D.y, D.z, i.particles, 3)
            }
            if (void 0 !== k.minDur && k.minDur--,
            void 0 !== k.minDur && k.minDur >= 0) {
                const e = I.default.getType(A)
                  , t = f.default[e];
                t && t.water ? (itemManager.remove(k),
                audio.queueEffect(s.SfxType.Water, D.x, D.y, D.z)) : k.placeOnTile(D.x, D.y, D.z, !0)
            } else
                y.default.get(v).source(m.Source.Action, m.Source.Item).type(y.MessageType.Bad).send(u.default.BrokenWhileFiring, k.getName()),
                itemManager.remove(k);
            v.queueSoundEffect(s.SfxType.Bow);
            break;
        case s.AttackType.ThrowItem:
            if (P = s.SkillType.Throwing,
            !t || !R)
                return;
            e.setDelay(25);
            let d = Math.floor(4 / x);
            if (d > 5 && (d = 5),
            v.reduceStat(r.Stat.Stamina, Math.floor(x)),
            C = game.rangeFinder(d, v.getSkill(s.SkillType.Throwing)),
            D = v.checkForTargetInRange(C, G),
            A = game.getTile(D.x, D.y, D.z),
            D.player)
                b = D.player;
            else if (D.creature)
                M = D.creature;
            else if (D.npc)
                b = D.npc,
                D.npc.makeHostile();
            else {
                const a = A.doodad;
                if (a) {
                    const e = a.description();
                    e && e.isTrap ? a.setOffTrap(v, !0) : a.damage()
                }
                D.obstacle ? y.default.get(v).source(m.Source.Action, m.Source.Item).send(u.default.ThrownIntoObstacle, t.getName()) : y.default.get(v).source(m.Source.Action, m.Source.Item).send(u.default.YouThrew, t.getName()),
                e.addSkillGains(P, .1);
                const i = f.default[I.default.getType(A)];
                i && game.particle.createMultiple(D.x, D.y, D.z, i.particles, 3)
            }
            if (e.setItemsUsed(!1),
            void 0 !== t.minDur && (R.damageModifier ? t.minDur -= R.damageModifier : t.minDur--),
            void 0 !== t.minDur && t.minDur >= 0) {
                const e = I.default.getType(A)
                  , a = f.default[e];
                a && a.water ? (audio.queueEffect(s.SfxType.Water, D.x, D.y, D.z),
                y.default.get(v).source(m.Source.Action, m.Source.Item).send(u.default.ThrownIntoDepths, t.getName()),
                t.dropInWater(v, D.x, D.y, !0)) : t.placeOnTile(D.x, D.y, D.z, !0)
            } else
                y.default.get(v).source(m.Source.Action, m.Source.Item).type(y.MessageType.Bad).send(u.default.BrokenOnImpact, t.getName()),
                itemManager.breakContainerOnTile(t, D.x, D.y, D.z);
            audio.queueEffect(s.SfxType.Throw, D.x, D.y, D.z),
            v.addMilestone(h.MilestoneType.Thrower),
            itemManager.isContainer(t) && ui.closeContainer(t)
        }
        if ((M || b) && (t || a === s.AttackType.HandToHand)) {
            let n;
            n = a === s.AttackType.HandToHand ? u.default.YourFist : k ? k.getName() : t ? t.getName() : u.default.AnUnknownItem;
            const o = S.default.percent(50);
            if (v.getSkill(P) >= o) {
                let o, p;
                if (a === s.AttackType.HandToHand)
                    o = s.DamageType.Blunt;
                else if (k) {
                    const e = l.default[k.type];
                    e && (o = e.damageType)
                } else
                    t && R && (o = R.damageType);
                void 0 === o && (o = s.DamageType.Blunt);
                const h = R ? R.attack : void 0
                  , f = R ? R.ranged : void 0
                  , S = e.executor.getStat(r.Stat.Attack).value;
                switch (a) {
                case s.AttackType.Shoot:
                    if (f && k) {
                        const e = l.default[k.type];
                        e && void 0 !== e.attack ? (p = f.attack + e.attack,
                        k.legendary && k.legendary.type === s.LegendaryType.Attack && (p += k.legendary.value)) : p = 0
                    } else
                        p = 0;
                    break;
                case s.AttackType.ThrowItem:
                    p = h || (t ? Math.floor(x / 4) - S : 0);
                    break;
                case s.AttackType.HandToHand:
                    p = 0;
                    break;
                default:
                    p = void 0 !== h ? h : 0
                }
                let I;
                if (P !== s.SkillType.Tactics && (p += Math.floor(v.getSkill(P) / 30)),
                t && t.legendary && t.legendary.type === s.LegendaryType.Attack && (p += t.legendary.value),
                (p += S) <= 0 && (p = 1),
                multiplayer.addSyncCheck(c.MultiplayerSyncCheck.ActionAttack, `DA:${p}`),
                b) {
                    let e;
                    e = a === s.AttackType.HandToHand ? d.default.message(u.default.DeathByFistByPlayer).addArgs(v.getName()) : d.default.message(u.default.DeathByWeaponByPlayer).addArgs(n, v.getName()),
                    I = b.damage({
                        human: v,
                        amount: p,
                        type: o,
                        weaponName: n,
                        damageMessage: e
                    }),
                    b.queueSoundEffect(s.SfxType.Hit),
                    multiplayer.isConnected() && b.updateStatsAndAttributes(),
                    b instanceof g.default && v instanceof g.default && (v.setTamedCreatureEnemy(b),
                    b.setTamedCreatureEnemy(v))
                } else
                    void 0 !== M && (I = M.damage({
                        human: v,
                        amount: p,
                        type: o,
                        weaponName: n
                    }),
                    M.queueSoundEffect(s.SfxType.Hit, 0, 1));
                void 0 !== I && I > 0 && (P === s.SkillType.Tactics ? e.addSkillGains(P) : e.addSkillGains(T.tuple(P), T.tuple(s.SkillType.Tactics))),
                a === s.AttackType.HandToHand ? v instanceof g.default && v.hurtHands(u.default.ToFight) && y.default.get(v).source(m.Source.Combat, m.Source.Wellbeing, m.Source.Equipment, m.Source.Action).type(y.MessageType.Bad).send(u.default.HurtHandsHittingWithoutWeapons, (M || b).getName()) : a === s.AttackType.Melee && t && t.damage(i.ActionType[e.type])
            } else {
                e.setSoundEffect(s.SfxType.Miss);
                let t = d.default.message(u.default.YourFist)
                  , a = d.default.message(u.default.TheirFist);
                n instanceof d.default ? t = a = n : "number" == typeof n && n !== u.default.YourFist && (t = a = d.default.message(n)),
                game.notifier.addStat((M || b).x, (M || b).y, (M || b).z, s.StatType.Miss, 0),
                y.default.get(v).source(m.Source.Combat, m.Source.Action).type(y.MessageType.Miss).send(u.default.MissedWith, (M || b).getName(), t),
                b instanceof g.default && y.default.get(b).source(m.Source.Combat).type(y.MessageType.Miss).send(u.default.MissedYouWith, v.getName(), a),
                e.addSkillGains(P, .1)
            }
        }
        a !== s.AttackType.Shoot && a !== s.AttackType.ThrowItem || e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        a === s.AttackType.HandToHand && v.reduceStat(r.Stat.Stamina, 1),
        e.setStaminaReduction(P)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Build", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "game/IGame", "item/Items", "language/dictionary/Message", "language/Translation", "mod/IHookManager", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/TileHelpers", "utilities/TilePosition"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.Item).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        if (void 0 === t.minDur)
            return;
        e.setDelay(25);
        const a = t.description();
        if (!a || t.minDur <= 0)
            return void c.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(l.default.TooDamaged, t.getName(), u.default.message(l.default.Build));
        const n = e.executor.getFacingTile();
        if (!n)
            return;
        const g = n
          , f = h.default.getType(n);
        if (g.containedItems && g.containedItems.length > 0)
            return void c.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(l.default.CannotBuildHere, t.getName());
        const {x: T, y: S, z: I} = e.executor.getFacingPoint()
          , v = m.default[f];
        if (void 0 !== n.doodad || f === o.TerrainType.CaveEntrance || f === o.TerrainType.Lava || f === o.TerrainType.CoolingLava || v && !v.passable || void 0 !== n.creature || void 0 !== n.npc || void 0 !== n.events || !e.executor.checkAndRemoveBlood() || game.isPlayerAtPosition(T, S, I))
            return c.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(l.default.CannotPlaceHere, t.getName()),
            void game.checkForHiddenMob(e.executor, T, S, I);
        let w;
        if (e.type === i.ActionType.PlaceDown)
            w = doodadManager.create(o.DoodadType.Item, T, S, I, {
                item: t
            });
        else {
            const e = a.onUse;
            if (e) {
                const t = e[i.ActionType.Build];
                w = doodadManager.create(t, T, S, I)
            } else {
                const e = t.description();
                if (e && e.doodad && e.doodad.group === o.DoodadTypeGroup.Well) {
                    if (w = doodadManager.create(o.DoodadType.Item, T, S, I, {
                        item: t
                    })) {
                        const e = game.wellData[y.getTileId(T, S, I)];
                        let t = e ? e.quantity : 1
                          , a = e ? e.waterType : r.WaterType.None;
                        for (let e = T - 6; e <= T + 6; e++)
                            for (let t = S - 6; t <= S + 6; t++) {
                                const i = m.default[h.default.getType(game.getTile(e, t, I))];
                                if (i && i.water && !i.freshWater) {
                                    a = r.WaterType.Seawater;
                                    break
                                }
                            }
                        if (a !== r.WaterType.Seawater) {
                            const e = m.default[h.default.getType(game.getTile(T, S, o.WorldZ.Cave))];
                            I === o.WorldZ.Cave || e && (e.water || e.shallowWater) ? (t = -1,
                            a = r.WaterType.FreshWater) : e && !e.passable ? a = r.WaterType.FreshWater : (t = 0,
                            a = r.WaterType.None)
                        }
                        game.wellData[y.getTileId(T, S, I)] = {
                            quantity: t,
                            waterType: a
                        }
                    }
                } else
                    w = doodadManager.create(o.DoodadType.Item, T, S, I, {
                        item: t
                    })
            }
        }
        if (w) {
            if (w.minDur = t.minDur,
            w.maxDur = t.maxDur,
            w.quality = t.quality,
            w.weight = t.weight,
            void 0 !== t.renamed && (w.renamed = t.renamed),
            void 0 !== t.legendary && (w.legendary = t.legendary),
            void 0 !== t.disassembly && (w.disassembly = t.disassembly),
            w.ownerIdentifier = void 0 !== t.ownerIdentifier ? t.ownerIdentifier : e.executor.identifier,
            t.type === o.ItemType.WoodenDoor || t.type === o.ItemType.WoodenGate) {
                const t = w;
                t.orientation = o.DoorOrientation.Default,
                e.executor.facingDirection !== o.Direction.East && e.executor.facingDirection !== o.Direction.West || (t.orientation = o.DoorOrientation.Vertical,
                world.updateTile(T, S, I, n))
            }
            if (a.isTorch) {
                const e = a.lit;
                if (t.decay) {
                    w.decay = t.decay;
                    const e = w.description();
                    e && e.isLitTorch && w.decay <= 200 && world.updateTile(T, S, I, n)
                } else if (a.decayMax)
                    w.decay = a.decayMax;
                else if (e) {
                    const t = s.default[e];
                    t && void 0 !== t.decayMax && (w.decay = t.decayMax)
                }
            }
            modManager.getHook(d.Hook.OnBuild).call(e.executor, t, n, w),
            itemManager.remove(t),
            game.packGround(T, S, I),
            v && e.setParticle(v.particles, !0),
            e.setPassTurn(),
            e.setUpdateTablesAndWeight(),
            e.setSoundEffect(o.SfxType.Throw, !0),
            e.setStaminaReduction(o.SkillType.Mining),
            c.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(l.default.SetUp, t.getName())
        }
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Carve", ["require", "exports", "action/Action", "action/IAction", "creature/corpse/Corpses", "creature/Creatures", "entity/IEntity", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(r.EntityType.Player).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        e.setDelay(25);
        const a = e.executor.getFacingTile()
          , {x: r, y: g, z: f} = e.executor.getFacingPoint();
        if (void 0 !== a.creature || void 0 !== a.npc || game.isPlayerAtPosition(r, g, f))
            return c.default.get(e.executor).source(d.Source.Action).send(l.default.SomethingInTheWayOf, u.default.message(l.default.Carving)),
            void game.checkForHiddenMob(e.executor, r, g, f);
        const T = a.corpses;
        if (T) {
            let t = !1
              , a = !1;
            for (let e = T.length - 1; e >= 0; e--) {
                const i = T[e]
                  , o = n.default[i.type];
                if (!o || !o.blood) {
                    a = !0;
                    break
                }
                corpseManager.remove(i),
                t = !0
            }
            if (t && !a)
                return e.setParticle(h.default[m.ParticleType.Blood], !0),
                e.setSoundEffect(s.SfxType.PickUp, !0),
                c.default.get(e.executor).source(d.Source.Action).send(l.default.RemovedBlood),
                void e.setUpdateView();
            t && c.default.get(e.executor).source(d.Source.Action).send(l.default.RemovedBlood)
        }
        if (a.events)
            return tileEventManager.canGather(a) ? (e.get(i.ActionType.Gather).execute(e.executor, t, void 0),
            void e.setDelay(0)) : void c.default.get(e.executor).source(d.Source.Action).send(l.default.SomethingInTheWayOf, u.default.message(l.default.Carving));
        if (T) {
            const t = T.length - 1
              , a = T[t]
              , i = a.type
              , r = o.default[i]
              , u = n.default[i];
            let g;
            i === s.CreatureType.PirateGhost && e.executor.addMilestone(p.MilestoneType.ReaperOfSouls),
            i === s.CreatureType.LavaBeetle && game.changeTile(s.TerrainType.Lava, a.x, a.y, a.z, !1),
            c.default.get(e.executor).source(d.Source.Action, d.Source.Resource).send(l.default.CarvedUpCorpse),
            e.setItemsUsed(),
            g = a.aberrant && r && r.aberrantBlood ? r.aberrantBlood : r && r.blood ? r.blood : h.default[m.ParticleType.Blood],
            e.setParticle(g, !0);
            let f = 25;
            const S = u && u.skill ? u.skill : s.SkillType.Anatomy
              , I = Math.ceil(y.default.int(e.executor.getSkill(S) / 33)) + 1
              , v = corpseManager.getResources(a);
            if (v)
                for (let t = 0; t < I; t++) {
                    let i = 0;
                    if (a.step && (i = a.step),
                    v[i] !== s.ItemType.None) {
                        if (v[i]) {
                            let t = s.ItemQuality.Random;
                            a.aberrant && (t = itemManager.getRandomQuality(v[i], 560));
                            const n = e.executor.createItemInInventory(v[i], t);
                            c.default.get(e.executor).source(d.Source.Action, d.Source.Item, d.Source.Resource).send(l.default.YouPickedUp, n.getName()),
                            f += 4
                        }
                    } else
                        t--;
                    if (a.step ? a.step++ : a.step = 1,
                    a.step >= v.length) {
                        corpseManager.remove(a),
                        r && !r.blood && corpseManager.createBlood(a.x, a.y, a.z);
                        break
                    }
                }
            return r && (a.aberrant && r.reputation < 0 ? e.setReputationChange(25) : e.setReputationChange(r.reputation >= 0 ? 25 : -25)),
            e.addSkillGains(S),
            e.setDelay(f),
            e.setStaminaReduction(S),
            e.setSoundEffect(s.SfxType.PickUp, !0),
            e.setUpdateTablesAndWeight(),
            void e.setPassTurn()
        }
        if (a.doodad) {
            if (a.doodad.canPickup(e.executor))
                return e.get(i.ActionType.Pickup).execute(e.executor, t),
                void e.setDelay(0);
            if (a.doodad.canHarvest())
                return e.get(i.ActionType.Harvest).execute(e.executor, t, void 0),
                void e.setDelay(0);
            if (a.doodad.isGatherable())
                return e.get(i.ActionType.Gather).execute(e.executor, t, void 0),
                void e.setDelay(0)
        }
        c.default.get(e.executor).source(d.Source.Action).send(l.default.NothingHereToCarve)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Cast", ["require", "exports", "action/Action", "action/IAction", "creature/ICreature", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/math/Vector3", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.Item).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        let a, o, h = 0;
        const y = c.default.percent()
          , g = e.executor.getSkill(r.SkillType.Fishing);
        let f = !1
          , T = !1;
        const S = t.description()
          , I = S ? S.ranged : void 0;
        if (!I)
            return;
        e.setDelay(25);
        let v = I.range;
        t.legendary && t.legendary.type === r.LegendaryType.Range && (v += t.legendary.value),
        h = game.rangeFinder(v, g),
        u.default.get(e.executor).source(l.Source.Action).send(s.default.CastYourLine, h);
        const w = e.executor.checkForTargetInRange(h);
        if (void 0 !== w.creature)
            (o = (a = w.creature).description()) && !o.fishable && (u.default.get(e.executor).source(l.Source.Action, l.Source.Creature).send(s.default.CannotFishFor, a.getName()),
            f = !0);
        else if (w.obstacle)
            f = !0,
            u.default.get(e.executor).source(l.Source.Action).send(s.default.SomethingInTheWayOfFishing);
        else {
            if (w.water) {
                const t = 16;
                if (game.fillCount = 0,
                game.fillTile = [],
                game.checkWaterFill(w.x, w.y, w.z, t),
                game.fillCount >= t)
                    if (g >= y) {
                        u.default.get(e.executor).source(l.Source.Action).send(s.default.ShadowInTheWater);
                        const t = creatureManager.spawnFromGroup(w.freshWater ? n.SpawnGroup.FreshWater : n.SpawnGroup.Seawater, w.x, w.y, w.z, !0);
                        t && t.skipNextUpdate(),
                        e.addSkillGains(r.SkillType.Fishing, .1),
                        T = !0
                    } else if (g >= y - 20 && !w.freshWater) {
                        u.default.get(e.executor).source(l.Source.Action, l.Source.Item, l.Source.Resource).send(s.default.SeaweedFromWater);
                        const t = e.executor.createItemInInventory(r.ItemType.Badderlocks);
                        u.default.get(e.executor).source(l.Source.Action, l.Source.Item, l.Source.Resource).send(s.default.YouPickedUp, t.getName()),
                        e.addSkillGains(r.SkillType.Fishing, .1),
                        T = !0
                    }
            } else
                u.default.get(e.executor).source(l.Source.Action).send(s.default.MustCastIntoWater);
            T || u.default.get(e.executor).source(l.Source.Action).send(s.default.NoFishAtLocation),
            f = !0
        }
        const M = game.getTile(w.x, w.y, w.z)
          , b = d.default[m.default.getType(M)];
        b && e.setParticle({
            color: b.particles,
            position: new p.default(w),
            count: 3
        });
        const k = M
          , C = k.containedItems;
        if (C && C.length > 0) {
            const t = C[C.length - 1];
            itemManager.moveToContainer(e.executor, t, e.executor.inventory),
            u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(s.default.YouPickedUp, t.getName())
        }
        if (e.setItemsUsed(),
        e.setReputationChange(25),
        e.setStaminaReduction(r.SkillType.Fishing),
        e.setUpdateTablesAndWeight(),
        e.setPassTurn(),
        f)
            e.setSoundEffect({
                type: w.water ? r.SfxType.Water : r.SfxType.Throw,
                position: new p.default(w)
            });
        else {
            if (a) {
                const t = itemManager.getItemInContainerByGroup(e.executor.inventory, r.ItemTypeGroup.Bait);
                if (t || g >= y - 25) {
                    if (g >= y - 50 && o) {
                        const t = o.loot;
                        if (t) {
                            const i = e.executor.createItemInInventory(t[0].item);
                            u.default.get(e.executor).source(l.Source.Action, l.Source.Item, l.Source.Resource).send(s.default.CaughtFish, i.getName()),
                            creatureManager.remove(a),
                            e.addSkillGains(r.SkillType.Fishing)
                        }
                    } else
                        u.default.get(e.executor).source(l.Source.Action, l.Source.Resource).type(u.MessageType.Bad).send(s.default.FailedToCatchFish),
                        e.addSkillGains(r.SkillType.Fishing, .1);
                    t && t.damage(i.ActionType[e.type], t.getDurabilityCharge())
                } else
                    u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(s.default.FishingWithNoBait)
            }
            e.setSoundEffect({
                type: r.SfxType.Water,
                position: new p.default(w)
            })
        }
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("item/Item", ["require", "exports", "action/IAction", "creature/ICreature", "entity/IEntity", "entity/IStats", "Enums", "game/IGame", "item/IItem", "item/ItemRecipeRequirementChecker", "item/Items", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Misc", "language/dictionary/Note", "language/Translation", "mod/IHookManager", "multiplayer/IMultiplayer", "multiplayer/packets/shared/UpdateItemQuickSlotPacket", "player/IMessageManager", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "save/ISerializer", "tile/ITileEvent", "tile/Terrains", "utilities/enum/Enums", "utilities/Log", "utilities/math/Math2", "utilities/math/Vector3", "utilities/Objects", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const B = new D.default(D.LogSource.ItemManager);
    class E {
        constructor(e, t=r.ItemQuality.Random) {
            if (void 0 === e)
                return;
            this.type = e;
            const a = this.description();
            if (!a)
                return;
            a.durability ? this.maxDur = Math.floor(a.durability) - R.default.int(3) : this.maxDur = itemManager.getDefaultDurability(),
            a.decayMax && (this.decay = a.decayMax + 10 * this.maxDur);
            const i = a.recipe;
            (a.disassemble && i || a.inheritWeight) && (this.disassembly = itemManager.getDisassemblyComponents(a, t),
            a.disassemble && (this.weight = this.getDisassemblyWeight())),
            void 0 === this.weight && (this.weight = itemManager.getWeight(e)),
            t === r.ItemQuality.Random ? this.setQuality(itemManager.getRandomQuality(this.type)) : this.setQuality(t),
            void 0 !== a.weightCapacity && (this.weightCapacity = a.weightCapacity,
            this.containedItems = []),
            e !== r.ItemType.TatteredMap && e !== r.ItemType.DrawnMap || this.initializeMap(),
            itemManager.isInGroup(e, r.ItemTypeGroup.Book) && (this.book = R.default.chance(.75) ? C.default.getRandom(r.BookType) : r.BookType.RandomEvent),
            this.minDur = this.maxDur
        }
        getName(e, t, a=!1, i=!0) {
            const n = [];
            this.used && void 0 !== this.used.skill && n.push(new y.default(p.Dictionary.Skill,this.used.skill)),
            this.used && void 0 !== this.used.recipe && n.push(y.default.nameOf(p.Dictionary.Item, this.used.recipe, !1)),
            this.used && void 0 !== this.used.map && n.push(!0);
            const o = y.default.nameOf(p.Dictionary.Item, this, t, e, ...n).setFailWith(new y.default(p.Dictionary.Misc,m.MiscTranslation.UnknownItem));
            if (i) {
                if (this.quality && this.quality !== r.ItemQuality.Legendary && o.addReformatter(new y.default(p.Dictionary.Misc,m.MiscTranslation.ItemQuality).addArgs(r.ItemQuality[this.quality].toLowerCase()), !0),
                this.quality === r.ItemQuality.Legendary && !this.renamed) {
                    const {type: e, skill: t, stat: a} = this.legendary
                      , i = void 0 !== t ? new y.default(p.Dictionary.Skill,t) : void 0 !== a ? new y.default(p.Dictionary.Stat,a) : void 0;
                    o.addReformatter(new y.default(p.Dictionary.Misc,m.MiscTranslation.ItemLegendary).addArgs(new y.default(p.Dictionary.LegendaryType,e).addArgs(i)))
                }
                this.quality && o.addReformatter(new y.default(p.Dictionary.Misc,m.MiscTranslation.ItemQualityColor).addArgs(r.ItemQuality[this.quality].toLowerCase()))
            }
            return t && 1 !== t && a && o.addReformatter(new y.default(p.Dictionary.Misc,m.MiscTranslation.CountThing).addArgs(t)),
            o
        }
        description() {
            return this._description || (this._description = d.default[this.type]),
            this._description
        }
        isValid() {
            return game.items[this.id] === this
        }
        shouldBeProtected() {
            return this.isEquipped() || void 0 !== this.quickSlot
        }
        getDecayMax() {
            const e = this.description();
            return e && void 0 !== e.decayMax ? e.decayMax + 10 * this.maxDur : 0
        }
        getTotalWeight() {
            let e = this.weight;
            return this.legendary && this.legendary.type === r.LegendaryType.ItemWeight && (e -= this.legendary.value),
            itemManager.isContainer(this) && (e += itemManager.computeContainerWeight(this)),
            e
        }
        getDisassemblyWeight() {
            let e = 0;
            if (this.disassembly)
                for (const t of this.disassembly)
                    t.disassembly ? e += t.getDisassemblyWeight() : e += t.weight;
            const t = this.description();
            return t && t.reducedWeight && (e -= t.reducedWeight),
            t && t.minimumWeight && e < t.minimumWeight && (e = t.minimumWeight),
            A.default.roundNumber(e, 1)
        }
        verifyAndFixItem() {
            const e = this.description();
            if (void 0 !== this.minDur && void 0 !== this.maxDur && (isNaN(this.minDur) || isNaN(this.maxDur))) {
                let t = itemManager.getDefaultDurability();
                e && e.durability && (t = e.durability - R.default.int(3));
                const a = this.minDur
                  , i = this.maxDur;
                this.maxDur = t,
                this.setQuality(this.quality),
                this.minDur = this.maxDur,
                B.warn(`Detected item [${r.ItemType[this.type]}] with invalid durability, fixing`, this, a, i, this.maxDur)
            }
            if (e && this.disassembly) {
                const t = e.recipe
                  , a = [];
                for (let e = 0; e < this.disassembly.length; e++)
                    void 0 === this.disassembly[e].description && (this.disassembly[e] = itemManager.createFake(this.disassembly[e].type, this.disassembly[e].quality),
                    B.warn(`Detected item [${r.ItemType[this.type]}] with invalid disassembly items, fixing`, this)),
                    t && a.push(this.disassembly[e].type),
                    this.disassembly[e].verifyAndFixItem();
                t && !this.checkIfItemArraysMatch(itemManager.getDisassemblyComponentsAsItemTypes(e), a) && (this.disassembly = itemManager.getDisassemblyComponents(e, this.quality),
                this.weight = this.getDisassemblyWeight(),
                B.warn(`Detected item [${r.ItemType[this.type]}] with old recipe/disassembly items, fixing`, this))
            } else if (e && e.disassemble) {
                const t = e.recipe;
                t && (this.disassembly = itemManager.getDisassemblyComponents(e, this.quality),
                this.weight = this.getDisassemblyWeight(),
                B.warn(`Detected item [${r.ItemType[this.type]}] with no disassembly items, fixing`, this))
            }
            if (void 0 === this.weight && (this.disassembly ? this.weight = this.getDisassemblyWeight() : this.weight = itemManager.getWeight(this.type),
            B.warn(`Detected item [${r.ItemType[this.type]}] with no weight, new weight: ${this.weight}`, this)),
            void 0 !== this.weight) {
                let e = 0;
                const t = itemManager.getWeight(this.type, r.WeightType.Min);
                this.weight < t && (e = t);
                const a = itemManager.getWeight(this.type, r.WeightType.Max);
                if (this.weight > a && (e = a),
                this.disassembly) {
                    const e = this.getDisassemblyWeight();
                    if (this.weight !== e && e <= t && e >= a) {
                        const t = this.weight;
                        this.weight = e,
                        B.warn(`Detected item [${r.ItemType[this.type]}] with wrong weight based on disassembly items, new weight: ${e}, before: ${t}`, this)
                    }
                }
                if (this.weight < t || this.weight > a) {
                    const t = this.weight;
                    this.weight = e,
                    B.warn(`Detected item [${r.ItemType[this.type]}] with invalid weight, new weight: ${e}, before: ${t}`, this)
                }
            }
            if (this.quality === r.ItemQuality.Legendary && this.legendary.type === r.LegendaryType.ItemWeight && this.weight - this.legendary.value <= 0) {
                const e = this.legendary.value;
                this.legendary.value = A.default.roundNumber(.1 + R.default.int(100 * this.weight / 2.5) / 100, 1),
                this.weight - this.legendary.value <= 0 ? (this.setLegendary(),
                B.warn(`Detected item [${r.ItemType[this.type]}] with invalid legendary item weight that could not be given the same property due to a weight change.`, G.default.stringify(this, 4, !0))) : B.warn(`Detected item [${r.ItemType[this.type]}] with invalid legendary item weight, new reduced weight: ${this.legendary.value}, before: ${e}`, G.default.stringify(this, 4, !0))
            }
        }
        damage(e, t) {
            multiplayer.addSyncCheck(f.MultiplayerSyncCheck.ItemDamage, `${this.id}-${this.type}-${e}-${void 0 !== t ? t : ""}-${void 0 !== this.minDur ? this.minDur : ""}-${void 0 !== this.maxDur ? this.maxDur : ""}`);
            const a = modManager.getHook(g.Hook.OnItemDamage).call(this, t);
            if (void 0 !== a && (t = a) <= 0)
                return;
            const i = this.description()
              , n = this.getOwner()
              , o = n || this.getLocation();
            if (this.minDur - (t || 0) <= 0)
                return I.default.get(n).source(S.Source.Item).type(I.MessageType.Bad).send(c.default.DestroyedFromUse, this.getName()),
                void 0 !== n ? n.queueSoundEffect(r.SfxType.Fail) : void 0 !== o && audio.queueEffect(r.SfxType.Fail, o.x, o.y, o.z),
                this.spawnOnBreak(),
                void itemManager.remove(this);
            let s = 1;
            if (void 0 !== t)
                s = t;
            else if (i) {
                const e = i.damageModifier;
                e && (s = e)
            }
            if (this.minDur -= s,
            this.isDamaged() && i && this.minDur <= 10)
                if (I.default.get(n).source(S.Source.Item).type(I.MessageType.Bad).send(!1 !== i.repairable && i.durability ? c.default.InNeedOfRepair : c.default.CloseToBeingDestroyed, this.getName()),
                void 0 !== n) {
                    let e = !1;
                    (game.crafted[r.ItemType.AnimalGlue] || game.crafted[r.ItemType.SlimeGlue]) && (e = !0);
                    let t = !1, a;
                    const i = itemManager.getItemInContainerByGroup(n.inventory, r.ItemTypeGroup.Repair);
                    i && (t = !0,
                    a = i.getName(!1)),
                    n.notes.write(h.default.Durability, {
                        item: this.getName(!1),
                        repairItemName: a,
                        canRepair: t,
                        canGlue: e
                    }),
                    n.queueSoundEffect(r.SfxType.Damaged)
                } else
                    void 0 !== o && audio.queueEffect(r.SfxType.Damaged, o.x, o.y, o.z);
            ui.updateItem(this)
        }
        isDamaged() {
            return this.minDur / this.maxDur <= .1 || this.minDur <= 2
        }
        isInTradeContainer() {
            return void 0 !== this.containedWithin && this.containedWithin.containerType === l.ContainerType.Trade
        }
        isEquipped() {
            return void 0 !== this.equippedId
        }
        getEquipSlot() {
            if (void 0 !== this.equippedId && void 0 !== this.equippedType)
                switch (this.equippedType) {
                case n.EntityType.Player:
                    return players[this.equippedId].getEquipSlotForItem(this);
                case n.EntityType.NPC:
                    return game.npcs[this.equippedId].getEquipSlotForItem(this)
                }
        }
        setQuickSlot(e, t) {
            if (multiplayer.isConnected()) {
                const a = new T.default;
                a.pid = e.id,
                a.item = this,
                a.quickSlot = t,
                multiplayer.syncPacket(a, ()=>{
                    this.quickSlot = t,
                    e.isLocalPlayer() && setTimeout(()=>{
                        this.isValid() && ui.updateItem(this)
                    }
                    , 1)
                }
                , !0)
            } else
                this.quickSlot = t;
            modManager.getHook(g.Hook.OnItemQuickslot).call(this, e, t)
        }
        clearQuickSlot() {
            this.quickSlot = void 0
        }
        isDecayed() {
            const e = this.description();
            return !!(this.decay && e && (void 0 !== e.decayMax && this.decay / this.getDecayMax() <= .1 || void 0 !== e.decayMax && this.decay <= 2))
        }
        changeInto(e, t) {
            const a = d.default[e];
            if (!a)
                return;
            const i = this.description();
            this.type = e,
            this._description = a;
            const n = this.weight;
            a.weight && (this.weight = itemManager.getWeight(this.type),
            this.weight > n && (this.weight = n)),
            ui.updateItem(this);
            const o = this.getOwner();
            void 0 !== o && (modManager.getHook(g.Hook.OnInventoryItemUpdate).call(o, this, this.containedWithin),
            t || this.acquireNotify(o)),
            (a && a.onEquipEffect || i && i.onEquipEffect) && (void 0 !== o && o.updateStatsAndAttributes(),
            game.updateView(s.RenderSource.ItemEquipEffect, !0))
        }
        returns() {
            const e = this.description()
              , t = e ? e.returnOnUse : void 0;
            return !!t && (this.changeInto(t[0]),
            t[1] || this.damage("IR"),
            !0)
        }
        setUsed(e, t) {
            this.used = Object.assign({}, this.used, e, {
                usedBy: [...this.used&&this.used.usedBy||[], ...e&&e.usedBy||[], ...t&&[t.identifier]||[]]
            })
        }
        spawnOnBreak() {
            const e = this.description();
            return this.spawnCreatureOnItem(e ? e.spawnOnBreak : void 0)
        }
        spawnOnDecay() {
            const e = this.description();
            return this.spawnCreatureOnItem(e ? e.spawnOnDecay : void 0)
        }
        spawnCreatureOnItem(e, t, a, i) {
            if (void 0 === e)
                return;
            const n = this.description();
            if (!n)
                return;
            const o = this.getLocation();
            if (o) {
                const r = [];
                for (let e = -1; e <= 1; e++)
                    for (let t = -1; t <= 1; t++)
                        r.push([e, t]);
                const s = R.default.shuffle(r);
                if (i) {
                    const e = i.direction;
                    r.unshift([e.x, e.y])
                }
                for (const i of s) {
                    const r = creatureManager.spawn(e, i[0] + o.x, i[1] + o.y, o.z, a, t, n.spawnableTiles);
                    if (r)
                        return I.default.toAll(e=>e.ifVisible(o).source(S.Source.Creature, S.Source.Item).send(c.default.YouSeeSpringForth, r.getName())),
                        r
                }
            }
        }
        getLocation() {
            const e = this.containedWithin
              , t = itemManager.getContainerReference(e);
            let a;
            switch (t.type) {
            case l.ContainerReferenceType.PlayerInventory:
                a = players[t.pid];
                break;
            case l.ContainerReferenceType.Doodad:
            case l.ContainerReferenceType.Tile:
                a = t;
                break;
            case l.ContainerReferenceType.Item:
                const e = t
                  , i = e ? game.items[e.id] : void 0;
                a = i ? i.getLocation() : void 0
            }
            return a && new P.default(a).raw()
        }
        dropInWater(e, t, n, o) {
            let s;
            void 0 !== t && void 0 !== n ? s = {
                x: t,
                y: n
            } : (s = e.options.dropLocation === r.DropLocation.Feet ? e.getPoint() : e.getFacingPoint(),
            o || game.particle.create(s.x, s.y, e.z, w.default[v.ParticleType.Water]));
            const l = game.getTile(s.x, s.y, e.z);
            if (l && !l.creature) {
                const t = 16;
                if (game.fillCount = 0,
                game.fillTile = [],
                game.checkWaterFill(s.x, s.y, e.z, t),
                game.fillCount >= t) {
                    const t = x.default.getType(l)
                      , n = k.default[t];
                    if (n && n) {
                        const t = this.description();
                        if (t && t.use && t.use.indexOf(a.ActionType.Eat) > -1) {
                            const t = R.default.percent();
                            if (t <= 7) {
                                const t = creatureManager.spawnFromGroup(n.freshWater ? i.SpawnGroup.FreshWater : i.SpawnGroup.Seawater, s.x, s.y, e.z);
                                t && (I.default.get(e).source(S.Source.Creature, S.Source.Item).send(c.default.StirredUpCreature),
                                t.skipNextUpdate())
                            }
                        }
                    }
                }
            }
            itemManager.remove(this)
        }
        placeOnTile(e, t, a, i, n) {
            const o = itemManager.getTileContainer(e, t, a);
            if (!i && game.isPositionFull(e, t, a))
                return multiplayer.addSyncCheck(f.MultiplayerSyncCheck.PlaceOnTile, {
                    x: e,
                    y: t,
                    z: a,
                    id: this.id,
                    tileFull: !0
                }),
                !1;
            const s = this.description();
            s && s.revert && this.changeInto(s.revert, !0);
            const l = game.getTile(e, t, a)
              , u = x.default.getType(l);
            return u !== r.TerrainType.Lava && u !== r.TerrainType.CoolingLava || tileEventManager.get(l, b.TileEventType.Fire) || (tileEventManager.create(b.TileEventType.Fire, e, t, a),
            game.particle.create(e, t, a, w.default[v.ParticleType.Fire])),
            multiplayer.addSyncCheck(f.MultiplayerSyncCheck.PlaceOnTile, {
                x: e,
                y: t,
                z: a,
                force: i,
                id: this.id,
                valid: void 0 !== o,
                items: void 0 !== o && void 0 !== o.containedItems ? o.containedItems.length : "error"
            }),
            itemManager.addToContainerInternal(this, o, !1, n),
            !0
        }
        initializeMap() {
            if (game.playing)
                for (; ; ) {
                    const e = 50 + R.default.int(400)
                      , t = 50 + R.default.int(400);
                    if (x.default.getType(game.getTile(e, t, r.WorldZ.Overworld)) !== r.TerrainType.DeepSeawater) {
                        this.tatteredMap = {
                            x: e,
                            y: t,
                            z: r.WorldZ.Overworld
                        };
                        break
                    }
                }
            else
                this.tatteredMap = {
                    x: 0,
                    y: 0,
                    z: 0,
                    reinitialize: !0
                }
        }
        setQuality(e) {
            const t = this.description();
            if (!t)
                return;
            this.quality = e || r.ItemQuality.None;
            const a = t.durability ? t.durability : itemManager.getDefaultDurability();
            this.maxDur = game.getMaxDurability(this.quality, a),
            this.quality === r.ItemQuality.Legendary && this.setLegendary()
        }
        setLegendary() {
            const e = this.description();
            if (!e)
                return;
            const t = [];
            e.attack && t.push(r.LegendaryType.Attack),
            e.defense && t.push(r.LegendaryType.Defense),
            e.isTorch && t.push(r.LegendaryType.Illumination),
            e.weightCapacity && (t.push(r.LegendaryType.WeightCapacity),
            t.push(r.LegendaryType.ContainerWeight)),
            this.weight > .1 && t.push(r.LegendaryType.ItemWeight),
            e.equip && (t.push(r.LegendaryType.Stat),
            t.push(r.LegendaryType.Skill),
            t.push(r.LegendaryType.Benignity),
            t.push(r.LegendaryType.Malignity),
            t.push(r.LegendaryType.MaxWeight)),
            e.ranged && t.push(r.LegendaryType.Range),
            itemManager.isInGroup(this.type, r.ItemTypeGroup.Trap) && t.push(r.LegendaryType.TrapDamage);
            const i = [a.ActionType.Eat, a.ActionType.Heal, a.ActionType.HealOther, a.ActionType.DrinkItem, a.ActionType.DrinkCure];
            if (e.use) {
                const a = e.use.some(e=>i.includes(e));
                a && t.push(r.LegendaryType.UseBenefits)
            }
            if (t.push(r.LegendaryType.Worth),
            t.length) {
                const a = R.default.choice(...t);
                switch (this.legendary = {
                    type: a,
                    value: 0
                },
                a) {
                case r.LegendaryType.Attack:
                    this.legendary.value = 1 + R.default.int(2);
                    break;
                case r.LegendaryType.WeightCapacity:
                    this.legendary.value = 1 + A.default.roundNumber(R.default.int(1e3) / 100, 1);
                    break;
                case r.LegendaryType.Illumination:
                    this.legendary.value = 10 + R.default.int(10);
                    break;
                case r.LegendaryType.Defense:
                    this.legendary.value = 1 + R.default.int(2);
                    break;
                case r.LegendaryType.ItemWeight:
                    this.legendary.value = A.default.roundNumber(.1 + R.default.int(100 * this.weight / 2.5) / 100, 1),
                    this.weight - this.legendary.value <= 0 && (this.legendary.value = A.default.roundNumber(this.weight - .1, 1));
                    break;
                case r.LegendaryType.Stat:
                    this.legendary.value = 1 + R.default.int(3),
                    this.legendary.stat = R.default.choice(o.Stat.Health, o.Stat.Stamina, o.Stat.Metabolism);
                    break;
                case r.LegendaryType.Skill:
                    this.legendary.value = A.default.roundNumber(2.5 + R.default.int(400) / 100, 1),
                    this.legendary.skill = C.default.getRandom(r.SkillType);
                    break;
                case r.LegendaryType.Benignity:
                case r.LegendaryType.Malignity:
                    this.legendary.value = 1e3 + 5 * Math.ceil(R.default.int(4e3) / 5);
                    break;
                case r.LegendaryType.Range:
                case r.LegendaryType.TrapDamage:
                    this.legendary.value = 1 + R.default.int(3);
                    break;
                case r.LegendaryType.UseBenefits:
                    this.legendary.value = 2 + R.default.int(2);
                    break;
                case r.LegendaryType.Worth:
                    this.legendary.value = e.worth ? e.worth * (2 + R.default.int(2)) : 5;
                    break;
                case r.LegendaryType.MaxWeight:
                    this.legendary.value = 1 + R.default.int(2);
                    break;
                case r.LegendaryType.ContainerWeight:
                    this.legendary.value = A.default.roundNumber(5 + R.default.float(15), 1)
                }
            }
        }
        acquireNotify(e) {
            if (e.state !== r.PlayerState.None)
                return;
            const t = this.type;
            if (game.playing && game.notifier.addItem(e.x, e.y, e.z, t),
            itemManager.checkMilestones(e, this),
            game.isChallenge)
                return;
            const a = this.description();
            if (!a)
                return;
            const i = a.recipes;
            if (i)
                for (const t of i) {
                    if (game.crafted[t])
                        continue;
                    const a = d.default[t]
                      , i = a ? a.recipe : void 0;
                    if (i) {
                        const a = new u.default(e,i,!1);
                        a.process(!1),
                        a.isDiscovered() && (game.crafted[t] = {
                            newUnlock: !0,
                            unlockTime: Date.now()
                        })
                    }
                }
        }
        getStokeFireValue() {
            const e = this.description();
            if (e && e.onUse)
                return e.onUse[a.ActionType.StokeFire] + this.getOnUseBonus()
        }
        getOnUseBonus() {
            switch (this.quality) {
            case r.ItemQuality.Remarkable:
                return 1;
            case r.ItemQuality.Exceptional:
                return 2;
            case r.ItemQuality.Legendary:
                return 4
            }
            return 0
        }
        getWorth(e) {
            const t = this.description();
            if (!t || void 0 === t.worth)
                return;
            let a = 1;
            switch (this.quality) {
            case r.ItemQuality.Remarkable:
                a = 2;
                break;
            case r.ItemQuality.Exceptional:
                a = 3;
                break;
            case r.ItemQuality.Legendary:
                a = 4
            }
            let i = 1;
            void 0 !== this.minDur && void 0 !== this.maxDur && (i = this.minDur / this.maxDur);
            let n = t.worth * a * i;
            return e && this.legendary && this.legendary.type === r.LegendaryType.Worth && (n += this.legendary.value),
            n <= 0 && (n = 1),
            Math.round(n)
        }
        canBurnPlayer() {
            const e = itemManager.getContainerReference(this.containedWithin, void 0, !1);
            if (e.type === l.ContainerReferenceType.Tile || e.type === l.ContainerReferenceType.Doodad) {
                const t = game.getTile(e.x, e.y, e.z);
                if (!t)
                    return !1;
                if (x.default.getType(t) === r.TerrainType.Lava)
                    return !0;
                if (tileEventManager.get(t, b.TileEventType.Fire))
                    return !0;
                if (t.doodad) {
                    const e = t.doodad.description();
                    if (e && e.providesFire)
                        return !0
                }
            }
            return !1
        }
        getBaseDefense() {
            const e = this.description();
            return e ? (e.defense && e.defense.base ? e.defense.base : 0) + (this.legendary && this.legendary.type === r.LegendaryType.Defense ? this.legendary.value : 0) : 0
        }
        getDurabilityCharge() {
            return this.maxDur ? Math.ceil(this.maxDur / 10) : 1
        }
        revertFromDoodad(e) {
            void 0 !== e.legendary && (this.legendary = e.legendary),
            void 0 !== e.disassembly && (this.disassembly = e.disassembly),
            void 0 !== e.ownerIdentifier && (this.ownerIdentifier = e.ownerIdentifier),
            void 0 !== e.renamed && (this.renamed = e.renamed)
        }
        getContainerWeightReduction() {
            return .5 - (this.legendary && this.legendary.type === r.LegendaryType.ContainerWeight ? this.legendary.value / 100 : 0)
        }
        onUnserialized() {
            this.description()
        }
        checkIfItemsMatch(e, t) {
            return e === t || itemManager.isGroup(e) && itemManager.isInGroup(t, e)
        }
        checkIfItemArraysMatch(e, t) {
            return void 0 === t.find(t=>void 0 === e.find(e=>this.checkIfItemsMatch(e, t)))
        }
        getOwner() {
            return itemManager.getPlayerWithItemInInventory(this)
        }
    }
    __decorate([M.SaveProperty()], E.prototype, "book", void 0),
    __decorate([M.SaveProperty()], E.prototype, "containedItems", void 0),
    __decorate([M.SaveProperty()], E.prototype, "containedWithin", void 0),
    __decorate([M.SaveProperty()], E.prototype, "decay", void 0),
    __decorate([M.SaveProperty()], E.prototype, "disassembly", void 0),
    __decorate([M.SaveProperty()], E.prototype, "equippedId", void 0),
    __decorate([M.SaveProperty()], E.prototype, "equippedType", void 0),
    __decorate([M.SaveProperty()], E.prototype, "id", void 0),
    __decorate([M.SaveProperty()], E.prototype, "itemOrders", void 0),
    __decorate([M.SaveProperty()], E.prototype, "legendary", void 0),
    __decorate([M.SaveProperty()], E.prototype, "maxDur", void 0),
    __decorate([M.SaveProperty()], E.prototype, "minDur", void 0),
    __decorate([M.SaveProperty()], E.prototype, "order", void 0),
    __decorate([M.SaveProperty()], E.prototype, "ownerIdentifier", void 0),
    __decorate([M.SaveProperty()], E.prototype, "used", void 0),
    __decorate([M.SaveProperty()], E.prototype, "quality", void 0),
    __decorate([M.SaveProperty()], E.prototype, "quickSlot", void 0),
    __decorate([M.SaveProperty()], E.prototype, "renamed", void 0),
    __decorate([M.SaveProperty()], E.prototype, "tatteredMap", void 0),
    __decorate([M.SaveProperty()], E.prototype, "type", void 0),
    __decorate([M.SaveProperty()], E.prototype, "weight", void 0),
    __decorate([M.SaveProperty()], E.prototype, "weightCapacity", void 0),
    t.default = E
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/helper/ConsumeItemType", ["require", "exports", "action/IAction", "entity/Entity", "entity/IEntity", "entity/IStats", "Enums", "item/Item", "item/Items", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Note", "language/Translation", "mod/IHookManager", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "player/note/NoteManager", "utilities/Log", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S) {
    function I(e, t, I=e.type) {
        const v = "number" == typeof t ? t : t.type
          , w = modManager.getHook(m.Hook.CanConsumeItem).call(e.executor, v, I);
        if (void 0 !== w)
            return w;
        let M = 0;
        const b = l.default[v];
        if (!b)
            return !1;
        if (!b.onUse)
            return !1;
        const k = I;
        I === a.ActionType.DrinkInFront && (I = a.ActionType.DrinkItem);
        const C = b.onUse[I];
        if (!C)
            return T.default.info(T.LogSource.ActionManager)(`Invalid action type ${a.ActionType[I]} for onUse`, b),
            !1;
        e.setDelay(25),
        t instanceof s.default && b.skillUse && (M = e.executor.getConsumeBonus(t, b.skillUse) + 1,
        e.addSkillGains(b.skillUse)),
        i.default.is(e.executor, n.EntityType.Player) && e.executor.revealItem(v);
        let[D,A,P,G] = C
          , R = 0;
        "object" == typeof t && t.legendary && t.legendary.type === r.LegendaryType.UseBenefits && (R = t.legendary.value),
        D > 0 && (D += S.default.int(M) + R),
        A > 0 && (A += S.default.int(M) + R),
        P > 0 && (P += S.default.int(M) + R),
        G > 0 && (G += S.default.int(M) + R);
        const x = "number" == typeof t ? c.default.nameOf(u.Dictionary.Item, t) : t.getName();
        if (0 !== D)
            if (D > 0)
                e.executor.increaseStat(o.Stat.Health, D),
                game.notifier.addStat(e.executor.x, e.executor.y, e.executor.z, r.StatType.Health, D),
                g.default.get(e.executor).source(h.Source.Action, h.Source.Wellbeing).send(d.default.GainedHealth, D);
            else if (D < 0) {
                g.default.get(e.executor).source(h.Source.Action, h.Source.Wellbeing).type(g.MessageType.Bad).send(d.default.LostHealth, -1 * D);
                let t = !1;
                if (e.executor.damage(D, c.default.message(d.default.DeathByConsumption).addArgs(k === a.ActionType.DrinkInFront ? c.default.message(d.default.UnpurifiedFreshWater) : x), 0, !1),
                !e.executor.hasStatus(r.StatusType.Poisoned)) {
                    const a = S.default.percent()
                      , i = Math.floor(e.executor.getSkill(r.SkillType.Anatomy) / 10);
                    a <= 20 - i && (g.default.get(e.executor).source(h.Source.Wellbeing, h.Source.Action).type(g.MessageType.Bad).send(d.default.BeenPoisoned),
                    e.addSkillGains(r.SkillType.Anatomy, .1),
                    e.executor.setStatus(r.StatusType.Poisoned, !0, n.StatusEffectChangeReason.Gained),
                    t = !0,
                    f.default.get(e.executor).write(p.default.Poisoned, x))
                }
                f.default.get(e.executor).write(p.default.Inedible, {
                    item: x,
                    poisoned: t
                })
            }
        const B = e.executor.getStat(o.Stat.Stamina);
        0 !== A && (e.executor.increaseStat(B, A),
        game.notifier.addStat(e.executor.x, e.executor.y, e.executor.z, r.StatType.Stamina, A),
        A > 0 ? g.default.get(e.executor).source(h.Source.Action, h.Source.Wellbeing).send(d.default.GainedStamina, A) : A < 0 && g.default.get(e.executor).source(h.Source.Wellbeing, h.Source.Action).type(g.MessageType.Bad).send(d.default.LostStamina, -1 * A));
        let E = !1
          , L = !1;
        const O = e.executor.getStat(o.Stat.Hunger)
          , F = e.executor.getStat(o.Stat.Thirst);
        if (0 !== P && P > 0 && O.value >= O.max && (G <= 0 || F.value >= F.max) && (E = !0),
        0 !== G && G > 0 && F.value >= F.max && (P <= 0 || O.value >= O.max) && (L = !0),
        0 !== P && (game.notifier.addStat(e.executor.x, e.executor.y, e.executor.z, r.StatType.Metabolism, P),
        P > 0 ? g.default.get(e.executor).source(h.Source.Action, h.Source.Wellbeing).send(d.default.LostHunger, P) : P < 0 && g.default.get(e.executor).source(h.Source.Action, h.Source.Wellbeing).type(g.MessageType.Bad).send(d.default.GainedHunger, -1 * P),
        e.executor.increaseStat(O, P),
        O.value < 0 && e.executor.setStat(O, 0)),
        E) {
            const t = Math.ceil(B.max / 5);
            e.executor.reduceStat(B, t),
            game.notifier.addStat(e.executor.x, e.executor.y, e.executor.z, r.StatType.Stamina, -1 * t),
            g.default.get(e.executor).source(h.Source.Wellbeing, h.Source.Action).type(g.MessageType.Bad).send(d.default.OverEatingLostStamina, t),
            e.executor.queueSoundEffect(r.SfxType.Hurt)
        }
        if (0 !== G && (game.notifier.addStat(e.executor.x, e.executor.y, e.executor.z, r.StatType.Thirst, G),
        G > 0 ? g.default.get(e.executor).source(h.Source.Wellbeing, h.Source.Action).send(d.default.LostThirst, G) : G < 0 && g.default.get(e.executor).source(h.Source.Action, h.Source.Wellbeing).type(g.MessageType.Bad).send(d.default.GainedThirst, -1 * G),
        e.executor.increaseStat(F, G),
        G > 0 && F.value < 0 && e.executor.setStat(F, 0)),
        L) {
            const t = Math.ceil(B.max / 5);
            e.executor.reduceStat(o.Stat.Stamina, t),
            game.notifier.addStat(e.executor.x, e.executor.y, e.executor.z, r.StatType.Stamina, -1 * t),
            g.default.get(e.executor).source(h.Source.Wellbeing, h.Source.Action).type(g.MessageType.Bad).send(d.default.OverHydratingLostStamina, t),
            e.executor.queueSoundEffect(r.SfxType.Hurt)
        }
        return e.executor.queueSoundEffect(r.SfxType.Eating),
        e.executor.updateStatsAndAttributes(),
        b.onUse[a.ActionType.Heal] ? (g.default.get(e.executor).source(h.Source.Action, h.Source.Item).send(d.default.YouUsed, x),
        e.executor.hasStatus(r.StatusType.Bleeding) && (e.executor.setStatus(r.StatusType.Bleeding, !1, n.StatusEffectChangeReason.Treated),
        e.executor.hasStatus(r.StatusType.Bleeding) || (corpseManager.createBlood(e.executor.x, e.executor.y, e.executor.z),
        e.executor.addMilestone(y.MilestoneType.Doctor, r.StatusType.Bleeding),
        g.default.get(e.executor).source(h.Source.Wellbeing).send(d.default.StoppedYourBleeding))),
        !0) : b.onUse[a.ActionType.Apply] ? (g.default.get(e.executor).source(h.Source.Wellbeing, h.Source.Item).send(d.default.YouApplied, x),
        e.executor.hasStatus(r.StatusType.Burned) && (e.executor.setStatus(r.StatusType.Burned, !1, n.StatusEffectChangeReason.Treated),
        e.executor.hasStatus(r.StatusType.Burned) || (e.executor.addMilestone(y.MilestoneType.Doctor, r.StatusType.Burned),
        g.default.get(e.executor).source(h.Source.Wellbeing).send(d.default.SoothedYourBurnInjuries))),
        !0) : !!b.onUse[a.ActionType.DrinkCure] && (g.default.get(e.executor).source(h.Source.Wellbeing, h.Source.Item).send(d.default.YouDrank, x),
        e.executor.hasStatus(r.StatusType.Poisoned) && (e.executor.setStatus(r.StatusType.Poisoned, !1, n.StatusEffectChangeReason.Treated),
        e.executor.hasStatus(r.StatusType.Poisoned) || (e.executor.addMilestone(y.MilestoneType.Doctor, r.StatusType.Poisoned),
        g.default.get(e.executor).source(h.Source.Wellbeing).send(d.default.CuredYourPoison))),
        !0)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = I
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/ConsumeItem", ["require", "exports", "action/Action", "action/actions/helper/ConsumeItemType", "action/IAction", "entity/IEntity", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(n.ActionArgument.ItemNearby).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setPreExecutionHandler((e,t)=>{
        e.type !== n.ActionType.Eat && e.addItems(t)
    }
    ).setHandler((e,t)=>{
        const a = t.description();
        if (!a)
            return;
        e.type === n.ActionType.Eat && e.addItems(t),
        e.setDelay(25);
        let o = !1;
        const m = a.onUse;
        if (m && m[n.ActionType.Heal]) {
            const t = c.default.percent(75)
              , i = a.skillUse;
            i && e.executor.getSkill(i) <= t && (p.default.get(e.executor).source(d.Source.Action, d.Source.Wellbeing, d.Source.Item).type(p.MessageType.Bad).send(l.default.YouFailedToHeal, new u.default(s.Dictionary.Skill,i)),
            e.setItemsUsed(),
            e.addSkillGains(i, .1),
            e.setSoundEffect(r.SfxType.Fail),
            o = !0)
        }
        if (!o) {
            if (!i.default(e, t)) {
                let a;
                a = m && m[n.ActionType.DrinkItem] ? l.default.YouDrank : l.default.YouAte,
                p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(a, t.getName())
            }
            t.returns() || itemManager.remove(t)
        }
        e.setReputationChange(25),
        e.setUpdateTablesAndWeight(),
        e.setPassTurn()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Craft", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemType,i.ActionArgument.ItemArrayNearby,i.ActionArgument.ItemArrayNearby,i.anyOf(i.ActionArgument.ItemNearby, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t,a,i,n,r=!1)=>{
        const s = itemManager.craft(e.executor, t, a, i, n);
        r && e.executor.burn(!1, !0, o.EquipType.Hands),
        s !== o.CraftStatus.Invalid && (s === o.CraftStatus.Failed ? (e.setDelay(13),
        e.setSoundEffect(o.SfxType.Fail)) : e.setDelay(25),
        e.setUpdateTablesAndWeight(),
        e.setPassTurn())
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Dig", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "entity/IStats", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "tile/TerrainResources", "tile/Terrains", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemInventory, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        const a = e.executor.getFacingTile()
          , n = y.default.getType(a)
          , {x: g, y: f, z: T} = e.executor.getFacingPoint();
        e.setDelay(25);
        const S = a;
        if (void 0 !== a.creature || void 0 !== a.npc || S.containedItems && S.containedItems.length > 0 || void 0 !== a.events || game.isPlayerAtPosition(g, f, T))
            return p.default.get(e.executor).source(d.Source.Action).send(l.default.SomethingInTheWayOf, u.default.message(l.default.Digging)),
            void game.checkForHiddenMob(e.executor, g, f, T);
        if (!e.executor.checkAndRemoveBlood())
            return void p.default.get(e.executor).source(d.Source.Action).send(l.default.SomethingInTheWayOfCarveFirst, u.default.message(l.default.Digging));
        const I = m.default[n];
        if (void 0 !== a.doodad) {
            if (a.doodad.canPickup(e.executor))
                return e.get(i.ActionType.Pickup).execute(e.executor, t),
                void e.setDelay(0);
            if (a.doodad.canHarvest())
                return e.get(i.ActionType.Harvest).execute(e.executor, t),
                void e.setDelay(0);
            if (a.doodad.isGatherable() || tileEventManager.canGather(a))
                return e.get(i.ActionType.Gather).execute(e.executor, t),
                void e.setDelay(0)
        }
        if (I && (I.water || !I.passable) || void 0 !== a.doodad)
            return void p.default.get(e.executor).source(d.Source.Action).send(l.default.CannotDoThatHere, u.default.message(l.default.Dig));
        game.packGround(g, f, T);
        const v = itemManager.getItemsInContainerByType(e.executor.inventory, r.ItemType.TatteredMap, !0);
        if (v.length)
            for (const a of v) {
                const n = a.tatteredMap;
                if (n && (!a.used || void 0 === a.used.map)) {
                    const a = n.x
                      , o = n.y;
                    if (g === a && f === o)
                        return e.get(i.ActionType.GatherTreasure).execute(e.executor, t),
                        void e.setDelay(0)
                }
            }
        I && e.setParticle(I.particles, !0);
        let w = h.default.percent(35);
        t || (w += 20,
        e.executor.hurtHands(l.default.Dig, l.default.Digging));
        let M = !1;
        const b = n === r.TerrainType.Grass ? r.SkillType.Botany : r.SkillType.Mining;
        if (e.executor.getSkill(r.SkillType.Mining) >= w) {
            let a;
            const i = game.getTileData(g, f, T);
            let o, s, u, S;
            const v = c.default[n];
            if (v && v.items)
                for (const w of v.items) {
                    const k = void 0 !== w.chance ? w.chance : 100
                      , C = w.chanceOutOf ? w.chanceOutOf : 100;
                    if (-1 * k > h.default.percent(C))
                        continue;
                    const D = h.default.percent();
                    let A = w.tileChangeChance;
                    if (void 0 === A && (A = k,
                    a = w.tileChange),
                    w.tileChange && D <= A)
                        if (a = w.tileChange,
                        I && I.shallowWater && I.freshWater)
                            a = r.TerrainType.FreshWater;
                        else if (I && I.shallowWater)
                            a = r.TerrainType.Seawater;
                        else if (!v.disableWaterRouting) {
                            o = [[g + 1, f], [g - 1, f], [g, f + 1], [g, f - 1], [g + 1, f - 1], [g - 1, f + 1], [g + 1, f + 1], [g - 1, f - 1]];
                            for (let e = 0; e < o.length; e++) {
                                s = game.getTile(o[e][0], o[e][1], T),
                                u = y.default.getType(s);
                                const t = m.default[u];
                                if (t && (t.water || t.shallowWater)) {
                                    const i = 50;
                                    if (game.fillCount = 0,
                                    game.fillTile = [],
                                    game.checkWaterFill(o[e][0], o[e][1], T, i),
                                    h.default.float() * i + game.fillCount >= i) {
                                        a = t.freshWater ? r.TerrainType.ShallowFreshWater : r.TerrainType.ShallowSeawater;
                                        break
                                    }
                                }
                            }
                        }
                    e.setItemsUsed(),
                    e.addSkillGains(b),
                    t || p.default.get(e.executor).source(d.Source.Action).send(l.default.HandsNotEffectiveForDigging);
                    let P = w.type, G = r.ItemQuality.Random, R, x;
                    if (i && i.length > 1) {
                        let e = i[0]
                          , t = I;
                        I && I.shallowWater && i[1] && (e = i[1],
                        t = m.default[e.type]);
                        const a = c.default[e.type];
                        t && t.regathered && a && a.defaultItem && (P = a.defaultItem),
                        e.minDur && e.maxDur && (R = e.minDur - 1,
                        x = e.maxDur),
                        void 0 !== e.quality && (G = e.quality)
                    }
                    if (n !== r.TerrainType.CaveEntrance) {
                        const t = e.executor.createItemInInventory(P, G);
                        void 0 !== R && (t.minDur = R),
                        void 0 !== x && (t.maxDur = x),
                        void 0 === R && void 0 === x || ui.updateItem(t),
                        p.default.get(e.executor).source(d.Source.Action, d.Source.Item, d.Source.Resource).send(l.default.YouGathered, t.getName())
                    }
                    M = !0,
                    i && i.length <= 1 && (game.makeLavaPassage(e.executor) ? a = r.TerrainType.Lava : (S = game.makeCaveEntrance(e.executor)) && (a = S));
                    break
                }
            if (v && (M || !v) && (i && i.length > 1 && (I && I.shallowWater && i[2] && i.shift(),
            i.shift(),
            (a = i[0].type) === r.TerrainType.CaveEntrance && game.changeTile(a, g, f, T === r.WorldZ.Cave ? r.WorldZ.Overworld : r.WorldZ.Cave, !0)),
            void 0 !== a)) {
                const e = m.default[a];
                if (n === r.TerrainType.CaveEntrance)
                    game.changeTile(a, g, f, T, !0),
                    game.changeTile(r.TerrainType.Dirt, g, f, T === r.WorldZ.Overworld ? r.WorldZ.Cave : r.WorldZ.Overworld, !0, !0);
                else if (game.changeTile(a, g, f, T, !1),
                !S && a === r.TerrainType.CaveEntrance) {
                    game.changeTile(a, g, f, T === r.WorldZ.Overworld ? r.WorldZ.Cave : r.WorldZ.Overworld, !1, !0, !0);
                    const e = game.getTile(g, f, T === r.WorldZ.Overworld ? r.WorldZ.Cave : r.WorldZ.Overworld).doodad;
                    e && e.damage(!0)
                }
                if (e && (e.water || e.shallowWater)) {
                    o = [[g + 1, f], [g - 1, f], [g, f + 1], [g, f - 1]];
                    for (let t = 0; t < o.length; t++) {
                        s = game.getTile(o[t][0], o[t][1], T),
                        u = y.default.getType(s);
                        const a = m.default[u];
                        if (a && !a.freshWater && (a.water || a.shallowWater)) {
                            game.contaminatedWater.push({
                                x: g,
                                y: f,
                                z: T
                            });
                            break
                        }
                        if (a && a.freshWater && !e.freshWater) {
                            game.contaminatedWater.push({
                                x: o[t][0],
                                y: o[t][1],
                                z: T
                            });
                            break
                        }
                    }
                }
            }
        }
        M || (0 === h.default.int(5) && e.addSkillGains(b, .1),
        p.default.get(e.executor).source(d.Source.Action, d.Source.Resource).send(l.default.DoNotProduceAnyResources, u.default.message(l.default.DigAway), new u.default(s.Dictionary.Terrain,n))),
        t || (e.executor.reduceStat(o.Stat.Stamina, 1),
        n !== r.TerrainType.Lava && n !== r.TerrainType.CoolingLava || e.executor.burn(!1, !0, r.EquipType.Hands)),
        creatureManager.maybeSpawnClawWorm(e.executor),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect(r.SfxType.PickUp, !0),
        e.setStaminaReduction(r.SkillType.Mining)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Disassemble", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "item/Items", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>{
        e.addItems(t);
        const a = r.default[t.type];
        if (a.requiredForDisassembly)
            for (const i of a.requiredForDisassembly) {
                const a = itemManager.getItemForHuman(e.executor, i);
                if (!a) {
                    const a = itemManager.getItemTypeGroupName(i);
                    return d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.RequiredForDisassembly, a, t.getName()),
                    !1
                }
                e.addItems(a)
            }
        return !0
    }
    ).setHandler((e,t)=>{
        const a = t.minDur
          , i = t.maxDur;
        if (void 0 === a || void 0 === i)
            return;
        e.setDelay(25);
        const n = e.executor.getTile()
          , m = p.default[c.default.getType(n)];
        if (m && m.water)
            return void d.default.get(e.executor).source(u.Source.Action).send(s.default.CannotInWater, l.default.message(s.default.Disassemble));
        const h = r.default[t.type];
        if (!h)
            return;
        const y = t.disassembly;
        if (!y)
            return;
        const g = itemManager.hasAdditionalRequirements(e.executor, t.type, s.default.Disassemble, !0, !0);
        if (!g.requirementsMet)
            return;
        if (e.setItemsUsed(),
        g.isLava && game.doLavaEvents(g.x, g.y, g.z),
        itemManager.isContainer(t)) {
            const a = t;
            itemManager.moveAllFromContainerToInventory(e.executor, a) && e.setUpdateTablesAndWeight(),
            ui.closeContainer(a)
        }
        const f = a / i;
        let T = h.durability, S, I, v;
        T || (T = itemManager.getDefaultDurability());
        let w = 0;
        const M = []
          , b = h.recipe;
        if (b)
            for (const e of b.components) {
                const t = e.disassembleAmount
                  , a = e.type;
                for (let e = 0; e < t; e++)
                    M.push(a)
            }
        for (let t = 0; t < y.length; t++) {
            const a = y[t];
            let i = !1;
            for (let e = 0; e < M.length; e++)
                if (M[e] === a.type || itemManager.isGroup(M[e]) && itemManager.isInGroup(a.type, M[e])) {
                    M.splice(e, 1),
                    i = !0;
                    break
                }
            if (!i)
                continue;
            const n = a.maxDur;
            if (void 0 === n)
                continue;
            S = n;
            const o = a.quality;
            if (I = Math.floor(S * f * .75),
            void 0 !== a.minDur && I >= a.minDur && (I = a.minDur - 1),
            I <= 0) {
                if (w++,
                1 === y.length || y.length !== w)
                    continue;
                I = 0
            }
            (v = e.executor.createItemInInventory(a.type, o)).minDur = I,
            v.maxDur = S,
            v.weight = a.weight,
            a.legendary && (v.legendary = a.legendary),
            ui.updateItem(v),
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.YouSalvaged, v.getName())
        }
        d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.YouDisassembled, t.getName()),
        w >= 1 && d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.MaterialsDestroyed, l.default.message(y.length === w ? s.default.All : s.default.Some), l.default.message(s.default.Disassembling));
        let k = o.SkillType.Tinkering;
        h.recipe && void 0 !== h.recipe.skill && (k = h.recipe.skill,
        e.setReputationChange(-1 * h.recipe.reputation)),
        e.addSkillGains(k, .1),
        itemManager.remove(t),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect(o.SfxType.Craft),
        e.setStaminaReduction(k)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/DrawMap", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "item/Items", "language/dictionary/Message", "mod/IHookManager", "player/IMessageManager", "player/MessageManager", "utilities/math/Vector3", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>{
        const a = itemManager.getItemInContainer(e.executor.inventory, o.ItemType.Inkstick);
        return a ? (e.addItems(t, a),
        !0) : (d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.NoInkToDrawMap),
        !1)
    }
    ).setConfirmer(async e=>e.confirmItemsBroken()).setHandler((e,t)=>{
        if (void 0 === t.minDur || void 0 === t.maxDur)
            return;
        const a = r.default[o.ItemType.DrawnMap];
        if (!a || void 0 === a.durability)
            return;
        e.setDelay(25),
        e.setItemsUsed(),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setReputationChange(25);
        const i = c.default.percent(25);
        if (e.executor.getSkill(o.SkillType.Cartography) >= i) {
            const i = a.durability - (t.maxDur - t.minDur)
              , n = e.executor.createItemInInventory(o.ItemType.DrawnMap, t.quality);
            n.tatteredMap = {
                x: e.executor.x,
                y: e.executor.y,
                z: e.executor.z
            },
            n.minDur = n.maxDur = i,
            ui.updateItem(n),
            itemManager.remove(t),
            e.executor.isLocalPlayer() && modManager.getHook(l.Hook.OnReadMap).call(e.executor, {
                item: n,
                tilePosition: new p.default(n.tatteredMap.x,n.tatteredMap.y,n.tatteredMap.z)
            }),
            e.addSkillGains(o.SkillType.Cartography),
            e.setSoundEffect(o.SfxType.Throw),
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.DrewSurroundings),
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.YouPickedUp, n.getName())
        } else
            e.setSoundEffect(o.SfxType.Fail),
            e.addSkillGains(o.SkillType.Cartography, .1),
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).type(d.MessageType.Bad).send(s.default.FailedToDrawMap)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/DrinkInFront", ["require", "exports", "action/Action", "action/actions/helper/ConsumeItemType", "action/IAction", "entity/IEntity", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "tile/Terrains", "utilities/math/Vector3", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = (new a.Action).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setHandler(e=>{
        const t = e.executor.getFacingTile();
        if (!t)
            return;
        const a = g.default.getType(t)
          , {x: o, y: f, z: T} = e.executor.getFacingPoint()
          , S = h.default[a];
        S && (S.water || S.shallowWater ? (p.default.get(e.executor).source(d.Source.Action).send(l.default.YouDrank, new u.default(s.Dictionary.Terrain,g.default.getType(game.getTile(o, f, T)))),
        i.default(e, S.freshWater ? r.ItemType.WaterskinOfUnpurifiedFreshWater : r.ItemType.WaterskinOfSeawater, n.ActionType.DrinkInFront),
        game.consumeWaterTile(o, f, T)) : a === r.TerrainType.Snow && (p.default.get(e.executor).source(d.Source.Action).send(l.default.YouDrank, new u.default(s.Dictionary.Terrain,g.default.getType(game.getTile(o, f, T)))),
        i.default(e, r.ItemType.PileOfSnow, n.ActionType.DrinkItem),
        game.changeTile(r.TerrainType.Dirt, o, f, T, !1)),
        e.setParticle({
            color: m.default[c.ParticleType.Water],
            position: new y.default(o,f,T)
        }),
        e.setPassTurn())
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Drop", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "language/Translation", "mod/IHookManager", "player/IMessageManager", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "tile/ITileEvent", "tile/Terrains", "utilities/math/Vector3", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby,i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t,a=!1,i=!1)=>{
        let n, f;
        e.executor.options.dropLocation === o.DropLocation.Feet ? (n = e.executor.getTile(),
        f = e.executor.getPoint()) : (n = e.executor.getFacingTile(),
        f = e.executor.getFacingPoint()),
        e.setDelay(13);
        const T = modManager.getHook(l.Hook.CanDropItem).call(e.executor, t, n, a, i ? t.quality : void 0);
        if (!1 === T)
            return;
        e.executor.raft === t.id && e.executor.setRaft(void 0),
        game.checkForHiddenMob(e.executor, f.x, f.y, e.executor.z);
        const S = n.doodad;
        if (S) {
            const a = S.description();
            if (a)
                if (a.isTrap)
                    S.setOffTrap(e.executor, !0);
                else if (a.disableDrop || a.blockMove) {
                    if (!a.blockMove || e.executor.options.dropLocation !== o.DropLocation.FeetWhenFacingBlocked)
                        return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(r.default.CannotDropHere, t.getName());
                    n = e.executor.getTile(),
                    f = e.executor.getPoint()
                }
        }
        let I = !1
          , v = !1
          , w = !1;
        const M = g.default.getType(n)
          , b = h.default[M];
        if (b) {
            if (b.water && (I = !0),
            b.shallowWater && (v = !0),
            !b.passable && !I) {
                if (e.executor.options.dropLocation !== o.DropLocation.FeetWhenFacingBlocked)
                    return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(r.default.CannotDropHere, t.getName());
                n = e.executor.getTile(),
                f = e.executor.getPoint()
            }
            tileEventManager.get(n, m.TileEventType.Fire) && b.passable && (w = !0)
        }
        if (a) {
            const a = []
              , n = t.containedWithin;
            for (const e of n.containedItems)
                e.type !== t.type || i && e.quality !== t.quality || a.push(e);
            let o = 0
              , l = !1;
            const p = a.length;
            for (let t = 0; t < p; t++) {
                const i = a[t];
                if (I)
                    o++,
                    i.dropInWater(e.executor, void 0, void 0, 0 !== t);
                else {
                    if (!i.placeOnTile(f.x, f.y, e.executor.z, !1)) {
                        l = !0;
                        break
                    }
                    o++,
                    itemManager.isContainer(i) && ui.closeContainer(i)
                }
            }
            const c = itemManager.getItemTranslations(a).collect(s.default.formatList);
            if (I ? d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(r.default.DroppedIntoDepths, c) : l ? (o && d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(w ? r.default.AttemptedToDropAllIntoFire : r.default.AttemptedToPlaceAllOnGround, c),
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(r.default.NoRoomToDrop, t.getName())) : o && d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(w ? r.default.DroppedIntoFire : r.default.PlacedOnGround, c),
            !o)
                return
        } else if (I)
            t.dropInWater(e.executor),
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(r.default.DroppedIntoDepths, t.getName());
        else {
            if (!t.placeOnTile(f.x, f.y, e.executor.z, !1))
                return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(r.default.NoRoomToDrop, t.getName());
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(w ? r.default.DroppedIntoFire : r.default.PlacedOnGround, t.getName()),
            itemManager.isContainer(t) && ui.closeContainer(t)
        }
        v && e.setParticle({
            color: c.default[p.ParticleType.Water],
            position: new y.default(f,e.executor.z)
        }),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect(I ? o.SfxType.Water : o.SfxType.PickUp, !0)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Equip", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby,i.ActionArgument.EquipType,i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player).setHandler((e,t,a,i,n)=>{
        e.setDelay(25),
        e.executor.equip(t, a, i, n),
        t.legendary && void 0 !== t.legendary.skill && ui.highlight(3, `#skills div[data-skill="${t.legendary.skill}"]`),
        i || e.setPassTurn()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Extinguish", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "item/Items", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        const a = r.itemDescriptions[t.type];
        if (!a)
            return;
        const i = a.revert;
        i && (e.setDelay(25),
        t.changeInto(i),
        u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(s.default.ExtinguishedTorch),
        e.setStaminaReduction(o.SkillType.Camping),
        e.executor.calculateEquipmentStats(),
        e.setPassTurn(),
        e.setSoundEffect(o.SfxType.Trample),
        e.setUpdateTablesAndWeight())
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Gather", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "entity/IStats", "Enums", "item/Items", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "tile/TerrainResources", "tile/Terrains", "tile/TileEvents", "utilities/enum/Enums", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S) {
    var I;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Doodad = 0] = "Doodad",
        e[e.TileEvent = 1] = "TileEvent",
        e[e.Tile = 2] = "Tile"
    }(I = t.GatherType || (t.GatherType = {})),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemInventory, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player).setPreExecutionHandler((e,t,a)=>{
        let n;
        if (!a && !t) {
            if (void 0 === (n = e.executor.handToUse))
                return void e.setDelay(13);
            if (t = e.executor.getEquippedItem(n)) {
                const e = s.default[t.type];
                e && e.use && e.use.includes(i.ActionType.Gather) || (t = void 0)
            }
        }
        e.addItems(t)
    }
    ).setHandler((e,t,a)=>{
        const n = e.executor.getFacingTile();
        if (!n)
            return;
        e.setDelay(25);
        const v = S.default.getType(n);
        let w, M, b = r.SfxType.PickUp, k, C, D, A;
        const P = tileEventManager.canGather(n);
        if (void 0 !== P) {
            const e = g.default[P.type];
            e && (w = e.items,
            M = e.skillUse,
            k = r.ItemQuality.Random,
            C = e.particles,
            D = I.TileEvent,
            A = d.default.nameOf(l.Dictionary.TileEvent, P.type, !1))
        }
        if (!P && !e.executor.checkAndRemoveBlood())
            return void m.default.get(e.executor).source(p.Source.Action).send(u.default.SomethingInTheWayOfCarveFirst, d.default.message(u.default.Gathering));
        const {x: G, y: R, z: x} = e.executor.getFacingPoint();
        if (void 0 !== n.creature || void 0 !== n.npc || game.isPlayerAtPosition(G, R, x))
            return m.default.get(e.executor).source(p.Source.Action).send(u.default.SomethingInTheWayOf, d.default.message(u.default.Gathering)),
            void game.checkForHiddenMob(e.executor, G, R, x);
        const B = y.default[v];
        let E = 25;
        const L = n.doodad;
        if (void 0 === D && L) {
            const a = L.description();
            if (!a)
                return;
            if (L.canPickup(e.executor))
                return e.get(i.ActionType.Pickup).execute(e.executor, t),
                void e.setDelay(0);
            if (L.canHarvest())
                return e.get(i.ActionType.Harvest).execute(e.executor, t, void 0),
                void e.setDelay(0);
            const n = L.getGrowingStage();
            if (!a.gather || void 0 === n)
                return void m.default.get(e.executor).source(p.Source.Action).send(u.default.NothingToGetFromThis, d.default.message(u.default.Gather), L.getName());
            if (C = L.getGrowthParticles(),
            !L.canGather() && L)
                return m.default.get(e.executor).source(p.Source.Action).send(u.default.GatherDestroy, L.getName()),
                n === r.GrowingStage.Germinating && B && (C = B.particles),
                void 0 !== e.executor.checkForGatherFire() && e.executor.burn(!1, !0, t ? void 0 : r.EquipType.Hands),
                e.setItemsUsed(),
                e.setReputationChange(-25),
                C && e.setParticle(C, !0),
                e.setDelay(E),
                e.setPassTurn(),
                e.setSoundEffect(r.SfxType.PickUp, !0),
                e.setStaminaReduction(M),
                void doodadManager.remove(L);
            w = a.gather[n],
            M = a.gatherSkillUse ? a.gatherSkillUse : a.skillUse,
            k = L.quality,
            D = I.Doodad,
            A = L.getName(!1),
            a.causesStatus && L.causeStatus(e.executor, r.EquipType.Hands)
        }
        if (void 0 === D && B) {
            if (!B.gather)
                return void m.default.get(e.executor).source(p.Source.Action).send(u.default.CannotHere, d.default.message(u.default.Gather));
            w = h.default[v],
            M = B.gatherSkillUse,
            k = r.ItemQuality.Random,
            C = B.particles,
            D = I.Tile,
            A = new d.default(l.Dictionary.Terrain,v),
            f.default.isModded(r.TerrainType, v) || e.executor.addMilestone(c.MilestoneType.Explorer, v)
        }
        void 0 === M && (M = r.SkillType.Mining);
        const O = e.executor.getSkill(M);
        let F;
        if (!a && !t) {
            if (!(F = e.executor.getAndSwitchHandToUse()))
                return void e.setDelay(13);
            if (t = e.executor.getEquippedItem(F)) {
                const e = s.default[t.type];
                e && e.use && -1 !== e.use.indexOf(i.ActionType.Gather) || (t = void 0)
            }
        }
        let _ = 15
          , H = 1;
        if (t) {
            const a = t.description();
            if (a && void 0 !== a.attack) {
                const i = a.damageType;
                if (void 0 !== i)
                    if (M === r.SkillType.Mining)
                        i & r.DamageType.Blunt ? (_ = 10 - a.attack,
                        H++,
                        B && B.sound && (b = B.sound)) : m.default.get(e.executor).source(p.Source.Action, p.Source.Equipment, p.Source.Resource).send(u.default.AppearedNotEffectiveForGathering, t.getName());
                    else if (i & r.DamageType.Slashing) {
                        if (_ = 10 - a.attack,
                        H++,
                        L) {
                            const e = L.description()
                              , t = L.getGrowingStage();
                            e && e.isTree && void 0 !== t && t >= r.GrowingStage.Budding && t <= r.GrowingStage.Dead && (b = r.SfxType.TreeHit)
                        }
                    } else
                        m.default.get(e.executor).source(p.Source.Action, p.Source.Equipment, p.Source.Resource).send(u.default.AppearedNotEffectiveForGathering, t.getName())
            }
        } else
            m.default.get(e.executor).source(p.Source.Action, p.Source.Equipment, p.Source.Resource).send(u.default.AppearedNotEffectiveForGathering, d.default.message(u.default.YourHands));
        if (H += Math.ceil(T.default.int(e.executor.getSkill(M) / 33)),
        _ = Math.ceil(100 * T.default.float() + _) - 45,
        !t) {
            let t;
            if (F === r.EquipType.LeftHand ? t = u.default.LeftHand : F === r.EquipType.RightHand && (t = u.default.RightHand),
            D === I.Doodad && L) {
                const a = L.description()
                  , i = L.getGrowingStage();
                a && a.gatherCanHurtHands && i && i > r.GrowingStage.Vegetative && e.executor.hurtHands(u.default.Gather, u.default.Gathering, t)
            } else
                D === I.Tile && e.executor.hurtHands(u.default.Gather, u.default.Gathering, t)
        }
        if (O > _) {
            w = Array.isArray(w) ? w : w.items;
            for (let t = 0; t < H; t++) {
                let a = 0;
                if (D === I.Doodad && L && L.step)
                    a = L.step;
                else if (D === I.TileEvent && P && P.step)
                    a = P.step;
                else if (D === I.Tile) {
                    const e = game.getOrCreateTileData(G, R, x);
                    if (e.length > 0) {
                        const t = e[0].step;
                        t && (a = t)
                    }
                }
                if (w[a]) {
                    const i = void 0 !== w[a].chance ? w[a].chance : 100
                      , n = void 0 !== w[a].chanceOutOf ? w[a].chanceOutOf : 100;
                    if (void 0 !== i && T.default.percent(0, n) > i || 100 === i) {
                        const t = itemManager.getQualityBasedOnSkill(k, e.executor.getSkill(M || r.SkillType.Mining), !0)
                          , i = e.executor.createItemInInventory(w[a].type, t);
                        void 0 !== i && void 0 !== i.maxDur && L && L.minDur && L.maxDur && (i.minDur = Math.ceil(i.maxDur / (L.maxDur / L.minDur)),
                        ui.updateItem(i)),
                        e.executor.options.dropOnGatherHarvest && i.placeOnTile(e.executor.x, e.executor.y, x, !1),
                        m.default.get(e.executor).source(p.Source.Action, p.Source.Item, p.Source.Resource).send(e.executor.options.dropOnGatherHarvest ? u.default.YouGatheredAndDropped : u.default.YouGathered, i.getName()),
                        e.addSkillGains(M),
                        e.setMilestone(c.MilestoneType.Gatherer)
                    } else
                        t--
                }
                if (D === I.Doodad && L) {
                    L.step ? L.step++ : L.step = 1;
                    const e = L.getGrowingStage()
                      , t = L.description();
                    L.step >= w.length && (t && t.isTree && void 0 !== e && e > r.GrowingStage.Vegetative && e < r.GrowingStage.Dead ? (L.setGrowingStage(r.GrowingStage.Dead, !0),
                    L.spread = void 0,
                    L.step = void 0) : doodadManager.remove(L))
                } else if (D === I.TileEvent && P)
                    P.step ? P.step++ : P.step = 1,
                    P.step >= w.length && tileEventManager.remove(P);
                else if (D === I.Tile) {
                    const t = game.getOrCreateTileData(G, R, x);
                    if (t.length > 0 ? t[0].step ? t[0].step++ : t[0].step = 1 : t.push({
                        type: v,
                        step: 1
                    }),
                    t[0].step >= w.length) {
                        game.makeLavaPassage(e.executor) || void 0 === game.makeCaveEntrance(e.executor) && B && void 0 !== B.leftOver && game.changeTile(B.leftOver, G, R, x, !1);
                        break
                    }
                }
            }
            if (L) {
                const t = L.description();
                D === I.Doodad && T.default.chance(.3 - e.executor.getSkill(M) / 1e3 - (t && t.isTree ? .1 : 0)) && L.damage()
            }
        } else
            0 === T.default.int(5) && e.addSkillGains(M, .1),
            m.default.get(e.executor).source(p.Source.Action, p.Source.Resource).send(u.default.DoNotProduceAnyResources, d.default.message(u.default.HackAway), A);
        const W = n;
        if (W.containedItems && W.containedItems.length > 0) {
            const t = W.containedItems[W.containedItems.length - 1];
            itemManager.moveToContainer(e.executor, t, e.executor.inventory),
            m.default.get(e.executor).source(p.Source.Action, p.Source.Item, p.Source.Resource).send(u.default.YouPickedUp, t.getName()),
            E += 4
        }
        creatureManager.maybeSpawnClawWorm(e.executor),
        t || e.executor.reduceStat(o.Stat.Stamina, 1),
        void 0 !== e.executor.checkForGatherFire() && e.executor.burn(!1, !0, t ? void 0 : r.EquipType.Hands),
        e.setItemsUsed(),
        e.setPassTurn(),
        e.setStaminaReduction(M),
        e.setUpdateTablesAndWeight(),
        e.setDelay(E),
        C && e.setParticle(C, !0),
        e.setSoundEffect(b, !0)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/GatherMilk", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "entity/IStats", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "tile/Terrains", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        const a = e.executor.getFacingTile()
          , i = m.default[y.default.getType(a)];
        if (!i)
            return;
        e.setDelay(25);
        const n = a.creature;
        if (void 0 !== n) {
            if (game.isTileFull(a)) {
                d.default.get(e.executor).source(u.Source.Action).send(s.default.SomethingInTheWayOf, l.default.message(s.default.Milking));
                const {x: t, y: a, z: i} = e.executor.getFacingPoint();
                game.checkForHiddenMob(e.executor, t, a, i)
            } else if (n) {
                if (n.type !== r.CreatureType.Goat)
                    return void d.default.get(e.executor).source(u.Source.Action, u.Source.Creature).send(s.default.ThisCannotBeMilked);
                if (!n.isTamed())
                    return d.default.get(e.executor).source(u.Source.Action, u.Source.Creature).send(s.default.WildGoatRefusedToBeMilked),
                    e.setPassTurn(),
                    e.setStaminaReduction(r.SkillType.Taming),
                    void e.setSoundEffect({
                        type: r.SfxType.CreatureNoise,
                        inFront: !0
                    });
                if (n.hasStat(o.Stat.Produce) && n.getStat(o.Stat.Produce).value >= 0)
                    return void d.default.get(e.executor).source(u.Source.Action, u.Source.Allies, u.Source.Creature).send(s.default.GoatHasNoMilk);
                if (n.setStat(o.Stat.Produce, 2e3 + h.default.int(1e3)),
                n.hasStat(o.Stat.Happiness)) {
                    const t = 250 - 10 * e.executor.getSkill(r.SkillType.Taming);
                    t > 0 && n.reduceStat(o.Stat.Happiness, t)
                }
                d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.Filled, t.getName());
                const a = t.description();
                a && a.gather && t.changeInto(a.gather.milk),
                e.setPassTurn(),
                e.setUpdateTablesAndWeight(),
                e.setParticle({
                    color: c.default[p.ParticleType.Milk],
                    inFront: !0
                }),
                e.setSoundEffect({
                    type: r.SfxType.CreatureNoise,
                    inFront: !0
                }),
                d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.YouPickedUp, t.getName()),
                e.addSkillGains(r.SkillType.Taming),
                e.setStaminaReduction(r.SkillType.Taming)
            }
        } else
            d.default.get(e.executor).source(u.Source.Action).send(s.default.ThereIsNothingToMilk)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/GatherTreasure", ["require", "exports", "action/Action", "action/IAction", "creature/ICreature", "entity/IEntity", "Enums", "language/dictionary/Message", "mod/IHookManager", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "tile/Terrains", "utilities/math/Vector3", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemNearby, i.ActionArgument.Undefined)).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        const a = e.executor.getFacingTile()
          , i = y.default.getType(a)
          , o = c.default[i];
        if (!o)
            return;
        let g;
        e.setDelay(25),
        g = o && o.water ? r.SkillType.Fishing : r.SkillType.Mining;
        const f = Math.floor(e.executor.getSkill(g) / 10) + 1;
        let T = !1;
        const S = itemManager.getItemsInContainerByType(e.executor.inventory, r.ItemType.TatteredMap, !0);
        let I = !0;
        for (const e of S)
            e.used && void 0 !== e.used.map || (I = !1);
        if (S.length <= 0 || I)
            p.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.DoNotHaveTreasureMaps);
        else {
            for (const I of S) {
                if (!I.tatteredMap)
                    continue;
                const S = I.tatteredMap.x
                  , v = I.tatteredMap.y;
                if (e.executor.x + f >= S && e.executor.y + f >= v && e.executor.x - f <= S && e.executor.y - f <= v) {
                    if (!o.passable && !o.water || void 0 !== a.doodad || void 0 !== a.events || !e.executor.checkAndRemoveBlood() || game.isPlayerAtPosition(S, v, e.executor.z))
                        return void p.default.get(e.executor).source(u.Source.Action).send(s.default.TreasureIsBlocked);
                    if (o.water && t && t.type !== r.ItemType.FishingNet)
                        return void p.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.NeedFishingNetForTreasure);
                    if (!o.water && t && t.type === r.ItemType.FishingNet)
                        return void p.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.NeedAShovelToDigTreasure);
                    T = !0;
                    const {x: f, y: w} = e.executor.getFacingPoint();
                    o && game.particle.create(f, w, e.executor.z, o.particles);
                    const M = doodadManager.create(r.DoodadType.LockedWoodenChest, f, w, e.executor.z);
                    M && (M.treasure = !0),
                    i === r.TerrainType.CaveEntrance && (game.changeTile(r.TerrainType.Dirt, f, w, r.WorldZ.Overworld, !0),
                    game.changeTile(r.TerrainType.Dirt, f, w, r.WorldZ.Cave, !0)),
                    e.executor.addMilestone(d.MilestoneType.TreasureHunter);
                    const b = [];
                    for (let e = -12; e <= 12; e++)
                        for (let t = -12; t <= 12; t++)
                            b.push([e, t]);
                    let k = 0;
                    const C = h.default.shuffle(b);
                    for (const t of C) {
                        const a = game.getTile(t[0] + e.executor.x, t[1] + e.executor.y, e.executor.z);
                        if (!a)
                            continue;
                        if (void 0 !== a.npc)
                            continue;
                        if (void 0 !== a.doodad) {
                            const e = a.doodad.description();
                            if (e && e.blockMove)
                                continue
                        }
                        const i = y.default.getType(a)
                          , o = c.default[i];
                        let s;
                        if (o && (o.passable ? s = creatureManager.spawnFromGroup(n.SpawnGroup.Guardians, t[0] + e.executor.x, t[1] + e.executor.y, e.executor.z, !0) : o.water ? s = creatureManager.spawn(r.CreatureType.Shark, t[0] + e.executor.x, t[1] + e.executor.y, e.executor.z, !0) : o.passable || (s = creatureManager.spawn(r.CreatureType.PirateGhost, t[0] + e.executor.x, t[1] + e.executor.y, e.executor.z, !0)),
                        s && (game.particle.create(t[0] + e.executor.x, t[1] + e.executor.y, e.executor.z, o.particles),
                        s.queueSoundEffect(r.SfxType.CreatureNoise),
                        s.skipNextUpdate(),
                        k++)),
                        k >= 5)
                            break
                    }
                    e.addSkillGains(g),
                    e.setItemsUsed(),
                    p.default.get(e.executor).source(u.Source.Action).send(s.default.DugTreasureOut),
                    k >= 1 && p.default.get(e.executor).source(u.Source.Action, u.Source.Creature).send(s.default.SummonedGuardiansByDiggingTreasure),
                    modManager.getHook(l.Hook.OnDigTreasure).call(e.executor, new m.default(f,w,e.executor.z)),
                    e.setReputationChange(-500),
                    e.setStaminaReduction(r.SkillType.Mining),
                    I.setUsed({
                        map: new m.default(f,w,e.executor.z)
                    }, e.executor),
                    e.setPassTurn(),
                    e.setUpdateTablesAndWeight(),
                    e.setSoundEffect({
                        type: r.SfxType.Hit,
                        position: new m.default(S,v,e.executor.z)
                    });
                    break
                }
            }
            T || p.default.get(e.executor).source(u.Source.Action).send(s.default.NotInRangeOfTreasure)
        }
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/GatherWater", ["require", "exports", "action/Action", "action/IAction", "doodad/Doodads", "entity/IEntity", "Enums", "game/IGame", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/TileHelpers", "utilities/TilePosition"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setHandler((e,t)=>{
        const a = e.executor.getFacingTile()
          , i = c.default[m.default.getType(a)];
        if (!i)
            return;
        e.setDelay(25);
        const {x: o, y: y, z: g} = e.executor.getFacingPoint();
        if (void 0 !== a.creature || void 0 !== a.npc || game.isTileFull(a) || game.isPlayerAtPosition(o, y, g))
            return p.default.get(e.executor).source(d.Source.Action).send(l.default.SomethingInTheWayOf, u.default.message(l.default.WaterGathering)),
            void game.checkForHiddenMob(e.executor, o, y, g);
        let f = !1;
        const T = a.doodad;
        if (T) {
            const a = T.description();
            if (!a)
                return;
            const u = game.wellData[h.getTileId(o, y, g)];
            if (a.isWaterSource || a.waterStill) {
                if (T.gatherReady) {
                    p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.FilledFrom, t.getName(), T.getName());
                    const n = t.description();
                    n && n.gather && t.changeInto(n.gather.desalinated),
                    p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.YouPickedUp, t.getName()),
                    T.decay = -1,
                    T.gatherReady = !1,
                    a.waterStill && a.revert && T.changeType(a.revert),
                    world.updateTile(T.x, T.y, T.z, T.getTile()),
                    e.setPassTurn(),
                    e.setUpdateTablesAndWeight(),
                    e.setParticle(i.particles, !0),
                    e.setStaminaReduction(r.SkillType.Chemistry)
                } else if (a.decayMax === T.decay)
                    p.default.get(e.executor).source(d.Source.Action).send(l.default.NoWaterInStill);
                else {
                    const t = void 0 !== a.lit ? n.default[a.lit] : void 0;
                    t && t.waterStill ? p.default.get(e.executor).source(d.Source.Action).send(l.default.RequiresFireToBeLit) : p.default.get(e.executor).source(d.Source.Action).send(l.default.NotEnoughPurifiedWaterYet)
                }
                f = !0
            } else if (a.waterStill)
                p.default.get(e.executor).source(d.Source.Action).send(l.default.WaitUntilFireCooledToGetWater),
                f = !0;
            else if (a.group === r.DoodadTypeGroup.Well && u)
                if (u.quantity >= 1 || -1 === u.quantity) {
                    p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.FilledFrom, t.getName(), T.getName());
                    const a = c.default[m.default.getType(game.getTile(o, y, r.WorldZ.Cave))];
                    g === r.WorldZ.Overworld && a && (-1 !== u.quantity || a.water || a.shallowWater ? (a.water || a.shallowWater) && (u.quantity = -1) : u.quantity = 20),
                    u.quantity >= 1 && u.quantity--;
                    const n = t.description();
                    u.waterType !== s.WaterType.Seawater && n && n.gather ? t.changeInto(n.gather.unpurified) : n && n.gather && t.changeInto(n.gather.seawater),
                    e.setPassTurn(),
                    e.setUpdateTablesAndWeight(),
                    e.setParticle(i.particles, !0),
                    f = !0
                } else
                    u.waterType === s.WaterType.None ? (p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.NoGroundWater),
                    f = !0) : (p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.WellIsDry),
                    f = !0)
        }
        if (!f)
            if (i.water || i.shallowWater || m.default.getType(a) === r.TerrainType.Snow) {
                p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.Filled, t.getName());
                const n = t.description();
                (m.default.getType(a) === r.TerrainType.Snow || i.freshWater) && n && n.gather ? (t.changeInto(n.gather.unpurified),
                m.default.getType(a) === r.TerrainType.Snow && game.changeTile(r.TerrainType.Dirt, o, y, g, !1)) : n && n.gather && t.changeInto(n.gather.seawater),
                (i.water || i.shallowWater) && game.consumeWaterTile(o, y, g),
                e.setPassTurn(),
                e.setUpdateTablesAndWeight(),
                e.setParticle(i.particles, !0),
                p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.YouPickedUp, t.getName()),
                e.setStaminaReduction(r.SkillType.Chemistry)
            } else
                p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.NothingHereToFill, t.getName())
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Grasp", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler(e=>{
        e.setDelay(25);
        const t = e.executor.getFacingTile()
          , a = t;
        if (!a.containedItems || !a.containedItems.length)
            return void s.default.get(e.executor).source(r.Source.Action).send(o.default.NothingHereToGrasp);
        const i = a.containedItems[a.containedItems.length - 1];
        itemManager.moveToContainer(e.executor, i, e.executor.inventory),
        s.default.get(e.executor).source(r.Source.Action, r.Source.Item).send(o.default.YouPickedUp, i.getName()),
        e.setDelay(29),
        e.setItemsUsed(),
        e.setUpdateTablesAndWeight(),
        e.setPassTurn()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Harvest", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "entity/IStats", "Enums", "item/Items", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemInventory, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t,a)=>{
        let n;
        if (!a && !t) {
            if (void 0 === (n = e.executor.handToUse))
                return void e.setDelay(13);
            if (t = e.executor.getEquippedItem(n)) {
                const e = s.default[t.type];
                e && e.use && (e.use.includes(i.ActionType.Harvest) || e.use.includes(i.ActionType.Gather)) || (t = void 0)
            }
        }
        e.addItems(t)
    }
    ).setHandler((e,t,a)=>{
        const n = e.executor.getFacingTile();
        if (!n)
            return;
        if (e.setDelay(25),
        !a && !t) {
            const a = e.executor.getAndSwitchHandToUse();
            if (!a)
                return void e.setDelay(13);
            if (t = e.executor.getEquippedItem(a)) {
                const e = s.default[t.type];
                e && e.use && (e.use.includes(i.ActionType.Harvest) || e.use.includes(i.ActionType.Gather)) || (t = void 0)
            }
        }
        if (!e.executor.checkAndRemoveBlood())
            return void p.default.get(e.executor).source(d.Source.Action).send(l.default.SomethingInTheWayOfCarveFirst, u.default.message(l.default.Harvesting));
        const {x: m, y: h, z: y} = e.executor.getFacingPoint();
        if (void 0 !== n.creature || void 0 !== n.npc || game.isPlayerAtPosition(m, h, y))
            return p.default.get(e.executor).source(d.Source.Action).send(l.default.SomethingInTheWayOf, u.default.message(l.default.Harvesting)),
            void game.checkForHiddenMob(e.executor, m, h, y);
        const g = n.doodad;
        if (!g)
            return void p.default.get(e.executor).source(d.Source.Action).send(l.default.CannotHere, u.default.message(l.default.Harvest));
        let f, T;
        const S = g.description();
        if (!S)
            return;
        const I = g.getGrowthParticles()
          , v = g.getGrowingStage();
        if (!S.harvest || void 0 === v)
            return void p.default.get(e.executor).source(d.Source.Action).send(l.default.NothingToHarvestFromThisGather, g.getName());
        if (!(f = S.harvest[v]))
            return void p.default.get(e.executor).source(d.Source.Action).send(l.default.NothingUsefulToHarvestYet, g.getName());
        T = g.quality,
        S.causesStatus && g.causeStatus(e.executor, r.EquipType.Hands);
        const w = S.skillUse ? S.skillUse : r.SkillType.Gardening
          , M = e.executor.getSkill(w);
        let b = 25;
        const k = Math.ceil(c.default.int(M / 33)) + 1;
        if (M > Math.ceil(100 * c.default.float() - 30)) {
            for (let t = 0; t < k; t++) {
                let a = 0;
                if (g.step && (a = g.step),
                f[a]) {
                    const i = void 0 !== f[a].chance ? f[a].chance : 100
                      , n = void 0 !== f[a].chanceOutOf ? f[a].chanceOutOf : 100;
                    if (void 0 !== i && c.default.percent(0, n) > i || 100 === i) {
                        const t = itemManager.getQualityBasedOnSkill(T, M, !0)
                          , i = e.executor.createItemInInventory(f[a].type, t);
                        void 0 !== i && void 0 !== i.maxDur && !S.isTree && g.minDur && g.maxDur && (i.minDur = Math.ceil(i.maxDur / (g.maxDur / g.minDur)),
                        ui.updateItem(i)),
                        e.executor.options.dropOnGatherHarvest && i.placeOnTile(e.executor.x, e.executor.y, y, !1),
                        p.default.get(e.executor).source(d.Source.Action, d.Source.Item, d.Source.Resource).send(e.executor.options.dropOnGatherHarvest ? l.default.YouHarvestedAndDropped : l.default.YouHarvested, i.getName()),
                        b += 4
                    } else
                        t--
                }
                if (g.step ? g.step++ : g.step = 1,
                g.step >= f.length) {
                    g.setGrowingStage(r.GrowingStage.Budding, !0),
                    g.step = void 0,
                    void 0 !== S.decayMax && S.decayMax > 0 && (g.decay = S.decayMax);
                    break
                }
            }
            c.default.chance(.3 - e.executor.getSkill(w) / 1e3 - (S.isTree ? .1 : 0)) && g.damage()
        } else
            p.default.get(e.executor).source(d.Source.Action, d.Source.Resource).send(l.default.DoNotProduceAnyResources, u.default.message(l.default.PickAway), g.getName(!1)),
            0 === c.default.int(5) && e.addSkillGains(w, .1);
        creatureManager.maybeSpawnClawWorm(e.executor),
        e.setItemsUsed(),
        t || e.executor.reduceStat(o.Stat.Stamina, 1);
        const C = e.executor.checkForGatherFire();
        void 0 !== C && e.executor.burn(!1, !0, t ? void 0 : r.EquipType.Hands),
        e.addSkillGains(w),
        e.setPassTurn(),
        e.setStaminaReduction(w),
        e.setUpdateTablesAndWeight(),
        e.setDelay(b),
        I && e.setParticle(I, !0),
        e.setSoundEffect(r.SfxType.PickUp, !0)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/HealOther", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "entity/IStats", "Enums", "item/Items", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        e.setDelay(25);
        const a = e.executor.getFacingTile()
          , y = a.creature
          , g = a.npc
          , f = game.getPlayersAtTile(a)
          , T = f && f.length > 0 ? f[0] : y || g;
        if (!T)
            return void m.default.get(e.executor).source(p.Source.Action).send(u.default.NotFacingOtherToHeal);
        const S = s.default[t.type];
        if (!S)
            return;
        const I = S.onUse;
        if (!I || !I[i.ActionType.HealOther])
            return;
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setReputationChange(25);
        const v = h.default.percent(50)
          , w = S.skillUse;
        if (w && e.executor.getSkill(w) <= v)
            e.setItemsUsed(),
            T.queueSoundEffect(r.SfxType.Fail),
            e.addSkillGains(w, .1),
            m.default.get(e.executor).source(p.Source.Action, p.Source.Allies).type(m.MessageType.Bad).send(u.default.YouFailedToHealOther, T.getName(), new d.default(l.Dictionary.Skill,w));
        else {
            const a = T.getStat(o.Stat.Health)
              , s = I[i.ActionType.HealOther]
              , l = w ? h.default.int(e.executor.getConsumeBonus(t, w) + 1) : 0
              , d = t.legendary && t.legendary.type === r.LegendaryType.UseBenefits ? t.legendary.value : 0
              , S = s + l + d;
            T.increaseStat(a, S),
            T.hasStatus(r.StatusType.Bleeding) && (T.setStatus(r.StatusType.Bleeding, !1, n.StatusEffectChangeReason.Treated),
            T.hasStatus(r.StatusType.Bleeding) || (corpseManager.createBlood(T.x, T.y, T.z),
            e.executor.addMilestone(c.MilestoneType.Doctor, r.StatusType.Bleeding))),
            game.notifier.addStat(T.x, T.y, T.z, r.StatType.Health, S);
            let v = m.MessageType.Good;
            y ? (y.queueSoundEffect(r.SfxType.CreatureNoise),
            y.isTamed() || (v = m.MessageType.Bad)) : f && multiplayer.isConnected() && multiplayer.getOptions().pvp ? v = m.MessageType.Bad : g && g.isHostile() && (g.ai = n.AiType.Waiting,
            m.default.get(e.executor).source(p.Source.Action).send(u.default.NoLongerHostile, g.getName())),
            T.queueSoundEffect(r.SfxType.Eating),
            w && e.addSkillGains(w),
            m.default.get(e.executor).source(p.Source.Action, p.Source.Allies).type(v).send(u.default.YouHaveHealedOther, T.getName()),
            itemManager.remove(t)
        }
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Idle", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = (new a.Action).setUsableBy(n.EntityType.Player).setUsableWhen(i.ActionUsability.Ghost).setHandler(e=>{
        e.executor.nextX = e.executor.x,
        e.executor.nextY = e.executor.y,
        e.setPassTurn(o.TurnType.ForcePickUp),
        e.setDelay(13)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Ignite", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "tile/ITileEvent", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        if (e.setDelay(25),
        !t.isEquipped())
            return void l.default.get(e.executor).source(s.Source.Action, s.Source.Equipment, s.Source.Item).send(r.default.MustBeEquippedToIgnite, t.getName());
        const a = e.executor.getFacingTile()
          , i = d.default.getType(a)
          , n = a.doodad
          , p = a.creature;
        if (!tileEventManager.get(a, u.TileEventType.Fire) && i !== o.TerrainType.Lava && i !== o.TerrainType.CoolingLava) {
            const a = n ? n.description() : void 0
              , i = p ? p.description() : void 0;
            if (!(a && a.providesFire || i && i.providesFire))
                return void l.default.get(e.executor).source(s.Source.Action, s.Source.Item).send(r.default.RequiresYouFacingFireSource, t.getName())
        }
        const c = t.description();
        if (!c)
            return;
        const m = c.lit;
        m && (t.changeInto(m),
        void 0 === t.decay && (t.decay = t.getDecayMax()),
        l.default.get(e.executor).source(s.Source.Action, s.Source.Item).send(r.default.YouPickedUp, t.getName()),
        e.addSkillGains(o.SkillType.Camping),
        e.setStaminaReduction(o.SkillType.Camping),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect(o.SfxType.Throw))
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Inspect", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "game/inspection/IInspection", "game/inspection/Inspect", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "utilities/math/Vector3"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.Vector3).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        const a = r.default.inspect(e.executor, new p.default(t), o.InspectionContext.Message);
        for (const t of a)
            for (const a of t.content)
                d.default.get(e.executor).source(u.Source.Action).type(a.messageType).send(a.text.addReformatter(a.name && l.default.message(s.default.YouSee)))
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Jump", ["require", "exports", "action/Action", "entity/IEntity", "entity/IStats", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = (new a.Action).setUsableBy(i.EntityType.Player, i.EntityType.NPC).setHandler(e=>{
        if (!e.executor.canJump())
            return;
        e.setDelay(25);
        const t = e.executor.getStat(n.Stat.Stamina)
          , a = Math.floor(10 + e.executor.getStat(n.Stat.Weight).value / 2);
        t.value < a ? l.default.get(e.executor).source(s.Source.Action).send(r.default.TooExhaustedToJump) : (e.executor.setPosition({
            x: e.executor.x + 2 * e.executor.direction.x,
            y: e.executor.y + 2 * e.executor.direction.y,
            z: e.executor.z
        }),
        e.executor.reduceStat(t, a),
        e.setPassTurn(o.TurnType.CheckUnderPlayer))
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Learn", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "item/Items", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "player/Skills", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/math/Math2", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        if (e.setDelay(25),
        t.used && t.used.usedBy)
            for (const a of t.used.usedBy)
                if (a === e.executor.identifier)
                    return void p.default.get(e.executor).source(d.Source.Action).send(l.default.YouHaveAlreadyLearned, t.getName());
        if (t.type === o.ItemType.OldEducationalScroll) {
            let a = !0
              , i = !0
              , n = !1
              , r = m.default.values(o.SkillType).collect(h.default.toArray);
            r = g.default.shuffle(r);
            for (const a of r) {
                const o = e.executor.skills[a];
                if (!o || o.core >= 100)
                    continue;
                const r = c.skillDescriptions[a];
                if (r) {
                    i = !1,
                    t.used || (n = a);
                    break
                }
            }
            if (t.used && void 0 !== t.used.skill) {
                const a = e.executor.skills[t.used.skill];
                a && a.core < 100 && (n = t.used.skill)
            }
            if (n) {
                const i = y.default.roundNumber(g.default.percent(0, 1, !1) + .5, 1);
                e.executor.skillGain(n, i, !0),
                e.setItemsUsed(),
                t.setUsed({
                    skill: n
                }, e.executor),
                e.setSoundEffect(o.SfxType.Exceptional),
                e.setReputationChange(100),
                e.setPassTurn(),
                a = !1,
                p.default.get(e.executor).source(d.Source.Action, d.Source.Skill).type(p.MessageType.Good).send(l.default.KnowledgeHasIncreased, new u.default(s.Dictionary.Skill,n))
            }
            a && (p.default.get(e.executor).source(d.Source.Action, d.Source.Skill, d.Source.Item).send(l.default.ScrollProvidedNoUsefulInsight),
            i && p.default.get(e.executor).type(p.MessageType.Good).source(d.Source.Action, d.Source.Item).send(l.default.ScrollMaster, u.default.message(l.default.Skills)))
        } else {
            let a = !1
              , i = !0;
            if (!game.isChallenge) {
                const e = {};
                for (const t of m.default.values(o.ItemType))
                    if (t !== o.ItemType.None) {
                        const a = r.default[t];
                        a && a.recipe && !1 !== a.craftable && (e[t] = !0)
                    }
                for (const t in game.crafted)
                    delete e[t];
                const n = Object.keys(e);
                n.length >= 1 && !t.used && (a = parseInt(g.default.getElement(n), 10)),
                i = !n.length,
                t.used && void 0 !== t.used.recipe && !game.crafted[t.used.recipe] && (a = t.used.recipe)
            }
            a ? (game.crafted[a] = {
                newUnlock: !0,
                unlockTime: Date.now()
            },
            p.default.get(e.executor).source(d.Source.Action, d.Source.Item).type(p.MessageType.Good).send(l.default.LearnedHowToCreate, u.default.nameOf(s.Dictionary.Item, a)),
            e.setItemsUsed(),
            t.setUsed({
                recipe: a
            }, e.executor),
            e.setSoundEffect(o.SfxType.Exceptional),
            e.setReputationChange(100),
            e.setPassTurn(),
            e.setUpdateTablesAndWeight()) : (p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.ScrollProvidedNoUsefulInsight),
            i && p.default.get(e.executor).source(d.Source.Action, d.Source.Item).type(p.MessageType.Good).send(l.default.ScrollMaster, u.default.message(l.default.Crafts).inContext(1)))
        }
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/LockPick", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        e.setDelay(25);
        const a = e.executor.getFacingTile()
          , n = a.doodad
          , p = n ? n.description() : void 0;
        if (!n || !p || !p.isLocked)
            return void u.default.get(e.executor).source(s.Source.Action).send(r.default.NotFacingLockedObject);
        const c = d.default.percent(10);
        e.executor.getSkill(o.SkillType.LockPicking) >= c ? (u.default.get(e.executor).source(s.Source.Action).send(r.default.UnlockedChest),
        e.addSkillGains(o.SkillType.LockPicking),
        n.addTreasureChestLoot(),
        e.executor.addMilestone(l.MilestoneType.Locksmith),
        e.get(i.ActionType.OpenContainer).execute(e.executor, n),
        e.setReputationChange(-1e3)) : (e.addSkillGains(o.SkillType.LockPicking, .1),
        u.default.get(e.executor).source(s.Source.Action).type(u.MessageType.Bad).send(r.default.FailedToPickLock)),
        e.setItemsUsed(),
        e.setStaminaReduction(o.SkillType.LockPicking),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect(o.SfxType.Throw, !0)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Move", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "language/dictionary/Message", "multiplayer/IMultiplayer", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.Direction).setUsableBy(n.EntityType.Player).setUsableWhen(i.ActionUsability.Ghost).setHandler((e,t)=>{
        if (multiplayer.addSyncCheck(r.MultiplayerSyncCheck.ActionMove, e.executor.stopNextMovement ? 1 : 0),
        e.executor.stopNextMovement)
            return e.executor.stopNextMovement = !1,
            l.default.get(e.executor).source(s.Source.Action, s.Source.Combat).type(l.MessageType.Bad).send(o.default.TrapStoppedYou),
            e.setPassTurn(),
            void e.setDelay(25);
        const a = game.directionToMovement(t);
        a.x += e.executor.x,
        a.y += e.executor.y,
        e.get(i.ActionType.MoveTo).execute(e.executor, a, t)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/MoveItem", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "item/IItem", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/IMilestone", "player/MessageManager"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemNearby, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Container, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Container, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.ItemType, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.ItemQuality, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t,a,i,c,m)=>{
        let h, y, g = 0, f = 0;
        const T = void 0 !== t && t.isInTradeContainer()
          , S = void 0 !== i && i.containerType === r.ContainerType.Trade;
        let I, v;
        if (i) {
            const e = itemManager.getContainerReference(i);
            v = e.type === r.ContainerReferenceType.Item ? i.getName() : e.type === r.ContainerReferenceType.Doodad ? i.getName() : l.default.message(s.default.YourInventory)
        }
        if (T || S) {
            if (void 0 === t)
                return;
            if (itemManager.isInGroup(t.type, o.ItemTypeGroup.Untradable))
                return void p.default.get(e.executor).source(u.Source.Action, u.Source.Allies, u.Source.Item).send(s.default.WillNotTrade, t.getName());
            if (void 0 === (I = t.getWorth(!0)))
                return;
            if (T && (I = Math.round(1.5 * I)),
            y = T ? t.containedWithin : i,
            void 0 === (h = itemManager.getNPCFromInventoryContainer(y)) || h.isHostile())
                return;
            if (T) {
                const t = h.getProperty(n.Property.Credit).get(e.executor.identifier) || 0;
                if (t < I)
                    return void p.default.get(e.executor).source(u.Source.Action, u.Source.Allies, u.Source.Item).send(s.default.ChatPlayerMessage, h.getName(), l.default.message(s.default.YouNeedMoreCredit).addArgs(I - t))
            }
            g = S ? I + (f = Math.round(I * (e.executor.getSkill(o.SkillType.Bartering) / 100 / 3))) : -1 * I
        }
        if (void 0 !== t && void 0 !== i) {
            const a = itemManager.moveToContainer(e.executor, t, i);
            if (a)
                if (e.setUpdateTablesAndWeight(),
                void 0 !== h && 0 !== g) {
                    S ? (p.default.get(e.executor).source(u.Source.Action, u.Source.Allies, u.Source.Item).send(s.default.ChatPlayerMessage, h.getName(), l.default.message(s.default.ThanksSelling).addArgs(t.getName(), g)),
                    f > 0 && p.default.get(e.executor).source(u.Source.Action).send(s.default.BarteringSkillsProvided, f)) : p.default.get(e.executor).source(u.Source.Action, u.Source.Allies, u.Source.Item).send(s.default.ChatPlayerMessage, h.getName(), l.default.message(s.default.ThanksBuying).addArgs(I, t.getName()));
                    const a = h.getProperty(n.Property.Credit);
                    a.has(e.executor.identifier) && (g += a.get(e.executor.identifier)),
                    a.set(e.executor.identifier, g),
                    ui.refreshContainerName(y),
                    e.executor.skillGain(o.SkillType.Bartering),
                    e.executor.addMilestone(d.MilestoneType.Merchant),
                    e.setPassTurn()
                } else
                    v && p.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.MovedItem, t.getName(), v)
        } else if (void 0 !== a && void 0 !== i) {
            if (a.containerType === r.ContainerType.Trade)
                return;
            const t = itemManager.moveAllFromContainerToContainer(e.executor, a, i, c, m);
            t.length && (e.setUpdateTablesAndWeight(),
            v && c && p.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.MovedItem, itemManager.getItemListTranslation(t), v))
        }
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/MoveTo", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "item/Items", "language/dictionary/Message", "language/dictionary/Note", "mod/IHookManager", "multiplayer/IMultiplayer", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "player/note/Corpse", "tile/Terrains", "utilities/enum/Enums", "utilities/Log", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T) {
    function S(e) {
        e.executor.anim = 1 - e.executor.anim,
        e.setDelay(13, !0),
        e.setUpdateView()
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.Vector2,i.anyOf(i.ActionArgument.Direction, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player).setUsableWhen(i.ActionUsability.Ghost).setHandler((e,t,a=o.Direction.None)=>{
        const n = game.getWrappedCoord(t.x)
          , I = game.getWrappedCoord(t.y)
          , v = game.getTile(n, I, e.executor.z);
        if (v && !1 !== modManager.getHook(u.Hook.OnMove).call(e.executor, n, I, v, a))
            if (e.executor.staminaCheck()) {
                if (e.executor.isMoving = !0,
                e.executor.isMovingClientside = !0,
                e.executor.nextX = e.executor.x,
                e.executor.nextY = e.executor.y,
                !e.executor.isGhost()) {
                    multiplayer.addSyncCheck(d.MultiplayerSyncCheck.ActionMove, "NG");
                    const t = T.default.getType(e.executor.getTile());
                    g.default.isModded(o.TerrainType, t) || e.executor.addMilestone(c.MilestoneType.Explorer, t);
                    const a = v.creature;
                    if (a) {
                        if (e.executor.addDelay(40, !0),
                        game.checkForHiddenMob(e.executor, a.x, a.y, a.z),
                        !a.isTamed() || multiplayer.isConnected() && multiplayer.getOptions().pvp && a.getOwner() !== e.executor)
                            return multiplayer.addSyncCheck(d.MultiplayerSyncCheck.ActionMove, "A1"),
                            e.get(i.ActionType.Attack).execute(e.executor),
                            void e.setPassTurn(o.TurnType.DontEnterCaves);
                        if (!a.canSwapWith(e.executor))
                            return void S(e)
                    }
                    const u = v.npc;
                    if (u) {
                        if (e.executor.addDelay(40, !0),
                        u.isHostile())
                            multiplayer.addSyncCheck(d.MultiplayerSyncCheck.ActionMove, "A2"),
                            e.get(i.ActionType.Attack).execute(e.executor),
                            e.setPassTurn(o.TurnType.DontEnterCaves);
                        else {
                            S(e);
                            const t = u.getActions();
                            void 0 !== t && -1 !== t.indexOf(i.ActionType.Trade) && (e.get(i.ActionType.Trade).execute(e.executor, u),
                            e.executor.notes.write(l.default.Mercantile, u.getName()))
                        }
                        return
                    }
                    const f = T.default.getType(v)
                      , w = y.default[f];
                    if (w && w.gather)
                        return void (e.executor.options.autoGatherHarvest ? (multiplayer.addSyncCheck(d.MultiplayerSyncCheck.ActionMove, "G"),
                        e.get(i.ActionType.Gather).execute(e.executor)) : S(e));
                    if (players.length > 1) {
                        const t = game.getPlayersAtPosition(n, I, e.executor.z, !1, !0);
                        if (t.length > 0) {
                            const a = t[0];
                            return void (multiplayer.isConnected() && multiplayer.getOptions().pvp && !a.isConnecting ? (multiplayer.addSyncCheck(d.MultiplayerSyncCheck.ActionMove, "A3"),
                            e.executor.addDelay(40, !0),
                            e.get(i.ActionType.Attack).execute(e.executor),
                            e.setPassTurn(o.TurnType.DontEnterCaves)) : S(e))
                        }
                    }
                    const M = v.doodad;
                    if (M) {
                        if (M.blocksMove() && e.get(i.ActionType.OpenDoor).execute(e.executor))
                            return void S(e);
                        const t = M.description();
                        if (t) {
                            if (itemManager.isContainer(M))
                                return e.executor.resetMovementStates(),
                                e.get(i.ActionType.OpenContainer).execute(e.executor, M),
                                void S(e);
                            if (t.isLocked) {
                                multiplayer.addSyncCheck(d.MultiplayerSyncCheck.ActionMove, "L");
                                const a = e.executor.getAndSwitchHandToUse();
                                if (void 0 === a)
                                    return m.default.get(e.executor).source(p.Source.Action).send(s.default.ObjectIsLocked),
                                    void S(e);
                                m.default.get(e.executor).source(p.Source.Action).send(s.default.ObjectIsLockedAttemptToBreakIt),
                                M.damage(),
                                e.addSkillGains(o.SkillType.Tactics, .1);
                                const n = e.executor.getEquippedItem(a);
                                return n ? n.damage(i.ActionType[e.type]) : e.executor.hurtHands(s.default.ToDamageAChest) && m.default.get(e.executor).source(p.Source.Action).type(m.MessageType.Bad).send(s.default.HurtHandsHittingWithoutWeapons, M.getName()),
                                e.setStaminaReduction(o.SkillType.Tactics),
                                t.particles && e.setParticle(t.particles, !0),
                                e.executor.addDelay(40, !0),
                                e.executor.checkWeight(),
                                void e.setPassTurn(o.TurnType.CheckUnderPlayer)
                            }
                            if (t.blockMove) {
                                if (e.executor.options.autoGatherHarvest) {
                                    const t = M.getGrowingStage();
                                    if (M.canHarvest())
                                        return multiplayer.addSyncCheck(d.MultiplayerSyncCheck.ActionMove, "H"),
                                        void e.get(i.ActionType.Harvest).execute(e.executor);
                                    if (void 0 !== t && t > o.GrowingStage.Vegetative)
                                        return M.canGather() ? (multiplayer.addSyncCheck(d.MultiplayerSyncCheck.ActionMove, "G"),
                                        void e.get(i.ActionType.Gather).execute(e.executor)) : void S(e)
                                }
                                if (M.blocksMove())
                                    return void S(e)
                            }
                        }
                    }
                    if (h.default(e.executor, v),
                    e.executor.walkSoundCounter++,
                    e.executor.walkSoundCounter >= 4) {
                        e.executor.walkSoundCounter = 0;
                        let t = o.SfxType.Walk;
                        w && (w.shallowWater || w.water) && (t = o.SfxType.Swim),
                        e.setSoundEffect({
                            type: t,
                            noPosition: e.executor.isLocalPlayer()
                        })
                    }
                    w && w.shallowWater && e.setParticle(w.particles, !0),
                    void 0 !== e.executor.raft && (game.items[e.executor.raft].damage("Raft", 1),
                    !w || w.water || w.shallowWater || e.executor.setRaft(void 0));
                    const b = e.executor.getEquippedItems();
                    for (const t of b) {
                        const a = r.itemDescriptions[t.type];
                        if (a) {
                            const i = a.onEquipEffect;
                            i && i[0] === o.OnEquipType.Telescopy && t.damage("T", 1),
                            w && w.water && a.revert && a.isTorch && void 0 === e.executor.raft && (t.changeInto(a.revert),
                            m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(s.default.ExtinguishedTorch))
                        }
                    }
                    a && (a.skipNextUpdate(),
                    a.fromX = a.x,
                    a.fromY = a.y,
                    a.facingDirection = Math.ceil((Math.atan2(e.executor.y - a.y, a.x - e.executor.x) + Math.PI) / (Math.PI / 2)) % 4,
                    a.moveTo(e.executor.x, e.executor.y, e.executor.z))
                }
                e.executor.addDelay(10, !0),
                e.executor.checkWeight(),
                e.executor.facingDirection === a ? (e.executor.nextX = n,
                e.executor.nextY = I,
                e.executor.isLocalPlayer() && ui.onMove(),
                e.setPassTurn(o.TurnType.CheckUnderPlayer),
                multiplayer.addSyncCheck(d.MultiplayerSyncCheck.ActionMove, "E")) : f.default.trace(f.LogSource.ActionManager)("Tried to move in a direction different from facing direction")
            } else
                multiplayer.addSyncCheck(d.MultiplayerSyncCheck.ActionMove, "SC")
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Offer", ["require", "exports", "action/Action", "action/IAction", "creature/Creatures", "entity/IEntity", "entity/IStats", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(o.EntityType.Player).setHandler((e,t)=>{
        e.setDelay(25);
        const a = e.executor.getFacingTile()
          , o = a.creature;
        if (!o)
            return void p.default.get(e.executor).source(d.Source.Action).send(l.default.NotFacingCreatureToOfferThisTo);
        const m = t.description();
        if (m && o) {
            if (!o.isTamed() && o.hasStat(r.Stat.Happiness) && o.getStat(r.Stat.Happiness).value >= 0)
                return void p.default.get(e.executor).source(d.Source.Action, d.Source.Creature).send(l.default.RefusedToBeTamed, o.getName());
            const a = o.aberrant
              , m = n.default[o.type];
            let h = l.default.CreatureAppeased, y = p.MessageType.None, g;
            if (m && m.acceptedItems) {
                if (void 0 !== (g = o.offer([t])) && a) {
                    const a = o.getStatValue(r.Stat.Tamed)
                      , i = c.default.percent() - Math.floor(e.executor.getSkill(s.SkillType.Taming) / 7.5) - (a || 1);
                    if (i >= 50)
                        return p.default.get(e.executor).source(d.Source.Action, d.Source.Creature).type(p.MessageType.Bad).send(o.isTamed() ? l.default.OfferAberrantFailButTamed : l.default.OfferAberrantFail, o.getName()),
                        e.setPassTurn(),
                        e.addSkillGains(s.SkillType.Taming),
                        o.queueSoundEffect(s.SfxType.CreatureNoise),
                        void itemManager.remove(t)
                }
                void 0 !== g && (e.addSkillGains(s.SkillType.Taming),
                o.queueSoundEffect(s.SfxType.CreatureNoise),
                o.isTamed() ? (o.increaseTamedCount(),
                o.setStat(r.Stat.Happiness, creatureManager.getHappinessLevel(e.executor, o))) : o.tame(e.executor),
                itemManager.remove(t))
            }
            void 0 === g && (h = l.default.CreatureAngered,
            y = p.MessageType.Bad,
            o.queueSoundEffect(s.SfxType.CreatureHit),
            e.get(i.ActionType.Drop).execute(e.executor, t)),
            p.default.get(e.executor).source(d.Source.Action, d.Source.Allies, d.Source.Creature, d.Source.Item).type(y).send(l.default.YouOfferedToCreature, t.getName(), o.getName(), u.default.message(h)),
            e.setStaminaReduction(s.SkillType.Taming),
            void 0 !== g && e.setPassTurn()
        } else
            e.get(i.ActionType.Drop).execute(e.executor, t)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/OpenBottle", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        e.setDelay(25);
        const a = u.default.int(5);
        let i;
        switch (a) {
        case 1:
            i = o.ItemType.TatteredMap;
            break;
        case 2:
            i = o.ItemType.OldInstructionalScroll;
            break;
        case 3:
            i = o.ItemType.OldEducationalScroll;
            break;
        case 4:
            i = o.ItemType.PaperSheet;
            break;
        default:
            i = o.ItemType.RefinedSand
        }
        if (i) {
            const t = e.executor.createItemInInventory(i);
            l.default.get(e.executor).source(s.Source.Action, s.Source.Item).send(r.default.DiscoveredInTheBottle, t.getName())
        } else
            e.setSoundEffect(o.SfxType.Fail),
            l.default.get(e.executor).source(s.Source.Action, s.Source.Item).type(l.MessageType.Bad).send(r.default.PaperTurnedToMush);
        e.executor.createItemInInventory(o.ItemType.GlassBottle, t.quality),
        itemManager.remove(t),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setReputationChange(25)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Paddle", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player).setHandler((e,t)=>{
        if (e.setDelay(25),
        e.executor.raft)
            e.executor.setRaft(void 0);
        else {
            const a = l.default[u.default.getType(e.executor.getTile())]
              , n = l.default[u.default.getType(e.executor.getFacingTile())];
            let d = !0;
            if (a && (a.water || a.shallowWater) && (d = !1),
            d && n && (n.water || n.shallowWater)) {
                d = !1;
                const t = game.directionToMovement(e.executor.facingDirection);
                t.x += e.executor.x,
                t.y += e.executor.y,
                e.get(i.ActionType.MoveTo).execute(e.executor, t, e.executor.facingDirection)
            }
            if (d)
                return void s.default.get(e.executor).source(r.Source.Action).send(o.default.NeedWaterForRaft);
            e.executor.setRaft(t.id)
        }
        e.setPassTurn()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Pet", ["require", "exports", "action/Action", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = (new a.Action).setUsableBy(i.EntityType.Player, i.EntityType.NPC).setHandler(e=>{
        const t = e.executor.getFacingTile();
        if (!t)
            return;
        const a = t.creature;
        void 0 !== a && (e.setDelay(25),
        a.pet() && (a.queueSoundEffect(n.SfxType.CreatureNoise),
        s.default.get(e.executor).source(r.Source.Action, r.Source.Allies, r.Source.Creature).send(o.default.PetCreature, a.getName())))
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Pickup", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "mod/IHookManager", "player/IMessageManager", "player/MessageManager", "tile/ITileEvent", "tile/Terrains", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemInventory, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        const a = e.executor.getFacingTile()
          , n = h.default.getType(a)
          , y = m.default[n];
        if (!y)
            return;
        const g = a.doodad;
        if (!g)
            return;
        const f = g.description();
        if (!f)
            return;
        if (!g.canPickup(e.executor))
            return;
        const T = g.getPickupTypes();
        if (!T)
            return;
        if (e.setDelay(25),
        itemManager.isContainer(g) && g.containedItems.length > 0 || f && f.isLocked)
            return void p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(s.default.CannotPickUpWithItemsInside, g.getName());
        if (f.blockDig)
            return void p.default.get(e.executor).source(d.Source.Action).send(s.default.CannotPickUpWhileLit, g.getName());
        if (g.gatherReady || void 0 !== g.decay && g.decay > 0 && f && f.isWaterSource)
            return void p.default.get(e.executor).source(d.Source.Action).send(s.default.CannotPickupWhenFull, g.getName());
        if (tileEventManager.get(a, c.TileEventType.TumblingTumbleweed))
            return void p.default.get(e.executor).source(d.Source.Action).send(s.default.IsInTheWayOfPickingUp, l.default.nameOf(r.Dictionary.TileEvent, c.TileEventType.TumblingTumbleweed), g.getName());
        if (a.corpses)
            return void p.default.get(e.executor).source(d.Source.Action).send(s.default.IsInTheWayOfPickingUp, corpseManager.getCorpseListTranslation(a.corpses), g.getName());
        if (game.isPlayerAtTile(a)) {
            const t = game.getPlayersAtTile(a);
            if (t.length > 0 !== void 0)
                for (const a of t)
                    return void p.default.get(e.executor).source(d.Source.Action).send(s.default.IsInTheWayOfPickingUp, a.getName(), g.getName())
        } else
            tileEventManager.get(a, c.TileEventType.Fire) && !t && e.executor.burn(!1, !0, o.EquipType.Hands);
        itemManager.isContainer(g) && ui.closeContainer(g);
        let S = 13;
        f.gatherCanHurtHands && (t || e.executor.hurtHands(s.default.Gather, s.default.Gathering)),
        e.setItemsUsed();
        for (const t of T) {
            let a;
            if (f.isLitTorch || f.isUnlitTorch) {
                if ((a = e.executor.createItemInInventory(T[0], g.quality)).decay = g.decay,
                !f.lit && void 0 !== g.decay) {
                    a.decay = g.decay;
                    const t = e.executor.getEquippedItem(o.EquipType.RightHand);
                    if (void 0 === t)
                        e.executor.equip(a, o.EquipType.RightHand, !0);
                    else {
                        const i = e.executor.getEquippedItem(o.EquipType.LeftHand);
                        void 0 === i ? e.executor.equip(a, o.EquipType.LeftHand, !0) : void 0 !== t && (e.executor.unequip(t, !0),
                        e.executor.equip(a, o.EquipType.RightHand, !0))
                    }
                }
            } else
                a = e.executor.createItemInInventory(t, g.quality);
            if (void 0 !== g.hitchedCreature) {
                const e = game.creatures[g.hitchedCreature];
                e && (e.hitchedTo = void 0)
            }
            void 0 !== g.weight && 1 === T.length && (a.weight = g.weight),
            a.revertFromDoodad(g),
            f.reduceDurabilityOnGather && (a.minDur = g.minDur,
            a.maxDur = g.maxDur,
            a.damage(i.ActionType[e.type])),
            p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(s.default.YouPickedUp, a.getName()),
            S += 4
        }
        modManager.getHook(u.Hook.OnPickupDoodad).call(e.executor, g),
        doodadManager.remove(g),
        e.setDelay(S),
        e.setPassTurn(),
        e.setStaminaReduction(void 0 !== f.skillUse ? f.skillUse : o.SkillType.Mining),
        e.setUpdateTablesAndWeight(),
        e.setParticle(y.particles, !0),
        e.setSoundEffect(o.SfxType.PickUp, !0)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/PickupAllItems", ["require", "exports", "action/Action", "entity/IEntity", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = (new a.Action).setUsableBy(i.EntityType.Player, i.EntityType.NPC).setHandler(e=>{
        const t = e.executor.getFacingTile()
          , a = t
          , i = a.containedItems;
        let s = 25;
        if (i && i.length > 0) {
            const t = itemManager.moveAllFromContainerToContainer(e.executor, a, e.executor.inventory, void 0, void 0, !1);
            s += 4 * t.length,
            t.length > 0 && r.default.get(e.executor).source(o.Source.Action, o.Source.Item).send(n.default.YouPickedUp, itemManager.getItemListTranslation(t))
        }
        e.executor.checkUnder(!0, !1),
        e.setDelay(s),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("action/actions/PickupItem", ["require", "exports", "action/Action", "entity/IEntity"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = (new a.Action).setUsableBy(i.EntityType.Player, i.EntityType.NPC).setHandler(e=>{
        e.executor.checkUnder(!0, !0),
        e.setDelay(13),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Plant", ["require", "exports", "action/Action", "action/IAction", "doodad/Doodads", "entity/IEntity", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Note", "language/Translation", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "player/note/NoteManager", "tile/Terrains", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        const a = e.executor.getFacingTile()
          , o = t.description()
          , T = o ? o.onUse : void 0;
        if (!T)
            return;
        e.setDelay(25);
        const S = T[i.ActionType.Plant]
          , I = n.default[S];
        if (void 0 !== t.minDur && t.minDur > 0 && I) {
            const n = f.default.getType(a)
              , o = y.default[n]
              , {x: S, y: v, z: w} = e.executor.getFacingPoint();
            if (!game.isPositionEmpty(S, v, w) || game.isPlayerAtPosition(S, v, w))
                return m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(l.default.SomethingInTheWayOfPlanting, t.getName()),
                void game.checkForHiddenMob(e.executor, S, v, w);
            if (!I.allowedTiles)
                return;
            const M = I.allowedTiles.length;
            for (let y = 0; y < M; y++)
                if (f.default.getType(a) === I.allowedTiles[y]) {
                    if (!f.default.isTilled(a) && o)
                        return void m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(l.default.CannotPlantHereTilled, t.getName(), new d.default(s.Dictionary.Terrain,n));
                    const y = g.default.percent(75);
                    if (e.executor.getSkill(r.SkillType.Gardening) >= y) {
                        let a;
                        a = T[i.ActionType.Plant];
                        const n = doodadManager.create(a, S, v, w);
                        n && (n.minDur = t.minDur,
                        n.maxDur = t.maxDur,
                        n.quality = t.quality,
                        n.setGrowingStage(r.GrowingStage.Germinating, !0),
                        n.decay && (n.decay -= Math.ceil(n.decay * (e.executor.getSkill(I.skillUse ? I.skillUse : r.SkillType.Gardening) / 100 / 2))),
                        game.packGround(S, v, w),
                        m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(l.default.PlantedInGround, t.getName()),
                        e.addSkillGains(r.SkillType.Gardening),
                        itemManager.remove(t),
                        e.setReputationChange(75),
                        e.executor.addMilestone(c.MilestoneType.Gardener),
                        e.setSoundEffect({
                            type: r.SfxType.PickUp,
                            inFront: !0
                        }))
                    } else
                        e.addSkillGains(r.SkillType.Gardening, .1),
                        e.setItemsUsed(),
                        e.setSoundEffect({
                            type: r.SfxType.Trample,
                            inFront: !0
                        }),
                        m.default.get(e.executor).source(p.Source.Action, p.Source.Item).type(m.MessageType.Bad).send(l.default.FailedToPlant, t.getName());
                    return h.default.get(e.executor).write(u.default.Gardening, d.default.message(l.default.Planting)),
                    o && e.setParticle({
                        color: o.particles,
                        inFront: !0
                    }),
                    e.setStaminaReduction(r.SkillType.Gardening),
                    e.setUpdateTablesAndWeight(),
                    void e.setPassTurn()
                }
            m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(l.default.NotSuitableToPlant, t.getName(), new d.default(s.Dictionary.Terrain,n))
        } else
            m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(l.default.TooDamaged, t.getName(), d.default.message(l.default.Plant))
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Pour", ["require", "exports", "action/Action", "action/IAction", "doodad/Doodads", "entity/IEntity", "Enums", "game/IGame", "item/Items", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "tile/ITileEvent", "tile/Terrains", "utilities/Random", "utilities/TileHelpers", "utilities/TilePosition"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        e.setDelay(25);
        const a = l.default[t.type]
          , i = a ? a.returnOnUse : void 0
          , v = itemManager.isInGroup(t.type, r.ItemTypeGroup.Milk);
        let w = !1;
        const M = e.executor.getFacingTile()
          , b = S.default.getType(M)
          , k = tileEventManager.get(M, g.TileEventType.Fire);
        k && (m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(u.default.ExtinguishedFire),
        w = !0,
        tileEventManager.remove(k),
        e.setReputationChange(25));
        const {x: C, y: D, z: A} = e.executor.getFacingPoint()
          , P = game.getPlayersAtTile(M);
        if (void 0 !== M.creature) {
            const a = M.creature;
            if (a.type === r.CreatureType.FireElemental) {
                m.default.get(e.executor).source(p.Source.Action, p.Source.Creature, p.Source.Item).send(u.default.DamagedByPouring, a.getName(), d.default.message(v ? u.default.Milk : u.default.Water));
                const i = T.default.intInRange(12, 16);
                a.damage({
                    human: e.executor,
                    amount: i,
                    type: r.DamageType.True,
                    weaponName: t.getName()
                }),
                w = !0
            }
        } else if (P.length > 0) {
            const t = P[0];
            t.hasStatus(r.StatusType.Burned) && (t.setStatus(r.StatusType.Burned, !1, o.StatusEffectChangeReason.Treated),
            t.hasStatus(r.StatusType.Burned) || (t.addMilestone(c.MilestoneType.Doctor, r.StatusType.Burned),
            m.default.get(e.executor).source(p.Source.Action, p.Source.Wellbeing, p.Source.Allies).send(u.default.SoothedTheirBurnInjuries)),
            w = !0)
        } else if (M.doodad) {
            const a = M.doodad
              , i = a.description()
              , o = game.wellData[I.getTileId(C, D, A)];
            if (i && void 0 !== a.decay && a.x === C && a.y === D) {
                if (i.isWaterSource && !v)
                    if (-1 !== a.decay || a.gatherReady) {
                        if (!k)
                            return void m.default.get(e.executor).source(p.Source.Action).send(u.default.AlreadyWaterInStill)
                    } else {
                        const t = i.lit;
                        if (t) {
                            const e = n.default[t];
                            e && e.waterStill && (a.decay = 1)
                        } else
                            a.decay = 400;
                        m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(u.default.PouredWaterIntoStill),
                        w = !0
                    }
                else if (i.providesFire) {
                    k || m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(u.default.ExtinguishedFire),
                    w = !0;
                    const t = i.revert;
                    t && (i.waterStill && a.decay >= 0 ? a.decay = 1 : i.isLitTorch || (a.decay = -1),
                    a.changeType(t),
                    world.updateTile(a.x, a.y, a.z, M))
                } else if (i.canGrow) {
                    let i = 0;
                    if (itemManager.isInGroup(t.type, r.ItemTypeGroup.ContainerOfSeawater))
                        i = -75,
                        m.default.get(e.executor).source(p.Source.Action, p.Source.Item).type(m.MessageType.Bad).send(u.default.PourHarmedPlant, t.getName(), a.getName()),
                        void 0 !== a.spread && a.spread >= 1 && a.spread--,
                        a.decay += 120;
                    else {
                        v && a.increaseFertility() && (m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(u.default.PourIncreasedFertility, a.getName(), d.default.message(u.default.Milk)),
                        i += 25),
                        a.minDur && a.maxDur && a.minDur < a.maxDur && (a.minDur++,
                        m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(u.default.PourHealedPlant, a.getName(), d.default.message(a.minDur === a.maxDur ? u.default.PourHealedPlantFully : u.default.PourHealedPlantPartially), d.default.message(v ? u.default.Milk : u.default.Water)),
                        i += 25);
                        const t = a.getGrowingStage();
                        void 0 !== t && t < r.GrowingStage.Ripening && (a.decay -= 40 + Math.floor(e.executor.getSkill(r.SkillType.Gardening) / 5),
                        a.decay < 0 && (a.decay = 0),
                        m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(u.default.HelpGrow, d.default.message(v ? u.default.Milk : u.default.Water), a.getName()),
                        i = 75)
                    }
                    0 !== i ? (e.setReputationChange(i),
                    w = !0,
                    i > 0 && e.addSkillGains(r.SkillType.Gardening)) : m.default.get(e.executor).source(p.Source.Action).send(u.default.HasNoEffect, d.default.message(v ? u.default.Milk : u.default.Water), a.getName())
                }
            } else if (i && i.group === r.DoodadTypeGroup.Well && o) {
                if (o.quantity >= 20 || -1 === o.quantity)
                    return void m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(u.default.WellIsFull);
                0 === o.quantity && o.waterType === s.WaterType.Seawater && itemManager.isInGroup(t.type, r.ItemTypeGroup.ContainerOfSeawater) && (o.waterType = s.WaterType.FreshWater),
                o.quantity++,
                itemManager.isInGroup(t.type, r.ItemTypeGroup.ContainerOfSeawater) && (o.waterType = s.WaterType.Seawater)
            }
        } else
            b !== r.TerrainType.Lava && b !== r.TerrainType.CoolingLava || (b === r.TerrainType.Lava ? (m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(u.default.YouCooledLava),
            game.changeTile(r.TerrainType.CoolingLava, C, D, A, !1)) : (m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(u.default.YouHardenedCooledLava),
            game.changeTile(r.TerrainType.Obsidian, C, D, A, !1)));
        w || m.default.get(e.executor).source(p.Source.Action, p.Source.Item).send(u.default.PouredOut, d.default.message(v ? u.default.Milk : u.default.Water)),
        e.setParticle({
            color: v ? y.default[h.ParticleType.Milk] : f.default[r.TerrainType.Seawater].particles,
            inFront: !0
        }),
        i ? (t.changeInto(i[0]),
        e.setItemsUsed()) : itemManager.remove(t),
        game.checkForHiddenMob(e.executor, C, D, A),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect({
            type: r.SfxType.Water,
            inFront: !0
        })
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/PourOnYourself", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "tile/Terrains"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        e.setDelay(25);
        const a = itemManager.isInGroup(t.type, o.ItemTypeGroup.Milk);
        d.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(r.default.PouredOutOnYourself, s.default.message(a ? r.default.Milk : r.default.Water)),
        e.executor.hasStatus(o.StatusType.Burned) && (e.executor.setStatus(o.StatusType.Burned, !1, n.StatusEffectChangeReason.Treated),
        e.executor.hasStatus(o.StatusType.Burned) || (e.executor.addMilestone(u.MilestoneType.Doctor, o.StatusType.Burned),
        d.default.get(e.executor).source(l.Source.Action, l.Source.Wellbeing).send(r.default.SoothedYourBurnInjuries))),
        e.setParticle(a ? c.default[p.ParticleType.Milk] : m.default[o.TerrainType.Seawater].particles);
        const i = t.description()
          , h = i ? i.returnOnUse : void 0;
        h ? (t.changeInto(h[0]),
        e.setItemsUsed()) : itemManager.remove(t),
        e.addSkillGains(o.SkillType.Anatomy),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect(o.SfxType.Water)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Preserve", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "item/Items", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby,i.anyOf(i.ActionArgument.ItemNearby, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t,a)=>{
        if (e.setDelay(25),
        !a) {
            const t = e.executor.getFacingTile()
              , i = t;
            i.containedItems && i.containedItems.length > 0 && (a = i.containedItems[i.containedItems.length - 1])
        }
        if (!a)
            return void d.default.get(e.executor).source(u.Source.Action).send(s.default.NotFacingValidItem, l.default.message(s.default.Preservation));
        const n = r.itemDescriptions[a.type];
        if (n && n.decayMax && n.use && -1 !== n.use.indexOf(i.ActionType.Eat) && -1 === n.use.indexOf(i.ActionType.Preserve)) {
            if (void 0 !== a.decay && a.decay > 2 * n.decayMax)
                return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.AlreadyPreserved, a.getName());
            const i = p.default.percent(20);
            let r = o.SkillType.Cooking;
            return n.recipe && void 0 !== n.recipe.skill && (r = n.recipe.skill),
            e.setPassTurn(),
            e.setUpdateTablesAndWeight(),
            e.setStaminaReduction(r),
            void (e.executor.getSkill(r) >= i ? (a.decay = 2 * n.decayMax + (p.default.int(500) - 250),
            ui.updateItem(a),
            itemManager.remove(t),
            e.setReputationChange(25),
            e.addSkillGains(r),
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.PreservedFood),
            e.setSoundEffect(o.SfxType.Craft)) : (e.setItemsUsed(),
            e.addSkillGains(r, .1),
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).type(d.MessageType.Bad).send(s.default.FailedToPreserve),
            e.setSoundEffect(o.SfxType.Fail)))
        }
        d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.CannotBePreserved, a.getName())
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Read", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "mod/IHookManager", "player/IMessageManager", "player/MessageManager", "utilities/math/Math2", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        e.setDelay(25);
        const a = t.renamed;
        delete t.renamed;
        const i = t.getName(!1);
        if (t.renamed = a,
        void 0 !== t.book) {
            if (t.book > o.BookType.RandomEvent) {
                const a = new l.default(r.Dictionary.Book,t.book);
                t.renamed || (t.renamed = a.serialize()),
                modManager.getHook(u.Hook.OnOpenBook).call(e.executor, t.book),
                p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(s.default.BookOpen, i, a)
            } else {
                const a = m.default.int(3);
                if (1 === a)
                    p.default.get(e.executor).source(d.Source.Action, d.Source.Item).type(p.MessageType.Bad).send(s.default.BookCrumbles, i),
                    itemManager.remove(t),
                    e.setUpdateTablesAndWeight();
                else if (2 === a)
                    p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(s.default.BookEmpty, i);
                else {
                    const a = itemManager.getWeight(t.type, o.WeightType.Min);
                    if (t.weight < a + .2)
                        p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(s.default.BookEmpty, i);
                    else {
                        const n = m.default.int(3) + 1
                          , u = [o.ItemType.TatteredMap, o.ItemType.OldInstructionalScroll, o.ItemType.OldEducationalScroll]
                          , h = [s.default.BookBlank, s.default.BookDiagrams, s.default.BookScribbles]
                          , y = m.default.getElement(u)
                          , g = m.default.getElement(h);
                        let f = 0;
                        for (let i = 0; i < n; i++) {
                            const i = e.executor.createItemInInventory(y);
                            if (f++,
                            t.weight - i.weight < a + .2) {
                                t.weight = c.default.roundNumber(t.weight - i.weight, 1);
                                break
                            }
                            t.weight = c.default.roundNumber(t.weight - i.weight, 1)
                        }
                        p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(s.default.BookContains, i, l.default.ofNumber(f), l.default.nameOf(r.Dictionary.Item, y, f, !1), l.default.message(g)),
                        e.setUpdateTablesAndWeight()
                    }
                }
                t.book = void 0
            }
            e.setSoundEffect({
                type: o.SfxType.PickUp,
                inFront: !0
            }),
            e.setPassTurn()
        } else
            p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(s.default.BookNothing, i)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Reinforce", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "item/Items", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby,i.anyOf(i.ActionArgument.ItemNearby, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t,a)=>{
        if (e.setDelay(25),
        !a) {
            const t = e.executor.getFacingTile()
              , i = t;
            if (i.containedItems)
                for (let e = 0; e < i.containedItems.length; e++) {
                    const t = i.containedItems[e]
                      , n = r.default[t.type];
                    if (n && n.durability) {
                        a = t;
                        break
                    }
                }
        }
        if (a && void 0 !== a.minDur && void 0 !== a.maxDur) {
            const i = r.default[a.type];
            if (i && i.durability) {
                let n = 4;
                if (a.quality === o.ItemQuality.Remarkable ? n = 3 : a.quality === o.ItemQuality.Exceptional ? n = 2 : a.quality === o.ItemQuality.Legendary && (n = 1),
                a.maxDur + 25 >= 10 * i.durability / n + 125)
                    return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.NoRoomForImprovement, a.getName());
                const l = p.default.percent(20);
                let c = o.SkillType.Tinkering;
                const m = i.recipe;
                if (m && m.skill && (c = m.skill),
                i.inheritWeight) {
                    const e = r.default[i.inheritWeight];
                    e && e.recipe && e.recipe.skill && (c = e.recipe.skill)
                }
                if (e.executor.getSkill(c) >= l) {
                    const i = 10 + p.default.int(10);
                    a.maxDur += i,
                    e.addSkillGains(c),
                    a.minDur += Math.floor(i / 2),
                    a.minDur > a.maxDur && (a.minDur = a.maxDur),
                    d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.Reinforce, a.getName()),
                    e.setSoundEffect(o.SfxType.Craft),
                    itemManager.remove(t),
                    ui.updateItem(a)
                } else
                    e.addSkillGains(c, .1),
                    d.default.get(e.executor).source(u.Source.Action, u.Source.Item).type(d.MessageType.Bad).send(s.default.FailedToReinforce, a.getName()),
                    e.setItemsUsed(),
                    e.setSoundEffect(o.SfxType.Fail);
                e.setReputationChange(-25),
                e.setStaminaReduction(c),
                e.setUpdateTablesAndWeight(),
                e.setPassTurn()
            } else
                d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.CannotBeReinforced, a.getName())
        } else
            d.default.get(e.executor).source(u.Source.Action).send(s.default.NotFacingValidItem, l.default.message(s.default.Reinforcement))
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Release", ["require", "exports", "action/Action", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = (new a.Action).setUsableBy(i.EntityType.Player).setHandler(e=>{
        const t = e.executor.getFacingTile();
        if (!t)
            return;
        const a = t.creature;
        void 0 !== a && e.executor.hasTamedCreature(a) && (e.setDelay(25),
        a.release(),
        e.setPassTurn(),
        a.queueSoundEffect(n.SfxType.CreatureNoise),
        s.default.get(e.executor).source(r.Source.Action, r.Source.Allies, r.Source.Creature).send(o.default.YouHaveReleased, a.getName()))
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Rename", ["require", "exports", "action/Action", "action/IAction", "creature/Creature", "entity/IEntity", "language/dictionary/Message", "language/Translation"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemNearby, i.ActionArgument.Doodad, i.ActionArgument.Creature),i.ActionArgument.String).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setHandler((e,t,a)=>{
        if (!(t instanceof n.default) || t.isTamed())
            if (e.setDelay(25),
            void 0 !== a && a.length > 0) {
                if (t.renamed = a,
                !(t instanceof n.default) && itemManager.isContainer(t) && ui.isContainerOpen(t)) {
                    const e = t.getName().inContext(3).getString();
                    ui.openContainer(t, `${e} (${s.default.message(r.default.Container)})`)
                }
            } else
                delete t.renamed
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Repair", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "item/Items", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby,i.anyOf(i.ActionArgument.ItemNearby, i.ActionArgument.Doodad, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t,a)=>{
        e.setDelay(25);
        const i = e.executor.getTile()
          , n = p.default[m.default.getType(i)];
        if (n && n.water)
            return void d.default.get(e.executor).source(u.Source.Action).send(s.default.CannotInWater, l.default.message(s.default.Repair));
        let h = !0, y, g, f;
        if (!a) {
            const t = e.executor.getFacingTile()
              , i = t;
            if (i.containedItems)
                for (let e = 0; e < i.containedItems.length; e++) {
                    const t = i.containedItems[e]
                      , n = r.default[t.type];
                    if (n && n.durability && void 0 !== t.minDur && void 0 !== t.maxDur && t.minDur < t.maxDur && !1 !== n.repairable) {
                        a = t,
                        h = !0;
                        break
                    }
                }
            const n = t.doodad;
            n && (a = n,
            h = !1)
        }
        if (void 0 === a || void 0 === a.minDur || void 0 === a.maxDur)
            return void d.default.get(e.executor).source(u.Source.Action).send(s.default.NotFacingValidItem, l.default.message(s.default.Repair));
        if (h ? (y = r.default[a.type],
        f = a.type) : (g = a.description()) && g.repairItem && (y = r.default[g.repairItem],
        f = g.repairItem),
        f) {
            const t = itemManager.hasAdditionalRequirements(e.executor, f, s.default.Repair, !0, !0);
            if (!t.requirementsMet)
                return;
            t.isLava && game.doLavaEvents(t.x, t.y, t.z)
        }
        if (y && !y.durability)
            return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.CannotBeRepaired, a.getName());
        if (a.minDur >= a.maxDur)
            return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.AlreadyFullyRepaired, a.getName());
        if (g && g.providesFire)
            return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.CannotRepairWhileLit, a.getName());
        const T = c.default.percent(20);
        let S = o.SkillType.Tinkering;
        if (y) {
            const e = y.recipe;
            e && e.skill && (S = e.skill)
        }
        if (e.executor.getSkill(S) >= T) {
            let t = Math.floor((a.maxDur - a.minDur) / 3);
            if (t <= 0 && (t = 1),
            a.maxDur -= t,
            a.maxDur <= 1)
                return h ? itemManager.remove(a) : doodadManager.remove(a),
                d.default.get(e.executor).source(u.Source.Action, u.Source.Item).type(d.MessageType.Bad).send(s.default.BrokeIntoPieces, a.getName()),
                e.setItemsUsed(),
                e.setStaminaReduction(S),
                e.setPassTurn(),
                e.setUpdateTablesAndWeight(),
                void e.setSoundEffect(o.SfxType.Fail);
            e.addSkillGains(S),
            a.minDur = a.maxDur,
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.YouRepair, a.getName()),
            e.setSoundEffect(o.SfxType.Craft),
            h && a && ui.updateItem(a)
        } else
            e.addSkillGains(S, .1),
            d.default.get(e.executor).source(u.Source.Action, u.Source.Item).type(d.MessageType.Bad).send(s.default.FailedToRepair, a.getName()),
            e.setSoundEffect(o.SfxType.Fail);
        e.setItemsUsed(),
        e.setStaminaReduction(S),
        e.setUpdateTablesAndWeight(),
        e.setPassTurn()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Rest", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "entity/IStats", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "tile/ITileEvent", "tile/Terrains", "utilities/Async", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemNearby, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Doodad, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.RestType, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player).setUsableWhen(i.ActionUsability.Resting).setHandler((e,t,a,n,f)=>{
        if (e.type === i.ActionType.Sleep ? n = r.RestType.Sleeping : void 0 === n && (n = r.RestType.Resting),
        e.setDelay(25),
        f)
            return void e.executor.cancelResting(r.RestCancelReason.Canceled);
        if (e.executor.isResting())
            return;
        const T = g.default.getType(a ? a.getTile() : e.executor.getTile())
          , S = m.default[T]
          , I = !(!a || a.getTile() !== e.executor.getTile());
        if (S && S.noResting || a && !I && game.getPlayersAtTile(a.getTile()).length > 0)
            return void p.default.get(e.executor).source(d.Source.Action).send(n === r.RestType.Resting ? l.default.CannotRestHere : l.default.CannotSleepHere);
        const v = e.executor.getStat(o.Stat.Stamina)
          , w = e.executor.getStat(o.Stat.Health)
          , M = e.executor.getStat(o.Stat.Hunger)
          , b = e.executor.getStat(o.Stat.Thirst);
        if (n === r.RestType.Resting && v.value === v.max)
            return void p.default.get(e.executor).source(d.Source.Action, d.Source.Wellbeing).send(l.default.StaminaIsFull);
        w.changeTimer = 0,
        v.changeTimer = 0,
        M.changeTimer = 0,
        b.changeTimer = 0,
        p.default.get(e.executor).source(d.Source.Action).send(n === r.RestType.Resting ? l.default.YouBeginResting : l.default.BeginSleeping);
        let k = Math.ceil(15 * e.executor.getSkill(r.SkillType.Camping));
        n === r.RestType.Sleeping && (game.time.isNight() || e.executor.z === r.WorldZ.Cave) && (k += 500);
        let C = 2;
        void 0 === t && void 0 === a || (C = 1),
        a && !I && e.executor.setPosition(a);
        let D = 2;
        if (n === r.RestType.Sleeping) {
            let t = !1;
            for (let a = -1; a <= 1 && !t; a++)
                for (let i = -1; i <= 1; i++) {
                    const n = game.getTile(e.executor.x + a, e.executor.y + i, e.executor.z);
                    if (game.isOnFire(n) !== r.FireType.None) {
                        D = 1,
                        k *= 2,
                        p.default.get(e.executor).source(d.Source.Action, d.Source.Wellbeing).send(l.default.FireAroundYouIsWarm),
                        t = !0;
                        break
                    }
                }
        }
        S && S.reduceRest && (k = Math.floor(k / 2),
        p.default.get(e.executor).source(d.Source.Action, d.Source.Wellbeing).type(p.MessageType.Bad).send(l.default.ReduceLength, u.default.message(n === r.RestType.Sleeping ? l.default.Sleeping : l.default.Resting), new u.default(s.Dictionary.Terrain,T), u.default.message(n === r.RestType.Sleeping ? l.default.Sleep : l.default.Rest))),
        k < 100 ? k = 100 : k > 1600 && (k = 1600),
        k += y.default.int(50),
        k -= 25,
        e.executor.setStatChangeTimerIgnoreDifficultyOptions(v, 1 + D + C + (n === r.RestType.Sleeping ? 0 : 1), 1 + Math.floor(e.executor.getStatMax(o.Stat.Stamina) / 100 / (n === r.RestType.Sleeping ? 1 : 2))),
        n === r.RestType.Sleeping && (e.executor.setStatChangeTimerIgnoreDifficultyOptions(w, 40 + (D + 2 * C), 1),
        e.executor.setStatChangeTimerIgnoreDifficultyOptions(M, 220, -1),
        e.executor.setStatChangeTimerIgnoreDifficultyOptions(b, 160, -1)),
        e.executor.queueSoundEffect(r.SfxType.PickUp),
        e.executor.addDelay(40, !0),
        e.executor.resetMovementStates();
        const A = [r.EquipType.LeftHand, r.EquipType.RightHand];
        for (const t of A) {
            const a = e.executor.getEquippedItem(t);
            if (a && itemManager.isInGroup(a.type, r.ItemTypeGroup.LitTorch)) {
                let t = [[e.executor.x + 1, e.executor.y], [e.executor.x - 1, e.executor.y], [e.executor.x, e.executor.y + 1], [e.executor.x, e.executor.y - 1], [e.executor.x, e.executor.y]];
                t = y.default.shuffle(t);
                for (const a of t)
                    if (game.isFlammable(a[0], a[1], e.executor.z)) {
                        tileEventManager.create(c.TileEventType.Fire, a[0], a[1], e.executor.z),
                        p.default.get(e.executor).source(d.Source.Action, d.Source.Equipment, d.Source.Item).type(p.MessageType.Bad).send(l.default.YouDropTheTorch);
                        break
                    }
                const i = a.description();
                i && i.revert && (a.changeInto(i.revert),
                e.executor.calculateEquipmentStats(),
                e.setSoundEffect(r.SfxType.Trample),
                e.setUpdateTablesAndWeight())
            }
        }
        e.executor.startResting({
            type: n,
            totalCycles: k,
            startHealth: w.value,
            itemId: t ? t.id : void 0,
            doodadId: a ? a.id : void 0
        }),
        e.executor.spawnPoint = {
            x: e.executor.x,
            y: e.executor.y,
            z: e.executor.z
        },
        e.executor.skillGain(r.SkillType.Camping),
        game.isRealTimeMode() || setTimeout(async()=>{
            for (; e.executor.isResting(); )
                e.executor.tick(),
                e.executor.restData && e.executor.restData.type === r.RestType.Resting && await h.sleep(500)
        }
        , 800)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Rub", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "entity/IStats", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        let a, c;
        e.setDelay(25);
        const m = e.executor.getStat(o.Stat.Malignity)
          , h = e.executor.getStat(o.Stat.Benignity);
        if (e.type === i.ActionType.RubClockwise) {
            if (0 === h.value)
                return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.YourRubbingNoEffect);
            e.executor.reduceStat(h, 5e3 + p.default.int(2e3), n.IStatChangeInfo.get(!0)),
            h.value < 0 && e.executor.setStat(h, 0),
            a = s.default.Clockwise,
            c = s.default.Negatively
        } else {
            if (0 === m.value)
                return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.YourRubbingNoEffect);
            e.executor.reduceStat(m, 5e3 + p.default.int(2e3), n.IStatChangeInfo.get(!0)),
            m.value < 0 && e.executor.setStat(m, 0),
            a = s.default.Counterclockwise,
            c = s.default.Positively
        }
        d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(s.default.YouRub, t.getName(), l.default.message(a), l.default.message(c)),
        itemManager.remove(t),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect(r.SfxType.Exceptional)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/SetDown", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        if (void 0 === t.minDur)
            return;
        const a = e.executor.getFacingTile()
          , n = p.default.getType(a)
          , c = t.description();
        if (!c)
            return;
        const m = c.onUse;
        if (!m)
            return;
        e.setDelay(25);
        const h = m[i.ActionType.SetDown];
        if (t.minDur <= 0)
            return void u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(r.default.TooDamaged, t.getName(), s.default.message(r.default.Place));
        if (e.executor.swimming)
            return void u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(r.default.CannotPlaceThatFromHere, t.getName());
        const {x: y, y: g, z: f} = e.executor.getFacingPoint()
          , T = a;
        if (void 0 !== a.creature || void 0 !== a.npc || void 0 !== a.events || n === o.TerrainType.Lava || T.containedItems && T.containedItems.length > 0 || !e.executor.checkAndRemoveBlood() || game.isPlayerAtPosition(y, g, f))
            return u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(r.default.SomethingInTheWayOfPlacing, t.getName()),
            void game.checkForHiddenMob(e.executor, y, g, f);
        const S = d.default[n];
        let I = !1;
        if (a.doodad) {
            const e = a.doodad.description();
            e && (e.isWall || e.isFence || e.isGate || e.isDoor) && (I = !0)
        }
        if (!I && void 0 !== a.doodad)
            return void u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(r.default.SomethingInTheWayOfPlacing, t.getName());
        const v = d.default[h];
        if (S && (S.passable || S.water)) {
            {
                p.default.isTilled(a) && p.default.setTilled(a, !1);
                const e = {
                    type: h
                };
                if (e.quality = t.quality,
                v && v.durability && t.minDur && (e.minDur = t.minDur,
                e.maxDur = t.maxDur),
                n === o.TerrainType.CaveEntrance && game.changeTile(o.TerrainType.Dirt, y, g, f === o.WorldZ.Overworld ? o.WorldZ.Cave : o.WorldZ.Overworld, !1),
                S && S.water) {
                    let t;
                    switch (n) {
                    case o.TerrainType.DeepFreshWater:
                        t = o.TerrainType.FreshWater;
                        break;
                    case o.TerrainType.DeepSeawater:
                        t = o.TerrainType.Seawater;
                        break;
                    case o.TerrainType.FreshWater:
                        t = o.TerrainType.ShallowFreshWater;
                        break;
                    case o.TerrainType.Seawater:
                    default:
                        t = o.TerrainType.ShallowSeawater
                    }
                    game.changeTile(e, y, g, f, !0),
                    game.changeTile(t, y, g, f, !0)
                } else
                    game.changeTile(e, y, g, f, !0)
            }
            v && e.setParticle({
                color: v.particles,
                inFront: !0
            }),
            itemManager.remove(t),
            e.setPassTurn(),
            e.setUpdateTablesAndWeight(),
            e.setSoundEffect({
                type: o.SfxType.PickUp,
                inFront: !0
            }),
            e.setStaminaReduction(o.SkillType.Mining)
        } else
            u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(r.default.CannotPlaceThatHere, t.getName())
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/SmotherFire", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "tile/ITileEvent", "tile/Terrains", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        if (void 0 === t.minDur)
            return;
        const a = e.executor.getFacingTile()
          , n = m.default.getType(a)
          , h = t.description();
        if (!h)
            return;
        if (e.setDelay(25),
        t.minDur <= 0)
            return void u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(r.default.TooDamaged, t.getName(), s.default.message(r.default.Place));
        if (e.executor.swimming)
            return void u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(r.default.CannotPlaceThatFromHere, t.getName());
        const y = h.onUse;
        let g, f;
        y && (g = y[i.ActionType.SmotherFire]),
        f = g ? p.default[g] : p.default[n];
        const {x: T, y: S, z: I} = e.executor.getFacingPoint();
        let v = !1
          , w = !1;
        const M = tileEventManager.get(a, d.TileEventType.Fire);
        if (M) {
            v = !0;
            const t = c.default.percent(25)
              , a = e.executor.getSkill(o.SkillType.Camping);
            a >= t ? tileEventManager.remove(M) : (M.spread && (M.spread -= Math.floor(a / M.spread)),
            M.decay && (M.decay -= Math.floor(a / M.decay)),
            u.default.get(e.executor).source(l.Source.Action).send(r.default.YouFailedToExtinguishedFireFully),
            w = !0)
        }
        const b = a.doodad;
        if (b) {
            const e = b.description();
            if (e && e.providesFire) {
                const t = e.revert;
                t && (e.waterStill && void 0 !== b.decay && b.decay >= 0 ? b.decay = 1 : e.isLitTorch || (b.decay = -1),
                b.changeType(t),
                world.updateTile(b.x, b.y, b.z, a),
                v = !0)
            }
        }
        if (v) {
            if (w || u.default.get(e.executor).source(l.Source.Action).send(r.default.ExtinguishedFire),
            g) {
                if (m.default.isTilled(a) && m.default.setTilled(a, !1),
                n === o.TerrainType.CaveEntrance && game.changeTile(o.TerrainType.Dirt, T, S, I === o.WorldZ.Overworld ? o.WorldZ.Cave : o.WorldZ.Overworld, !1),
                n !== o.TerrainType.Lava) {
                    const e = {
                        type: g,
                        quality: t.quality
                    };
                    game.changeTile(e, T, S, I, !0)
                }
                itemManager.remove(t)
            } else
                t.placeOnTile(T, S, I, !0);
            f && e.setParticle({
                color: f.particles,
                inFront: !0
            }),
            e.setReputationChange(25),
            e.setPassTurn(),
            e.setUpdateTablesAndWeight(),
            e.setSoundEffect({
                type: o.SfxType.PickUp,
                inFront: !0
            }),
            e.addSkillGains(o.SkillType.Camping),
            e.setStaminaReduction(o.SkillType.Camping)
        } else
            u.default.get(e.executor).source(l.Source.Action).send(r.default.NothingToSmother)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Squeeze", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        const a = e.executor.getFacingTile()
          , i = u.default[d.default.getType(a)];
        if (i && !i.passable)
            return void l.default.get(e.executor).source(s.Source.Action).send(r.default.SomethingInTheWayOfPerforming);
        e.setDelay(25);
        const n = a.doodad;
        if (n) {
            const t = n.description();
            if (t && !t.isFlammable)
                return void l.default.get(e.executor).source(s.Source.Action).send(r.default.SomethingInTheWayOfPerforming)
        }
        i && (i.water || i.shallowWater) ? l.default.get(e.executor).source(s.Source.Action).send(r.default.CannotBePerformedOverWater) : (game.fireBreath(e.executor.x, e.executor.y, e.executor.z, e.executor.facingDirection, t.getName(), !0),
        itemManager.remove(t),
        e.setReputationChange(-100),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect(o.SfxType.Throw))
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/StartFire", ["require", "exports", "action/Action", "action/IAction", "doodad/Doodads", "entity/IEntity", "Enums", "item/Items", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "tile/ITileEvent", "tile/Terrains", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory,i.anyOf(i.ActionArgument.ItemInventory, i.ActionArgument.Undefined)).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t,a)=>{
        if (!t)
            return;
        e.setDelay(25);
        const o = e.executor.getFacingTile();
        if (t.type === r.ItemType.Lens && -1 === e.executor.z)
            return void d.default.get(e.executor).source(u.Source.Action).send(l.default.ThereIsNoSunToStartFire);
        if (t.type === r.ItemType.Lens && !game.time.isBetween("7am", "7pm"))
            return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.SunNotBrightEnoughToStartFire, t.getName());
        if (!a && tileEventManager.get(o, m.TileEventType.Fire))
            return void d.default.get(e.executor).source(u.Source.Action).send(l.default.CannotStartFireHere);
        if (a && !a.isEquipped())
            return void d.default.get(e.executor).source(u.Source.Action, u.Source.Equipment, u.Source.Item).send(l.default.MustBeEquippedToIgnite, a.getName());
        const f = o;
        let T, S, I;
        !a && f.containedItems && f.containedItems.length && (T = itemManager.getItemInContainerByGroup(f, r.ItemTypeGroup.Kindling),
        S = itemManager.getItemInContainerByGroup(f, r.ItemTypeGroup.Tinder),
        I = itemManager.getItemInContainerByGroup(f, r.ItemTypeGroup.Fuel)),
        T || (T = itemManager.getItemInContainerByGroup(e.executor.inventory, r.ItemTypeGroup.Kindling));
        let v = !1;
        S || (S = itemManager.getItemInContainerByGroup(e.executor.inventory, r.ItemTypeGroup.Tinder));
        let w = !1;
        I || (I = itemManager.getItemInContainerByGroup(e.executor.inventory, r.ItemTypeGroup.Fuel));
        let M = !1
          , b = h.default[g.default.getType(o)];
        const k = s.default[t.type];
        let C;
        if (a || void 0 === o.doodad)
            if (k && !k.equip) {
                if (a || b && !b.flammable) {
                    if (!T)
                        return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.NoKindlingToStartFire);
                    if (!S)
                        return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.NoTinderToStartFire);
                    v = !0,
                    w = !0
                } else if (b && b.flammable) {
                    if (!S)
                        return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.NoTinderToStartFire);
                    w = !0
                }
            } else if (b && !b.flammable) {
                if (!T && !I)
                    return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.NoKindlingOrFuelItemsToStartFire);
                M = !0
            }
        if (C = o.doodad) {
            const t = C.description();
            if (t && t.lit) {
                if (t.isUnlitTorch) {
                    if (k && !k.equip) {
                        if (!S)
                            return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.NoTinderToStartFire);
                        w = !0
                    }
                } else if (k && !k.equip) {
                    if (!T)
                        return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.NoKindlingToStartFire);
                    if (!S)
                        return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.NoTinderToStartFire);
                    v = !0,
                    w = !0
                } else if (k && k.equip) {
                    if (!T && !I)
                        return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.NoKindlingOrFuelItemsToStartFire);
                    M = !0
                }
                const a = t.lit;
                if (a) {
                    const t = n.default[a];
                    if (t && t.waterStill) {
                        if (C.gatherReady)
                            return void d.default.get(e.executor).source(u.Source.Action).send(l.default.AlreadyDesalinatedWaterInStill);
                        if (1 !== C.decay)
                            return void d.default.get(e.executor).source(u.Source.Action).send(l.default.StillHasNoWaterToPurify)
                    }
                }
            } else {
                if (!t || !t.isFlammable)
                    return void d.default.get(e.executor).source(u.Source.Action).send(l.default.CannotStartFireHere);
                if (k && !k.equip) {
                    if (!S)
                        return void d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.NoTinderToStartFire);
                    w = !0
                }
                C = void 0
            }
        }
        if (!a) {
            const t = (b = h.default[g.default.getType(o)]) && (b.flammable || b.passable && !b.water && !b.shallowWater) || C;
            if (!t)
                return void d.default.get(e.executor).source(u.Source.Action).send(l.default.CannotStartFireHere)
        }
        let D = y.default.percent(20);
        if (k && k.equip && (D *= .5),
        e.executor.getSkill(r.SkillType.Camping) >= D) {
            if (a) {
                const t = a.description();
                if (!t)
                    return;
                const i = t.lit;
                if (!i)
                    return;
                d.default.get(e.executor).source(u.Source.Action, u.Source.Item).send(l.default.IgnitedTorch, a.getName()),
                a.changeInto(i),
                void 0 === a.decay && (a.decay = a.getDecayMax())
            } else if (C) {
                const e = C.description();
                if (e && e.lit) {
                    const t = e.lit;
                    if (t) {
                        const e = n.default[t];
                        e && ((void 0 === C.decay || -1 === C.decay || e.waterStill) && (C.decay = e.decayMax),
                        C.changeType(t),
                        world.updateTile(C.x, C.y, C.z, o))
                    }
                }
            } else {
                e.setReputationChange(-250);
                const {x: t, y: a, z: i} = e.executor.getFacingPoint();
                tileEventManager.create(m.TileEventType.Fire, t, a, i)
            }
            a || (d.default.get(e.executor).source(u.Source.Action).send(l.default.StartedFire),
            o.npc && o.npc.makeHostile()),
            e.addSkillGains(r.SkillType.Camping),
            v && T && itemManager.remove(T),
            w && S && itemManager.remove(S),
            M && T ? itemManager.remove(T) : M && I && itemManager.remove(I)
        } else
            v && T && T.damage(i.ActionType[e.type]),
            w && S && S.damage(i.ActionType[e.type]),
            M && T ? T.damage(i.ActionType[e.type]) : M && I && I.damage(i.ActionType[e.type]),
            e.addSkillGains(r.SkillType.Camping, .1),
            a ? d.default.get(e.executor).source(u.Source.Action, u.Source.Item).type(d.MessageType.Bad).send(l.default.FailedToIgniteTorch, a.getName()) : d.default.get(e.executor).source(u.Source.Action).type(d.MessageType.Bad).send(l.default.FailedToStartFire);
        e.setItemsUsed(),
        e.setParticle({
            color: c.default[p.ParticleType.Fire],
            inFront: !a
        }),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect({
            type: r.SfxType.Throw,
            inFront: !a
        }),
        e.setStaminaReduction(r.SkillType.Camping)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/StokeFire", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "game/inspection/Inspect", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "tile/ITileEvent", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        const a = e.executor.getFacingTile()
          , i = t.description();
        if (!i)
            return;
        e.setDelay(25);
        const {x: n, y: h, z: y} = e.executor.getFacingPoint();
        if (game.isPositionFull(n, h, y))
            return void u.default.get(e.executor).source(l.Source.Action).send(s.default.SomethingInTheWayOfFire);
        const g = t.getStokeFireValue();
        let f = !1;
        const T = tileEventManager.get(a, c.TileEventType.Fire);
        if (T && g)
            f = !0,
            void 0 !== T.decay && (T.decay += 20 * g),
            void 0 !== T.spread && (u.default.get(e.executor).send(r.default.ofFire(T.decay, !0)),
            T.spread += g),
            void 0 !== T.decay && T.decay > 800 && 0 === m.default.int(2) && tileEventManager.fireOverflow(T.x, T.y, T.z);
        else if (g && void 0 !== a.doodad) {
            const t = a.doodad.description();
            if (t && t.providesFire) {
                if (!1 === t.canStoke)
                    return void u.default.get(e.executor).source(l.Source.Action).send(s.default.NoNeedToStokeFire);
                const i = a.doodad;
                if (void 0 !== i.decay) {
                    const t = i.isEmbers();
                    i.decay += 20 * g;
                    const a = i.isEmbers();
                    t !== a && world.updateTile(i.x, i.y, i.z, game.getTileFromPoint(i)),
                    u.default.get(e.executor).send(r.default.ofFire(i.decay))
                }
                void 0 !== i.decay && i.decay > 800 && 0 === m.default.int(2) && tileEventManager.fireOverflow(i.x, i.y, i.z),
                f = !0
            }
        }
        f ? (itemManager.remove(t),
        u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(s.default.AddedFuelToFire),
        e.addSkillGains(o.SkillType.Camping),
        e.setStaminaReduction(o.SkillType.Camping),
        e.setParticle({
            color: p.default[d.ParticleType.Fire],
            inFront: !0
        }),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight(),
        e.setSoundEffect({
            type: o.SfxType.Throw,
            inFront: !0
        })) : u.default.get(e.executor).source(l.Source.Action, l.Source.Item).send(s.default.NoFireToStokeWith, t.getName())
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Tame", ["require", "exports", "action/Action", "creature/Creatures", "entity/IEntity", "entity/IStats", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = (new a.Action).setUsableBy(n.EntityType.Player).setHandler(e=>{
        const t = e.executor.getFacingTile();
        if (!t)
            return;
        const a = t.creature;
        if (void 0 === a)
            return;
        if (e.setDelay(25),
        !a.isTamed() && a.hasStat(o.Stat.Happiness) && a.getStat(o.Stat.Happiness).value >= 0)
            return void u.default.get(e.executor).source(l.Source.Action, l.Source.Creature).send(s.default.RefusedToBeTamed, a.getName());
        const n = i.default[a.type];
        if (n && n.tamingDifficulty) {
            e.setPassTurn(),
            e.setStaminaReduction(r.SkillType.Taming);
            const t = d.default.int(n.tamingDifficulty)
              , i = a.hasStat(o.Stat.Tamed) ? a.getStatValue(o.Stat.Tamed) : void 0;
            e.executor.getSkill(r.SkillType.Taming) + (void 0 !== i ? i : 1) >= t ? (a.tame(e.executor),
            a.queueSoundEffect(r.SfxType.CreatureNoise),
            e.setReputationChange(25),
            e.addSkillGains(r.SkillType.Taming),
            u.default.get(e.executor).source(l.Source.Action, l.Source.Allies, l.Source.Creature).send(s.default.YouHaveTamed, a.getName())) : (a.queueSoundEffect(r.SfxType.CreatureHit),
            e.addSkillGains(r.SkillType.Taming, .1),
            u.default.get(e.executor).source(l.Source.Action, l.Source.Creature).type(u.MessageType.Bad).send(s.default.FailedToTame, a.getName()))
        } else
            u.default.get(e.executor).source(l.Source.Action, l.Source.Creature).send(s.default.CannotBeTamed, a.getName())
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Teleport", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        e.setDelay(25);
        const a = [];
        for (let t = 5; t <= 10; t++) {
            const i = e.executor.x + e.executor.direction.x * t
              , n = e.executor.y + e.executor.direction.y * t
              , o = game.getTile(i, n, e.executor.z)
              , r = o.doodad;
            if (r) {
                const e = r.description();
                if (e && e.blockMove)
                    continue
            }
            if (game.isPlayerAtPosition(i, n, e.executor.z))
                continue;
            if (void 0 !== o.creature || void 0 !== o.npc)
                continue;
            const s = u.default[p.default.getType(o)];
            s && !s.passable || a.push(t)
        }
        if (0 === a.length)
            return void l.default.get(e.executor).source(s.Source.Action).send(r.default.TeleportBlocked);
        const i = d.default.getElement(a)
          , n = e.executor.x + e.executor.direction.x * i
          , c = e.executor.y + e.executor.direction.y * i;
        e.executor.setPosition({
            x: n,
            y: c,
            z: e.executor.z
        }),
        e.setItemsUsed(),
        e.setPassTurn(),
        e.setUpdateView(),
        e.setSoundEffect(o.SfxType.Walk),
        e.setReputationChange(-25),
        e.setUpdateTablesAndWeight(),
        l.default.get(e.executor).source(s.Source.Action).send(r.default.Teleported)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/TellTime", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "game/TimeManager", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const p = {
        [r.PartOfDay.Dawn]: s.default.TimeIsDawn,
        [r.PartOfDay.Sunrise]: s.default.TimeIsSunrise,
        [r.PartOfDay.Daytime]: s.default.TimeIsDaytime,
        [r.PartOfDay.Sunset]: s.default.TimeIsSunset,
        [r.PartOfDay.Dusk]: s.default.TimeIsDusk,
        [r.PartOfDay.Nighttime]: s.default.TimeIsNighttime
    }
      , c = {
        [r.DayQuarter.Day1]: s.default.DayQuarter1,
        [r.DayQuarter.Day2]: s.default.DayQuarter2,
        [r.DayQuarter.Day3]: s.default.DayQuarter3,
        [r.DayQuarter.Day4]: s.default.DayQuarter4,
        [r.DayQuarter.Night1]: s.default.NightQuarter1,
        [r.DayQuarter.Night2]: s.default.NightQuarter2,
        [r.DayQuarter.Night3]: s.default.NightQuarter3,
        [r.DayQuarter.Night4]: s.default.NightQuarter4
    };
    t.default = new a.Action(i.ActionArgument.ItemNearby).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        if (e.setDelay(25),
        e.executor.z < o.WorldZ.Overworld)
            return void d.default.get(e.executor).source(u.Source.Action).send(s.default.CannotToTellTime);
        e.addSkillGains(o.SkillType.Camping, .1);
        const a = game.time;
        d.default.get(e.executor).source(u.Source.Action).send(p[a.getPartOfDay()]),
        e.executor.getSkill(o.SkillType.Camping) >= 50 ? d.default.get(e.executor).source(u.Source.Action).send(s.default.TimeIs, a.getHour(), l.default.ofNumber(a.getHour())) : d.default.get(e.executor).source(u.Source.Action).send(c[a.getDayQuarter()]),
        e.setItemsUsed(),
        e.setPassTurn(),
        e.setUpdateTablesAndWeight()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Till", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Note", "language/Translation", "player/IMessageManager", "player/MessageManager", "tile/Terrains", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemInventory, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t)=>{
        const a = e.executor.getFacingTile()
          , n = h.default.getType(a)
          , {x: y, y: g, z: f} = e.executor.getFacingPoint();
        e.setDelay(25);
        const T = a;
        if (void 0 !== a.creature || void 0 !== a.npc || T.containedItems && T.containedItems.length > 0 || void 0 !== a.events || void 0 !== a.doodad || game.isPlayerAtPosition(y, g, f))
            return p.default.get(e.executor).source(d.Source.Action).send(s.default.SomethingInTheWayOf, u.default.message(s.default.Tilling)),
            void game.checkForHiddenMob(e.executor, y, g, f);
        if (!e.executor.checkAndRemoveBlood())
            return void p.default.get(e.executor).source(d.Source.Action).send(s.default.SomethingInTheWayOfCarveFirst, u.default.message(s.default.Tilling));
        const S = c.default[n];
        if (!S)
            return;
        if (n === o.TerrainType.Grass)
            return e.get(i.ActionType.Dig).execute(e.executor, t),
            void e.setDelay(0);
        if (!S.tillable)
            return void p.default.get(e.executor).source(d.Source.Action).send(s.default.CannotDoThatHere, u.default.message(s.default.Till));
        const I = m.default.percent(65)
          , v = new u.default(r.Dictionary.Terrain,n)
          , w = game.getOrCreateTileData(y, g, f);
        e.executor.getSkill(o.SkillType.Gardening) >= I ? (e.executor.notes.write(l.default.Gardening, u.default.message(s.default.Tilling)),
        0 === w.length ? w.push({
            type: h.default.getType(a),
            tilled: !0
        }) : w[0].tilled = !w[0].tilled,
        w[0].tilled ? (p.default.get(e.executor).source(d.Source.Action).send(s.default.YouTilled, v),
        e.addSkillGains(o.SkillType.Gardening)) : p.default.get(e.executor).source(d.Source.Action).send(s.default.YouPacked, v),
        h.default.setTilled(a, !!w[0].tilled),
        world.updateTile(y, g, f, a)) : (h.default.isTilled(a) || 0 !== m.default.int(5) || e.addSkillGains(o.SkillType.Gardening, .1),
        p.default.get(e.executor).source(d.Source.Action).send(s.default.AttemptToTill, u.default.message(h.default.isTilled(a) ? s.default.Pack : s.default.Till), v)),
        e.setParticle({
            color: S.particles,
            position: {
                x: y,
                y: g,
                z: f
            }
        }),
        e.setItemsUsed(),
        creatureManager.maybeSpawnClawWorm(e.executor),
        e.setPassTurn(),
        e.setStaminaReduction(o.SkillType.Gardening),
        e.setSoundEffect({
            type: o.SfxType.PickUp,
            inFront: !0
        })
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/ToggleContainer", ["require", "exports", "action/Action", "action/IAction", "doodad/doodads/Doodad", "entity/IEntity", "Enums", "item/Item", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.Container,i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined)).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setHandler((e,t,a)=>{
        e.executor.isLocalPlayer() && (e.type !== i.ActionType.CloseContainer ? (t instanceof n.default || t instanceof s.default) && (ui.isContainerOpen(t) || (p.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.YouOpen, t.getName()),
        ui.openContainer(t, `${t.getName().inContext(3).getString()} (${u.default.message(l.default.Container).getString()})`),
        a || e.setSoundEffect(r.SfxType.PickUp)),
        a || e.executor.addDelay(40)) : ui.isContainerOpen(t) && ui.closeContainer(t))
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/ToggleDoor", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = (new a.Action).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler(e=>{
        const t = e.executor.getFacingTile()
          , a = t.doodad;
        if (!a)
            return !1;
        const n = u[a.type];
        if (void 0 === n)
            return !1;
        e.setDelay(25);
        const {x: d, y: p, z: c} = e.executor.getFacingPoint();
        if (e.type === i.ActionType.CloseDoor) {
            const a = t;
            if (a.containedItems && a.containedItems.length > 0 || void 0 !== t.creature || void 0 !== t.npc || void 0 !== t.events || !e.executor.checkAndRemoveBlood() || game.isPlayerAtPosition(d, p, c))
                return l.default.get(e.executor).source(s.Source.Action).send(r.default.SomethingInWayOfClosingDoor),
                !1
        }
        return a.changeType(n),
        world.updateTile(d, p, c, t),
        e.setPassTurn(),
        e.setSoundEffect(o.SfxType.PickUp, !0),
        !0
    }
    );
    const u = {
        [o.DoodadType.WoodenDoor]: o.DoodadType.WoodenDoorOpen,
        [o.DoodadType.WoodenGate]: o.DoodadType.WoodenGateOpen,
        [o.DoodadType.WoodenDoorOpen]: o.DoodadType.WoodenDoor,
        [o.DoodadType.WoodenGateOpen]: o.DoodadType.WoodenGate
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/ToggleHitch", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = (new a.Action).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler(e=>{
        const t = e.executor.getFacingTile();
        e.setDelay(25);
        const a = t.creature;
        if (void 0 === a)
            return;
        if (e.type === i.ActionType.Unhitch && void 0 === a.hitchedTo)
            return;
        if (e.type === i.ActionType.Unhitch) {
            const t = game.doodads[a.hitchedTo];
            return t && void 0 !== t.hitchedCreature && (t.hitchedCreature = void 0,
            a.hitchedTo = void 0),
            l.default.get(e.executor).source(s.Source.Action, s.Source.Creature).send(r.default.UnhitchCreature, a.getName()),
            e.setSoundEffect({
                type: o.SfxType.CreatureNoise,
                inFront: !0
            }),
            void e.setPassTurn()
        }
        const n = a.description();
        if (n && n.disableHitching)
            return void l.default.get(e.executor).source(s.Source.Action, s.Source.Creature).send(r.default.HitchDisabled, a.getName());
        let p, c = !1;
        for (const e of d.default.tilesAround(a)) {
            if (!e || !e.doodad)
                continue;
            const t = e.doodad.description();
            if (t && t.group === o.DoodadTypeGroup.Hitch) {
                if (void 0 === e.doodad.hitchedCreature) {
                    p = e.doodad;
                    break
                }
                c = !0
            }
        }
        if (void 0 === p)
            return void (c && l.default.get(e.executor).source(s.Source.Action, s.Source.Creature).send(r.default.HitchInUse, a.getName()));
        const m = e.executor.getSkill(o.SkillType.Taming) / 100;
        let h = (.25 + .25 * m) * (a.aberrant ? .5 : 1);
        a.isTamed() && (h = a.aberrant ? .5 + .5 * m : 1);
        const y = u.default.chance(h);
        y && (a.hitchedTo = p.id,
        p.hitchedCreature = a.id),
        l.default.get(e.executor).source(s.Source.Action, s.Source.Creature, a.isTamed() && s.Source.Allies).send(y ? r.default.HitchCreature : r.default.HitchAttempt, a.getName()),
        a.isTamed() || e.addSkillGains(o.SkillType.Taming, y ? void 0 : .1),
        e.setSoundEffect({
            type: o.SfxType.CreatureNoise,
            inFront: !0
        }),
        e.setStaminaReduction(o.SkillType.Taming),
        e.setPassTurn()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Trade", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.NPC).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        if (t.isHostile())
            return;
        let a;
        const i = t.getProperty(n.Property.Talked);
        if (i.has(e.executor.identifier)) {
            let i = 0;
            const o = t.getProperty(n.Property.Credit);
            o.has(e.executor.identifier) && (i = o.get(e.executor.identifier)),
            a = i > 0 ? r.default.NPCWelcomeCredit : r.default.NPCWelcome
        } else
            a = d.default.getElement([r.default.NPCStartingDialog1, r.default.NPCStartingDialog2, r.default.NPCStartingDialog3, r.default.NPCStartingDialog4]),
            i.set(e.executor.identifier, !0);
        u.default.get(e.executor).source(l.Source.Action, l.Source.Allies).send(r.default.ChatPlayerMessage, t.getName(), s.default.message(a)),
        t.addAiType(n.AiType.Waiting),
        t.updateDirection(e.executor.x, e.executor.y),
        e.executor.isLocalPlayer() && !ui.isContainerOpen(t.inventory) && (ui.openContainer(t.inventory, s.default.message(r.default.TradingWith).inContext(3).getString(t.getName())),
        e.setSoundEffect(o.SfxType.PickUp)),
        e.setDelay(40)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Transmogrify", ["require", "exports", "action/Action", "action/IAction", "entity/Entity", "entity/IEntity", "Enums", "item/Items", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemInventory,i.anyOf(i.ActionArgument.ItemInventory, i.ActionArgument.Undefined)).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setPreExecutionHandler((e,t)=>e.addItems(t)).setHandler((e,t,a)=>{
        if (e.setDelay(25),
        !a) {
            const t = e.executor.getFacingTile()
              , i = t;
            if (i.containedItems)
                for (let e = 0; e < i.containedItems.length; e++) {
                    a = i.containedItems[e];
                    break
                }
        }
        if (void 0 === a)
            return void c.default.get(e.executor).source(d.Source.Action).send(l.default.NotFacingValidItem, u.default.message(l.default.Transmogrification));
        const i = s.default[a.type];
        if (!i)
            return;
        const h = m.default.percent();
        let y = r.SkillType.Tinkering;
        const g = i.recipe;
        if (g && g.skill && (y = g.skill),
        h >= 85 - e.executor.getSkill(y) / 4) {
            e.addSkillGains(y);
            const i = a.maxDur;
            a.setQuality(r.ItemQuality.Legendary),
            void 0 !== i && i > a.maxDur && (a.maxDur = i),
            a.minDur = a.maxDur,
            itemManager.remove(t),
            c.default.get(e.executor).source(d.Source.Action, d.Source.Item).send(l.default.Transmogrified, a.getName()),
            e.setSoundEffect(r.SfxType.Craft),
            e.setReputationChange(-250),
            ui.updateItem(a),
            e.executor.addMilestone(p.MilestoneType.Artificer),
            n.default.is(e.executor, o.EntityType.Player) && itemManager.checkMilestones(e.executor, a)
        } else
            e.addSkillGains(y, .1),
            c.default.get(e.executor).source(d.Source.Action, d.Source.Item).type(c.MessageType.Bad).send(l.default.FailedToTransmogrify, a.getName()),
            e.setItemsUsed(),
            e.setSoundEffect(r.SfxType.Fail);
        e.setStaminaReduction(y),
        e.setUpdateTablesAndWeight(),
        e.setPassTurn()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/TravelAway", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "entity/IStats", "Enums", "language/dictionary/Message", "language/dictionary/UiTranslation", "language/Translation", "mod/IHookManager", "newui/screen/screens/menu/component/IMenu", "player/IMessageManager", "player/MessageManager", "player/quest/quest/IQuest", "player/quest/requirement/IRequirement", "utilities/Async", "utilities/iterable/Collectors", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T) {
    async function S() {
        await newui.showLoadingInterrupt(l.default .GameInterruptLoadingTraveling,l.default .GameInterruptLoadingTravelingDescription),
        ui.hideInGameScreen(),
        await g.sleep(50),
        game.resetGameState()
    }
    async function I(e) {
        saveData.gameState = r.PlayerState.Won,
        saveDataGlobal.gameHighscores.push({
            name: saveData.gameSlotName,
            score: e.executor.score,
            turns: e.executor.turns,
            message: u.default.message(s.default.ReturnedToCivilization).serialize(),
            difficulty: game.getDifficulty(),
            date: Date.now(),
            characterName: e.executor.name
        }),
        game.setPaused(!0, !0),
        await g.sleep(500),
        await newui.interrupt().withMenu(p.MenuId.GameEnd,e=>e.setGameEndData({state:r.PlayerState.Won,highscore:saveDataGlobal.gameHighscores.collect(f.default .last())})),
        m.default.get(e.executor).source(c.Source.Action).type(m.MessageType.Stat).send(s.default.ReturningToCivilizationSetOffAgain)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemNearby, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined),i.anyOf(i.ActionArgument.Boolean, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player).setPreExecutionHandler((e,t)=>e.addItems(t)).setConfirmer(async(e,t,a,n,o)=>{
        if (!t && !o)
            return !1;
        e.setDelay(25);
        const u = e.type === i.ActionType.TraverseTheSea;
        if (multiplayer.isConnected() && (u || !game.isChallenge))
            return m.default.get(e.executor).source(c.Source.Action, c.Source.Multiplayer).send(s.default.CannotLeave),
            !1;
        if (!n && e.executor.z !== r.WorldZ.Overworld)
            return m.default.get(e.executor).source(c.Source.Action).send(s.default.NeedToStartTravelsOutside),
            !1;
        const d = e.executor.getTile();
        if (!n && T.default.getType(d) !== r.TerrainType.DeepSeawater && T.default.getType(d) !== r.TerrainType.Seawater && T.default.getType(d) !== r.TerrainType.ShallowSeawater)
            return m.default.get(e.executor).source(c.Source.Action).send(s.default.StartTravelInWater),
            !1;
        const p = itemManager.getItemInContainer(e.executor.inventory, r.ItemType.GoldCoins)
          , g = itemManager.getItemInContainer(e.executor.inventory, r.ItemType.GoldenChalice)
          , f = itemManager.getItemInContainer(e.executor.inventory, r.ItemType.GoldenKey)
          , S = itemManager.getItemInContainer(e.executor.inventory, r.ItemType.GoldenRing)
          , I = itemManager.getItemInContainer(e.executor.inventory, r.ItemType.GoldenSword);
        if (!(u || o || game.isChallenge || p && g && f && S && I))
            return m.default.get(e.executor).source(c.Source.Action, c.Source.Item).send(s.default.NotEnoughTreasureToReturn),
            !1;
        if (!o && game.isChallenge) {
            const t = e.executor.quests.getQuests(h.QuestType.Challenge)[0];
            for (const a of t.getRequirements())
                if (a.data.type !== y.RequirementType.SailToCivilization && !a.data.completed)
                    return m.default.get(e.executor).source(c.Source.Action, c.Source.Item).send(s.default.NoReturnWithoutCompletingChallenges),
                    !1
        }
        if (!game.isChallenge) {
            const e = game.isChallenge ? l.default.GameInterruptSailAwayEnd : u ? l.default.GameInterruptTravelAway : l.default.GameInterruptSailAwayReturnable
              , t = game.isChallenge ? l.default.GameInterruptSailAwayEndDescription : u ? l.default.GameInterruptTravelAwayDescription : l.default.GameInterruptSailAwayReturnableDescription;
            if (!a && !await newui.interrupt(e,t).withConfirmation())
                return !1
        }
        return !0
    }
    ).setHandler((e,t)=>{
        const a = e.type === i.ActionType.TraverseTheSea
          , n = itemManager.getItemInContainer(e.executor.inventory, r.ItemType.GoldCoins)
          , l = itemManager.getItemInContainer(e.executor.inventory, r.ItemType.GoldenChalice)
          , p = itemManager.getItemInContainer(e.executor.inventory, r.ItemType.GoldenKey)
          , h = itemManager.getItemInContainer(e.executor.inventory, r.ItemType.GoldenRing)
          , y = itemManager.getItemInContainer(e.executor.inventory, r.ItemType.GoldenSword);
        e.setItemsUsed();
        let g = r.PlayerState.None;
        if (a) {
            e.executor.state = r.PlayerState.Traveling,
            g = r.PlayerState.Traveling;
            for (const e of game.items)
                if (e)
                    if (void 0 === itemManager.getPlayerWithItemInInventory(e) && void 0 === itemManager.getAbsentPlayerWithItemInInventory(e))
                        itemManager.remove(e);
                    else {
                        const t = e.type;
                        t !== r.ItemType.TatteredMap && t !== r.ItemType.DrawnMap || delete e.tatteredMap
                    }
        } else
            n && l && p && h && y && (itemManager.remove(n),
            itemManager.remove(l),
            itemManager.remove(p),
            itemManager.remove(h),
            itemManager.remove(y)),
            e.executor.state = r.PlayerState.Won,
            g = r.PlayerState.Won;
        const f = e.executor.getStat(o.Stat.Stamina)
          , T = e.executor.getStat(o.Stat.Health)
          , v = e.executor.getStat(o.Stat.Hunger)
          , w = e.executor.getStat(o.Stat.Thirst);
        let M = 0
          , b = 0;
        const k = T.value;
        if (!game.isChallenge) {
            for (let t = 0; t < 5; t++) {
                const t = itemManager.getItemInContainerByGroup(e.executor.inventory, r.ItemTypeGroup.Food);
                t ? t.returns() || itemManager.remove(t) : (e.executor.reduceStat(v, 5),
                v.value < 0 && (e.executor.reduceStat(T, -1 * v.value),
                e.executor.reduceStat(f, -1 * v.value),
                M += -1 * v.value));
                const a = itemManager.getItemInContainerByGroup(e.executor.inventory, r.ItemTypeGroup.Liquid);
                a ? a.returns() || itemManager.remove(a) : (e.executor.reduceStat(w, 5),
                w.value < 0 && (e.executor.reduceStat(T, -1 * w.value),
                e.executor.reduceStat(f, -1 * w.value),
                b += -1 * w.value))
            }
            T.value <= 0 && e.executor.setStat(T, 1)
        }
        if (e.executor.updateReputation(5e3),
        e.executor.travelData = {
            starvation: M,
            dehydration: b,
            originalHealth: k,
            itemId: t && t.id,
            state: g
        },
        g === r.PlayerState.Won) {
            for (const t of game.getPlayers())
                t !== e.executor && (t.deathBy = u.default.message(s.default.DeathByChallengeWinner).serialize(),
                t.kill(),
                t.messages.type(m.MessageType.Bad).source(c.Source.Multiplayer, c.Source.Meta).send(s.default.PlayerHasWonChallenge, e.executor.getName()));
            modManager.getHook(d.Hook.OnSailToCivilization).call(e.executor),
            e.executor.isLocalPlayer() && I(e)
        } else
            S()
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/Unequip", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.anyOf(i.ActionArgument.ItemInventory, i.ActionArgument.Undefined)).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t)=>{
        e.setDelay(13),
        void 0 === t ? e.executor.unequipAll() : e.executor.unequip(t)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/UpdateDirection", ["require", "exports", "action/Action", "action/IAction", "entity/Entity", "entity/IEntity", "mod/IHookManager"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.Direction,i.anyOf(i.ActionArgument.Number, i.ActionArgument.Undefined)).setUsableBy(o.EntityType.Player, o.EntityType.NPC).setUsableWhen(i.ActionUsability.Ghost).setHandler((e,t,a)=>{
        const i = game.directionToMovement(t);
        e.executor.direction.x = i.x,
        e.executor.direction.y = i.y,
        e.executor.facingDirection = t,
        n.default.is(e.executor, o.EntityType.Player) && (e.executor.nextMoveTime = game.absoluteTime + (void 0 !== a ? a : 2) * game.interval),
        e.setUpdateRender(),
        e.executor.isLocalPlayer() && ui.onUpdateDirection(),
        modManager.getHook(r.Hook.OnMoveDirectionUpdate).call(e.executor, t)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/actions/UseItem", ["require", "exports", "action/Action", "action/IAction", "entity/IEntity", "Enums", "language/dictionary/Message", "player/IMessageManager", "player/MessageManager"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = new a.Action(i.ActionArgument.ItemNearby,i.ActionArgument.ActionType).setUsableBy(n.EntityType.Player, n.EntityType.NPC).setHandler((e,t,a)=>{
        const n = t.description();
        if (void 0 !== n) {
            if (a === i.ActionType.Shoot || a === i.ActionType.Sling || a === i.ActionType.Fire) {
                let a = !1;
                if (t.isEquipped() ? n.twoHanded && e.executor.getEquippedItem(o.EquipType.LeftHand) && e.executor.getEquippedItem(o.EquipType.RightHand) && (l.default.get(e.executor).source(s.Source.Action, s.Source.Equipment, s.Source.Item).send(r.default.NeedFreeHandToShoot, t.getName()),
                a = !0) : (l.default.get(e.executor).source(s.Source.Action, s.Source.Equipment, s.Source.Item).send(r.default.NeedToEquipToShoot, t.getName()),
                a = !0),
                a)
                    return void e.setDelay(25)
            }
            e.get(a).execute(e.executor, t)
        }
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/Actions", ["require", "exports", "action/actions/AddFuel", "action/actions/Attack", "action/actions/Build", "action/actions/Carve", "action/actions/Cast", "action/actions/ConsumeItem", "action/actions/Craft", "action/actions/Decode", "action/actions/Dig", "action/actions/Disassemble", "action/actions/Dismantle", "action/actions/DrawMap", "action/actions/DrinkInFront", "action/actions/Drop", "action/actions/Equip", "action/actions/Extinguish", "action/actions/Gather", "action/actions/GatherMilk", "action/actions/GatherTreasure", "action/actions/GatherWater", "action/actions/Grasp", "action/actions/Harvest", "action/actions/HealOther", "action/actions/Idle", "action/actions/Ignite", "action/actions/Inspect", "action/actions/Jump", "action/actions/Learn", "action/actions/LockPick", "action/actions/Move", "action/actions/MoveItem", "action/actions/MoveTo", "action/actions/Offer", "action/actions/OpenBottle", "action/actions/Paddle", "action/actions/Pet", "action/actions/Pickup", "action/actions/PickupAllItems", "action/actions/PickupItem", "action/actions/Plant", "action/actions/Pour", "action/actions/PourOnYourself", "action/actions/Preserve", "action/actions/Read", "action/actions/Reinforce", "action/actions/Release", "action/actions/Rename", "action/actions/Repair", "action/actions/Rest", "action/actions/Rub", "action/actions/SetDown", "action/actions/SmotherFire", "action/actions/Squeeze", "action/actions/StartFire", "action/actions/StokeFire", "action/actions/Tame", "action/actions/Teleport", "action/actions/TellTime", "action/actions/Till", "action/actions/ToggleContainer", "action/actions/ToggleDoor", "action/actions/ToggleHitch", "action/actions/Trade", "action/actions/Transmogrify", "action/actions/TravelAway", "action/actions/Unequip", "action/actions/UpdateDirection", "action/actions/UseItem", "action/IAction", "utilities/iterable/Collectors", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L, O, F, _, H, W, N, q, U, z, V, j, Q, $, Y, J, K, X, Z, ee, te, ae, ie, ne, oe, re, se, le, ue, de, pe, ce, me, he, ye, ge, fe, Te) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const Se = {
        [ge.ActionType.AddFuel]: a.default,
        [ge.ActionType.Apply]: s.default,
        [ge.ActionType.Attack]: i.default,
        [ge.ActionType.Build]: n.default,
        [ge.ActionType.Carve]: o.default,
        [ge.ActionType.Cast]: r.default,
        [ge.ActionType.CloseContainer]: se.default,
        [ge.ActionType.CloseDoor]: le.default,
        [ge.ActionType.Craft]: l.default,
        [ge.ActionType.Decode]: u.default,
        [ge.ActionType.Dig]: d.default,
        [ge.ActionType.Disassemble]: p.default,
        [ge.ActionType.Dismantle]: c.default,
        [ge.ActionType.DrawMap]: m.default,
        [ge.ActionType.DrinkCure]: s.default,
        [ge.ActionType.DrinkInFront]: h.default,
        [ge.ActionType.DrinkItem]: s.default,
        [ge.ActionType.Drop]: y.default,
        [ge.ActionType.Eat]: s.default,
        [ge.ActionType.Equip]: g.default,
        [ge.ActionType.Extinguish]: f.default,
        [ge.ActionType.Fire]: i.default,
        [ge.ActionType.Gather]: T.default,
        [ge.ActionType.GatherMilk]: S.default,
        [ge.ActionType.GatherTreasure]: I.default,
        [ge.ActionType.GatherWater]: v.default,
        [ge.ActionType.Grasp]: w.default,
        [ge.ActionType.Harvest]: M.default,
        [ge.ActionType.Heal]: s.default,
        [ge.ActionType.HealOther]: b.default,
        [ge.ActionType.Hitch]: ue.default,
        [ge.ActionType.Idle]: k.default,
        [ge.ActionType.Ignite]: C.default,
        [ge.ActionType.Inspect]: D.default,
        [ge.ActionType.Jump]: A.default,
        [ge.ActionType.Learn]: P.default,
        [ge.ActionType.LockPick]: G.default,
        [ge.ActionType.Move]: R.default,
        [ge.ActionType.MoveItem]: x.default,
        [ge.ActionType.MoveTo]: B.default,
        [ge.ActionType.Offer]: E.default,
        [ge.ActionType.OpenBottle]: L.default,
        [ge.ActionType.OpenContainer]: se.default,
        [ge.ActionType.OpenDoor]: le.default,
        [ge.ActionType.Paddle]: O.default,
        [ge.ActionType.Pet]: F.default,
        [ge.ActionType.Pickup]: _.default,
        [ge.ActionType.PickupAllItems]: H.default,
        [ge.ActionType.PickupItem]: W.default,
        [ge.ActionType.PlaceDown]: n.default,
        [ge.ActionType.Plant]: N.default,
        [ge.ActionType.Pour]: q.default,
        [ge.ActionType.PourOnYourself]: U.default,
        [ge.ActionType.Preserve]: z.default,
        [ge.ActionType.Read]: V.default,
        [ge.ActionType.Reinforce]: j.default,
        [ge.ActionType.Release]: Q.default,
        [ge.ActionType.Rename]: $.default,
        [ge.ActionType.Repair]: Y.default,
        [ge.ActionType.Rest]: J.default,
        [ge.ActionType.RubClockwise]: K.default,
        [ge.ActionType.RubCounterclockwise]: K.default,
        [ge.ActionType.SailToCivilization]: ce.default,
        [ge.ActionType.SetDown]: X.default,
        [ge.ActionType.Shoot]: i.default,
        [ge.ActionType.Sleep]: J.default,
        [ge.ActionType.Sling]: i.default,
        [ge.ActionType.SmotherFire]: Z.default,
        [ge.ActionType.Squeeze]: ee.default,
        [ge.ActionType.StartFire]: te.default,
        [ge.ActionType.StokeFire]: ae.default,
        [ge.ActionType.Tame]: ie.default,
        [ge.ActionType.Teleport]: ne.default,
        [ge.ActionType.TellTime]: oe.default,
        [ge.ActionType.Throw]: i.default,
        [ge.ActionType.Till]: re.default,
        [ge.ActionType.Trade]: de.default,
        [ge.ActionType.Transmogrify]: pe.default,
        [ge.ActionType.TraverseTheSea]: ce.default,
        [ge.ActionType.Unequip]: me.default,
        [ge.ActionType.Unhitch]: ue.default,
        [ge.ActionType.UpdateDirection]: he.default,
        [ge.ActionType.UseItem]: ye.default
    }
      , Ie = Te.default.entries(Se).collect(fe.default.toArray);
    for (const [e,t] of Ie)
        Ie.some(([a,i])=>a !== e && t === i) && (Se[e] = t.clone());
    for (const [e,t] of Te.default.entries(Se))
        t.type = +e;
    t.default = Se
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/ActionExecutor", ["require", "exports", "action/Actions", "action/IAction", "creature/Creature", "doodad/doodads/Doodad", "entity/Entity", "entity/Human", "entity/IEntity", "Enums", "game/IGame", "item/Item", "language/dictionary/Message", "language/dictionary/UiTranslation", "language/Translation", "mod/IHookManager", "multiplayer/packets/shared/ActionPacket", "npc/BaseNPC", "player/IMilestone", "player/MessageManager", "player/Player", "utilities/enum/Enums", "utilities/iterable/Generators", "utilities/Log", "utilities/math/Vector2", "utilities/math/Vector3", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const D = new M.default(M.LogSource.ActionManager);
    var A;
    !function(e) {
        e[e.Confirmation = 0] = "Confirmation",
        e[e.Execution = 1] = "Execution"
    }(A || (A = {}));
    const P = Symbol("DELAY")
      , G = Symbol("PASS_TURN");
    class R {
        constructor(e, t=e.type) {
            this.action = e,
            this.type = t,
            this._actionStack = [],
            this.executionStage = A.Confirmation,
            this.shouldSkipConfirmation = !1,
            this.updateTablesAndWeight = !1,
            this.reputationChange = 0,
            this.items = [],
            this.itemsUsed = !1,
            C.initializePrivateStore(this, [[G, !1]])
        }
        static get(e) {
            let t;
            return "number" == typeof e ? (t = e,
            e = a.default[t]) : t = e.type,
            new R(e,t)
        }
        static executeMultiplayer(e, t) {
            let a = !0
              , i = t;
            if (i || ((i = R.get(e.action))._executor = e.entity,
            i.items = e.items,
            i.canExecute(!0) || (a = !1)),
            multiplayer.isServer() && a && !t) {
                const t = x(i.executor, i.action, e.arguments);
                (t.problems.length > 0 || e.items && !e.items.every(e=>null !== e && void 0 !== e)) && (a = !1)
            }
            if (a)
                return multiplayer.syncPacket(e, ()=>i.executeInternal(e.arguments), !1, e.action);
            multiplayer.clearSyncPacketWaiting(e, e.action)
        }
        get executor() {
            return this._executor
        }
        get actionStack() {
            return this._actionStack
        }
        get lastAction() {
            return this._actionStack[this._actionStack.length - 1]
        }
        skipConfirmation() {
            return this.shouldSkipConfirmation = !0,
            this
        }
        execute(e, ...t) {
            if (this._executor = e,
            !this.canExecute())
                return;
            const a = this.action.type
              , {problems: n, argumentTypes: o} = x(e, this.action, t);
            if (n.length)
                D.warn(`Failed to execute ${i.ActionType[a]} as `, e, ". Problems: ", ...[""].concat(...n.map(e=>["\n\t", ...e])));
            else if (!this.action.preExecutionHandler || !1 !== this.action.preExecutionHandler(this, ...t))
                return !this.items.length || this._actionStack.length || this.shouldSkipConfirmation ? this.executeConfirmer(e, t, o) : new Promise(async a=>{
                    const i = await this.confirmItemsBroken();
                    a(i ? this.executeConfirmer(e, t, o) : void 0)
                }
                )
        }
        isArgumentType(e, t, a) {
            let i = this.action.argumentTypes[t];
            return Array.isArray(i) && (i = B(this.executor, i, e)),
            i === a
        }
        get(e) {
            const t = R.get(e);
            return t._actionStack = [...this._actionStack, this.action.type],
            t
        }
        setDelay(e, t) {
            return this.privateStore.set(P, w.tuple(e, t)),
            this
        }
        setPassTurn(e) {
            return this.privateStore.set(G, void 0 === e || e),
            this
        }
        setUpdateView(e=!1) {
            return this.updateView = e,
            this
        }
        setUpdateRender() {
            return this.updateRender = !0,
            this
        }
        setUpdateTablesAndWeight() {
            return this.updateTablesAndWeight = !0,
            this
        }
        setStaminaReduction(e) {
            return this.staminaReduction = e,
            this
        }
        setReputationChange(e) {
            return this.reputationChange = e,
            this
        }
        addSkillGains(e, t, ...a) {
            return "number" == typeof e ? a.push(w.tuple(e, t)) : (a.push(e),
            t && a.push(t)),
            this.skillGains ? this.skillGains.push(...a) : this.skillGains = [...a],
            this
        }
        setMilestone(e, t) {
            return this.milestone = w.tuple(e, t),
            this
        }
        setSoundEffect(e, t) {
            return "number" == typeof e && (e = {
                type: e,
                inFront: t
            }),
            this.sfx = e,
            this
        }
        setParticle(e, t, a) {
            return "r"in e && ("boolean" == typeof t && (a = t,
            t = void 0),
            e = {
                color: e,
                count: t,
                inFront: a
            }),
            this.particle = e,
            this
        }
        addItems(...e) {
            const t = e.filter(e=>e && e.isValid());
            return this.items.push(...t),
            this
        }
        getItems() {
            return this.items.values()
        }
        removeItems(...e) {
            if (0 === e.length)
                return this.items.splice(0, 1 / 0),
                this;
            for (const t of e) {
                if (!t)
                    continue;
                const e = this.items.indexOf(t);
                -1 !== e && this.items.splice(e, 1)
            }
            return this
        }
        setItemsUsed(e=!0) {
            return this.itemsUsed = e,
            this
        }
        async confirmItemsBroken() {
            if (!this.items.length || this.executionStage === A.Execution || !saveDataGlobal.options.warnWhenBreakingItems)
                return !0;
            const e = this.items.filter(e=>0 === e.minDur);
            if (!e.length)
                return !0;
            const t = itemManager.getItemListTranslation(e, !1);
            return newui.interrupt(h.default.ui(m.default.GameInterruptItemsMayBeDestroyedOnUse).addArgs(t)).withDescription(h.default.ui(m.default.GameInterruptItemsMayBeDestroyedOnUseDescription).addArgs(t)).withConfirmation()
        }
        executeConfirmer(e, t, a) {
            return !this.action.confirmer || this._actionStack.length || this.shouldSkipConfirmation ? (this.shouldSkipConfirmation = !1,
            this.executeInternalOrMultiplayer(e, t, a)) : new Promise(async i=>{
                const n = await this.action.confirmer(this,...t);
                i(n ? this.executeInternalOrMultiplayer(e, t, a) : void 0)
            }
            )
        }
        executeInternalOrMultiplayer(e, t, a) {
            if (this.executionStage = A.Execution,
            this._actionStack.length || !multiplayer.isConnected())
                return this.executeInternal(t);
            const i = new g.default;
            return i.entity = e,
            i.action = this.action.type,
            i.arguments = t,
            i.argumentTypes = a,
            i.items = this.items,
            R.executeMultiplayer(i, this)
        }
        executeInternal(e) {
            if (!1 === modManager.getHook(y.Hook.PreExecuteAction).call(this, this.action, e))
                return;
            let t;
            try {
                t = this.action.handler(this, ...e)
            } catch (t) {
                D.error(`Error whilst executing ${i.ActionType[this.action.type]}:`, t, e)
            }
            const a = this.executor;
            return r.default.is(a, l.EntityType.Player) && void 0 !== this.action.type && !v.default.isModded(i.ActionType, this.action.type) && a.addMilestone(T.MilestoneType.Operator, this.action.type),
            modManager.getHook(y.Hook.PostExecuteAction).call(this, this.action, e),
            game.playing && (t && "object" == typeof t && (t instanceof Promise || "function" == typeof t.then) ? (multiplayer.isConnected() && D.warn("Executing async action while playing multiplayer could result in desyncs", this.action, this),
            t.then(()=>{
                this.handleApi()
            }
            )) : this.handleApi()),
            t
        }
        handleApi() {
            if (r.default.isNot(this.executor, l.EntityType.Creature)) {
                const e = this.executor;
                if (this.staminaReduction && e.staminaReduction(this.staminaReduction),
                this.reputationChange && e.updateReputation(this.reputationChange),
                this.milestone && e.addMilestone(...this.milestone),
                this.skillGains)
                    for (const t of this.skillGains)
                        e.skillGain(...t)
            }
            if (void 0 !== this.sfx)
                if (this.sfx.inFront)
                    this.executor.queueSoundEffectInFront(this.sfx.type, this.sfx.delay, this.sfx.speed, this.sfx.noPosition);
                else {
                    const e = this.sfx.position || {}
                      , t = void 0 === e.x ? this.executor.x : e.x
                      , a = void 0 === e.y ? this.executor.y : e.y
                      , i = void 0 === e.z ? this.executor.z : e.z;
                    audio.queueEffect(this.sfx.type, t, a, i, this.sfx.delay, this.sfx.speed, this.sfx.noPosition)
                }
            if (this.particle) {
                const e = this.particle.color
                  , t = this.particle.position || (this.particle.inFront ? this.executor.getFacingPoint() : {})
                  , a = void 0 === t.x ? this.executor.x : t.x
                  , i = void 0 === t.y ? this.executor.y : t.y
                  , n = void 0 === t.z ? this.executor.z : t.z;
                void 0 !== this.particle.count ? game.particle.createMultiple(a, i, n, e, this.particle.count) : game.particle.create(a, i, n, e)
            }
            if (r.default.is(this.executor, l.EntityType.Player)) {
                const e = this.executor
                  , t = this.privateStore.get(P);
                t && e.addDelay(...t),
                this.updateTablesAndWeight && e.updateTablesAndWeight();
                const a = this.privateStore.get(G);
                !1 !== a && game.passTurn(e, "number" == typeof a ? a : void 0)
            }
            if (this.updateRender && game.updateRender(d.RenderSource.ActionManager),
            void 0 !== this.updateView && game.updateView(d.RenderSource.ActionManager, this.updateView),
            this.itemsUsed)
                for (const e of this.items)
                    e.damage(i.ActionType[this.action.type])
        }
        canExecute(e=!1) {
            if (this._actionStack.length)
                return !0;
            if (!e) {
                if (r.default.is(this.executor, l.EntityType.Player)) {
                    const e = this.executor;
                    if (!this.isUsableWhen(i.ActionUsability.Moving) && e.isLocalPlayer() && e.isMovingClientside && 1 !== e.movementProgress && e.moveType !== u.MoveType.Flying)
                        return !1;
                    if (!this.isUsableWhen(i.ActionUsability.Delayed) && e.hasDelay() && !e.isResting())
                        return e.messages.send(c.default.YouCannotDoThatYet),
                        !1
                }
                if (!this.isUsableWhen(i.ActionUsability.Paused) && game.paused)
                    return !1
            }
            if (r.default.isNot(this.executor, l.EntityType.Creature)) {
                const e = this.executor;
                if (!this.isUsableWhen(i.ActionUsability.Resting) && e.isResting())
                    return !1;
                if (!this.isUsableWhen(i.ActionUsability.Ghost) && e.isGhost())
                    return r.default.is(e, l.EntityType.Player) && (e.messages.type(S.MessageType.Miss).send(c.default.GhostNoActions),
                    e.addDelay(25)),
                    !1
            }
            return !0
        }
        isUsableWhen(e) {
            return !0 === this.action.usability[e]
        }
    }
    function x(e, t, a) {
        const n = []
          , o = [];
        t.validExecutors.includes(e.entityType) || n.push([`Executor is invalid. Executed by: ${l.EntityType[e.entityType]} Expected: ${t.validExecutors.map(e=>l.EntityType[e]).join(" | ")}`]);
        for (let r = 0; r < t.argumentTypes.length; r++) {
            const s = t.argumentTypes[r]
              , l = a[r]
              , u = B(e, s, l);
            if (void 0 === u) {
                const e = Array.isArray(s) ? s.map(e=>i.ActionArgument[e]).join(" | ") : i.ActionArgument[s];
                n.push([`Argument ${r} is invalid. Got:`, l, `Expected: ${e}`])
            } else
                o.push(u)
        }
        return {
            problems: n,
            argumentTypes: o
        }
    }
    function B(e, t, a) {
        if (Array.isArray(t)) {
            for (const i of t)
                if (E(e, i, a))
                    return i
        } else if (E(e, t, a))
            return t
    }
    function E(e, t, a) {
        if (Array.isArray(t))
            return t.some(t=>E(e, t, a));
        switch (t) {
        case i.ActionArgument.Undefined:
            return void 0 === a;
        case i.ActionArgument.Null:
            return null === a;
        case i.ActionArgument.Boolean:
            return "boolean" == typeof a;
        case i.ActionArgument.Number:
            return "number" == typeof a;
        case i.ActionArgument.String:
            return "string" == typeof a;
        case i.ActionArgument.Array:
            return Array.isArray(a);
        case i.ActionArgument.Object:
            return "object" == typeof a;
        case i.ActionArgument.AttackType:
            return v.default.isValid(u.AttackType, a);
        case i.ActionArgument.Container:
            return itemManager.isContainer(a);
        case i.ActionArgument.Doodad:
            return a instanceof o.default;
        case i.ActionArgument.Corpse:
            return "object" == typeof a && v.default.isValid(u.CreatureType, a.type) && void 0 !== game.corpses[a.id];
        case i.ActionArgument.Creature:
            return a instanceof n.default;
        case i.ActionArgument.NPC:
            return a instanceof f.default;
        case i.ActionArgument.Player:
            return a instanceof I.default;
        case i.ActionArgument.Human:
            return a instanceof s.default;
        case i.ActionArgument.EquipType:
            return v.default.isValid(u.EquipType, a);
        case i.ActionArgument.Direction:
            return v.default.isValid(u.Direction, a, !1);
        case i.ActionArgument.ItemQuality:
            return v.default.isValid(u.ItemQuality, a);
        case i.ActionArgument.ItemType:
            return v.default.isValid(u.ItemType, a);
        case i.ActionArgument.Vector2:
            return b.default.is(a);
        case i.ActionArgument.Vector3:
            return k.default.is(a);
        case i.ActionArgument.RestType:
            return v.default.isValid(u.RestType, a);
        case i.ActionArgument.ActionType:
            return v.default.isValid(i.ActionType, a);
        case i.ActionArgument.DoodadType:
            return v.default.isValid(u.DoodadType, a);
        case i.ActionArgument.Entity:
            return a instanceof r.default;
        case i.ActionArgument.Item:
            return a instanceof p.default;
        case i.ActionArgument.ItemNearby:
            return L(e, a);
        case i.ActionArgument.ItemInventory:
            return L(e, a, !1);
        case i.ActionArgument.ItemArray:
            return Array.isArray(a) && a.every(e=>e instanceof p.default);
        case i.ActionArgument.ItemArrayNearby:
            return Array.isArray(a) && a.every(t=>L(e, t));
        case i.ActionArgument.ItemArrayInventory:
            return Array.isArray(a) && a.every(t=>L(e, t, !1));
        case i.ActionArgument.TileEvent:
            return tileEventManager.is(a)
        }
    }
    function L(e, t, a=!0) {
        const i = e.inventory;
        return t instanceof p.default && (void 0 !== i && itemManager.isContainableInContainer(t, i) && !t.isInTradeContainer() || a && r.default.is(e, l.EntityType.Player) && itemManager.isContainableInAdjacentContainer(e, t, !0, !0))
    }
    __decorate([C.Final], R.prototype, "setDelay", null),
    __decorate([C.Final], R.prototype, "setPassTurn", null),
    __decorate([C.Final], R.prototype, "handleApi", null),
    t.default = R,
    t.getArgumentType = B
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("action/IAction", ["require", "exports"], function(e, t) {
    var a, i, n;
    function o(...e) {
        return e
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Disassemble = 0] = "Disassemble",
        e[e.Pickup = 1] = "Pickup",
        e[e.Throw = 2] = "Throw",
        e[e.Attack = 3] = "Attack",
        e[e.StartFire = 4] = "StartFire",
        e[e.Carve = 5] = "Carve",
        e[e.SetDown = 6] = "SetDown",
        e[e.Eat = 7] = "Eat",
        e[e.DrinkItem = 8] = "DrinkItem",
        e[e.Rest = 9] = "Rest",
        e[e.Sleep = 10] = "Sleep",
        e[e.Heal = 11] = "Heal",
        e[e.Dig = 12] = "Dig",
        e[e.Paddle = 13] = "Paddle",
        e[e.GatherWater = 14] = "GatherWater",
        e[e.Shoot = 15] = "Shoot",
        e[e.Cast = 16] = "Cast",
        e[e.TraverseTheSea = 17] = "TraverseTheSea",
        e[e.LockPick = 18] = "LockPick",
        e[e.Sling = 19] = "Sling",
        e[e.Repair = 20] = "Repair",
        e[e.Decode = 21] = "Decode",
        e[e.Learn = 22] = "Learn",
        e[e.Reinforce = 23] = "Reinforce",
        e[e.Gather = 24] = "Gather",
        e[e.StokeFire = 25] = "StokeFire",
        e[e.Pour = 26] = "Pour",
        e[e.Plant = 27] = "Plant",
        e[e.GatherTreasure = 28] = "GatherTreasure",
        e[e.Ignite = 29] = "Ignite",
        e[e.Build = 30] = "Build",
        e[e.OpenContainer = 31] = "OpenContainer",
        e[e.Preserve = 32] = "Preserve",
        e[e.OpenBottle = 33] = "OpenBottle",
        e[e.DrinkCure = 34] = "DrinkCure",
        e[e.TellTime = 35] = "TellTime",
        e[e.SailToCivilization = 36] = "SailToCivilization",
        e[e.Transmogrify = 37] = "Transmogrify",
        e[e.Fire = 38] = "Fire",
        e[e.Teleport = 39] = "Teleport",
        e[e.Extinguish = 40] = "Extinguish",
        e[e.DrawMap = 41] = "DrawMap",
        e[e.Dismantle = 42] = "Dismantle",
        e[e.PourOnYourself = 43] = "PourOnYourself",
        e[e.Squeeze = 44] = "Squeeze",
        e[e.Pet = 45] = "Pet",
        e[e.Tame = 46] = "Tame",
        e[e.Release = 47] = "Release",
        e[e.HealOther = 48] = "HealOther",
        e[e.RubClockwise = 49] = "RubClockwise",
        e[e.RubCounterclockwise = 50] = "RubCounterclockwise",
        e[e.OpenDoor = 51] = "OpenDoor",
        e[e.CloseDoor = 52] = "CloseDoor",
        e[e.AddFuel = 53] = "AddFuel",
        e[e.Grasp = 54] = "Grasp",
        e[e.PickupItem = 55] = "PickupItem",
        e[e.PickupAllItems = 56] = "PickupAllItems",
        e[e.Offer = 57] = "Offer",
        e[e.Drop = 58] = "Drop",
        e[e.Jump = 59] = "Jump",
        e[e.Move = 60] = "Move",
        e[e.MoveTo = 61] = "MoveTo",
        e[e.UpdateDirection = 62] = "UpdateDirection",
        e[e.Idle = 63] = "Idle",
        e[e.DrinkInFront = 64] = "DrinkInFront",
        e[e.UseItem = 65] = "UseItem",
        e[e.Equip = 66] = "Equip",
        e[e.Unequip = 67] = "Unequip",
        e[e.MoveItem = 68] = "MoveItem",
        e[e.Craft = 69] = "Craft",
        e[e.Till = 70] = "Till",
        e[e.Rename = 71] = "Rename",
        e[e.Harvest = 72] = "Harvest",
        e[e.GatherMilk = 73] = "GatherMilk",
        e[e.Read = 74] = "Read",
        e[e.CloseContainer = 75] = "CloseContainer",
        e[e.SmotherFire = 76] = "SmotherFire",
        e[e.Trade = 77] = "Trade",
        e[e.PlaceDown = 78] = "PlaceDown",
        e[e.Inspect = 79] = "Inspect",
        e[e.Apply = 80] = "Apply",
        e[e.Hitch = 81] = "Hitch",
        e[e.Unhitch = 82] = "Unhitch"
    }(a = t.ActionType || (t.ActionType = {})),
    function(e) {
        e[e.Paused = 0] = "Paused",
        e[e.Resting = 1] = "Resting",
        e[e.Moving = 2] = "Moving",
        e[e.Ghost = 3] = "Ghost",
        e[e.Delayed = 4] = "Delayed"
    }(i = t.ActionUsability || (t.ActionUsability = {})),
    t.anyOf = o,
    function(e) {
        e[e.Undefined = 0] = "Undefined",
        e[e.Null = 1] = "Null",
        e[e.Boolean = 2] = "Boolean",
        e[e.Number = 3] = "Number",
        e[e.String = 4] = "String",
        e[e.Array = 5] = "Array",
        e[e.Object = 6] = "Object",
        e[e.ActionType = 7] = "ActionType",
        e[e.AttackType = 8] = "AttackType",
        e[e.Container = 9] = "Container",
        e[e.Corpse = 10] = "Corpse",
        e[e.Creature = 11] = "Creature",
        e[e.Direction = 12] = "Direction",
        e[e.Doodad = 13] = "Doodad",
        e[e.DoodadType = 14] = "DoodadType",
        e[e.Entity = 15] = "Entity",
        e[e.EquipType = 16] = "EquipType",
        e[e.Human = 17] = "Human",
        e[e.Item = 18] = "Item",
        e[e.ItemArray = 19] = "ItemArray",
        e[e.ItemArrayInventory = 20] = "ItemArrayInventory",
        e[e.ItemArrayNearby = 21] = "ItemArrayNearby",
        e[e.ItemInventory = 22] = "ItemInventory",
        e[e.ItemNearby = 23] = "ItemNearby",
        e[e.ItemQuality = 24] = "ItemQuality",
        e[e.ItemType = 25] = "ItemType",
        e[e.NPC = 26] = "NPC",
        e[e.Player = 27] = "Player",
        e[e.RestType = 28] = "RestType",
        e[e.TileEvent = 29] = "TileEvent",
        e[e.Vector2 = 30] = "Vector2",
        e[e.Vector3 = 31] = "Vector3"
    }(n = t.ActionArgument || (t.ActionArgument = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/Dictionaries", ["require", "exports", "action/IAction", "entity/IStats", "Enums", "game/Difficulty", "game/inspection/IInspection", "game/TimeManager", "language/dictionary/GameEndMessage", "language/dictionary/HumanName", "language/dictionary/InterruptChoice", "language/dictionary/Message", "language/dictionary/Misc", "language/dictionary/Note", "language/dictionary/UiTranslation", "mod/IModInfo", "mod/IModManager", "newui/screen/screens/game/component/QuadrantComponent", "newui/screen/screens/game/IGameScreenApi", "newui/screen/screens/menu/menus/character/Character", "newui/screen/screens/menu/menus/help/HelpArticleDescriptions", "newui/screen/screens/menu/menus/highscores/IHighscoresMenu", "newui/screen/screens/menu/menus/main/AboutMenu", "newui/screen/screens/menu/menus/mods/IModsMenu", "player/IMessageManager", "player/IMilestone", "player/quest/quest/IQuest", "player/quest/requirement/IRequirement", "save/data/ISaveDataGlobal", "save/ISaveManager", "tile/ITileEvent", "utilities/Trello"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R) {
    var x;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Action = 0] = "Action",
        e[e.Bindable = 1] = "Bindable",
        e[e.BindableType = 2] = "BindableType",
        e[e.BindPress = 3] = "BindPress",
        e[e.Book = 4] = "Book",
        e[e.ChangelogSection = 5] = "ChangelogSection",
        e[e.CharacterSort = 6] = "CharacterSort",
        e[e.Command = 7] = "Command",
        e[e.Corpse = 8] = "Corpse",
        e[e.Creature = 9] = "Creature",
        e[e.DamageType = 10] = "DamageType",
        e[e.Difficulty = 11] = "Difficulty",
        e[e.Doodad = 12] = "Doodad",
        e[e.DoodadGroup = 13] = "DoodadGroup",
        e[e.DoodadItem = 14] = "DoodadItem",
        e[e.EquipSlot = 15] = "EquipSlot",
        e[e.GameEndMessage = 16] = "GameEndMessage",
        e[e.Growth = 17] = "Growth",
        e[e.GrowthFungus = 18] = "GrowthFungus",
        e[e.HelpArticle = 19] = "HelpArticle",
        e[e.HighscoreSort = 20] = "HighscoreSort",
        e[e.HumanName = 21] = "HumanName",
        e[e.InspectType = 22] = "InspectType",
        e[e.InterruptChoice = 23] = "InterruptChoice",
        e[e.Item = 24] = "Item",
        e[e.ItemGroup = 25] = "ItemGroup",
        e[e.ItemQuality = 26] = "ItemQuality",
        e[e.LegendaryType = 27] = "LegendaryType",
        e[e.Message = 28] = "Message",
        e[e.MessagesTimestampMode = 29] = "MessagesTimestampMode",
        e[e.Milestone = 30] = "Milestone",
        e[e.Misc = 31] = "Misc",
        e[e.ModLoadError = 32] = "ModLoadError",
        e[e.ModSort = 33] = "ModSort",
        e[e.ModType = 34] = "ModType",
        e[e.MusicPlaylist = 35] = "MusicPlaylist",
        e[e.Note = 36] = "Note",
        e[e.Number = 37] = "Number",
        e[e.OnEquip = 38] = "OnEquip",
        e[e.PartOfDay = 39] = "PartOfDay",
        e[e.PowerMode = 40] = "PowerMode",
        e[e.Quest = 41] = "Quest",
        e[e.QuestRequirement = 42] = "QuestRequirement",
        e[e.SaveSlotSort = 43] = "SaveSlotSort",
        e[e.Skill = 44] = "Skill",
        e[e.Source = 45] = "Source",
        e[e.Stat = 46] = "Stat",
        e[e.StatusEffect = 47] = "StatusEffect",
        e[e.TeamMemberResponsibility = 48] = "TeamMemberResponsibility",
        e[e.Terrain = 49] = "Terrain",
        e[e.TileEvent = 50] = "TileEvent",
        e[e.Ui = 51] = "Ui",
        e[e.UiQuadrant = 52] = "UiQuadrant"
    }(x = t.Dictionary || (t.Dictionary = {})),
    t.SYMBOL_ANY_DICTIONARY = Symbol("SYMBOL_ANY_DICTIONARY");
    const B = {
        [x.Action]: a.ActionType,
        [x.Bindable]: n.Bindable,
        [x.BindableType]: n.BindableType,
        [x.BindPress]: t.SYMBOL_ANY_DICTIONARY,
        [x.Book]: n.BookType,
        [x.ChangelogSection]: R.ChangelogSection,
        [x.CharacterSort]: S.CharacterSort,
        [x.Command]: n.Command,
        [x.Corpse]: n.CreatureType,
        [x.Creature]: n.CreatureType,
        [x.DamageType]: n.DamageType,
        [x.Difficulty]: o.Difficulty,
        [x.Doodad]: n.DoodadType,
        [x.DoodadGroup]: n.DoodadTypeGroup,
        [x.DoodadItem]: n.ItemType,
        [x.EquipSlot]: n.EquipType,
        [x.GameEndMessage]: l.GameEndMessage,
        [x.Growth]: n.GrowingStage,
        [x.GrowthFungus]: n.GrowingStage,
        [x.HelpArticle]: I.HelpArticle,
        [x.HighscoreSort]: v.HighscoreSort,
        [x.HumanName]: u.default,
        [x.InspectType]: r.InspectType,
        [x.InterruptChoice]: d.default,
        [x.Item]: n.ItemType,
        [x.ItemGroup]: n.ItemTypeGroup,
        [x.ItemQuality]: n.ItemQuality,
        [x.LegendaryType]: n.LegendaryType,
        [x.Message]: p.default,
        [x.MessagesTimestampMode]: T.MessageTimestamp,
        [x.Milestone]: k.MilestoneType,
        [x.Misc]: c.MiscTranslation,
        [x.ModLoadError]: g.CanLoadState,
        [x.ModSort]: M.ModSort,
        [x.ModType]: y.ModType,
        [x.MusicPlaylist]: A.MusicPlaylist,
        [x.Note]: m.default,
        [x.Number]: t.SYMBOL_ANY_DICTIONARY,
        [x.OnEquip]: n.OnEquipType,
        [x.PartOfDay]: s.PartOfDay,
        [x.PowerMode]: A.PowerMode,
        [x.Quest]: C.QuestType,
        [x.QuestRequirement]: D.RequirementType,
        [x.SaveSlotSort]: P.SaveSort,
        [x.Skill]: n.SkillType,
        [x.Source]: b.Source,
        [x.Stat]: i.Stat,
        [x.StatusEffect]: n.StatusType,
        [x.TeamMemberResponsibility]: w.Responsibility,
        [x.Terrain]: n.TerrainType,
        [x.TileEvent]: G.TileEventType,
        [x.Ui]: h.default,
        [x.UiQuadrant]: f.Quadrant
    };
    t.strictDictionaries = B,
    t.default = B
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/segment/BindSegment", ["require", "exports", "Enums", "newui/BindingManager"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const n = {
        regex: /^Bindings:([A-Za-z0-9]+|\{[a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)*\})$/,
        handle: ([e,t],n,o,...r)=>{
            t = o.interpolateString(t, ...r);
            const s = isNaN(+t) ? a.Bindable[t] : +t;
            return "number" == typeof s ? o.interpolate(`{#--text-color-bind:${i.bindingManager.getBindingsTranslation(s)}}`) : `{${e}}`
        }
    };
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/segment/TranslationSegment", ["require", "exports", "language/Translation", "utilities/string/Interpolator"], function(e, t, a, i) {
    function n(e) {
        return {
            isTranslationSegment: !0,
            regex: /^([a-zA-Z0-9_-]+):(.*?)(?::(random|\d+))?(?::\((.*)\))?$/,
            handle: ([t,a,i,o,r],s,l,...u)=>{
                const d = n.resolveTranslation(e, l, a, i, o || "0", r, u);
                return void 0 === d ? `{${t}}` : d
            }
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        function t(e, t, i, o, r, s, l) {
            if (o = t.interpolateString(o, ...l),
            !/^[a-zA-Z0-9_-]+$/.test(o))
                return;
            const u = new a.default(`${i}:${o}:${r}`);
            if (!u.isValid)
                return;
            const d = n(t, s, ...l)
              , p = u.setRandom(e).setFailWith("_FAIL").get(...d);
            return "_FAIL" !== a.default.getString(p) ? p : void 0
        }
        function n(e, t, ...a) {
            if (!t)
                return [];
            const n = [];
            for (; ; ) {
                const o = i.default.getIndexOfTopLevel(",", t);
                if (-1 === o)
                    break;
                n.push(e.interpolate(t.slice(0, o), ...a)),
                t = t.slice(o + 1)
            }
            return n.push(e.interpolate(t, ...a)),
            n
        }
        e.resolveTranslation = t,
        e.getSubTranslationArgs = n
    }(n || (n = {})),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/segment/ConditionalTranslationSegment", ["require", "exports", "language/segment/TranslationSegment", "utilities/Random", "utilities/string/Interpolator"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const o = {
        regex: /^([a-zA-Z0-9_-]+):(.*?)(?::(random|\d+))?(?::\((.*)\))?\?/,
        handle: ([e,t,o,r,s],l,u,...d)=>{
            l = l.slice(e.length);
            const p = a.default.resolveTranslation(i.generalRandom, u, t, o, r, s, d);
            let c = n.default.getIndexOfTopLevel(":", l);
            c = -1 === c ? 1 / 0 : c;
            const m = p ? l.slice(0, c) : l.slice(c + 1);
            return u.interpolate(m, ...d)
        }
    };
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/segment/NumberSegment", ["require", "exports", "language/Translation"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        regex: /^num\((as words|(\d+)(!?))\):/,
        handle: ([e,,t,i],n,o,...r)=>{
            const s = parseFloat(o.interpolateString(n.slice(e.length), ...r));
            if (isNaN(s))
                return [];
            if (!t)
                return a.default.ofNumber(s).get();
            const l = s.toFixed(+t);
            return i ? [{
                content: l
            }] : [{
                content: `${+l}`
            }]
        }
    };
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/segment/ReformatSegment", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const a = {
        regex: /^reformat(?:\((\d+|\{[a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)*\})(?:,\s*(true|false|\{[a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)*\}))?\))?:/,
        handle: ([e,t,a],n,o,...r)=>{
            const s = o.interpolateString(n.slice(e.length), ...r);
            return t = t && o.interpolateString(t, ...r),
            languageManager.reformatSingularNoun(s, t && !isNaN(+t) ? +t : 2, i(a, o, r))
        }
    };
    function i(e, t, a) {
        switch (e) {
        case void 0:
            return;
        case "true":
            return !0;
        case "false":
            return !1;
        default:
            return i(t.interpolateString(e, ...a), t, a)
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/Translation", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Misc", "language/segment/BindSegment", "language/segment/ColorSegment", "language/segment/ConditionalTranslationSegment", "language/segment/NumberSegment", "language/segment/ReformatSegment", "language/segment/TextDecorationSegments", "language/segment/TranslationSegment", "mod/IHookManager", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Log", "utilities/Objects", "utilities/Random", "utilities/string/Interpolator", "utilities/string/Strings"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const v = new g.default(g.LogSource.Languages,"Translation");
    class w {
        constructor(e, t, a=0) {
            this.args = [],
            this.reformatters = [],
            this.interpolator = w.defaultInterpolator,
            this._context = 0,
            this.normalize = !1,
            this.random = T.generalRandom,
            this.translationId = M(e, t, a),
            [e,t,a] = b(this.translationId),
            void 0 === e ? v.warn("Invalid dictionary:", this.translationId) : void 0 === t ? v.warn("Invalid entry:", this.translationId) : this.translationData = [e, t, a],
            this.isValid = void 0 !== e && void 0 !== t
        }
        static formatList(e, t=1) {
            const a = e.values().map(e=>"string" == typeof e ? [{
                content: e
            }] : e).collect(h.default.toArray);
            if (0 === a.length)
                return w.message(n.default.None);
            if (1 === a.length) {
                const e = a.collect(h.default.first());
                return e instanceof w ? e : new w(i.Dictionary.Misc,o.MiscTranslation.Thing).addArgs(e)
            }
            if (2 === a.length && t)
                return new w(i.Dictionary.Misc,1 === t ? o.MiscTranslation.AAndB : o.MiscTranslation.AOrB).addArgs(...a);
            const r = new w(i.Dictionary.Misc,o.MiscTranslation.ListItemSeparator).get();
            for (let e = a.length - (t ? 2 : 1); e > 0; e--)
                a.splice(e, 0, r);
            const s = new w(i.Dictionary.Misc,o.MiscTranslation.Thing).addArgs((t ? a.slice(0, -1) : a).values().map(e=>"string" == typeof e ? {
                content: e
            } : e instanceof w ? e.get() : e).flatMap().collect(h.default.toArray));
            return t ? new w(i.Dictionary.Misc,1 === t ? o.MiscTranslation.AListAndB : o.MiscTranslation.AListOrB).addArgs(s, a.collect(h.default.last())) : s
        }
        static getString(...e) {
            return e.values().flatMap().map(e=>"string" == typeof e ? e : e instanceof w ? e.getString() : e.content).collect(h.default.toString(""))
        }
        static getAll(e, t) {
            const a = M(e, t);
            if ([e,t] = b(a),
            void 0 === e || void 0 === t)
                return v.warn(`Invalid ${void 0 === e ? "dictionary" : "entry"}:`, a),
                [];
            const i = w.provider(e, t);
            return i ? y.range(i.length).map(a=>new w(e,t,a)).collect(h.default.toArray) : []
        }
        static convertMakeStringToInterpolation(e) {
            return e.replace(/_(\d+)_/g, "{$1}")
        }
        static nameOf(e, t, a=1, n=!0, ...r) {
            "boolean" == typeof a && (n = a,
            a = 1);
            const s = "number" != typeof t && t.renamed && new w(i.Dictionary.Misc,o.MiscTranslation.Renamed).addArgs(t.renamed);
            return new w(e,"number" == typeof t ? t : t.type).addArgs(...r).addReformatter(new w(i.Dictionary.Misc,o.MiscTranslation.ReformatSingularNoun).addArgs(s, a, n))
        }
        static ofNumber(e, t=`${e}`) {
            const a = e
              , n = Math.floor(e / 1e9);
            e -= 1e9 * n;
            const o = Math.floor(e / 1e6);
            e -= 1e6 * o;
            const r = Math.floor(e / 1e3);
            e -= 1e3 * r;
            const s = Math.floor(e / 100);
            e -= 100 * s;
            const l = Math.floor(e / 10)
              , u = e -= 10 * l;
            let d = u ? new w(i.Dictionary.Number,`${u}`).setFailWith(`${u}`) : void 0;
            return l && (d = new w(i.Dictionary.Number,"Tens").addArgs({
                tens: new w(i.Dictionary.Number,`Ten${l}`).setFailWith(new w(i.Dictionary.Number,`${10 * l}`).setFailWith(`${10 * l}`)),
                ones: d,
                tensCount: l
            })),
            s && (d = new w(i.Dictionary.Number,"Hundreds").addArgs({
                hundreds: new w(i.Dictionary.Number,`Hundred${s}`).setFailWith(w.ofNumber(s, `${100 * s}`)),
                and: d,
                hundredsCount: s
            })),
            r && (d = new w(i.Dictionary.Number,"Thousands").addArgs({
                thousands: new w(i.Dictionary.Number,`Thousand${r}`).setFailWith(w.ofNumber(r, `${1e3 * r}`)),
                and: d,
                thousandsCount: r
            })),
            o && (d = new w(i.Dictionary.Number,"Millions").addArgs({
                millions: new w(i.Dictionary.Number,`Million${o}`).setFailWith(w.ofNumber(o, `${1e6 * o}`)),
                and: d,
                millionsCount: o
            })),
            n && (d = new w(i.Dictionary.Number,"Billions").addArgs({
                billions: new w(i.Dictionary.Number,`Billion${n}`).setFailWith(w.ofNumber(n, `${1e9 * n}`)),
                and: d,
                billionsCount: n
            })),
            new w(i.Dictionary.Number,`${a}`).setFailWith(d || t)
        }
        static generator(e) {
            if ("function" == typeof e)
                return ()=>w.getStringSections(e());
            const t = w.getStringSections(e).collect(h.default.toArray);
            return ()=>t
        }
        static isSerializedTranslation(e) {
            return "object" == typeof e && !!e && "isSerializedTranslation"in e && e.isSerializedTranslation
        }
        static deserialize(e) {
            const t = new w(e.id).inContext(e.context, e.normalize).setFailWith("object" == typeof e.failWith && "isSerializedTranslation"in e.failWith ? w.deserialize(e.failWith) : e.failWith).addArgs(...e.args||[]);
            for (const a of e.reformatters || [])
                t.addReformatter(w.deserialize(a));
            return t
        }
        static getStringSections(...e) {
            return e.values().map(e=>"string" == typeof e ? {
                content: e
            } : e).flatMap()
        }
        get context() {
            return this._context
        }
        withSegments(e, ...t) {
            return (t.length || e) && (this.interpolator = !0 === e ? new S.default(...t,...this.interpolator.segments) : new S.default(...this.interpolator.segments,e,...t)),
            this
        }
        addArgs(...e) {
            return this.args.push(...e),
            this
        }
        inContext(e=0, t=!1) {
            return this._context = e,
            this.normalize = t,
            this
        }
        addReformatter(e, t=!1) {
            return e ? (t ? this.reformatters.unshift(e) : this.reformatters.push(e),
            this) : this
        }
        setFailWith(e) {
            return this.failWith = e,
            this
        }
        hasFailWith() {
            return void 0 !== this.failWith
        }
        setRandom(e=T.generalRandom) {
            return e !== this.random && (this.random = e,
            this.interpolator = new S.default(...this.interpolator.segments.map(t=>"isTranslationSegment"in t?c.default (e):t))),
            this
        }
        get(...e) {
            let t = this.getSections(e);
            for (const e of this.reformatters)
                t = e instanceof w ? e.get(t) : e(t);
            return !(t = D(t, this._context, this.normalize)) || t[0] && "_FAIL" === t[0].content || (t = modManager.getHook(m.Hook.OnGetTranslation, t).call(t)),
            t
        }
        getString(...e) {
            return this.get(...e).map(e=>e.content).join("")
        }
        toString() {
            return this.getString()
        }
        serialize() {
            let e;
            if (this.interpolator !== w.defaultInterpolator && v.warn("Serializing a translation with additional segments. The additional segments cannot be serialized.", this),
            this.reformatters.length) {
                e = [];
                for (const t of this.reformatters)
                    t instanceof w ? e.push(t.serialize()) : v.warn("Tried to serializing a function reformatter on a translation. Function reformatters cannot be serialized.", this)
            }
            function t(e) {
                if ("function" == typeof e && (e = e()),
                e instanceof w)
                    return e.serialize();
                if ("object" == typeof e)
                    for (const a in e)
                        e[a] = t(e[a]);
                return e
            }
            const a = this.args.map(t)
              , i = {
                isSerializedTranslation: !0,
                id: this.translationId,
                args: a.length ? a : void 0,
                context: 0 === this._context ? void 0 : this._context,
                normalize: !!this.normalize || void 0,
                failWith: this.failWith instanceof w ? this.failWith.serialize() : this.failWith,
                reformatters: e
            };
            for (const e of f.default.keys(i).collect(h.default.toArray))
                void 0 === i[e] && delete i[e];
            return i
        }
        getSections(e) {
            if (!this.isValid)
                return this.getFailureSections();
            const t = this.getRawTranslations();
            if (!t || !t.length)
                return this.getFailureSections();
            const [,,a] = this.translationData
              , i = "random" === a ? this.random.choice(...t) : t[a];
            if (void 0 === i)
                return this.getFailureSections();
            const n = this.random;
            function o(e) {
                if ("function" == typeof e && (e = e()),
                "object" == typeof e) {
                    if (w.isSerializedTranslation(e) && (e = w.deserialize(e)),
                    e instanceof w)
                        return e.setRandom(n).get();
                    for (const t in e)
                        e[t] = o(e[t])
                }
                return e
            }
            return e = [...this.args, ...e].map(o),
            this.interpolator.interpolate(i, ...e)
        }
        getRawTranslations() {
            if (!this.isValid)
                return;
            const [e,t] = this.translationData
              , a = w.provider(e, t, void 0 !== this.failWith);
            return a && a.length ? a : void 0
        }
        getFailureSections() {
            let e = this.failWith;
            return void 0 === e ? e = `{${this.translationId.endsWith(":0") ? this.translationId.slice(0, -2) : this.translationId}}` : e instanceof w && (e = e.get()),
            w.getStringSections(e).collect(h.default.toArray)
        }
    }
    function M(e, t, a) {
        void 0 === t && ("string" == typeof e && ([e,t,a] = e.split(":")),
        t = isNaN(+t) ? t : +t),
        e = "number" == typeof e ? e : i.Dictionary[e];
        const n = i.Dictionary[e]
          , o = i.default[e]
          , r = "number" == typeof t && o && o !== i.SYMBOL_ANY_DICTIONARY ? o[t] : t;
        return `${n}:${r}:${a}`
    }
    function b(e) {
        const [t,a,i] = e.split(":")
          , n = k(t)
          , o = C(t, a);
        return y.tuple(n, o, isNaN(+i) ? "random" : +i)
    }
    function k(e) {
        return +i.Dictionary[I.default.formatCaseStyle(e, a.CaseStyle.PascalCase)]
    }
    function C(e, t) {
        const n = i.default[k(e)]
          , o = I.default.formatCaseStyle(t, a.CaseStyle.PascalCase);
        if (n && n !== i.SYMBOL_ANY_DICTIONARY && o in n) {
            const e = +n[o];
            if (!isNaN(e))
                return e
        }
        return t
    }
    function D(e, t, a=!1) {
        if (0 === t)
            return e;
        if (1 === t)
            return e.forEach(e=>e.content = e.content.toLowerCase()),
            e;
        if (2 === t)
            return e.forEach(e=>e.content = e.content.toUpperCase()),
            e;
        let i = !0
          , n = !0;
        for (let o = 0; o < e.length; o++) {
            const r = e[o];
            a && (r.content = r.content.toLowerCase());
            for (let e = 0; e < r.content.length; e++)
                /\w/.test(r.content[e]) && ((i || n && 3 === t) && (r.content = r.content.slice(0, e) + r.content[e].toUpperCase() + r.content.slice(e + 1)),
                i = !1,
                n = !1),
                /[\s-\/]/.test(r.content[e]) && (n = !0),
                /[.!?\n:]/.test(r.content[e]) && (i = !0,
                n = !0)
        }
        return e
    }
    w.RANDOM = "random",
    w.defaultInterpolator = new S.default(r.default,l.default,c.default(T.generalRandom),d.default,...S.basicInterpolator.segments,s.default,p.italicizedSegment,p.boldSegment,p.underlineSegment,u.default),
    __decorate([f.Bound], w.prototype, "get", null),
    function(e) {
        e.ui = (t=>new e(i.Dictionary.Ui,t)),
        e.message = (t=>new e(i.Dictionary.Message,t))
    }(w || (w = {})),
    t.default = w,
    window.Translation = w
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("Enums", ["require", "exports", "save/ISerializer"], function(e, t, a) {
    var i, n, o, r, s, l;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Type = 536870911] = "Type",
        e[e.Tilled = 536870912] = "Tilled",
        e[e.Wall = 1073741824] = "Wall",
        e[e.Fence = 2147483648] = "Fence"
    }(i = t.TerrainMask || (t.TerrainMask = {})),
    function(e) {
        e[e.Corpse = 0] = "Corpse",
        e[e.Item = 1] = "Item",
        e[e.Creature = 2] = "Creature",
        e[e.CreatureFlying = 3] = "CreatureFlying",
        e[e.Overlay = 4] = "Overlay",
        e[e.OverTrees = 5] = "OverTrees"
    }(n = t.SpriteBatchLayer || (t.SpriteBatchLayer = {})),
    function(e) {
        e[e.Min = 0] = "Min",
        e[e.Cave = 0] = "Cave",
        e[e.Overworld = 1] = "Overworld",
        e[e.Max = 1] = "Max"
    }(o = t.WorldZ || (t.WorldZ = {})),
    function(e) {
        e[e.Melee = 0] = "Melee",
        e[e.HandToHand = 1] = "HandToHand",
        e[e.Shoot = 2] = "Shoot",
        e[e.Sling = 3] = "Sling",
        e[e.Fire = 4] = "Fire",
        e[e.ThrowItem = 5] = "ThrowItem"
    }(r = t.AttackType || (t.AttackType = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Water = 1] = "Water",
        e[e.ShallowWater = 2] = "ShallowWater",
        e[e.Land = 4] = "Land",
        e[e.Tree = 8] = "Tree",
        e[e.Mountain = 16] = "Mountain",
        e[e.Fire = 32] = "Fire",
        e[e.BreakDoodads = 64] = "BreakDoodads",
        e[e.WetLand = 128] = "WetLand",
        e[e.Flying = 15] = "Flying"
    }(s = t.MoveType || (t.MoveType = {})),
    function(e) {
        e[e.Blunt = 1] = "Blunt",
        e[e.Slashing = 2] = "Slashing",
        e[e.Piercing = 4] = "Piercing",
        e[e.Fire = 8] = "Fire",
        e[e.True = 16] = "True"
    }(l = t.DamageType || (t.DamageType = {}));
    let u = class e {
        constructor(...e) {
            for (let t = 0; t < e.length; t += 2)
                this[e[t]] = e[t + 1]
        }
    }
    ;
    u = __decorate([a.SaveAllProperties()], u),
    t.Resistances = u;
    let d = class e {
        constructor(...e) {
            for (let t = 0; t < e.length; t += 2)
                this[e[t]] = e[t + 1]
        }
    }
    ;
    d = __decorate([a.SaveAllProperties()], d),
    t.Vulnerabilities = d;
    class p {
        constructor(e, t, a) {
            this.base = e,
            this.resist = t,
            this.vulnerable = a
        }
    }
    var c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L, O, F, _, H, W, N, q, U, z, V, j, Q, $, Y, J, K, X, Z, ee, te, ae, ie, ne, oe, re, se;
    __decorate([a.SaveProperty()], p.prototype, "base", void 0),
    __decorate([a.SaveProperty()], p.prototype, "resist", void 0),
    __decorate([a.SaveProperty()], p.prototype, "vulnerable", void 0),
    t.Defense = p,
    function(e) {
        e[e.Default = 0] = "Default",
        e[e.Vertical = 1] = "Vertical"
    }(c = t.DoorOrientation || (t.DoorOrientation = {})),
    function(e) {
        e[e.None = -1] = "None",
        e[e.East = 0] = "East",
        e[e.North = 1] = "North",
        e[e.West = 2] = "West",
        e[e.South = 3] = "South"
    }(m = t.Direction || (t.Direction = {})),
    function(e) {
        e[e.InGame = 0] = "InGame",
        e[e.Death = 1] = "Death",
        e[e.Quit = 2] = "Quit",
        e[e.BackToMainMenu = 3] = "BackToMainMenu",
        e[e.Multiplayer = 4] = "Multiplayer",
        e[e.Challenge = 5] = "Challenge"
    }(h = t.SaveType || (t.SaveType = {})),
    function(e) {
        e[e.Low = 0] = "Low",
        e[e.High = 1] = "High",
        e[e.Treasure = 2] = "Treasure",
        e[e.SeaTreasure = 3] = "SeaTreasure",
        e[e.CaveChest = 4] = "CaveChest",
        e[e.FireElemental = 5] = "FireElemental",
        e[e.VeryHigh = 6] = "VeryHigh"
    }(y = t.LootGroupType || (t.LootGroupType = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Held = 1] = "Held",
        e[e.Legs = 2] = "Legs",
        e[e.Chest = 3] = "Chest",
        e[e.Head = 4] = "Head",
        e[e.Belt = 5] = "Belt",
        e[e.Feet = 6] = "Feet",
        e[e.Neck = 7] = "Neck",
        e[e.Hands = 8] = "Hands",
        e[e.Back = 9] = "Back",
        e[e.LeftHand = 10] = "LeftHand",
        e[e.RightHand = 11] = "RightHand"
    }(g = t.EquipType || (t.EquipType = {})),
    function(e) {
        e[e.Simple = 0] = "Simple",
        e[e.Intermediate = 1] = "Intermediate",
        e[e.Advanced = 2] = "Advanced",
        e[e.Expert = 3] = "Expert"
    }(f = t.RecipeLevel || (t.RecipeLevel = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Copal = 1] = "Copal",
        e[e.AnimalSkull = 2] = "AnimalSkull",
        e[e.StoneArrow = 3] = "StoneArrow",
        e[e.StoneArrowhead = 4] = "StoneArrowhead",
        e[e.PileOfAsh = 5] = "PileOfAsh",
        e[e.BarkLeggings = 6] = "BarkLeggings",
        e[e.BarkShield = 7] = "BarkShield",
        e[e.BarkTunic = 8] = "BarkTunic",
        e[e.Bone = 9] = "Bone",
        e[e.Branch = 10] = "Branch",
        e[e.CactusSpines = 11] = "CactusSpines",
        e[e.Charcoal = 12] = "Charcoal",
        e[e.CobblestoneFlooring = 13] = "CobblestoneFlooring",
        e[e.CookedMeat = 14] = "CookedMeat",
        e[e.Earthworm = 15] = "Earthworm",
        e[e.Feather = 16] = "Feather",
        e[e.Fertilizer = 17] = "Fertilizer",
        e[e.WaterskinOfSeawater = 18] = "WaterskinOfSeawater",
        e[e.FirePlough = 19] = "FirePlough",
        e[e.BeggartickSeeds = 20] = "BeggartickSeeds",
        e[e.Fossil = 21] = "Fossil",
        e[e.GoldCoins = 22] = "GoldCoins",
        e[e.GoldenChalice = 23] = "GoldenChalice",
        e[e.GoldenRing = 24] = "GoldenRing",
        e[e.GoldenSword = 25] = "GoldenSword",
        e[e.GrassSeeds = 26] = "GrassSeeds",
        e[e.IronOre = 27] = "IronOre",
        e[e.WoodenDowels = 28] = "WoodenDowels",
        e[e.LargeRock = 29] = "LargeRock",
        e[e.LeafBedroll = 30] = "LeafBedroll",
        e[e.LeatherHide = 31] = "LeatherHide",
        e[e.Leaves = 32] = "Leaves",
        e[e.Limestone = 33] = "Limestone",
        e[e.Log = 34] = "Log",
        e[e.StoneMortarAndPestle = 35] = "StoneMortarAndPestle",
        e[e.ButtonMushrooms = 36] = "ButtonMushrooms",
        e[e.Nopal = 37] = "Nopal",
        e[e.Peat = 38] = "Peat",
        e[e.Sandstone = 39] = "Sandstone",
        e[e.PileOfGravel = 40] = "PileOfGravel",
        e[e.PileOfBeachSand = 41] = "PileOfBeachSand",
        e[e.WoodenArrow = 42] = "WoodenArrow",
        e[e.StoneAxe = 43] = "StoneAxe",
        e[e.Bandage = 44] = "Bandage",
        e[e.WovenFabric = 45] = "WovenFabric",
        e[e.CactusNeedle = 46] = "CactusNeedle",
        e[e.StoneShovel = 47] = "StoneShovel",
        e[e.WoodenSpear = 48] = "WoodenSpear",
        e[e.Suture = 49] = "Suture",
        e[e.Raft = 50] = "Raft",
        e[e.RawMeat = 51] = "RawMeat",
        e[e.Raspberries = 52] = "Raspberries",
        e[e.FlyAmanita = 53] = "FlyAmanita",
        e[e.Rope = 54] = "Rope",
        e[e.MapleSeeds = 55] = "MapleSeeds",
        e[e.Badderlocks = 56] = "Badderlocks",
        e[e.SharpGlass = 57] = "SharpGlass",
        e[e.SharpRock = 58] = "SharpRock",
        e[e.Skullcap = 59] = "Skullcap",
        e[e.SmoothRock = 60] = "SmoothRock",
        e[e.Soil = 61] = "Soil",
        e[e.StoneSpear = 62] = "StoneSpear",
        e[e.Stones = 63] = "Stones",
        e[e.StoneWall = 64] = "StoneWall",
        e[e.String = 65] = "String",
        e[e.StrippedBark = 66] = "StrippedBark",
        e[e.TannedLeather = 67] = "TannedLeather",
        e[e.Tannin = 68] = "Tannin",
        e[e.MilkThistleSeeds = 69] = "MilkThistleSeeds",
        e[e.TreeBark = 70] = "TreeBark",
        e[e.HoneyFungus = 71] = "HoneyFungus",
        e[e.ClematisVine = 72] = "ClematisVine",
        e[e.Twigs = 73] = "Twigs",
        e[e.Waterskin = 74] = "Waterskin",
        e[e.WoodenPole = 75] = "WoodenPole",
        e[e.PeatBandage = 76] = "PeatBandage",
        e[e.Bow = 77] = "Bow",
        e[e.BowDrill = 78] = "BowDrill",
        e[e.FishingNet = 79] = "FishingNet",
        e[e.RawCod = 80] = "RawCod",
        e[e.CookedCod = 81] = "CookedCod",
        e[e.StoneCampfire = 82] = "StoneCampfire",
        e[e.VineWhip = 83] = "VineWhip",
        e[e.PileOfSnow = 84] = "PileOfSnow",
        e[e.BarkTorch = 85] = "BarkTorch",
        e[e.LitBarkTorch = 86] = "LitBarkTorch",
        e[e.HandDrill = 87] = "HandDrill",
        e[e.SmallBag = 88] = "SmallBag",
        e[e.Shale = 89] = "Shale",
        e[e.SharpenedBone = 90] = "SharpenedBone",
        e[e.Grindstone = 91] = "Grindstone",
        e[e.RawFishSteak = 92] = "RawFishSteak",
        e[e.CookedFishSteak = 93] = "CookedFishSteak",
        e[e.WaterskinOfDesalinatedWater = 94] = "WaterskinOfDesalinatedWater",
        e[e.BoatPaddle = 95] = "BoatPaddle",
        e[e.BullBoat = 96] = "BullBoat",
        e[e.RefinedSand = 97] = "RefinedSand",
        e[e.Spyglass = 98] = "Spyglass",
        e[e.Flask = 99] = "Flask",
        e[e.RawClay = 100] = "RawClay",
        e[e.RawClayBlowpipe = 101] = "RawClayBlowpipe",
        e[e.ClayBlowpipe = 102] = "ClayBlowpipe",
        e[e.LeatherBelt = 103] = "LeatherBelt",
        e[e.LeatherTunic = 104] = "LeatherTunic",
        e[e.LeatherBoots = 105] = "LeatherBoots",
        e[e.LeatherCap = 106] = "LeatherCap",
        e[e.LeatherGorget = 107] = "LeatherGorget",
        e[e.LeatherPants = 108] = "LeatherPants",
        e[e.LeatherGloves = 109] = "LeatherGloves",
        e[e.StoneFurnace = 110] = "StoneFurnace",
        e[e.SandstoneKiln = 111] = "SandstoneKiln",
        e[e.IronTongs = 112] = "IronTongs",
        e[e.Talc = 113] = "Talc",
        e[e.TalcumPowder = 114] = "TalcumPowder",
        e[e.WoodenSandCastFlask = 115] = "WoodenSandCastFlask",
        e[e.Lens = 116] = "Lens",
        e[e.PlantRoots = 117] = "PlantRoots",
        e[e.LockPick = 118] = "LockPick",
        e[e.BoneNeedle = 119] = "BoneNeedle",
        e[e.Pineapple = 120] = "Pineapple",
        e[e.TatteredMap = 121] = "TatteredMap",
        e[e.Coal = 122] = "Coal",
        e[e.WroughtIron = 123] = "WroughtIron",
        e[e.LimestonePowder = 124] = "LimestonePowder",
        e[e.IronIngot = 125] = "IronIngot",
        e[e.Backpack = 126] = "Backpack",
        e[e.RottenMeat = 127] = "RottenMeat",
        e[e.StoneHammer = 128] = "StoneHammer",
        e[e.RawChicken = 129] = "RawChicken",
        e[e.CookedChicken = 130] = "CookedChicken",
        e[e.StoneAnvil = 131] = "StoneAnvil",
        e[e.WoodenChest = 132] = "WoodenChest",
        e[e.IronSword = 133] = "IronSword",
        e[e.IronBreastplate = 134] = "IronBreastplate",
        e[e.IronBoots = 135] = "IronBoots",
        e[e.IronHelmet = 136] = "IronHelmet",
        e[e.IronGorget = 137] = "IronGorget",
        e[e.IronGreaves = 138] = "IronGreaves",
        e[e.IronGauntlets = 139] = "IronGauntlets",
        e[e.IronShield = 140] = "IronShield",
        e[e.SandstoneWall = 141] = "SandstoneWall",
        e[e.SandstoneFlooring = 142] = "SandstoneFlooring",
        e[e.SpiderSilk = 143] = "SpiderSilk",
        e[e.AnimalFat = 144] = "AnimalFat",
        e[e.AnimalFatTorch = 145] = "AnimalFatTorch",
        e[e.ClayFlakes = 146] = "ClayFlakes",
        e[e.GreenSand = 147] = "GreenSand",
        e[e.OldInstructionalScroll = 148] = "OldInstructionalScroll",
        e[e.SlimeGelatin = 149] = "SlimeGelatin",
        e[e.SlimeGlue = 150] = "SlimeGlue",
        e[e.CookedSpiderMeat = 151] = "CookedSpiderMeat",
        e[e.SpiderMeat = 152] = "SpiderMeat",
        e[e.IronLockPick = 153] = "IronLockPick",
        e[e.RottingVegetation = 154] = "RottingVegetation",
        e[e.Chives = 155] = "Chives",
        e[e.IronHammer = 156] = "IronHammer",
        e[e.IronSpear = 157] = "IronSpear",
        e[e.IronShovel = 158] = "IronShovel",
        e[e.IronDoubleAxe = 159] = "IronDoubleAxe",
        e[e.IronPickaxe = 160] = "IronPickaxe",
        e[e.Inkstick = 161] = "Inkstick",
        e[e.Coconut = 162] = "Coconut",
        e[e.PalmLeaf = 163] = "PalmLeaf",
        e[e.Offal = 164] = "Offal",
        e[e.BoneFragments = 165] = "BoneFragments",
        e[e.LitPoleTorch = 166] = "LitPoleTorch",
        e[e.Cotton = 167] = "Cotton",
        e[e.CottonSeeds = 168] = "CottonSeeds",
        e[e.CottonFabric = 169] = "CottonFabric",
        e[e.BonePole = 170] = "BonePole",
        e[e.Tourniquet = 171] = "Tourniquet",
        e[e.WroughtIronPickaxe = 172] = "WroughtIronPickaxe",
        e[e.WroughtIronDoubleAxe = 173] = "WroughtIronDoubleAxe",
        e[e.WroughtIronShovel = 174] = "WroughtIronShovel",
        e[e.WroughtIronSpear = 175] = "WroughtIronSpear",
        e[e.WroughtIronHammer = 176] = "WroughtIronHammer",
        e[e.WroughtIronLockPick = 177] = "WroughtIronLockPick",
        e[e.WroughtIronShield = 178] = "WroughtIronShield",
        e[e.WroughtIronGauntlets = 179] = "WroughtIronGauntlets",
        e[e.WroughtIronGreaves = 180] = "WroughtIronGreaves",
        e[e.WroughtIronGorget = 181] = "WroughtIronGorget",
        e[e.WroughtIronHelmet = 182] = "WroughtIronHelmet",
        e[e.WroughtIronBoots = 183] = "WroughtIronBoots",
        e[e.WroughtIronBreastPlate = 184] = "WroughtIronBreastPlate",
        e[e.WroughtIronSword = 185] = "WroughtIronSword",
        e[e.WoodenWall = 186] = "WoodenWall",
        e[e.WoodenFlooring = 187] = "WoodenFlooring",
        e[e.WoodenDoor = 188] = "WoodenDoor",
        e[e.FishingRod = 189] = "FishingRod",
        e[e.MessageInABottle = 190] = "MessageInABottle",
        e[e.CarbonPowder = 191] = "CarbonPowder",
        e[e.PileOfCompost = 192] = "PileOfCompost",
        e[e.MeltedCopal = 193] = "MeltedCopal",
        e[e.WoodenShavings = 194] = "WoodenShavings",
        e[e.Deadfall = 195] = "Deadfall",
        e[e.Snare = 196] = "Snare",
        e[e.WaterskinOfMedicinalWater = 197] = "WaterskinOfMedicinalWater",
        e[e.CharcoalBandage = 198] = "CharcoalBandage",
        e[e.WoodenTongs = 199] = "WoodenTongs",
        e[e.WroughtIronTongs = 200] = "WroughtIronTongs",
        e[e.SheetOfGlass = 201] = "SheetOfGlass",
        e[e.SolarStill = 202] = "SolarStill",
        e[e.StoneWaterStill = 203] = "StoneWaterStill",
        e[e.Sundial = 204] = "Sundial",
        e[e.LitAnimalFatTorch = 205] = "LitAnimalFatTorch",
        e[e.Sinew = 206] = "Sinew",
        e[e.ShortBow = 207] = "ShortBow",
        e[e.LongBow = 208] = "LongBow",
        e[e.CompositeBow = 209] = "CompositeBow",
        e[e.WaterskinOfPurifiedFreshWater = 210] = "WaterskinOfPurifiedFreshWater",
        e[e.WaterskinOfUnpurifiedFreshWater = 211] = "WaterskinOfUnpurifiedFreshWater",
        e[e.GlassBottle = 212] = "GlassBottle",
        e[e.Cork = 213] = "Cork",
        e[e.GlassBottleOfSeawater = 214] = "GlassBottleOfSeawater",
        e[e.GlassBottleOfDesalinatedWater = 215] = "GlassBottleOfDesalinatedWater",
        e[e.GlassBottleOfMedicinalWater = 216] = "GlassBottleOfMedicinalWater",
        e[e.GlassBottleOfPurifiedFreshWater = 217] = "GlassBottleOfPurifiedFreshWater",
        e[e.GlassBottleOfUnpurifiedFreshWater = 218] = "GlassBottleOfUnpurifiedFreshWater",
        e[e.WroughtIronArrow = 219] = "WroughtIronArrow",
        e[e.IronArrow = 220] = "IronArrow",
        e[e.StoneBullet = 221] = "StoneBullet",
        e[e.WroughtIronBullet = 222] = "WroughtIronBullet",
        e[e.IronBullet = 223] = "IronBullet",
        e[e.LeatherQuiver = 224] = "LeatherQuiver",
        e[e.Ectoplasm = 225] = "Ectoplasm",
        e[e.MagicalEssence = 226] = "MagicalEssence",
        e[e.WoodenFence = 227] = "WoodenFence",
        e[e.CreatureIdol = 228] = "CreatureIdol",
        e[e.CordedSling = 229] = "CordedSling",
        e[e.LeatherSling = 230] = "LeatherSling",
        e[e.WroughtIronArrowhead = 231] = "WroughtIronArrowhead",
        e[e.IronArrowhead = 232] = "IronArrowhead",
        e[e.Hammock = 233] = "Hammock",
        e[e.CottonBedroll = 234] = "CottonBedroll",
        e[e.FeatherBedroll = 235] = "FeatherBedroll",
        e[e.RawTaintedMeat = 236] = "RawTaintedMeat",
        e[e.CookedTaintedMeat = 237] = "CookedTaintedMeat",
        e[e.StoneKnife = 238] = "StoneKnife",
        e[e.RawBlindfish = 239] = "RawBlindfish",
        e[e.CookedBlindfish = 240] = "CookedBlindfish",
        e[e.Pemmican = 241] = "Pemmican",
        e[e.PreparedPemmican = 242] = "PreparedPemmican",
        e[e.Sail = 243] = "Sail",
        e[e.Sailboat = 244] = "Sailboat",
        e[e.Egg = 245] = "Egg",
        e[e.BoiledEgg = 246] = "BoiledEgg",
        e[e.SheafOfHay = 247] = "SheafOfHay",
        e[e.Niter = 248] = "Niter",
        e[e.Saltpeter = 249] = "Saltpeter",
        e[e.BlackPowder = 250] = "BlackPowder",
        e[e.FlintlockPistol = 251] = "FlintlockPistol",
        e[e.Giblets = 252] = "Giblets",
        e[e.ExplosiveTrap = 253] = "ExplosiveTrap",
        e[e.SkeletalMageWand = 254] = "SkeletalMageWand",
        e[e.RawClayJug = 255] = "RawClayJug",
        e[e.ClayJug = 256] = "ClayJug",
        e[e.ClayJugOfSeawater = 257] = "ClayJugOfSeawater",
        e[e.ClayJugOfDesalinatedWater = 258] = "ClayJugOfDesalinatedWater",
        e[e.ClayJugOfMedicinalWater = 259] = "ClayJugOfMedicinalWater",
        e[e.ClayJugOfPurifiedFreshWater = 260] = "ClayJugOfPurifiedFreshWater",
        e[e.ClayJugOfUnpurifiedFreshWater = 261] = "ClayJugOfUnpurifiedFreshWater",
        e[e.RawClayBrick = 262] = "RawClayBrick",
        e[e.ClayBrick = 263] = "ClayBrick",
        e[e.ClayBrickWall = 264] = "ClayBrickWall",
        e[e.ClayBrickFlooring = 265] = "ClayBrickFlooring",
        e[e.PineappleSeeds = 266] = "PineappleSeeds",
        e[e.RaspberrySeeds = 267] = "RaspberrySeeds",
        e[e.PricklyPearSeeds = 268] = "PricklyPearSeeds",
        e[e.ClematisSeeds = 269] = "ClematisSeeds",
        e[e.PaperSheet = 270] = "PaperSheet",
        e[e.PaperMold = 271] = "PaperMold",
        e[e.Beggarticks = 272] = "Beggarticks",
        e[e.MilkThistleFlowers = 273] = "MilkThistleFlowers",
        e[e.DrawnMap = 274] = "DrawnMap",
        e[e.TatteredShirt = 275] = "TatteredShirt",
        e[e.TatteredPants = 276] = "TatteredPants",
        e[e.WoodenGate = 277] = "WoodenGate",
        e[e.PoisonIvyLeaves = 278] = "PoisonIvyLeaves",
        e[e.PoisonIvySeeds = 279] = "PoisonIvySeeds",
        e[e.WroughtIronChest = 280] = "WroughtIronChest",
        e[e.IronChest = 281] = "IronChest",
        e[e.SwitchgrassSeeds = 282] = "SwitchgrassSeeds",
        e[e.Apple = 283] = "Apple",
        e[e.SpiderEggs = 284] = "SpiderEggs",
        e[e.TailFeathers = 285] = "TailFeathers",
        e[e.AppleSeeds = 286] = "AppleSeeds",
        e[e.VenomGland = 287] = "VenomGland",
        e[e.OrnateWoodenChest = 288] = "OrnateWoodenChest",
        e[e.RollOfRedCarpet = 289] = "RollOfRedCarpet",
        e[e.OrnateCape = 290] = "OrnateCape",
        e[e.FireBladder = 291] = "FireBladder",
        e[e.GoldenKey = 292] = "GoldenKey",
        e[e.WoodenSword = 293] = "WoodenSword",
        e[e.ClayKiln = 294] = "ClayKiln",
        e[e.ClayCampfire = 295] = "ClayCampfire",
        e[e.ClayFurnace = 296] = "ClayFurnace",
        e[e.ClayWaterStill = 297] = "ClayWaterStill",
        e[e.SandstoneCampfire = 298] = "SandstoneCampfire",
        e[e.SandstoneFurnace = 299] = "SandstoneFurnace",
        e[e.SandstoneWaterStill = 300] = "SandstoneWaterStill",
        e[e.StoneKiln = 301] = "StoneKiln",
        e[e.WroughtIronAnvil = 302] = "WroughtIronAnvil",
        e[e.IronAnvil = 303] = "IronAnvil",
        e[e.MageRobe = 304] = "MageRobe",
        e[e.OrbOfInfluence = 305] = "OrbOfInfluence",
        e[e.AnimalClaw = 306] = "AnimalClaw",
        e[e.AnimalPelt = 307] = "AnimalPelt",
        e[e.AnimalFur = 308] = "AnimalFur",
        e[e.Scales = 309] = "Scales",
        e[e.SharkFin = 310] = "SharkFin",
        e[e.RawReptileMeat = 311] = "RawReptileMeat",
        e[e.CookedReptileMeat = 312] = "CookedReptileMeat",
        e[e.Tentacles = 313] = "Tentacles",
        e[e.CookedTentacles = 314] = "CookedTentacles",
        e[e.WormMeat = 315] = "WormMeat",
        e[e.CookedWormMeat = 316] = "CookedWormMeat",
        e[e.StonePickaxe = 317] = "StonePickaxe",
        e[e.WroughtIronAxe = 318] = "WroughtIronAxe",
        e[e.IronAxe = 319] = "IronAxe",
        e[e.FertileSoil = 320] = "FertileSoil",
        e[e.StoneHoe = 321] = "StoneHoe",
        e[e.WroughtIronHoe = 322] = "WroughtIronHoe",
        e[e.IronHoe = 323] = "IronHoe",
        e[e.LavaBeetleHelmet = 324] = "LavaBeetleHelmet",
        e[e.SpruceCone = 325] = "SpruceCone",
        e[e.SpruceSeeds = 326] = "SpruceSeeds",
        e[e.SpruceNeedles = 327] = "SpruceNeedles",
        e[e.CypressCone = 328] = "CypressCone",
        e[e.CypressSeeds = 329] = "CypressSeeds",
        e[e.CypressLeaves = 330] = "CypressLeaves",
        e[e.Lettuce = 331] = "Lettuce",
        e[e.LettuceSeeds = 332] = "LettuceSeeds",
        e[e.ChiveSeeds = 333] = "ChiveSeeds",
        e[e.Potato = 334] = "Potato",
        e[e.PotatoSeeds = 335] = "PotatoSeeds",
        e[e.Carrot = 336] = "Carrot",
        e[e.CarrotSeeds = 337] = "CarrotSeeds",
        e[e.CornEar = 338] = "CornEar",
        e[e.CornSeeds = 339] = "CornSeeds",
        e[e.Cucumber = 340] = "Cucumber",
        e[e.CucumberSeeds = 341] = "CucumberSeeds",
        e[e.Tomato = 342] = "Tomato",
        e[e.TomatoSeeds = 343] = "TomatoSeeds",
        e[e.Pumpkin = 344] = "Pumpkin",
        e[e.PumpkinSeeds = 345] = "PumpkinSeeds",
        e[e.PricklyPearFruit = 346] = "PricklyPearFruit",
        e[e.SugarCaneStalks = 347] = "SugarCaneStalks",
        e[e.SugarCaneSeeds = 348] = "SugarCaneSeeds",
        e[e.BushelOfWheat = 349] = "BushelOfWheat",
        e[e.Wheat = 350] = "Wheat",
        e[e.CookedPotato = 351] = "CookedPotato",
        e[e.CookedCornCob = 352] = "CookedCornCob",
        e[e.BundleOfSwitchgrass = 353] = "BundleOfSwitchgrass",
        e[e.Cloak = 354] = "Cloak",
        e[e.WoodenMortarAndPestle = 355] = "WoodenMortarAndPestle",
        e[e.SandstoneMortarAndPestle = 356] = "SandstoneMortarAndPestle",
        e[e.WroughtIronMortarAndPestle = 357] = "WroughtIronMortarAndPestle",
        e[e.IronMortarAndPestle = 358] = "IronMortarAndPestle",
        e[e.RawClayMortarAndPestle = 359] = "RawClayMortarAndPestle",
        e[e.ClayMortarAndPestle = 360] = "ClayMortarAndPestle",
        e[e.CopperOre = 361] = "CopperOre",
        e[e.CopperIngot = 362] = "CopperIngot",
        e[e.CopperPickaxe = 363] = "CopperPickaxe",
        e[e.CopperDoubleAxe = 364] = "CopperDoubleAxe",
        e[e.CopperShovel = 365] = "CopperShovel",
        e[e.CopperSpear = 366] = "CopperSpear",
        e[e.CopperHammer = 367] = "CopperHammer",
        e[e.CopperLockPick = 368] = "CopperLockPick",
        e[e.CopperShield = 369] = "CopperShield",
        e[e.CopperGauntlets = 370] = "CopperGauntlets",
        e[e.CopperGreaves = 371] = "CopperGreaves",
        e[e.CopperGorget = 372] = "CopperGorget",
        e[e.CopperHelmet = 373] = "CopperHelmet",
        e[e.CopperBoots = 374] = "CopperBoots",
        e[e.CopperBreastPlate = 375] = "CopperBreastPlate",
        e[e.CopperSword = 376] = "CopperSword",
        e[e.CopperTongs = 377] = "CopperTongs",
        e[e.CopperArrow = 378] = "CopperArrow",
        e[e.CopperBullet = 379] = "CopperBullet",
        e[e.CopperArrowhead = 380] = "CopperArrowhead",
        e[e.CopperChest = 381] = "CopperChest",
        e[e.CopperAnvil = 382] = "CopperAnvil",
        e[e.CopperAxe = 383] = "CopperAxe",
        e[e.CopperHoe = 384] = "CopperHoe",
        e[e.CopperMortarAndPestle = 385] = "CopperMortarAndPestle",
        e[e.WaterskinOfGoatMilk = 386] = "WaterskinOfGoatMilk",
        e[e.ClayJugOfGoatMilk = 387] = "ClayJugOfGoatMilk",
        e[e.GlassBottleOfGoatMilk = 388] = "GlassBottleOfGoatMilk",
        e[e.Obsidian = 389] = "Obsidian",
        e[e.OrnateBlueBook = 390] = "OrnateBlueBook",
        e[e.Journal = 391] = "Journal",
        e[e.MossCoveredBook = 392] = "MossCoveredBook",
        e[e.GildedRedBook = 393] = "GildedRedBook",
        e[e.ArrowShaft = 394] = "ArrowShaft",
        e[e.SlitherSucker = 395] = "SlitherSucker",
        e[e.AberrantSlitherSucker = 396] = "AberrantSlitherSucker",
        e[e.StrawHat = 397] = "StrawHat",
        e[e.BlackplateBoots = 398] = "BlackplateBoots",
        e[e.BlackplateBreastplate = 399] = "BlackplateBreastplate",
        e[e.BlackplateGauntlets = 400] = "BlackplateGauntlets",
        e[e.BlackplateGorget = 401] = "BlackplateGorget",
        e[e.BlackplateGreaves = 402] = "BlackplateGreaves",
        e[e.BlackplateHelmet = 403] = "BlackplateHelmet",
        e[e.DeathKnightAxe = 404] = "DeathKnightAxe",
        e[e.Macuahuitl = 405] = "Macuahuitl",
        e[e.ObsidianArrow = 406] = "ObsidianArrow",
        e[e.ObsidianArrowhead = 407] = "ObsidianArrowhead",
        e[e.ObsidianAxe = 408] = "ObsidianAxe",
        e[e.ObsidianKnife = 409] = "ObsidianKnife",
        e[e.ObsidianShovel = 410] = "ObsidianShovel",
        e[e.ObsidianSpear = 411] = "ObsidianSpear",
        e[e.TumbleweedSeeds = 412] = "TumbleweedSeeds",
        e[e.CoconutHusk = 413] = "CoconutHusk",
        e[e.PeeledCoconut = 414] = "PeeledCoconut",
        e[e.CoconutMeat = 415] = "CoconutMeat",
        e[e.CoconutContainerOfCoconutWater = 416] = "CoconutContainerOfCoconutWater",
        e[e.CoconutContainer = 417] = "CoconutContainer",
        e[e.CoconutContainerOfSeawater = 418] = "CoconutContainerOfSeawater",
        e[e.CoconutContainerOfDesalinatedWater = 419] = "CoconutContainerOfDesalinatedWater",
        e[e.CoconutContainerOfMedicinalWater = 420] = "CoconutContainerOfMedicinalWater",
        e[e.CoconutContainerOfPurifiedFreshWater = 421] = "CoconutContainerOfPurifiedFreshWater",
        e[e.CoconutContainerOfUnpurifiedFreshWater = 422] = "CoconutContainerOfUnpurifiedFreshWater",
        e[e.CoconutContainerOfGoatMilk = 423] = "CoconutContainerOfGoatMilk",
        e[e.OldEducationalScroll = 424] = "OldEducationalScroll",
        e[e.StrippedLeather = 425] = "StrippedLeather",
        e[e.ClaySandCastFlask = 426] = "ClaySandCastFlask",
        e[e.SandstoneSandCastFlask = 427] = "SandstoneSandCastFlask",
        e[e.StoneSandCastFlask = 428] = "StoneSandCastFlask",
        e[e.AnimalGlue = 429] = "AnimalGlue",
        e[e.CopalResin = 430] = "CopalResin",
        e[e.BoneMeal = 431] = "BoneMeal",
        e[e.PileOfDesertSand = 432] = "PileOfDesertSand",
        e[e.JoshuaTreeLeaves = 433] = "JoshuaTreeLeaves",
        e[e.JoshuaTreeFruit = 434] = "JoshuaTreeFruit",
        e[e.JoshuaTreeSeeds = 435] = "JoshuaTreeSeeds",
        e[e.CookedJoshuaTreeFruit = 436] = "CookedJoshuaTreeFruit",
        e[e.JoshuaTreeFlowers = 437] = "JoshuaTreeFlowers",
        e[e.SaguaroCactusFruit = 438] = "SaguaroCactusFruit",
        e[e.SaguaroCactusSeeds = 439] = "SaguaroCactusSeeds",
        e[e.SaguaroCactusChunk = 440] = "SaguaroCactusChunk",
        e[e.StoneWell = 441] = "StoneWell",
        e[e.SandstoneWell = 442] = "SandstoneWell",
        e[e.ClayBrickWell = 443] = "ClayBrickWell",
        e[e.AloeVeraLeaves = 444] = "AloeVeraLeaves",
        e[e.AloeVeraSeeds = 445] = "AloeVeraSeeds",
        e[e.DeadScorpion = 446] = "DeadScorpion",
        e[e.DeadAberrantScorpion = 447] = "DeadAberrantScorpion",
        e[e.CookedScorpion = 448] = "CookedScorpion",
        e[e.CookedAberrantScorpion = 449] = "CookedAberrantScorpion",
        e[e.ScorpionStinger = 450] = "ScorpionStinger",
        e[e.CopperBakingTray = 451] = "CopperBakingTray",
        e[e.WroughtIronBakingTray = 452] = "WroughtIronBakingTray",
        e[e.IronBakingTray = 453] = "IronBakingTray",
        e[e.Flour = 454] = "Flour",
        e[e.Dough = 455] = "Dough",
        e[e.Hardtack = 456] = "Hardtack",
        e[e.HitchingPost = 457] = "HitchingPost",
        e[e.ShreddedPaper = 458] = "ShreddedPaper"
    }(T = t.ItemType || (t.ItemType = {})),
    function(e) {
        e[e.Invalid = 800] = "Invalid",
        e[e.Sharpened = 801] = "Sharpened",
        e[e.Carbon = 802] = "Carbon",
        e[e.Arrow = 803] = "Arrow",
        e[e.CookingEquipment = 804] = "CookingEquipment",
        e[e.Fuel = 805] = "Fuel",
        e[e.Medicinal = 806] = "Medicinal",
        e[e.Meat = 807] = "Meat",
        e[e.Food = 808] = "Food",
        e[e.Bait = 809] = "Bait",
        e[e.Liquid = 810] = "Liquid",
        e[e.Treasure = 811] = "Treasure",
        e[e.Rock = 812] = "Rock",
        e[e.Compost = 813] = "Compost",
        e[e.Fabric = 814] = "Fabric",
        e[e.Needle = 815] = "Needle",
        e[e.Cordage = 816] = "Cordage",
        e[e.SharpenedRock = 817] = "SharpenedRock",
        e[e.Container = 818] = "Container",
        e[e.Pole = 819] = "Pole",
        e[e.LightSource = 820] = "LightSource",
        e[e.Repair = 821] = "Repair",
        e[e.Tongs = 822] = "Tongs",
        e[e.Hammer = 823] = "Hammer",
        e[e.Preservative = 824] = "Preservative",
        e[e.Reinforce = 825] = "Reinforce",
        e[e.GlassBottleOfPotableWater = 826] = "GlassBottleOfPotableWater",
        e[e.Bullet = 827] = "Bullet",
        e[e.Transmogrify = 828] = "Transmogrify",
        e[e.WaterskinOfPotableWater = 829] = "WaterskinOfPotableWater",
        e[e.Pulp = 830] = "Pulp",
        e[e.ClayJugOfPotableWater = 831] = "ClayJugOfPotableWater",
        e[e.Powder = 832] = "Powder",
        e[e.Equipment = 833] = "Equipment",
        e[e.Firemaking = 834] = "Firemaking",
        e[e.Bedding = 835] = "Bedding",
        e[e.Tool = 836] = "Tool",
        e[e.Weapon = 837] = "Weapon",
        e[e.Health = 838] = "Health",
        e[e.Travel = 839] = "Travel",
        e[e.Housing = 840] = "Housing",
        e[e.Heating = 841] = "Heating",
        e[e.Storage = 842] = "Storage",
        e[e.Trap = 843] = "Trap",
        e[e.Other = 844] = "Other",
        e[e.RawMeat = 845] = "RawMeat",
        e[e.CookedMeat = 846] = "CookedMeat",
        e[e.ContainerOfSeawater = 847] = "ContainerOfSeawater",
        e[e.ContainerOfDesalinatedWater = 848] = "ContainerOfDesalinatedWater",
        e[e.ContainerOfMedicinalWater = 849] = "ContainerOfMedicinalWater",
        e[e.ContainerOfPurifiedFreshWater = 850] = "ContainerOfPurifiedFreshWater",
        e[e.ContainerOfUnpurifiedFreshWater = 851] = "ContainerOfUnpurifiedFreshWater",
        e[e.Campfire = 852] = "Campfire",
        e[e.Furnace = 853] = "Furnace",
        e[e.Kiln = 854] = "Kiln",
        e[e.WaterStill = 855] = "WaterStill",
        e[e.Anvil = 856] = "Anvil",
        e[e.Seed = 857] = "Seed",
        e[e.Fruit = 858] = "Fruit",
        e[e.Vegetable = 859] = "Vegetable",
        e[e.Tinder = 860] = "Tinder",
        e[e.Bone = 861] = "Bone",
        e[e.Kindling = 862] = "Kindling",
        e[e.MortarAndPestle = 863] = "MortarAndPestle",
        e[e.Milk = 864] = "Milk",
        e[e.Book = 865] = "Book",
        e[e.CoconutContainerOfPotableWater = 866] = "CoconutContainerOfPotableWater",
        e[e.SandCastFlask = 867] = "SandCastFlask",
        e[e.Glue = 868] = "Glue",
        e[e.FireStarter = 869] = "FireStarter",
        e[e.Sand = 870] = "Sand",
        e[e.Untradable = 871] = "Untradable",
        e[e.Cookware = 872] = "Cookware",
        e[e.LitTorch = 873] = "LitTorch",
        e[e.Last = 874] = "Last"
    }(S = t.ItemTypeGroup || (t.ItemTypeGroup = {})),
    function(e) {
        e[e.DeepSeawater = 0] = "DeepSeawater",
        e[e.Seawater = 1] = "Seawater",
        e[e.ShallowSeawater = 2] = "ShallowSeawater",
        e[e.DeepFreshWater = 3] = "DeepFreshWater",
        e[e.FreshWater = 4] = "FreshWater",
        e[e.ShallowFreshWater = 5] = "ShallowFreshWater",
        e[e.Grass = 6] = "Grass",
        e[e.Gravel = 7] = "Gravel",
        e[e.Dirt = 8] = "Dirt",
        e[e.BeachSand = 9] = "BeachSand",
        e[e.Snow = 10] = "Snow",
        e[e.Swamp = 11] = "Swamp",
        e[e.Clay = 12] = "Clay",
        e[e.Ash = 13] = "Ash",
        e[e.Rocks = 14] = "Rocks",
        e[e.RocksWithIron = 15] = "RocksWithIron",
        e[e.RocksWithTalc = 16] = "RocksWithTalc",
        e[e.RocksWithCoal = 17] = "RocksWithCoal",
        e[e.RocksWithLimestone = 18] = "RocksWithLimestone",
        e[e.CobblestoneFlooring = 19] = "CobblestoneFlooring",
        e[e.Sandstone = 20] = "Sandstone",
        e[e.SandstoneFlooring = 21] = "SandstoneFlooring",
        e[e.SandstoneWithIron = 22] = "SandstoneWithIron",
        e[e.SandstoneWithNiter = 23] = "SandstoneWithNiter",
        e[e.WoodenFlooring = 24] = "WoodenFlooring",
        e[e.ClayBrickFlooring = 25] = "ClayBrickFlooring",
        e[e.CaveEntrance = 26] = "CaveEntrance",
        e[e.RedCarpet = 27] = "RedCarpet",
        e[e.Lava = 28] = "Lava",
        e[e.FertileSoil = 29] = "FertileSoil",
        e[e.RocksWithCopper = 30] = "RocksWithCopper",
        e[e.SandstoneWithCopper = 31] = "SandstoneWithCopper",
        e[e.CoolingLava = 32] = "CoolingLava",
        e[e.Obsidian = 33] = "Obsidian",
        e[e.DesertSand = 34] = "DesertSand"
    }(I = t.TerrainType || (t.TerrainType = {})),
    function(e) {
        e[e.WoodenDoor = 0] = "WoodenDoor",
        e[e.WoodenFence = 1] = "WoodenFence",
        e[e.WoodenWall = 2] = "WoodenWall",
        e[e.ClayBrickWall = 3] = "ClayBrickWall",
        e[e.SandstoneWall = 4] = "SandstoneWall",
        e[e.StoneWall = 5] = "StoneWall",
        e[e.SetExplosiveTrap = 6] = "SetExplosiveTrap",
        e[e.SetDeadfall = 7] = "SetDeadfall",
        e[e.SetSnare = 8] = "SetSnare",
        e[e.SetHobgoblinSnare = 9] = "SetHobgoblinSnare",
        e[e.SolarStill = 10] = "SolarStill",
        e[e.WoodenChest = 11] = "WoodenChest",
        e[e.LockedWoodenChest = 12] = "LockedWoodenChest",
        e[e.CreatureIdol = 13] = "CreatureIdol",
        e[e.Grass = 14] = "Grass",
        e[e.Clematis = 15] = "Clematis",
        e[e.MilkThistles = 16] = "MilkThistles",
        e[e.ButtonMushrooms = 17] = "ButtonMushrooms",
        e[e.FlyAmanita = 18] = "FlyAmanita",
        e[e.Switchgrass = 19] = "Switchgrass",
        e[e.Badderlocks = 20] = "Badderlocks",
        e[e.Chives = 21] = "Chives",
        e[e.Pineapple = 22] = "Pineapple",
        e[e.PileOfRocks = 23] = "PileOfRocks",
        e[e.RaspberryBush = 24] = "RaspberryBush",
        e[e.Beggarticks = 25] = "Beggarticks",
        e[e.Cotton = 26] = "Cotton",
        e[e.PricklyPears = 27] = "PricklyPears",
        e[e.Tumbleweed = 28] = "Tumbleweed",
        e[e.StoneWaterStill = 29] = "StoneWaterStill",
        e[e.LitStoneWaterStill = 30] = "LitStoneWaterStill",
        e[e.StoneCampfire = 31] = "StoneCampfire",
        e[e.LitStoneCampfire = 32] = "LitStoneCampfire",
        e[e.SandstoneKiln = 33] = "SandstoneKiln",
        e[e.LitSandstoneKiln = 34] = "LitSandstoneKiln",
        e[e.StoneFurnace = 35] = "StoneFurnace",
        e[e.LitStoneFurnace = 36] = "LitStoneFurnace",
        e[e.PoleTorchStand = 37] = "PoleTorchStand",
        e[e.LitPoleTorchStand = 38] = "LitPoleTorchStand",
        e[e.StoneAnvil = 39] = "StoneAnvil",
        e[e.Acid = 40] = "Acid",
        e[e.CaveEntrance = 41] = "CaveEntrance",
        e[e.WoodenDoorOpen = 42] = "WoodenDoorOpen",
        e[e.WoodenGate = 43] = "WoodenGate",
        e[e.WoodenGateOpen = 44] = "WoodenGateOpen",
        e[e.PoisonIvy = 45] = "PoisonIvy",
        e[e.WroughtIronChest = 46] = "WroughtIronChest",
        e[e.IronChest = 47] = "IronChest",
        e[e.OrnateWoodenChest = 48] = "OrnateWoodenChest",
        e[e.SkeletalRemains = 49] = "SkeletalRemains",
        e[e.ClayKiln = 50] = "ClayKiln",
        e[e.LitClayKiln = 51] = "LitClayKiln",
        e[e.ClayCampfire = 52] = "ClayCampfire",
        e[e.LitClayCampfire = 53] = "LitClayCampfire",
        e[e.ClayFurnace = 54] = "ClayFurnace",
        e[e.LitClayFurnace = 55] = "LitClayFurnace",
        e[e.ClayWaterStill = 56] = "ClayWaterStill",
        e[e.LitClayWaterStill = 57] = "LitClayWaterStill",
        e[e.SandstoneCampfire = 58] = "SandstoneCampfire",
        e[e.LitSandstoneCampfire = 59] = "LitSandstoneCampfire",
        e[e.SandstoneFurnace = 60] = "SandstoneFurnace",
        e[e.LitSandstoneFurnace = 61] = "LitSandstoneFurnace",
        e[e.SandstoneWaterStill = 62] = "SandstoneWaterStill",
        e[e.LitSandstoneWaterStill = 63] = "LitSandstoneWaterStill",
        e[e.StoneKiln = 64] = "StoneKiln",
        e[e.LitStoneKiln = 65] = "LitStoneKiln",
        e[e.WroughtIronAnvil = 66] = "WroughtIronAnvil",
        e[e.IronAnvil = 67] = "IronAnvil",
        e[e.MapleTree = 68] = "MapleTree",
        e[e.AppleTree = 69] = "AppleTree",
        e[e.SpruceTree = 70] = "SpruceTree",
        e[e.CypressTree = 71] = "CypressTree",
        e[e.CoconutTree = 72] = "CoconutTree",
        e[e.Lettuce = 73] = "Lettuce",
        e[e.PotatoPlant = 74] = "PotatoPlant",
        e[e.Carrots = 75] = "Carrots",
        e[e.CornStalks = 76] = "CornStalks",
        e[e.CucumberPlant = 77] = "CucumberPlant",
        e[e.TomatoPlant = 78] = "TomatoPlant",
        e[e.Pumpkin = 79] = "Pumpkin",
        e[e.SugarCaneStalks = 80] = "SugarCaneStalks",
        e[e.Wheat = 81] = "Wheat",
        e[e.CopperChest = 82] = "CopperChest",
        e[e.CopperAnvil = 83] = "CopperAnvil",
        e[e.BarkTorchStand = 84] = "BarkTorchStand",
        e[e.LitBarkTorchStand = 85] = "LitBarkTorchStand",
        e[e.AnimalFatTorchStand = 86] = "AnimalFatTorchStand",
        e[e.LitAnimalFatTorchStand = 87] = "LitAnimalFatTorchStand",
        e[e.Item = 88] = "Item",
        e[e.JoshuaTree = 89] = "JoshuaTree",
        e[e.SaguaroCactus = 90] = "SaguaroCactus",
        e[e.AloeVera = 91] = "AloeVera"
    }(v = t.DoodadType || (t.DoodadType = {})),
    function(e) {
        e[e.Invalid = 400] = "Invalid",
        e[e.LitCampfire = 401] = "LitCampfire",
        e[e.LitFurnace = 402] = "LitFurnace",
        e[e.LitKiln = 403] = "LitKiln",
        e[e.LitWaterStill = 404] = "LitWaterStill",
        e[e.Anvil = 405] = "Anvil",
        e[e.Well = 406] = "Well",
        e[e.Hitch = 407] = "Hitch",
        e[e.GatheredPlant = 408] = "GatheredPlant",
        e[e.Last = 409] = "Last"
    }(w = t.DoodadTypeGroup || (t.DoodadTypeGroup = {})),
    function(e) {
        e[e.Germinating = 0] = "Germinating",
        e[e.Seedling = 1] = "Seedling",
        e[e.Vegetative = 2] = "Vegetative",
        e[e.Budding = 3] = "Budding",
        e[e.Flowering = 4] = "Flowering",
        e[e.Ripening = 5] = "Ripening",
        e[e.Dead = 6] = "Dead"
    }(M = t.GrowingStage || (t.GrowingStage = {})),
    function(e) {
        e[e.RandomEvent = 0] = "RandomEvent",
        e[e.IslandPresence = 1] = "IslandPresence",
        e[e.Treasure = 2] = "Treasure",
        e[e.Deities = 3] = "Deities",
        e[e.PastCivilizations = 4] = "PastCivilizations",
        e[e.SandCasting = 5] = "SandCasting",
        e[e.WanderingMerchants = 6] = "WanderingMerchants",
        e[e.TrappersJournal = 7] = "TrappersJournal",
        e[e.TheForce = 8] = "TheForce",
        e[e.IslandRiddle = 9] = "IslandRiddle",
        e[e.Trapped = 10] = "Trapped"
    }(b = t.BookType || (t.BookType = {})),
    function(e) {
        e[e.Slime = 0] = "Slime",
        e[e.JellyCube = 1] = "JellyCube",
        e[e.GiantSpider = 2] = "GiantSpider",
        e[e.Bear = 3] = "Bear",
        e[e.Rabbit = 4] = "Rabbit",
        e[e.Snake = 5] = "Snake",
        e[e.GiantRat = 6] = "GiantRat",
        e[e.Rat = 7] = "Rat",
        e[e.VampireBat = 8] = "VampireBat",
        e[e.GreyWolf = 9] = "GreyWolf",
        e[e.Imp = 10] = "Imp",
        e[e.Bogling = 11] = "Bogling",
        e[e.LivingRock = 12] = "LivingRock",
        e[e.Shark = 13] = "Shark",
        e[e.Zombie = 14] = "Zombie",
        e[e.Skeleton = 15] = "Skeleton",
        e[e.PirateGhost = 16] = "PirateGhost",
        e[e.TimeSkitter = 17] = "TimeSkitter",
        e[e.Chicken = 18] = "Chicken",
        e[e.TrapdoorSpider = 19] = "TrapdoorSpider",
        e[e.FireElemental = 20] = "FireElemental",
        e[e.Cod = 21] = "Cod",
        e[e.Hobgoblin = 22] = "Hobgoblin",
        e[e.LivingMushroom = 23] = "LivingMushroom",
        e[e.Kraken = 24] = "Kraken",
        e[e.Blindfish = 25] = "Blindfish",
        e[e.Harpy = 26] = "Harpy",
        e[e.AcidSpitterDemon = 27] = "AcidSpitterDemon",
        e[e.SkeletalMage = 28] = "SkeletalMage",
        e[e.Blood = 29] = "Blood",
        e[e.ClawWorm = 30] = "ClawWorm",
        e[e.Drake = 31] = "Drake",
        e[e.Sandcat = 32] = "Sandcat",
        e[e.WaterBlood = 33] = "WaterBlood",
        e[e.LavaBeetle = 34] = "LavaBeetle",
        e[e.Goat = 35] = "Goat",
        e[e.SlitherSucker = 36] = "SlitherSucker",
        e[e.Mudskipper = 37] = "Mudskipper",
        e[e.Scorpion = 38] = "Scorpion",
        e[e.Rattlesnake = 39] = "Rattlesnake",
        e[e.AntelopeJackrabbit = 40] = "AntelopeJackrabbit"
    }(k = t.CreatureType || (t.CreatureType = {})),
    function(e) {
        e[e.Merchant = 0] = "Merchant",
        e[e.DeathKnight = 1] = "DeathKnight"
    }(C = t.NPCType || (t.NPCType = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Spike = 1] = "Spike",
        e[e.Bun = 2] = "Bun",
        e[e.Ponytail = 3] = "Ponytail",
        e[e.Afro = 4] = "Afro",
        e[e.Bouncy = 5] = "Bouncy",
        e[e.Dreads = 6] = "Dreads",
        e[e.Shaved = 7] = "Shaved",
        e[e.Long = 8] = "Long",
        e[e.Mohawk = 9] = "Mohawk"
    }(D = t.HairStyle || (t.HairStyle = {})),
    function(e) {
        e[e["#e7c978"] = 0] = "#e7c978",
        e[e["#b9793d"] = 1] = "#b9793d",
        e[e["#b84627"] = 2] = "#b84627",
        e[e["#7f3721"] = 3] = "#7f3721",
        e[e["#7e4b1c"] = 4] = "#7e4b1c",
        e[e["#422116"] = 5] = "#422116",
        e[e["#28222a"] = 6] = "#28222a",
        e[e["#bfb0a8"] = 7] = "#bfb0a8",
        e[e["#ffffff"] = 8] = "#ffffff"
    }(A = t.HairColor || (t.HairColor = {})),
    function(e) {
        e[e["#fddcd4"] = 0] = "#fddcd4",
        e[e["#d6be93"] = 1] = "#d6be93",
        e[e["#f0ceab"] = 2] = "#f0ceab",
        e[e["#c7a077"] = 3] = "#c7a077",
        e[e["#d89a72"] = 4] = "#d89a72",
        e[e["#89623a"] = 5] = "#89623a",
        e[e["#88563b"] = 6] = "#88563b",
        e[e["#613429"] = 7] = "#613429",
        e[e["#361e1c"] = 8] = "#361e1c"
    }(P = t.SkinColor || (t.SkinColor = {})),
    function(e) {
        e[e.Chemistry = 0] = "Chemistry",
        e[e.Anatomy = 1] = "Anatomy",
        e[e.Marksmanship = 2] = "Marksmanship",
        e[e.Blacksmithing = 3] = "Blacksmithing",
        e[e.Botany = 4] = "Botany",
        e[e.Camping = 5] = "Camping",
        e[e.Cartography = 6] = "Cartography",
        e[e.Claythrowing = 7] = "Claythrowing",
        e[e.Cooking = 8] = "Cooking",
        e[e.Fishing = 9] = "Fishing",
        e[e.Fletching = 10] = "Fletching",
        e[e.Glassblowing = 11] = "Glassblowing",
        e[e.Leatherworking = 12] = "Leatherworking",
        e[e.LockPicking = 13] = "LockPicking",
        e[e.Lumberjacking = 14] = "Lumberjacking",
        e[e.Mining = 15] = "Mining",
        e[e.Mycology = 16] = "Mycology",
        e[e.Parrying = 17] = "Parrying",
        e[e.Stonecrafting = 18] = "Stonecrafting",
        e[e.Swimming = 19] = "Swimming",
        e[e.Tactics = 20] = "Tactics",
        e[e.Tailoring = 21] = "Tailoring",
        e[e.Throwing = 22] = "Throwing",
        e[e.Tinkering = 23] = "Tinkering",
        e[e.Trapping = 24] = "Trapping",
        e[e.Woodworking = 25] = "Woodworking",
        e[e.Taming = 26] = "Taming",
        e[e.Gardening = 27] = "Gardening",
        e[e.Bartering = 28] = "Bartering"
    }(G = t.SkillType || (t.SkillType = {})),
    function(e) {
        e[e.Shipwrecked = 0] = "Shipwrecked",
        e[e.OpeningTheme = 1] = "OpeningTheme",
        e[e.DarkerWorld = 2] = "DarkerWorld",
        e[e.Crux = 3] = "Crux",
        e[e.TheFirstSpark = 4] = "TheFirstSpark",
        e[e.HauntingInterlude = 5] = "HauntingInterlude",
        e[e.NomadsHeartBeat = 6] = "NomadsHeartBeat",
        e[e.LootStep = 7] = "LootStep",
        e[e.PerilsOfPlunder = 8] = "PerilsOfPlunder",
        e[e.DreamInterlude = 9] = "DreamInterlude",
        e[e.TheWildBorn = 10] = "TheWildBorn",
        e[e.NightOwl = 11] = "NightOwl",
        e[e.SurvivalInstinct = 12] = "SurvivalInstinct",
        e[e.Savage = 13] = "Savage",
        e[e.Underworld = 14] = "Underworld",
        e[e.ThirdSunrise = 15] = "ThirdSunrise",
        e[e.WistfulInterlude = 16] = "WistfulInterlude",
        e[e.ShudderSounds = 17] = "ShudderSounds"
    }(R = t.Music || (t.Music = {})),
    function(e) {
        e[e.Bow = 0] = "Bow",
        e[e.Craft = 1] = "Craft",
        e[e.Death = 2] = "Death",
        e[e.Eating = 3] = "Eating",
        e[e.Exceptional = 4] = "Exceptional",
        e[e.Fail = 5] = "Fail",
        e[e.TreeHit = 6] = "TreeHit",
        e[e.Hit = 7] = "Hit",
        e[e.Hurt = 8] = "Hurt",
        e[e.Miss = 9] = "Miss",
        e[e.CreatureHit = 10] = "CreatureHit",
        e[e.CreatureNoise = 11] = "CreatureNoise",
        e[e.PickUp = 12] = "PickUp",
        e[e.RockHit = 13] = "RockHit",
        e[e.SandstoneHit = 14] = "SandstoneHit",
        e[e.Swim = 15] = "Swim",
        e[e.Throw = 16] = "Throw",
        e[e.Trample = 17] = "Trample",
        e[e.Walk = 18] = "Walk",
        e[e.Water = 19] = "Water",
        e[e.Click = 20] = "Click",
        e[e.Damaged = 21] = "Damaged",
        e[e.Chat = 22] = "Chat",
        e[e.UiSelect = 23] = "UiSelect",
        e[e.UiActivate = 24] = "UiActivate"
    }(x = t.SfxType || (t.SfxType = {})),
    function(e) {
        e[e.Commands = 0] = "Commands",
        e[e.Players = 1] = "Players",
        e[e.Ping = 2] = "Ping",
        e[e.Kick = 3] = "Kick",
        e[e.Banned = 4] = "Banned",
        e[e.Ban = 5] = "Ban",
        e[e.Unban = 6] = "Unban",
        e[e.Pause = 7] = "Pause",
        e[e.Save = 8] = "Save"
    }(B = t.Command || (t.Command = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Dead = 1] = "Dead",
        e[e.Won = 2] = "Won",
        e[e.Traveling = 3] = "Traveling",
        e[e.Ghost = 4] = "Ghost",
        e[e.Server = 5] = "Server"
    }(E = t.PlayerState || (t.PlayerState = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Inventory = 1] = "Inventory",
        e[e.TileItem = 2] = "TileItem",
        e[e.Doodad = 3] = "Doodad",
        e[e.TileEvent = 4] = "TileEvent",
        e[e.Corpse = 5] = "Corpse"
    }(L = t.ObjectContext || (t.ObjectContext = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.LongPause = 25] = "LongPause",
        e[e.Movement = 10] = "Movement",
        e[e.ShortPause = 13] = "ShortPause",
        e[e.Collision = 40] = "Collision",
        e[e.TurnDirection = 2] = "TurnDirection",
        e[e.ItemPickUp = 4] = "ItemPickUp",
        e[e.ReallyLongPause = 100] = "ReallyLongPause"
    }(O = t.Delay || (t.Delay = {})),
    function(e) {
        e[e.Min = 10] = "Min",
        e[e.Default = 50] = "Default",
        e[e.Max = 80] = "Max"
    }(F = t.TickSpeed || (t.TickSpeed = {})),
    function(e) {
        e[e.EnemyHealth = 0] = "EnemyHealth",
        e[e.Stat = 1] = "Stat",
        e[e.Stamina = 2] = "Stamina",
        e[e.Metabolism = 3] = "Metabolism",
        e[e.Health = 4] = "Health",
        e[e.Thirst = 5] = "Thirst",
        e[e.Zero = 6] = "Zero",
        e[e.Miss = 7] = "Miss"
    }(_ = t.StatType || (t.StatType = {})),
    function(e) {
        e[e.Bleeding = 0] = "Bleeding",
        e[e.Poisoned = 1] = "Poisoned",
        e[e.Burned = 2] = "Burned"
    }(H = t.StatusType || (t.StatusType = {})),
    function(e) {
        e[e.WalkDots = 0] = "WalkDots",
        e[e.Arrows = 1] = "Arrows",
        e[e.FootPrints = 2] = "FootPrints"
    }(W = t.OverlayType || (t.OverlayType = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Random = 1] = "Random",
        e[e.Exceptional = 2] = "Exceptional",
        e[e.Remarkable = 3] = "Remarkable",
        e[e.Legendary = 4] = "Legendary"
    }(N = t.ItemQuality || (t.ItemQuality = {})),
    function(e) {
        e[e.Attack = 0] = "Attack",
        e[e.Defense = 1] = "Defense",
        e[e.Illumination = 2] = "Illumination",
        e[e.WeightCapacity = 3] = "WeightCapacity",
        e[e.ItemWeight = 4] = "ItemWeight",
        e[e.Stat = 5] = "Stat",
        e[e.Skill = 6] = "Skill",
        e[e.Benignity = 7] = "Benignity",
        e[e.Malignity = 8] = "Malignity",
        e[e.Range = 9] = "Range",
        e[e.UseBenefits = 10] = "UseBenefits",
        e[e.Worth = 11] = "Worth",
        e[e.TrapDamage = 12] = "TrapDamage",
        e[e.MaxWeight = 13] = "MaxWeight",
        e[e.ContainerWeight = 14] = "ContainerWeight"
    }(q = t.LegendaryType || (t.LegendaryType = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Corpse = 1] = "Corpse",
        e[e.Item = 2] = "Item",
        e[e.Player = 4] = "Player",
        e[e.Creature = 8] = "Creature",
        e[e.Terrain = 16] = "Terrain",
        e[e.Overlay = 32] = "Overlay",
        e[e.OverTrees = 64] = "OverTrees",
        e[e.All = 65535] = "All"
    }(U = t.RenderFlag || (t.RenderFlag = {})),
    function(e) {
        e[e.LightSource = 0] = "LightSource",
        e[e.Telescopy = 1] = "Telescopy"
    }(z = t.OnEquipType || (t.OnEquipType = {})),
    t.itemQualitySortOrder = {},
    t.itemQualitySortOrder[N.None] = 0,
    t.itemQualitySortOrder[N.Random] = 1,
    t.itemQualitySortOrder[N.Remarkable] = 2,
    t.itemQualitySortOrder[N.Exceptional] = 3,
    t.itemQualitySortOrder[N.Legendary] = 4,
    t.onEquipTypes = [],
    t.onEquipTypes[z.LightSource] = {},
    t.onEquipTypes[z.Telescopy] = {},
    function(e) {
        e[e.CheckUnderPlayer = 0] = "CheckUnderPlayer",
        e[e.DontEnterCaves = 1] = "DontEnterCaves",
        e[e.ForcePickUp = 2] = "ForcePickUp"
    }(V = t.TurnType || (t.TurnType = {})),
    t.keyCodes = ["", "", "", "CANCEL", "", "", "HELP", "", "BACKSPACE", "TAB", "", "", "CLEAR", "ENTER", "ENTER SPECIAL", "", "SHIFT", "CONTROL", "ALT", "PAUSE", "CAPS LOCK", "KANA", "EISU", "JUNJA", "FINAL", "HANJA", "", "ESC", "CONVERT", "NON CONVERT", "ACCEPT", "MODE CHANGE", "SPACE", "PAGE UP", "PAGE DOWN", "END", "HOME", "LEFT", "UP", "RIGHT", "DOWN", "SELECT", "PRINT", "EXECUTE", "PRINT SCREEN", "INSERT", "DELETE", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "WINDOWS", "", "CONTEXT MENU", "", "SLEEP", "NUMPAD0", "NUMPAD1", "NUMPAD2", "NUMPAD3", "NUMPAD4", "NUMPAD5", "NUMPAD6", "NUMPAD7", "NUMPAD8", "NUMPAD9", "MULTIPLY", "ADD", "SEPARATOR", "SUBTRACT", "DECIMAL", "DIVIDE", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "", "", "", "", "", "", "", "", "NUM LOCK", "SCROLL LOCK", "WIN OEM FJ JISHO", "WIN OEM FJ MASSHOU", "WIN OEM FJ TOUROKU", "WIN OEM FJ LOYA", "WIN OEM FJ ROYA", "", "", "", "", "", "", "", "", "", "LEFT SHIFT", "RIGHT SHIFT", "LEFT CONTROL", "RIGHT CONTROL", "LEFT MENU", "RIGHT MENU", "BACK", "FORWARD", "REFRESH", "STOP", "SEARCH", "FAVORITES", "BROWSER/HOME", "VOLUME MUTE", "VOLUME DOWN", "VOLUME UP", "NEXT", "PREVIOUS", "STOP", "PLAY/PAUSE", "MAIL", "MEDIA", "START APP", "START APP 2", "", "", ";", "=", ",", "-", ".", "/", "`", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[", "\\", "]", "'", "", "META", "ALTGR", "", "WIN ICO HELP", "WIN ICO 00", "", "WIN ICO CLEAR", "", "", "WIN OEM RESET", "WIN OEM JUMP", "WIN OEM PA1", "WIN OEM PA2", "WIN OEM PA3", "WIN OEM WSCTRL", "WIN OEM CUSEL", "WIN OEM ATTN", "WIN OEM FINISH", "WIN OEM COPY", "WIN OEM AUTO", "WIN OEM ENLW", "WIN OEM BACKTAB", "ATTN", "CRSEL", "EXSEL", "EREOF", "PLAY", "ZOOM", "", "PA1", "WIN OEM CLEAR", ""],
    function(e) {
        e[e.Inventory = 0] = "Inventory",
        e[e.Crafting = 1] = "Crafting",
        e[e.Equipment = 2] = "Equipment",
        e[e.Map = 3] = "Map",
        e[e.Container = 4] = "Container",
        e[e.Custom = 5] = "Custom"
    }(j = t.DialogId || (t.DialogId = {})),
    function(e) {
        e[e.Name = 0] = "Name",
        e[e.Group = 1] = "Group",
        e[e.Weight = 2] = "Weight",
        e[e.Recent = 3] = "Recent",
        e[e.Skill = 4] = "Skill",
        e[e.Decay = 5] = "Decay",
        e[e.Quality = 6] = "Quality",
        e[e.Category = 7] = "Category",
        e[e.Durability = 8] = "Durability",
        e[e.DiscoveredTime = 9] = "DiscoveredTime",
        e[e.Best = 10] = "Best"
    }(Q = t.SortType || (t.SortType = {})),
    function(e) {
        e[e.Resting = 0] = "Resting",
        e[e.Sleeping = 1] = "Sleeping"
    }($ = t.RestType || (t.RestType = {})),
    function(e) {
        e[e.Normal = 0] = "Normal",
        e[e.Rest = 1] = "Rest"
    }(Y = t.LoadingType || (t.LoadingType = {})),
    function(e) {
        e[e.Invalid = 0] = "Invalid",
        e[e.Failed = 1] = "Failed",
        e[e.Success = 2] = "Success"
    }(J = t.CraftStatus || (t.CraftStatus = {})),
    function(e) {
        e[e.KeyDown = 0] = "KeyDown",
        e[e.KeyUp = 1] = "KeyUp",
        e[e.MouseDown = 2] = "MouseDown",
        e[e.MouseUpOrLeave = 3] = "MouseUpOrLeave",
        e[e.MouseMove = 4] = "MouseMove",
        e[e.MouseScroll = 5] = "MouseScroll"
    }(K = t.InputRecordType || (t.InputRecordType = {})),
    function(e) {
        e[e.PascalCase = 0] = "PascalCase",
        e[e.CamelCase = 1] = "CamelCase",
        e[e.SnakeCase = 2] = "SnakeCase",
        e[e.KebabCase = 3] = "KebabCase"
    }(X = t.CaseStyle || (t.CaseStyle = {})),
    function(e) {
        e[e.Normal = 0] = "Normal",
        e[e.Static = 1] = "Static",
        e[e.Min = 2] = "Min",
        e[e.Max = 3] = "Max"
    }(Z = t.WeightType || (t.WeightType = {})),
    function(e) {
        e[e.CreatureNearby = 0] = "CreatureNearby",
        e[e.Damaged = 1] = "Damaged",
        e[e.FullStamina = 2] = "FullStamina",
        e[e.NearbyCreatureDamagedDoodad = 3] = "NearbyCreatureDamagedDoodad",
        e[e.CreatureDamaged = 4] = "CreatureDamaged",
        e[e.Canceled = 5] = "Canceled"
    }(ee = t.RestCancelReason || (t.RestCancelReason = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Doodad = 1] = "Doodad",
        e[e.Fire = 2] = "Fire",
        e[e.Lava = 3] = "Lava",
        e[e.CoolingLava = 4] = "CoolingLava"
    }(te = t.FireType || (t.FireType = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.Overburdened = 1] = "Overburdened",
        e[e.Encumbered = 2] = "Encumbered"
    }(ae = t.WeightStatus || (t.WeightStatus = {})),
    function(e) {
        e[e.Connecting = 1] = "Connecting",
        e[e.Connected = 2] = "Connected",
        e[e.QueuingPackets = 4] = "QueuingPackets",
        e[e.CatchingUp = 8] = "CatchingUp",
        e[e.Ready = 16] = "Ready",
        e[e.Disconnecting = 32] = "Disconnecting",
        e[e.All = 63] = "All"
    }(ie = t.ConnectionState || (t.ConnectionState = {})),
    function(e) {
        e[e.Game = 0] = "Game",
        e[e.Dialog = 1] = "Dialog",
        e[e.Menu = 2] = "Menu",
        e[e.Developer = 3] = "Developer",
        e[e.Mod = 4] = "Mod"
    }(ne = t.BindableType || (t.BindableType = {})),
    function(e) {
        e[e.None = 0] = "None",
        e[e.GameMoveDirection = 1] = "GameMoveDirection",
        e[e.GameMoveToTile = 2] = "GameMoveToTile",
        e[e.GameMoveToTilePreview = 3] = "GameMoveToTilePreview",
        e[e.GameMoveDown = 4] = "GameMoveDown",
        e[e.GameMoveLeft = 5] = "GameMoveLeft",
        e[e.GameMoveRight = 6] = "GameMoveRight",
        e[e.GameMoveUp = 7] = "GameMoveUp",
        e[e.GameFaceDirection = 8] = "GameFaceDirection",
        e[e.GameFaceDown = 9] = "GameFaceDown",
        e[e.GameFaceLeft = 10] = "GameFaceLeft",
        e[e.GameFaceRight = 11] = "GameFaceRight",
        e[e.GameFaceUp = 12] = "GameFaceUp",
        e[e.GameIdle = 13] = "GameIdle",
        e[e.GameActions = 14] = "GameActions",
        e[e.GameItemMove = 15] = "GameItemMove",
        e[e.GameItemMenu = 16] = "GameItemMenu",
        e[e.GameItemQuickMove = 17] = "GameItemQuickMove",
        e[e.GameItemQuickMoveAll = 18] = "GameItemQuickMoveAll",
        e[e.GameItemDrop = 19] = "GameItemDrop",
        e[e.GameItemDropAll = 20] = "GameItemDropAll",
        e[e.GameItemEquipToggle = 21] = "GameItemEquipToggle",
        e[e.GameHandToggleLeft = 22] = "GameHandToggleLeft",
        e[e.GameHandToggleRight = 23] = "GameHandToggleRight",
        e[e.GameInspect = 24] = "GameInspect",
        e[e.GameMoreInformation = 25] = "GameMoreInformation",
        e[e.GameZoomIn = 26] = "GameZoomIn",
        e[e.GameZoomOut = 27] = "GameZoomOut",
        e[e.GamePause = 28] = "GamePause",
        e[e.GameSave = 29] = "GameSave",
        e[e.GameFullscreen = 30] = "GameFullscreen",
        e[e.GameScreenshotMode = 31] = "GameScreenshotMode",
        e[e.GameQuickSlotClear = 32] = "GameQuickSlotClear",
        e[e.GameQuickSlot1 = 33] = "GameQuickSlot1",
        e[e.GameQuickSlot2 = 34] = "GameQuickSlot2",
        e[e.GameQuickSlot3 = 35] = "GameQuickSlot3",
        e[e.GameQuickSlot4 = 36] = "GameQuickSlot4",
        e[e.GameQuickSlot5 = 37] = "GameQuickSlot5",
        e[e.GameQuickSlot6 = 38] = "GameQuickSlot6",
        e[e.GameQuickSlot7 = 39] = "GameQuickSlot7",
        e[e.GameQuickSlot8 = 40] = "GameQuickSlot8",
        e[e.GameQuickSlot9 = 41] = "GameQuickSlot9",
        e[e.GameQuickSlotToggle1 = 42] = "GameQuickSlotToggle1",
        e[e.GameQuickSlotToggle2 = 43] = "GameQuickSlotToggle2",
        e[e.GameQuickSlotToggle3 = 44] = "GameQuickSlotToggle3",
        e[e.GameQuickSlotToggle4 = 45] = "GameQuickSlotToggle4",
        e[e.GameQuickSlotToggle5 = 46] = "GameQuickSlotToggle5",
        e[e.GameQuickSlotToggle6 = 47] = "GameQuickSlotToggle6",
        e[e.GameQuickSlotToggle7 = 48] = "GameQuickSlotToggle7",
        e[e.GameQuickSlotToggle8 = 49] = "GameQuickSlotToggle8",
        e[e.GameQuickSlotToggle9 = 50] = "GameQuickSlotToggle9",
        e[e.GameContextMenu1 = 51] = "GameContextMenu1",
        e[e.GameContextMenu2 = 52] = "GameContextMenu2",
        e[e.GameContextMenu3 = 53] = "GameContextMenu3",
        e[e.GameContextMenu4 = 54] = "GameContextMenu4",
        e[e.GameContextMenu5 = 55] = "GameContextMenu5",
        e[e.GameContextMenu6 = 56] = "GameContextMenu6",
        e[e.GameContextMenu7 = 57] = "GameContextMenu7",
        e[e.GameContextMenu8 = 58] = "GameContextMenu8",
        e[e.GameContextMenu9 = 59] = "GameContextMenu9",
        e[e.GameContextMenu10 = 60] = "GameContextMenu10",
        e[e.GameContextMenu11 = 61] = "GameContextMenu11",
        e[e.GameContextMenu12 = 62] = "GameContextMenu12",
        e[e.GameContextMenu13 = 63] = "GameContextMenu13",
        e[e.GameContextMenu14 = 64] = "GameContextMenu14",
        e[e.GameContextMenu15 = 65] = "GameContextMenu15",
        e[e.GameContextMenu16 = 66] = "GameContextMenu16",
        e[e.GameContextMenu17 = 67] = "GameContextMenu17",
        e[e.GameContextMenu18 = 68] = "GameContextMenu18",
        e[e.GameContextMenu19 = 69] = "GameContextMenu19",
        e[e.GameContextMenu20 = 70] = "GameContextMenu20",
        e[e.GameContextMenu21 = 71] = "GameContextMenu21",
        e[e.GameContextMenu22 = 72] = "GameContextMenu22",
        e[e.GameContextMenu23 = 73] = "GameContextMenu23",
        e[e.GameContextMenu24 = 74] = "GameContextMenu24",
        e[e.DialogCloseAll = 75] = "DialogCloseAll",
        e[e.DialogOptions = 76] = "DialogOptions",
        e[e.DialogHelp = 77] = "DialogHelp",
        e[e.DialogMilestones = 78] = "DialogMilestones",
        e[e.DialogNotes = 79] = "DialogNotes",
        e[e.DialogMessages = 80] = "DialogMessages",
        e[e.DialogMessagesChatFocus = 81] = "DialogMessagesChatFocus",
        e[e.DialogInventory = 82] = "DialogInventory",
        e[e.DialogCrafting = 83] = "DialogCrafting",
        e[e.DialogDismantle = 84] = "DialogDismantle",
        e[e.DialogEquipment = 85] = "DialogEquipment",
        e[e.DialogSkills = 86] = "DialogSkills",
        e[e.DialogQuests = 87] = "DialogQuests",
        e[e.MenuEnter = 88] = "MenuEnter",
        e[e.MenuNext = 89] = "MenuNext",
        e[e.MenuPrevious = 90] = "MenuPrevious",
        e[e.MenuUp = 91] = "MenuUp",
        e[e.MenuDown = 92] = "MenuDown",
        e[e.MenuLeft = 93] = "MenuLeft",
        e[e.MenuRight = 94] = "MenuRight",
        e[e.MenuCancel = 95] = "MenuCancel",
        e[e.MenuContextMenu = 96] = "MenuContextMenu",
        e[e.DeveloperToggleDeveloperMode = 97] = "DeveloperToggleDeveloperMode",
        e[e.DeveloperToggleDeveloperTools = 98] = "DeveloperToggleDeveloperTools",
        e[e.DeveloperReloadGame = 99] = "DeveloperReloadGame",
        e[e.DeveloperReloadAndContinueGame = 100] = "DeveloperReloadAndContinueGame"
    }(oe = t.Bindable || (t.Bindable = {})),
    function(e) {
        e[e.Facing = 0] = "Facing",
        e[e.Feet = 1] = "Feet",
        e[e.FeetWhenFacingBlocked = 2] = "FeetWhenFacingBlocked"
    }(re = t.DropLocation || (t.DropLocation = {})),
    function(e) {
        e[e.Manual = 0] = "Manual",
        e[e.Simulated = 1] = "Simulated",
        e[e.RealTime = 2] = "RealTime"
    }(se = t.TurnMode || (t.TurnMode = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/enum/EnumCursor", ["require", "exports", "utilities/Emitter", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/math/Math2", "utilities/Random"], function(e, t, a, i, n, o, r) {
    var s, l;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Change = 0] = "Change"
    }(s = t.EnumCursorEvent || (t.EnumCursorEvent = {})),
    function(e) {
        e.Random = "Random"
    }(l = t.EnumCursorDefaultGenerator || (t.EnumCursorDefaultGenerator = {}));
    class u extends a.default {
        constructor(e, t=0) {
            super(),
            this.enumObject = e,
            this.refresh(),
            this.moveTo(t)
        }
        refresh() {
            const e = this.values && this.values[this.cursor];
            return this.values = i.default.values(this.enumObject).filter(e=>!this._filter || this._filter(this.enumObject[e], e)).collect(n.default.toArray),
            this.cursor = this.values.indexOf(e),
            -1 === this.cursor && this.moveToDefault(),
            this
        }
        filter(e) {
            return this._filter = e,
            this.refresh(),
            this
        }
        get() {
            return this.values[this.cursor]
        }
        moveTo(e) {
            return this.cursor = o.default.clamp(0, this.values.length - 1, e),
            this.emit(s.Change, this.values[this.cursor]),
            this
        }
        moveToEnumEntry(e) {
            return this.moveTo(this.values.indexOf(e)),
            this.values[this.cursor]
        }
        move(e) {
            return this.cursor += e,
            this.cursor >= this.values.length ? this.cursor = 0 : this.cursor < 0 && (this.cursor = this.values.length - 1),
            this.emit(s.Change, this.values[this.cursor]),
            this.values[this.cursor]
        }
        moveToRandom() {
            return this.moveTo(this.getRandomPosition()),
            this.values[this.cursor]
        }
        moveToDefault() {
            return this.moveTo("function" == typeof this.default ? this.default() : this.default),
            this.values[this.cursor]
        }
        next() {
            return this.move(1)
        }
        previous() {
            return this.move(-1)
        }
        setDefault(e) {
            return this.default = "string" == typeof e ? this.getDefaultGenerator(e) : e,
            this
        }
        setDefaultToEntry(e) {
            return this.default = this.values.indexOf(e),
            this
        }
        getRandomPosition() {
            return r.default.int(this.values.length)
        }
        getDefaultGenerator(e) {
            switch (e) {
            case l.Random:
                return this.getRandomPosition.bind(this)
            }
        }
    }
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("audio/IAudio", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/TerrainTileInfo", ["require", "exports", "utilities/math/Vector2"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const i = {
        q1TopRight: new a.default(.75,0),
        q1TopLeft: new a.default(.5,0),
        q1BottomLeft: new a.default(.5,.25),
        q1BottomRight: new a.default(.75,.25),
        q2TopRight: new a.default(.25,0),
        q2TopLeft: new a.default(0,0),
        q2BottomLeft: new a.default(0,.25),
        q2BottomRight: new a.default(.25,.25),
        q3TopRight: new a.default(.25,.5),
        q3TopLeft: new a.default(0,.5),
        q3BottomLeft: new a.default(0,.75),
        q3BottomRight: new a.default(.25,.75),
        q4TopRight: new a.default(.75,.5),
        q4TopLeft: new a.default(.5,.5),
        q4BottomLeft: new a.default(.5,.75),
        q4BottomRight: new a.default(.75,.75)
    };
    class n {
        constructor(e, t, n) {
            this.animated = n;
            for (const n in i) {
                const o = new a.default;
                i[n].copy(o),
                o.multiply(new a.default(4,4)).add(new a.default(e,t)),
                this[`center${n[0].toUpperCase() + n.slice(1)}`] = o;
                const r = new a.default;
                o.copy(r),
                r.y += 4,
                this[n] = r
            }
            for (const e in i) {
                const t = new a.default;
                i[e].copy(t)
            }
            this.q2TopRightQ1TopLeft = [this.q2TopRight, this.q1TopLeft],
            this.q3BottomRightQ4BottomLeft = [this.q3BottomRight, this.q4BottomLeft],
            this.q2BottomLeftQ3TopLeft = [this.q2BottomLeft, this.q3TopLeft],
            this.q1BottomRightQ4TopRight = [this.q1BottomRight, this.q4TopRight],
            this.centerAllQuadrantsTopLeft = [new a.default(e,t), new a.default([e + 2, t]), new a.default([e, t + 2]), new a.default([e + 2, t + 2])],
            this.centerAllQuadrantsTopRight = [new a.default([e + 1, t]), new a.default([e + 3, t]), new a.default([e + 1, t + 2]), new a.default([e + 3, t + 2])],
            this.centerAllQuadrantsBottomLeft = [new a.default([e, t + 1]), new a.default([e + 2, t + 1]), new a.default([e, t + 3]), new a.default([e + 2, t + 3])],
            this.centerAllQuadrantsBottomRight = [new a.default([e + 1, t + 1]), new a.default([e + 3, t + 1]), new a.default([e + 1, t + 3]), new a.default([e + 3, t + 3])]
        }
        getCenterTopLeft(e) {
            return this.centerAllQuadrantsTopLeft[e]
        }
        getCenterTopRight(e) {
            return this.centerAllQuadrantsTopRight[e]
        }
        getCenterBottomLeft(e) {
            return this.centerAllQuadrantsBottomLeft[e]
        }
        getCenterBottomRight(e) {
            return this.centerAllQuadrantsBottomRight[e]
        }
        getLeft(e) {
            return this.q2BottomLeftQ3TopLeft[Math.floor(.5 * e)]
        }
        getRight(e) {
            return this.q1BottomRightQ4TopRight[Math.floor(.5 * e)]
        }
        getTop(e) {
            return this.q2TopRightQ1TopLeft[Math.floor(.5 * e)]
        }
        getBottom(e) {
            return this.q3BottomRightQ4BottomLeft[Math.floor(.5 * e)]
        }
    }
    t.TerrainTileInfo = n;
    class o extends n {
        constructor(e, t, a) {
            super(e, t, a);
            const i = new n(e,t,a);
            i.q2TopRightQ1TopLeft[0].y += 4,
            i.q2BottomLeftQ3TopLeft[0].y += 4,
            i.q1BottomRightQ4TopRight[0].y += 4,
            i.q3BottomRightQ4BottomLeft[0].y += 4,
            i.q2TopRightQ1TopLeft[1].y += 4,
            i.q2BottomLeftQ3TopLeft[1].y += 4,
            i.q1BottomRightQ4TopRight[1].y += 4,
            i.q3BottomRightQ4BottomLeft[1].y += 4,
            i.q2TopLeft.y += 4,
            i.q1TopRight.y += 4,
            i.q3BottomLeft.y += 4,
            i.q4BottomRight.y += 4,
            i.q2BottomRight.y += 4,
            i.q1BottomLeft.y += 4,
            i.q3TopRight.y += 4,
            i.q4TopLeft.y += 4,
            this.extendedInfo = i
        }
    }
    t.MountainTileInfo = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/TileAdaptors", ["require", "exports", "Enums"], function(e, t, a) {
    function i(e) {
        t.defaultBackground = e
    }
    function n(e) {
        return !!e && (e.type === a.DoodadType.WoodenDoor || e.type === a.DoodadType.WoodenDoorOpen)
    }
    function o(e) {
        return e >= a.TerrainType.DeepFreshWater && e <= a.TerrainType.ShallowFreshWater ? e - 3 : e
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.setDefaultBackground = i,
    t.isDoor = n,
    t.getWaterType = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/tileAdaptors/Fence", ["require", "exports", "Enums", "utilities/math/Vector2"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        adaptGate(e, t, n, o, r, s) {
            const l = e.isFence(e.getTile(t, n - 1)) ? 1 : 0
              , u = e.isFence(e.getTile(t, n + 1)) ? 2 : 0
              , d = e.isFence(e.getTile(t - 1, n)) ? 1 : 0
              , p = e.isFence(e.getTile(t + 1, n)) ? 2 : 0
              , c = 2 * (d | p)
              , m = r ? u + 4 : 2 * l
              , h = tileAtlas.doodads[o].topLeft;
            o === a.DoodadType.WoodenGateOpen && r ? (s.TLBG = new i.default([h.x + 8, h.y + m]),
            s.TRBG = new i.default([h.x + 9, h.y + m]),
            s.BLBG = new i.default([h.x + 8, h.y + m + 1]),
            s.BRBG = new i.default([h.x + 9, h.y + m + 1])) : 0 !== u ? (s.TLBG = new i.default([h.x + 8, h.y]),
            s.TRBG = new i.default([h.x + 9, h.y]),
            s.BLBG = new i.default([h.x + 8, h.y + 1]),
            s.BRBG = new i.default([h.x + 9, h.y + 1])) : (s.TLBG = i.default.ZERO,
            s.TRBG = i.default.ZERO,
            s.BLBG = i.default.ZERO,
            s.BRBG = i.default.ZERO),
            s.TLFG = new i.default([h.x + c, h.y + m]),
            s.TRFG = new i.default([h.x + c + 1, h.y + m]),
            s.BLFG = new i.default([h.x + c, h.y + m + 1]),
            s.BRFG = new i.default([h.x + c + 1, h.y + m + 1]),
            s.overLayerBGTall = !0,
            s.TLBO = new i.default(s.TLBG.x,s.TLBG.y),
            s.TRBO = new i.default(s.TRBG.x,s.TRBG.y),
            s.BLBO = new i.default(s.BLBG.x,s.BLBG.y),
            s.BRBO = new i.default(s.BRBG.x,s.BRBG.y),
            r && (s.TLFO = new i.default([h.x + 8, h.y + 2]),
            s.TRFO = new i.default([h.x + 9, h.y + 2]),
            s.BLFO = new i.default([h.x + 8, h.y + 3]),
            s.BRFO = new i.default([h.x + 9, h.y + 3]))
        }
        adapt(e, t, a, n, o) {
            const r = e.isFence(e.getTile(t, a - 1)) ? 1 : 0
              , s = e.isFence(e.getTile(t, a + 1)) ? 2 : 0
              , l = e.isFence(e.getTile(t - 1, a)) ? 1 : 0
              , u = e.isFence(e.getTile(t + 1, a)) ? 2 : 0
              , d = 2 * (l | u)
              , p = 2 * (r | s)
              , c = tileAtlas.doodads[n].topLeft;
            o.TLFG = new i.default([c.x + d, c.y + p]),
            o.TRFG = new i.default([c.x + d + 1, c.y + p]),
            o.BLFG = new i.default([c.x + d, c.y + p + 1]),
            o.BRFG = new i.default([c.x + d + 1, c.y + p + 1]),
            o.TLBG = i.default.ZERO,
            o.TRBG = i.default.ZERO,
            o.BLBG = i.default.ZERO,
            o.BRBG = i.default.ZERO
        }
    }
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/tileAdaptors/Wall", ["require", "exports", "renderer/TileAdaptors", "utilities/math/Vector2", "utilities/TileHelpers"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o {
        adaptDoor(e, t, a, n, o, r) {
            const s = tileAtlas.doodads[n].topLeft;
            let l = s.x;
            const u = s.y;
            o && (l += 4),
            r.TLFG = new i.default(l,u),
            r.TRFG = new i.default([l + 1, u]),
            r.BLFG = new i.default([l, u + 1]),
            r.BRFG = new i.default([l + 1, u + 1]),
            r.TLBG = i.default.ZERO,
            r.TRBG = i.default.ZERO,
            r.BLBG = i.default.ZERO,
            r.BRBG = i.default.ZERO,
            r.TLFO = new i.default([r.TLFG.x + 2, r.TLFG.y]),
            r.TRFO = new i.default([r.TRFG.x + 2, r.TRFG.y]),
            r.BLFO = new i.default([r.BLFG.x + 2, r.BLFG.y]),
            r.BRFO = new i.default([r.BRFG.x + 2, r.BRFG.y])
        }
        adapt(e, t, o, r, s) {
            const l = e.isWall(e.getTile(t, o - 1)) ? 1 : 0
              , u = e.isWall(e.getTile(t - 1, o)) ? 1 : 0
              , d = e.isWall(e.getTile(t, o + 1)) ? 2 : 0
              , p = e.isWall(e.getTile(t + 1, o)) ? 2 : 0
              , c = !!l && a.isDoor(game.getTile(t, o - 1, e.level).doodad)
              , m = !!u && a.isDoor(game.getTile(t - 1, o, e.level).doodad)
              , h = !!d && a.isDoor(game.getTile(t, o + 1, e.level).doodad)
              , y = !!p && a.isDoor(game.getTile(t + 1, o, e.level).doodad)
              , g = 2 * (u | p);
            let f = g
              , T = g + 1
              , S = 2 * l
              , I = S
              , v = S;
            const w = 2 * Math.floor(2 * n.default.getTileVariation(t, o));
            6 !== g || h || (I += 2 * w,
            v += 2 * w),
            m && (f = 2,
            I = S + 4),
            y && (T = 3,
            v = S + 4),
            h && (I += m ? 0 : 8,
            v += y ? 0 : 8,
            m && (f += 2),
            y && (T += 2)),
            l || u || d || p ? !u || p || l || d ? !p || u || l || d || (y ? (f = 0,
            T = 1) : (f = 4,
            T = 5),
            I = 12,
            v = 12) : (m ? (f = 0,
            T = 1) : (f = 2,
            T = 3),
            I = 12,
            v = 12) : (f = 0,
            T = 1,
            I = 12,
            v = 12);
            const M = tileAtlas.doodads[r].topLeft;
            s.TLFG = new i.default([M.x + f, M.y + I]),
            s.TRFG = new i.default([M.x + T, M.y + v]),
            s.BLFG = new i.default([M.x + f, M.y + I + 1]),
            s.BRFG = new i.default([M.x + T, M.y + v + 1]),
            s.TLBG = i.default.ZERO,
            s.TRBG = i.default.ZERO,
            s.BLBG = i.default.ZERO,
            s.BRBG = i.default.ZERO,
            l ? (S = c ? 2 : 0,
            s.TLFO = new i.default([M.x, M.y + 4 + S]),
            s.TRFO = new i.default([M.x + 1, M.y + 4 + S]),
            s.BLFO = new i.default([M.x, M.y + 5 + S]),
            s.BRFO = new i.default([M.x + 1, M.y + 5 + S])) : (delete s.TLFO,
            delete s.TRFO,
            delete s.BLFO,
            delete s.BRFO)
        }
    }
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/Shaders", ["require", "exports", "utilities/Files", "utilities/Log"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const n = {};
    async function o() {
        i.default.info(i.LogSource.Shaders)("Loading shaders");
        const e = $("head");
        async function t(t, i, n) {
            const o = await a.default .getText(`static/shader/webgl${t}/${i}.${n}`);
            e.append(`<script id="${t}-${i}-${n}" type="x-shader/x-${n}" data-shader="1">${o}<\/script>`)
        }
        e.children("script[data-shader='1']").remove();
        const n = [{
            name: "tile-shader",
            types: ["vertex", "fragment"]
        }, {
            name: "world-texture",
            types: ["vertex", "fragment"]
        }, {
            name: "basic-texture",
            types: ["vertex", "fragment"]
        }, {
            name: "alpha-debug",
            types: ["fragment"]
        }, {
            name: "blur-horizontal",
            types: ["fragment"]
        }, {
            name: "blur-vertical",
            types: ["fragment"]
        }, {
            name: "fog",
            types: ["vertex", "fragment"]
        }, {
            name: "fov",
            types: ["vertex", "fragment"]
        }, {
            name: "sprite-shader",
            types: ["vertex", "fragment"]
        }, {
            name: "particle-shader",
            types: ["vertex", "fragment"]
        }, {
            name: "glyph",
            types: ["vertex", "fragment"]
        }]
          , o = [];
        for (const e of n)
            for (const a of e.types)
                o.push(t(1, e.name, a)),
                o.push(t(2, e.name, a));
        await Promise.all(o),
        i.default.info(i.LogSource.Shaders)(`Loaded ${o.length} shaders`)
    }
    function r() {
        const e = Object.keys(n);
        for (const t of e)
            n[t].compileProgram()
    }
    function s(e, t, a) {
        const i = e.createShader(a);
        if (!i)
            throw new Error("Unable to create shader");
        if (e.shaderSource(i, t),
        e.compileShader(i),
        e.getShaderParameter(i, e.COMPILE_STATUS))
            return i;
        throw new Error(`Shader compile error:\n${t}\n${e.getShaderInfoLog(i)}`)
    }
    function l(e, t, a) {
        const i = e.createProgram();
        if (!i)
            throw new Error("Unable to create program");
        if (e.attachShader(i, t),
        e.attachShader(i, a),
        e.linkProgram(i),
        e.getProgramParameter(i, e.LINK_STATUS))
            return i;
        throw new Error(`Program link error:\n${e.getProgramInfoLog(i)}`)
    }
    t.loadShaders = o,
    t.compileShaders = r;
    class u {
        constructor(e, t, a) {
            this.gl = e,
            this.vertexName = t,
            this.fragmentName = a,
            this.uniforms = {},
            this.attribs = {},
            n[t + a] = this,
            this.compileProgram()
        }
        compileProgram() {
            try {
                const e = this.gl instanceof WebGL2RenderingContext ? 2 : 1
                  , t = document.getElementById(`${e}-${this.vertexName}`).textContent
                  , a = document.getElementById(`${e}-${this.fragmentName}`).textContent
                  , n = s(this.gl, t, this.gl.VERTEX_SHADER)
                  , o = s(this.gl, a, this.gl.FRAGMENT_SHADER)
                  , r = l(this.gl, n, o)
                  , u = this.gl.getProgramParameter(r, this.gl.ACTIVE_UNIFORMS)
                  , d = this.gl.getProgramParameter(r, this.gl.ACTIVE_ATTRIBUTES);
                let p, c, m;
                for (m = 0; m < u; m++)
                    (c = this.gl.getActiveUniform(r, m)) && (p = this.gl.getUniformLocation(r, c.name),
                    this.uniforms[c.name] = p);
                for (m = 0; m < d; m++)
                    (c = this.gl.getActiveAttrib(r, m)) && (p = this.gl.getAttribLocation(r, c.name),
                    this.attribs[c.name] = p);
                this.program = r
            } catch (e) {
                i.default.error(i.LogSource.Shaders)("Failed to compile shader, better luck next time.", this.vertexName, this.fragmentName, e)
            }
        }
    }
    t.CompiledProgram = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/TileLayer", ["require", "exports", "renderer/Shaders", "utilities/math/Vector2"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        constructor(e, t, a, o) {
            this.width = e,
            this.height = t;
            const r = a.createTexture()
              , s = a instanceof WebGL2RenderingContext ? a.createVertexArray() : void 0;
            if (!r)
                throw new Error("Unable to create texture");
            this.texTiles = r,
            this.tileData = new ArrayBuffer(16 * e * t),
            this.tileDataU8 = new Uint8Array(this.tileData),
            this.tileDataU32 = new Uint32Array(this.tileData),
            this.singleTileData = new ArrayBuffer(16),
            this.singleTileDataU8 = new Uint8Array(this.singleTileData),
            this.singleTileDataU32 = new Uint32Array(this.singleTileData),
            this.inverseTileDataTextureSize = new i.default([1 / (2 * e), 1 / (2 * t)]),
            a.bindTexture(a.TEXTURE_2D, this.texTiles),
            a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, 2 * e, 2 * t, 0, a.RGBA, a.UNSIGNED_BYTE, this.tileDataU8),
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST),
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST),
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.REPEAT),
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.REPEAT),
            s && (this.vertexArray = s,
            a.bindVertexArray(this.vertexArray),
            a.bindBuffer(a.ARRAY_BUFFER, o),
            a.enableVertexAttribArray(n.tileShaderProgram.attribs.position),
            a.vertexAttribPointer(n.tileShaderProgram.attribs.position, 2, a.FLOAT, !1, 0, 0),
            a.bindBuffer(a.ARRAY_BUFFER, null),
            a.bindVertexArray(null))
        }
        static setTileTexture(e, t) {
            n.texTileSprites = e,
            n.inverseTileSpriteTextureSize = t
        }
        static compileShaders(e) {
            n.tileShaderProgram = new a.CompiledProgram(e,"tile-shader-vertex","tile-shader-fragment")
        }
        setTileTLFG(e, t, a) {
            this.tileDataU8[e + 0] = t,
            this.tileDataU8[e + 1] = a
        }
        setTileTRFG(e, t, a) {
            this.tileDataU8[e + 4 + 0] = t,
            this.tileDataU8[e + 4 + 1] = a
        }
        setTileBLFG(e, t, a) {
            this.tileDataU8[e + 0 + 8 * this.width + 0] = t,
            this.tileDataU8[e + 0 + 8 * this.width + 1] = a
        }
        setTileBRFG(e, t, a) {
            this.tileDataU8[e + 4 + 8 * this.width + 0] = t,
            this.tileDataU8[e + 4 + 8 * this.width + 1] = a
        }
        setTileTLBG(e, t, a) {
            this.tileDataU8[e + 2] = t,
            this.tileDataU8[e + 3] = a
        }
        setTileTRBG(e, t, a) {
            this.tileDataU8[e + 4 + 2] = t,
            this.tileDataU8[e + 4 + 3] = a
        }
        setTileBLBG(e, t, a) {
            this.tileDataU8[e + 0 + 8 * this.width + 2] = t,
            this.tileDataU8[e + 0 + 8 * this.width + 3] = a
        }
        setTileBRBG(e, t, a) {
            this.tileDataU8[e + 4 + 8 * this.width + 2] = t,
            this.tileDataU8[e + 4 + 8 * this.width + 3] = a
        }
        sendTileToGPU(e, t, a) {
            const i = 2 * e + 4 * t * this.width
              , n = this.singleTileDataU32;
            n[0] = this.tileDataU32[i],
            n[1] = this.tileDataU32[i + 1],
            n[2] = this.tileDataU32[i + 2 * this.width],
            n[3] = this.tileDataU32[i + 2 * this.width + 1],
            a.bindTexture(a.TEXTURE_2D, this.texTiles),
            a.texSubImage2D(a.TEXTURE_2D, 0, 2 * e, 2 * t, 2, 2, a.RGBA, a.UNSIGNED_BYTE, this.singleTileDataU8)
        }
        sendToGPU(e) {
            e.bindTexture(e.TEXTURE_2D, this.texTiles),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 2 * this.width, 2 * this.height, 0, e.RGBA, e.UNSIGNED_BYTE, this.tileDataU8)
        }
        render(e, t, a, i, o, r, s, l=!1) {
            const u = n.tileShaderProgram;
            e.useProgram(u.program),
            e.depthFunc(e.ALWAYS),
            e.uniform2f(u.uniforms.viewportSize, r / o, s / o),
            e.uniform2f(u.uniforms.inverseTileSpriteTextureSize, n.inverseTileSpriteTextureSize.x, n.inverseTileSpriteTextureSize.y),
            e.uniform1f(u.uniforms.tileSize, i),
            e.uniform1f(u.uniforms.inverseTileSize, 1 / i),
            e.uniform1i(u.uniforms.time, game.time.ticks),
            e.uniform1i(u.uniforms.fixedDepth, l ? 1 : 0),
            e.uniform2f(u.uniforms.viewOffset, Math.floor(t * i * 2), Math.floor(a * i * 2)),
            e.uniform2f(u.uniforms.inverseTileDataTextureSize, this.inverseTileDataTextureSize.x, this.inverseTileDataTextureSize.y),
            e.uniform2f(u.uniforms.tileDataTextureSize, this.width, this.height),
            this.vertexArray ? e.bindVertexArray(this.vertexArray) : (e.bindBuffer(e.ARRAY_BUFFER, renderer.positionBuffer),
            e.vertexAttribPointer(u.attribs.position, 2, e.FLOAT, !1, 0, 0),
            e.enableVertexAttribArray(u.attribs.position)),
            e.activeTexture(e.TEXTURE0),
            e.uniform1i(u.uniforms.sprites, 0),
            e.bindTexture(e.TEXTURE_2D, n.texTileSprites),
            e.activeTexture(e.TEXTURE1),
            e.uniform1i(u.uniforms.tiles, 1),
            e.bindTexture(e.TEXTURE_2D, this.texTiles),
            e.drawArrays(e.TRIANGLES, 0, 6),
            this.vertexArray ? e.bindVertexArray(null) : e.disableVertexAttribArray(u.attribs.position)
        }
        clear() {
            const e = this.tileDataU8
              , t = e.length;
            for (let a = 0; a < t; a++)
                e[a] = 0
        }
    }
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/WorldLayerRenderer", ["require", "exports", "Enums", "game/IGame", "renderer/RendererConstants", "renderer/TileAdaptors", "renderer/TileLayer", "tile/Terrains"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l {
        constructor(e, t, a, i, o, s) {
            this.gl = e,
            this.renderer = t,
            this.worldLayer = a,
            this.width = i,
            this.height = o,
            this.dirty = !0,
            this.terrainLayer = new r.default(i,o,e,s),
            this.terrainOverLayer = new r.default(i,o,e,s),
            this.doodadLayer = new r.default(i,o,e,s),
            this.doodadOverLayer = new r.default(i,o,e,s),
            a.onTileUpdate = ((e,t,a)=>{
                this.computeTile(e, t, a)
            }
            ),
            a.onDoodadUpdate = ((e,t,a,i,n,o,r)=>{
                this.setDoodad(e, t, a, i, n, o, r)
            }
            );
            const l = e.createTexture()
              , u = e.createTexture()
              , d = e.createTexture();
            if (!l || !u || !d)
                throw new Error("Unable to create texture");
            this.texLightBlock = l,
            e.bindTexture(e.TEXTURE_2D, this.texLightBlock),
            e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, a.lightBlockMap.width, a.lightBlockMap.height, 0, e.ALPHA, e.UNSIGNED_BYTE, n.emptyUint8Array),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT),
            this.texLightLevel = u,
            e.bindTexture(e.TEXTURE_2D, this.texLightLevel),
            e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, a.lightLevelMap.width, a.lightLevelMap.height, 0, e.ALPHA, e.UNSIGNED_BYTE, n.emptyUint8Array),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT),
            this.texExplored = d,
            e.bindTexture(e.TEXTURE_2D, this.texExplored),
            e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, world.width, world.height, 0, e.ALPHA, e.UNSIGNED_BYTE, a.exploredMap.data),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)
        }
        updateAll() {
            for (let e = 0; e < this.width; e++)
                for (let t = 0; t < this.height; t++)
                    this.computeTile(e, t);
            this.flush()
        }
        setDoodad(e, t, i, n, o, r, s=!1) {
            let l = 8 * e + 16 * t * this.width;
            if (n || (i = void 0),
            i === a.DoodadType.WoodenGate || i === a.DoodadType.WoodenGateOpen)
                ;
            else if (void 0 === i)
                this.doodadLayer.setTileTLFG(l, 0, 0),
                this.doodadLayer.setTileTRFG(l, 0, 0),
                this.doodadLayer.setTileBLFG(l, 0, 0),
                this.doodadLayer.setTileBRFG(l, 0, 0),
                this.doodadLayer.setTileTLBG(l, 0, 0),
                this.doodadLayer.setTileTRBG(l, 0, 0),
                this.doodadLayer.setTileBLBG(l, 0, 0),
                this.doodadLayer.setTileBRBG(l, 0, 0),
                this.doodadOverLayer.setTileTLFG(l, 0, 0),
                this.doodadOverLayer.setTileTRFG(l, 0, 0),
                this.doodadOverLayer.setTileBLFG(l, 0, 0),
                this.doodadOverLayer.setTileBRFG(l, 0, 0),
                t === this.height - 1 && (l -= 16 * this.width * this.height),
                l += 16 * this.width,
                this.doodadOverLayer.setTileTLBG(l, 0, 0),
                this.doodadOverLayer.setTileTRBG(l, 0, 0),
                this.doodadOverLayer.setTileBLBG(l, 0, 0),
                this.doodadOverLayer.setTileBRBG(l, 0, 0);
            else if (n && n.topLeft) {
                let e = 2 * o;
                n.animated ? (r && (e = 6 * o),
                this.doodadLayer.setTileTLBG(l, 255, 255),
                this.doodadLayer.setTileTRBG(l, 255, 255),
                this.doodadLayer.setTileBLBG(l, 255, 255),
                this.doodadLayer.setTileBRBG(l, 255, 255)) : (this.doodadLayer.setTileTLBG(l, 0, 0),
                this.doodadLayer.setTileTRBG(l, 0, 0),
                this.doodadLayer.setTileBLBG(l, 0, 0),
                this.doodadLayer.setTileBRBG(l, 0, 0)),
                this.doodadLayer.setTileTLFG(l, n.topLeft.x + e, n.topLeft.y),
                this.doodadLayer.setTileTRFG(l, n.topRight.x + e, n.topRight.y),
                this.doodadLayer.setTileBLFG(l, n.bottomLeft.x + e, n.bottomLeft.y),
                this.doodadLayer.setTileBRFG(l, n.bottomRight.x + e, n.bottomRight.y),
                n.tall ? (this.doodadOverLayer.setTileTLFG(l, n.topLeft.x + e, n.topLeft.y - 2),
                this.doodadOverLayer.setTileTRFG(l, n.topRight.x + e, n.topRight.y - 2),
                this.doodadOverLayer.setTileBLFG(l, n.bottomLeft.x + e, n.bottomLeft.y - 2),
                this.doodadOverLayer.setTileBRFG(l, n.bottomRight.x + e, n.bottomRight.y - 2)) : (this.doodadOverLayer.setTileTLFG(l, 0, 0),
                this.doodadOverLayer.setTileTRFG(l, 0, 0),
                this.doodadOverLayer.setTileBLFG(l, 0, 0),
                this.doodadOverLayer.setTileBRFG(l, 0, 0)),
                t === this.height - 1 && (l -= 16 * this.width * this.height),
                l += 16 * this.width,
                this.doodadOverLayer.setTileTLBG(l, 0, 0),
                this.doodadOverLayer.setTileTRBG(l, 0, 0),
                this.doodadOverLayer.setTileBLBG(l, 0, 0),
                this.doodadOverLayer.setTileBRBG(l, 0, 0)
            }
            s ? (this.doodadLayer.sendTileToGPU(e, t, this.gl),
            0 === t ? (this.doodadOverLayer.sendTileToGPU(e, this.height - 1, this.gl),
            this.doodadOverLayer.sendTileToGPU(e, t, this.gl)) : (this.doodadOverLayer.sendTileToGPU(e, t - 1, this.gl),
            this.doodadOverLayer.sendTileToGPU(e, t, this.gl))) : this.dirty = !0
        }
        renderFullbright(e, t, a, i, o, r) {
            this.dirty && this.flush();
            const s = this.gl
              , l = n.subTileSize;
            r ? this.doodadOverLayer.render(s, e, t + 1, l, a, i, o, !0) : (this.terrainLayer.render(s, e, t, l, a, i, o),
            this.terrainOverLayer.render(s, e, t, l, a, i, o),
            this.doodadLayer.render(s, e, t, l, a, i, o))
        }
        computeTile(e, t, i=!1) {
            e -= this.width * Math.floor(e / this.width),
            t -= this.height * Math.floor(t / this.height);
            const n = this.worldLayer
              , r = n.getTile(e, t)
              , l = 8 * e + 16 * t * this.width
              , u = {};
            let d, p = r & a.TerrainMask.Type;
            const c = game.getTile(e, t, n.level).doodad;
            if (void 0 !== c) {
                if (n.isWall(r)) {
                    const i = c.type;
                    if (i === a.DoodadType.WoodenDoor || i === a.DoodadType.WoodenDoorOpen) {
                        const o = c
                          , r = o.orientation === a.DoorOrientation.Vertical;
                        renderer.wallAdaptor.adaptDoor(n, e, t, i, r, u),
                        d = this.doodadOverLayer
                    } else
                        renderer.wallAdaptor.adapt(n, e, t, i, u)
                } else if (n.isFence(r)) {
                    const i = c.type;
                    if (i === a.DoodadType.WoodenGate || i === a.DoodadType.WoodenGateOpen) {
                        const o = c;
                        renderer.fenceAdaptor.adaptGate(n, e, t, i, o.orientation === a.DoorOrientation.Vertical, u)
                    } else
                        renderer.fenceAdaptor.adapt(n, e, t, i, u)
                }
                void 0 !== u.TLFG && (this.doodadLayer.setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                this.doodadLayer.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                this.doodadLayer.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                this.doodadLayer.setTileBRFG(l, u.BRFG.x, u.BRFG.y)),
                void 0 !== u.TLBG && (this.doodadLayer.setTileTLBG(l, u.TLBG.x, u.TLBG.y),
                this.doodadLayer.setTileTRBG(l, u.TRBG.x, u.TRBG.y),
                this.doodadLayer.setTileBLBG(l, u.BLBG.x, u.BLBG.y),
                this.doodadLayer.setTileBRBG(l, u.BRBG.x, u.BRBG.y));
                const i = c.description();
                if (!i || !i.isTall) {
                    const e = t === this.height - 1 ? l - 16 * this.width * (this.height - 1) : l + 16 * this.width;
                    void 0 !== u.TLFO ? (this.doodadOverLayer.setTileTLFG(u.overLayerFGTall ? e : l, u.TLFO.x, u.TLFO.y),
                    this.doodadOverLayer.setTileTRFG(u.overLayerFGTall ? e : l, u.TRFO.x, u.TRFO.y),
                    this.doodadOverLayer.setTileBLFG(u.overLayerFGTall ? e : l, u.BLFO.x, u.BLFO.y),
                    this.doodadOverLayer.setTileBRFG(u.overLayerFGTall ? e : l, u.BRFO.x, u.BRFO.y)) : (this.doodadOverLayer.setTileTLFG(u.overLayerFGTall ? e : l, 0, 0),
                    this.doodadOverLayer.setTileTRFG(u.overLayerFGTall ? e : l, 0, 0),
                    this.doodadOverLayer.setTileBLFG(u.overLayerFGTall ? e : l, 0, 0),
                    this.doodadOverLayer.setTileBRFG(u.overLayerFGTall ? e : l, 0, 0)),
                    void 0 !== u.TLBO ? (this.doodadOverLayer.setTileTLBG(u.overLayerBGTall ? e : l, u.TLBO.x, u.TLBO.y),
                    this.doodadOverLayer.setTileTRBG(u.overLayerBGTall ? e : l, u.TRBO.x, u.TRBO.y),
                    this.doodadOverLayer.setTileBLBG(u.overLayerBGTall ? e : l, u.BLBO.x, u.BLBO.y),
                    this.doodadOverLayer.setTileBRBG(u.overLayerBGTall ? e : l, u.BRBO.x, u.BRBO.y)) : (this.doodadOverLayer.setTileTLBG(u.overLayerBGTall ? e : l, 0, 0),
                    this.doodadOverLayer.setTileTRBG(u.overLayerBGTall ? e : l, 0, 0),
                    this.doodadOverLayer.setTileBLBG(u.overLayerBGTall ? e : l, 0, 0),
                    this.doodadOverLayer.setTileBRBG(u.overLayerBGTall ? e : l, 0, 0))
                }
            }
            if (n.isTilled(r) ? (renderer.tillAdaptor.adapt(n, e, t, p, u),
            (d = this.terrainOverLayer).setTileTLFG(l, u.TLFG.x, u.TLFG.y),
            d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
            d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
            d.setTileBRFG(l, u.BRFG.x, u.BRFG.y)) : ((d = this.terrainOverLayer).setTileTLFG(l, 0, 0),
            d.setTileTRFG(l, 0, 0),
            d.setTileBLFG(l, 0, 0),
            d.setTileBRFG(l, 0, 0)),
            p === a.TerrainType.Dirt)
                renderer.dirtAdaptor.adapt(n, e, t, a.TerrainType.Dirt, u),
                (d = this.terrainLayer).setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                d.setTileBRFG(l, u.BRFG.x, u.BRFG.y),
                d.setTileTLBG(l, u.TLBG.x, u.TLBG.y),
                d.setTileTRBG(l, u.TRBG.x, u.TRBG.y),
                d.setTileBLBG(l, u.BLBG.x, u.BLBG.y),
                d.setTileBRBG(l, u.BRBG.x, u.BRBG.y);
            else if (tileAtlas.isFloor(p))
                renderer.floorAdaptor.adapt(n, e, t, p, u),
                (d = this.terrainLayer).setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                d.setTileBRFG(l, u.BRFG.x, u.BRFG.y),
                d.setTileTLBG(l, u.TLBG.x, u.TLBG.y),
                d.setTileTRBG(l, u.TRBG.x, u.TRBG.y),
                d.setTileBLBG(l, u.BLBG.x, u.BLBG.y),
                d.setTileBRBG(l, u.BRBG.x, u.BRBG.y);
            else if (tileAtlas.isMountain(p)) {
                if (tileAtlas.isOre(p)) {
                    renderer.mountainAdaptor.adapt(n, e, t, p, u),
                    (d = this.doodadLayer).setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                    d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                    d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                    d.setTileBRFG(l, u.BRFG.x, u.BRFG.y),
                    d.setTileTLBG(l, 0, 0),
                    d.setTileTRBG(l, 0, 0),
                    d.setTileBLBG(l, 0, 0),
                    d.setTileBRBG(l, 0, 0);
                    const a = s.default[p]
                      , i = a ? a.baseTerrain : void 0;
                    void 0 !== i && (p = i)
                }
                renderer.mountainAdaptor.adapt(n, e, t, p, u),
                (d = this.terrainLayer).setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                d.setTileBRFG(l, u.BRFG.x, u.BRFG.y),
                d.setTileTLBG(l, u.TLBG.x, u.TLBG.y),
                d.setTileTRBG(l, u.TRBG.x, u.TRBG.y),
                d.setTileBLBG(l, u.BLBG.x, u.BLBG.y),
                d.setTileBRBG(l, u.BRBG.x, u.BRBG.y)
            } else if (tileAtlas.isWater(p)) {
                const i = o.getWaterType(p)
                  , r = i !== p ? 3 : 0;
                switch (i) {
                case a.TerrainType.DeepSeawater:
                    renderer.waterAdaptor.adapt(n, e, t, a.TerrainType.DeepSeawater + r, u),
                    (d = this.doodadLayer).setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                    d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                    d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                    d.setTileBRFG(l, u.BRFG.x, u.BRFG.y);
                case a.TerrainType.Seawater:
                    renderer.waterAdaptor.adapt(n, e, t, a.TerrainType.Seawater + r, u),
                    (d = this.doodadLayer).setTileTLBG(l, u.TLFG.x, u.TLFG.y),
                    d.setTileTRBG(l, u.TRFG.x, u.TRFG.y),
                    d.setTileBLBG(l, u.BLFG.x, u.BLFG.y),
                    d.setTileBRBG(l, u.BRFG.x, u.BRFG.y);
                case a.TerrainType.ShallowSeawater:
                    renderer.waterAdaptor.adapt(n, e, t, a.TerrainType.ShallowSeawater + r, u),
                    (d = this.terrainLayer).setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                    d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                    d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                    d.setTileBRFG(l, u.BRFG.x, u.BRFG.y),
                    d.setTileTLBG(l, u.TLBG.x, u.TLBG.y),
                    d.setTileTRBG(l, u.TRBG.x, u.TRBG.y),
                    d.setTileBLBG(l, u.BLBG.x, u.BLBG.y),
                    d.setTileBRBG(l, u.BRBG.x, u.BRBG.y)
                }
            } else if (tileAtlas.isLava(p))
                switch (p) {
                case a.TerrainType.Lava:
                    renderer.lavaAdaptor.adapt(n, e, t, a.TerrainType.Lava, u),
                    (d = this.doodadLayer).setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                    d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                    d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                    d.setTileBRFG(l, u.BRFG.x, u.BRFG.y);
                case a.TerrainType.CoolingLava:
                    renderer.lavaAdaptor.adapt(n, e, t, a.TerrainType.CoolingLava, u),
                    d = this.doodadLayer,
                    p === a.TerrainType.CoolingLava && (d.setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                    d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                    d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                    d.setTileBRFG(l, u.BRFG.x, u.BRFG.y)),
                    d.setTileTLBG(l, u.TLFG.x + 127, u.TLFG.y + 127),
                    d.setTileTRBG(l, u.TRFG.x + 127, u.TRFG.y + 127),
                    d.setTileBLBG(l, u.BLFG.x + 127, u.BLFG.y + 127),
                    d.setTileBRBG(l, u.BRFG.x + 127, u.BRFG.y + 127);
                case a.TerrainType.Obsidian:
                    renderer.lavaAdaptor.adapt(n, e, t, a.TerrainType.Obsidian, u),
                    (d = this.terrainLayer).setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                    d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                    d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                    d.setTileBRFG(l, u.BRFG.x, u.BRFG.y),
                    d.setTileTLBG(l, u.TLBG.x, u.TLBG.y),
                    d.setTileTRBG(l, u.TRBG.x, u.TRBG.y),
                    d.setTileBLBG(l, u.BLBG.x, u.BLBG.y),
                    d.setTileBRBG(l, u.BRBG.x, u.BRBG.y)
                }
            else {
                renderer.defaultAdaptor.adapt(n, e, t, p, u),
                (d = this.terrainLayer).setTileTLFG(l, u.TLFG.x, u.TLFG.y),
                d.setTileTRFG(l, u.TRFG.x, u.TRFG.y),
                d.setTileBLFG(l, u.BLFG.x, u.BLFG.y),
                d.setTileBRFG(l, u.BRFG.x, u.BRFG.y);
                let a = 0;
                const i = p ? tileAtlas.terrain[p] : void 0;
                i && i.animated && (a = 127),
                d.setTileTLBG(l, u.TLBG.x + a, u.TLBG.y + a),
                d.setTileTRBG(l, u.TRBG.x + a, u.TRBG.y + a),
                d.setTileBLBG(l, u.BLBG.x + a, u.BLBG.y + a),
                d.setTileBRBG(l, u.BRBG.x + a, u.BRBG.y + a)
            }
            i ? (this.terrainLayer.sendTileToGPU(e, t, this.gl),
            this.terrainOverLayer.sendTileToGPU(e, t, this.gl),
            this.doodadLayer.sendTileToGPU(e, t, this.gl),
            this.doodadOverLayer.sendTileToGPU(e, t, this.gl),
            this.updateTileLightBlock(e, t, this.worldLayer.lightBlockMap.get(e, t))) : this.dirty = !0
        }
        updateTileLightBlock(e, t, a) {
            const i = this.gl;
            i.bindTexture(i.TEXTURE_2D, this.texLightBlock),
            i.texSubImage2D(i.TEXTURE_2D, 0, e, t, 1, 1, i.ALPHA, i.UNSIGNED_BYTE, new Uint8Array([a]))
        }
        flush() {
            if (!this.dirty)
                return;
            const e = this.gl;
            this.dirty = !1,
            this.terrainLayer.sendToGPU(e),
            this.terrainOverLayer.sendToGPU(e),
            this.doodadLayer.sendToGPU(e),
            this.doodadOverLayer.sendToGPU(e),
            e.bindTexture(e.TEXTURE_2D, this.texLightBlock),
            e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, this.worldLayer.lightBlockMap.width, this.worldLayer.lightBlockMap.height, 0, e.ALPHA, e.UNSIGNED_BYTE, this.worldLayer.lightBlockMap.data),
            game.updateRender(i.RenderSource.WorldLayerRendererFlush)
        }
    }
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/math/Bound3", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor(e, t, a) {
            this.min = e,
            this.max = t,
            this.z = a
        }
        static contains(e, t, i, n) {
            return n === e.z && a.containsIgnoreZ(e, t, i)
        }
        static containsIgnoreZ(e, t, a) {
            const i = 512;
            return e.max.x > 512 && t < e.min.x ? t += 512 : e.min.x < 512 && t > e.max.x && (t -= 512),
            e.max.y > 512 && a < e.min.y ? a += 512 : e.min.y < 512 && a > e.max.y && (a -= 512),
            t >= e.min.x && t <= e.max.x && a >= e.min.y && a <= e.max.y
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/IWorldRenderer", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("DedicatedServer", ["require", "exports", "utilities/promise/ResolvablePromise"], function(e, t, a) {
    function i(e) {
        return ()=>e
    }
    function n(e) {
        return e
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.resourceLoader = {
        initialize: i(),
        loadResources: e=>new a.default(e=>{
            e()
        }
        ),
        takeLoadingSlot: i(),
        getImageOverride: i(),
        updateImageOverrides: i(),
        releaseLoadingSlot: i()
    },
    t.audio = {
        resetMusicHandler: i(),
        getMusicHandler: i(),
        setMusicHandler: i(),
        playMusic: i(),
        stopMusic: i(),
        processEffects: i(),
        queueEffect: i(),
        updateMusicSpeed: i(),
        updatePosition: i(),
        updateVolume: i()
    },
    t.notifier = {
        addItem: i(),
        addStat: i(),
        clear: i(),
        update: i(),
        setTexture: i(),
        render: i()
    },
    t.particle = {
        clear: i(),
        create: i(),
        createMultiple: i(),
        simulate: i(),
        render: i()
    },
    t.worldRenderer = {
        positionBuffer: n(),
        layers: n(),
        dirtAdaptor: n(),
        tillAdaptor: n(),
        waterAdaptor: n(),
        lavaAdaptor: n(),
        fenceAdaptor: n(),
        mountainAdaptor: n(),
        wallAdaptor: n(),
        defaultAdaptor: n(),
        floorAdaptor: n(),
        updateAll: i(),
        setSpriteTexture: i(),
        getPixelSize: i(),
        getZoom: i(),
        getTileScale: i(),
        setTileScale: i(),
        setZoom: i(),
        setViewport: i(),
        getViewport: i(),
        getTileViewport: i(),
        getAmbientColor: i(),
        getFogColor: i(),
        initializeSpriteBatch: i(),
        renderWorld: i(),
        render: i(),
        screenToTile: i(),
        getViewportBounds: i(),
        computeSpritesInViewport: i(),
        batchCreatures: i(),
        dispose: i()
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("creature/corpse/ICorpseManager", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("entity/IEntityManager", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("creature/ICreatureManager", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("doodad/IDoodadManager", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/LanguageJsonSchemaGenerator", ["require", "exports", "language/Dictionaries", "utilities/enum/Enums", "utilities/iterable/Generators", "utilities/Objects"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const r = {
        oneOf: [{
            type: "string"
        }, {
            type: "array",
            items: {
                anyOf: [{
                    type: "string"
                }, {
                    type: "null"
                }]
            },
            minItems: 1
        }]
    };
    function s(e) {
        const t = {}
          , n = a.default[e];
        for (const e of i.default.keys(n))
            t[e[0].toLowerCase() + e.slice(1)] = r;
        return {
            type: "object",
            properties: t
        }
    }
    function l() {
        const e = i.default.entries(a.Dictionary).map(([e,t])=>n.tuple(e[0].toLowerCase() + e.slice(1), s(t))).collect(o.default.create);
        return {
            title: "Wayward Language",
            description: "A language file for a Wayward mod.",
            type: "object",
            allOf: [{
                type: "object",
                anyOf: [{
                    type: "object",
                    properties: {
                        dictionaries: {
                            description: "An object containing all the dictionaries and their entries. For a list of all dictionaries, see: https://waywardgame.github.io/enums/dictionary.html",
                            type: "object",
                            properties: e
                        }
                    },
                    required: ["dictionaries"]
                }, {
                    type: "object",
                    properties: {
                        pluralizationRules: {
                            description: 'An object containing "pluralization rules" for the language. These affect how nouns in this language are pluralized. For example, you could make a rule that changed "octopus" to "octopi"',
                            type: "object",
                            properties: {
                                pluralRules: {
                                    description: "An object containing mappings from a singular noun to a plural noun.",
                                    type: "object",
                                    additionalProperties: {
                                        type: "string"
                                    }
                                },
                                singularRules: {
                                    description: "An object containing mappings from a plural noun to a singular noun.",
                                    type: "object",
                                    additionalProperties: {
                                        type: "string"
                                    }
                                },
                                uncountableRules: {
                                    description: "An array containing a list of nouns which have an identical plural and singular form.",
                                    type: "array",
                                    minItems: 1,
                                    items: {
                                        type: "string"
                                    }
                                },
                                irregularRules: {
                                    description: "An array containing a list of tuples, the first value of which represents a singular noun and the second value of which represents its plural noun.",
                                    type: "array",
                                    minItems: 1,
                                    items: {
                                        type: "array",
                                        items: [{
                                            type: "string"
                                        }, {
                                            type: "string"
                                        }]
                                    }
                                },
                                articleRules: {
                                    description: "An array containing a list of tuples, the first value of which is a number representing how many of an item must be present for the rule to match (null to match all), the second value of which is a regular expression matching a part/parts of a noun, and the third value of which is a replacement for matches of that regular expression.",
                                    type: "array",
                                    minItems: 1,
                                    items: {
                                        type: "array",
                                        items: [{
                                            anyOf: [{
                                                type: "integer"
                                            }, {
                                                type: "null"
                                            }, {
                                                type: "object",
                                                properties: {
                                                    min: {
                                                        type: "number"
                                                    },
                                                    max: {
                                                        type: "number"
                                                    }
                                                },
                                                required: ["min"]
                                            }]
                                        }, {
                                            type: "string"
                                        }, {
                                            type: "string"
                                        }]
                                    }
                                }
                            },
                            additionalProperties: !1
                        }
                    },
                    required: ["pluralizationRules"]
                }]
            }, {
                type: "object",
                oneOf: [{
                    type: "object",
                    properties: {
                        extends: {
                            description: "The name of the language that this file extends.",
                            type: "string"
                        }
                    },
                    required: ["extends"]
                }, {
                    type: "object",
                    properties: {
                        name: {
                            description: "The name of this language.",
                            type: "string"
                        },
                        shouldPluralize: {
                            description: "Whether things in this language should be pluralized.",
                            enum: [!0]
                        }
                    },
                    required: ["name"]
                }]
            }]
        }
    }
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("language/LanguageManager", ["require", "exports", "Enums", "language/Dictionaries", "language/dictionary/UiTranslation", "language/English", "language/Language", "language/LanguageExtension", "language/LanguageJsonSchemaGenerator", "language/Translation", "mod/IHookManager", "newui/BindingManager", "utilities/enum/Enums", "utilities/Files", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Log", "utilities/Objects", "utilities/string/Strings", "utilities/Version"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S) {
    var I;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Singular = 0] = "Singular",
        e[e.Plural = 1] = "Plural",
        e[e.Uncountable = 2] = "Uncountable",
        e[e.Unknown = 3] = "Unknown"
    }(I = t.NounType || (t.NounType = {}));
    const v = new g.default(g.LogSource.Languages);
    class w {
        constructor() {
            this.translationProviders = [],
            this.uiTranslationsToSelector = [],
            u.default.provider = this.getTranslation
        }
        get language() {
            return saveDataGlobal.languageManagerSaveData.language || o.english.language
        }
        set language(e) {
            saveDataGlobal.languageManagerSaveData.language = e,
            e = e.toLowerCase(),
            delete this.orderedTranslationProviders,
            modManager.getHook(d.Hook.OnLanguageChange).call(saveDataGlobal.languageManagerSaveData.language),
            this.refreshUiTranslations()
        }
        get providers() {
            return this.translationProviders
        }
        get orderedProviders() {
            if (!this.orderedTranslationProviders) {
                const e = this.language.toLowerCase()
                  , t = -1;
                this.orderedTranslationProviders = this.translationProviders.values(t).filter(t=>t.language.toLowerCase() === e).include(saveDataGlobal.options.fallBackToEnglish && "english" !== e ? this.translationProviders.values(t).filter(e=>"english" === e.language.toLowerCase()) : []).collect(h.default.toArray)
            }
            return this.orderedTranslationProviders
        }
        initialize() {
            this.add(o.english),
            this.setup(),
            this.language = this.language
        }
        shouldUseAlternateFontStyle() {
            const e = this.translationProviders.values().filter2(e=>e.language.toLowerCase() === this.language.toLowerCase() && e instanceof r.default).collect(h.default.first());
            return e && e.alternateFontStyle || !1
        }
        refreshUiTranslations() {
            const e = Object.keys(this.uiTranslationsToSelector);
            for (let t = 0; t < e.length; t++)
                this.refreshUiTranslation(parseInt(e[t], 10))
        }
        getTranslation(e, t, a=!1) {
            const n = i.Dictionary[e]
              , o = i.default[e];
            if (!o)
                return a || v.warn(`Invalid Dictionary.${e} "${n}"`),
                [];
            const r = this.getEntryNameFromEntryId(e, t);
            if (void 0 === r)
                return a || v.warn(`Invalid entry "${t}" for Dictionary.${e} "${n}"`),
                [];
            let s;
            for (const e of this.orderedProviders)
                if (s = e.getTranslation(n, r))
                    break;
            return s || o === i.SYMBOL_ANY_DICTIONARY || a || v.warn(`No translation for ${n}:${r}`),
            s
        }
        add(e) {
            this.translationProviders.push(e),
            delete this.orderedTranslationProviders
        }
        remove(e) {
            const t = this.translationProviders.indexOf(e);
            -1 !== t && this.translationProviders.splice(t, 1),
            delete this.orderedTranslationProviders,
            e instanceof r.default && e.language === this.language && (this.language = o.english.language)
        }
        serialize(e=this.language, t=a.CaseStyle.CamelCase) {
            e = e.toLowerCase();
            const i = this.translationProviders.values().filter2(t=>t.language.toLowerCase() === e && t instanceof r.default).collect(h.default.first())
              , n = i && {
                name: i.language,
                alternateFontStyle: i.alternateFontStyle,
                dictionaries: i.dictionaries.entries().map(([e,a])=>y.tuple(T.default.formatCaseStyle(e, t), a.entries().map(([e,a])=>y.tuple(T.default.formatCaseStyle(e, t), 1 === a.length ? a[0] : a)).collect(f.default.create))).collect(f.default.create),
                pluralizationRules: M(i.pluralizationRules)
            };
            return n
        }
        serializeLanguageToFile(e, t) {
            m.default.download(`${e}.json`, this.serialize(e, t), !0, !0)
        }
        deserialize(e) {
            let t;
            t = "name"in e ? new r.default(e.name,e.alternateFontStyle) : new s.default(e.extends);
            for (const [a,i] of f.default.entries(e.dictionaries))
                t.setDictionary(a, i);
            return e.pluralizationRules && (t.setIrregularRules(...e.pluralizationRules.irregularRules||[]),
            t.setUncountableRules(...e.pluralizationRules.uncountables||[]),
            t.setPluralizationRules(...f.default .entries(e.pluralizationRules.pluralRules).collect(h.default .toArray)),
            t.setSingularizationRules(...f.default .entries(e.pluralizationRules.singularRules).collect(h.default .toArray)),
            t.setArticleRules(...e.pluralizationRules.articleRules||[])),
            t
        }
        generateSchema() {
            m.default.download("lang.schema.json", l.default(), !0, !1)
        }
        reformatSingularNoun(e, t, a=!0) {
            const i = e.toLowerCase()
              , n = 1 === t ? e : this.plural(e);
            if (1 === t && this.getNounType(n) !== I.Singular && (t = 1243124),
            a)
                for (const {language: a, pluralizationRules: {articleRules: o, uncountables: r}} of this.orderedProviders) {
                    if (a !== this.language)
                        continue;
                    if (r.find(e=>e.test(i)))
                        return e;
                    const s = o.find(([e,a])=>(null === e || e === t || "number" != typeof e) && ((!e || "object" != typeof e || !(t < e.min || t > (e.max || 1 / 0))) && a.test(n)));
                    if (s)
                        return n.replace(s[1], s[2])
                }
            return n
        }
        getNounType(e, t=I.Unknown) {
            const a = e.toLowerCase();
            for (const {language: e, pluralizationRules: {irregularRules: t, singularRules: i, pluralRules: n, uncountables: o}} of this.orderedProviders) {
                if (e !== this.language)
                    continue;
                if (o.find(e=>e.test(a)))
                    return I.Uncountable;
                const r = t.find(([e,t])=>e === a || t === a);
                if (r)
                    return r[0] === a ? I.Singular : I.Plural;
                const s = n.find(([e])=>e.test(a));
                if (s)
                    return I.Singular;
                const l = i.find(([e])=>e.test(a));
                if (l)
                    return I.Plural
            }
            return t
        }
        plural(e) {
            const t = e.toLowerCase();
            for (const {language: a, pluralizationRules: {irregularRules: i, pluralRules: n, singularRules: o, uncountables: r}} of this.orderedProviders) {
                if (a !== this.language)
                    continue;
                if (r.find(e=>e.test(t)))
                    return e;
                const s = i.find(([e])=>e === t);
                if (s)
                    return s[1];
                const l = o.find(([e])=>e.test(t));
                if (l)
                    return e;
                const u = n.find(([e])=>e.test(t));
                if (u)
                    return t.replace(...u)
            }
            return e
        }
        getEntryNameFromEntryId(e, t) {
            const a = i.default[e];
            if (a) {
                if (a === i.SYMBOL_ANY_DICTIONARY)
                    return t;
                if (t in a)
                    return a[t];
                for (const [e,i] of c.default.entries(a))
                    if (i === t)
                        return e
            }
        }
        setup() {
            this.addTranslateSelectors([n.default.EquipmentBack, "ul[data-equip-slot='Back']", "data-tooltip"], [n.default.EquipmentBelt, "ul[data-equip-slot='Belt']", "data-tooltip"], [n.default.EquipmentChest, "ul[data-equip-slot='Chest']", "data-tooltip"], [n.default.EquipmentChest, "ul[data-equip-slot='Chest']", "data-tooltip"], [n.default.EquipmentFeet, "ul[data-equip-slot='Feet']", "data-tooltip"], [n.default.EquipmentHands, "ul[data-equip-slot='Hands']", "data-tooltip"], [n.default.EquipmentHead, "ul[data-equip-slot='Head']", "data-tooltip"], [n.default.EquipmentLeftHand, "ul[data-equip-slot='LeftHand']", "data-tooltip"], [n.default.EquipmentLeftHandOption, "#equipment div[data-checkbox-id='leftHand'] .label"], [n.default.EquipmentLegs, "ul[data-equip-slot='Legs']", "data-tooltip"], [n.default.EquipmentNeck, "ul[data-equip-slot='Neck']", "data-tooltip"], [n.default.EquipmentRightHand, "ul[data-equip-slot='RightHand']", "data-tooltip"], [n.default.EquipmentRightHandOption, "#equipment div[data-checkbox-id='rightHand'] .label"], [n.default.EquipmentUse, "#equipment .use-label"], [n.default.HudFilter, ".filter", "placeholder"], [n.default.QuickSlot1, "#numbers .number[data-quick-slot='1']", "", !1, e=>p.bindingManager.getBindingsTranslation(a.Bindable.GameQuickSlot1)], [n.default.QuickSlot2, "#numbers .number[data-quick-slot='2']", "", !1, e=>p.bindingManager.getBindingsTranslation(a.Bindable.GameQuickSlot2)], [n.default.QuickSlot3, "#numbers .number[data-quick-slot='3']", "", !1, e=>p.bindingManager.getBindingsTranslation(a.Bindable.GameQuickSlot3)], [n.default.QuickSlot4, "#numbers .number[data-quick-slot='4']", "", !1, e=>p.bindingManager.getBindingsTranslation(a.Bindable.GameQuickSlot4)], [n.default.QuickSlot5, "#numbers .number[data-quick-slot='5']", "", !1, e=>p.bindingManager.getBindingsTranslation(a.Bindable.GameQuickSlot5)], [n.default.QuickSlot6, "#numbers .number[data-quick-slot='6']", "", !1, e=>p.bindingManager.getBindingsTranslation(a.Bindable.GameQuickSlot6)], [n.default.QuickSlot7, "#numbers .number[data-quick-slot='7']", "", !1, e=>p.bindingManager.getBindingsTranslation(a.Bindable.GameQuickSlot7)], [n.default.QuickSlot8, "#numbers .number[data-quick-slot='8']", "", !1, e=>p.bindingManager.getBindingsTranslation(a.Bindable.GameQuickSlot8)], [n.default.QuickSlot9, "#numbers .number[data-quick-slot='9']", "", !1, e=>p.bindingManager.getBindingsTranslation(a.Bindable.GameQuickSlot9)], [n.default.TabCrafting, "#crafting-tab-buttons .crafting-tab"], [n.default.TabDismantle, "#crafting-tab-buttons .dismantle-tab"], [n.default.Version, "#version .info", "", !1, e=>e.getString(S.default.getVersionDisplayString())], [n.default.WindowTitleContainer, "#container", "title"], [n.default.WindowTitleCrafting, "#crafting", "title"], [n.default.WindowTitleEquipment, "#equipment", "title"], [n.default.WindowTitleInventory, "#inventory", "title"])
        }
        addTranslateSelector(e, t, a, i, n) {
            this.uiTranslationsToSelector[e] = {
                selector: t,
                html: i,
                attribute: a,
                func: n
            }
        }
        addTranslateSelectors(...e) {
            for (const t of e)
                this.addTranslateSelector(...t)
        }
        refreshUiTranslation(e) {
            const t = this.language
              , a = "string" == typeof e ? n.default[e] : e
              , i = this.uiTranslationsToSelector[a];
            let o = u.default.ui(a).getString(), r;
            if (o) {
                r = "object" == typeof i.selector ? i.selector : [i.selector];
                for (let e = 0; e < r.length; e++) {
                    const s = $(r[e]);
                    if (0 !== s.length)
                        if (i.func && (o = i.func(u.default.ui(a))),
                        i.attribute) {
                            if ("title" === i.attribute)
                                try {
                                    s.dialog("option", "title", o);
                                    continue
                                } catch (e) {}
                            s.attr(i.attribute, o)
                        } else if (i.html) {
                            const e = o.split(",");
                            let t = "";
                            for (let a = 0; a < e.length; a++)
                                t += `<li>${e[a]}</li>`;
                            s.html(t)
                        } else
                            s.text(o);
                    else {
                        const e = n.default[a];
                        e.startsWith("MenuChangelog") || "MenuDeleteGame" === e || "MenuEditGame" === e || "MenuExportGame" === e || "EnableHints" === e || "DisableHints" === e || game.playing || v.warn(`[${t}] Invalid selector for Ui ${n.default[a].toString()}, ${r.join(",")}`)
                    }
                }
            } else
                v.warn(`[${t}] Missing entry for Ui ${n.default[a] ? n.default[a].toString() : e}`)
        }
    }
    function M(e) {
        const {pluralRules: t, singularRules: a, uncountables: i, irregularRules: n, articleRules: o} = e
          , r = {
            pluralRules: t.values().map(b).collect(f.default.create),
            singularRules: a.values().map(b).collect(f.default.create),
            uncountables: i.map(k),
            irregularRules: n,
            articleRules: o.map(([e,t,a])=>y.tuple(e, k(t), a))
        };
        return Object.keys(r.pluralRules).length || delete r.pluralRules,
        Object.keys(r.singularRules).length || delete r.singularRules,
        r.uncountables.length || delete r.uncountables,
        r.irregularRules.length || delete r.irregularRules,
        r.articleRules.length || delete r.articleRules,
        r
    }
    function b([e,t]) {
        return y.tuple(k(e), t)
    }
    function k(e) {
        const t = e.source;
        return t.startsWith("\\b") && t.endsWith("$") ? t.slice(2, -1) : `/${t}/`
    }
    __decorate([f.Bound], w.prototype, "getTranslation", null),
    t.default = w
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/MainMenuScreen", ["require", "exports", "newui/screen/IScreen", "newui/screen/screens/menu/component/IMenu", "newui/screen/screens/menu/component/MenuScreen"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o extends n.default {
        constructor(e) {
            super(e, a.ScreenId.MainMenu),
            this.dataset.backgroundImage = a.Background[a.Background.Default],
            this.on("Show", ()=>this.showMenu(i.MenuId.Main))
        }
    }
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/screens/SplashScreen", ["require", "exports", "mod/IHookHost", "newui/component/Component", "newui/screen/IScreen", "newui/screen/Screen", "utilities/Async", "utilities/Objects"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l extends o.default {
        constructor(e) {
            super(e, n.ScreenId.Splash),
            this.on("Show", this.create)
        }
        onBindLoop(e, t) {
            return t.isAnythingDown() && this.showNext(),
            e
        }
        async create() {
            for (let e = 0; e < 25; e++) {
                const e = new i.default(this.api).classes.add("splash-particle").appendTo(this);
                e.style.setProperty("--random1", `${Math.random()}`),
                e.style.setProperty("--random2", `${Math.random()}`),
                e.style.setProperty("--random3", `${Math.random()}`),
                e.style.setProperty("--random4", `${Math.random()}`),
                e.style.setProperty("--random5", `${Math.random()}`)
            }
            new i.default(this.api).classes.add("splash-logo").appendTo(this),
            await r.sleep(1500),
            saveDataGlobal.options.skipSplash || await r.sleep(5e3),
            this.showNext()
        }
        async showNext() {
            this.api.isScreenVisible(n.ScreenId.Splash) && (document.getElementById("initial-load").remove(),
            saveDataGlobal.options.shouldLoadLastSave ? (saveDataGlobal.options.shouldLoadLastSave = !1,
            this.api.hideScreen(n.ScreenId.Splash),
            game.play({
                slot: await saveManager.getMostRecentSlot()
            })) : this.api.showScreen(n.ScreenId.MainMenu))
        }
    }
    __decorate([Override, a.HookMethod], l.prototype, "onBindLoop", null),
    __decorate([s.Bound], l.prototype, "create", null),
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/ScreenMap", ["require", "exports", "newui/screen/IScreen", "newui/screen/screens/GameScreen", "newui/screen/screens/InterruptScreen", "newui/screen/screens/MainMenuScreen", "newui/screen/screens/SplashScreen"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const s = {
        [a.ScreenId.MainMenu]: o.default,
        [a.ScreenId.Splash]: r.default,
        [a.ScreenId.Interrupt]: n.default,
        [a.ScreenId.Game]: i.default
    };
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/screen/ScreenManager", ["require", "exports", "newui/BindingManager", "newui/screen/IScreen", "newui/screen/ScreenMap", "utilities/Async", "utilities/Log"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const s = new r.default(r.LogSource.NewUi,"ScreenManager");
    class l {
        constructor(e) {
            this._screens = {},
            this.visibleScreen = i.ScreenId.None,
            this.overlayScreen = i.ScreenId.None,
            this.api = e
        }
        *screens() {
            for (const e in this._screens)
                yield this._screens[e]
        }
        getScreen(e) {
            if (e === i.ScreenId.None)
                return;
            if (this._screens[e])
                return this._screens[e];
            s.info(`Initialized screen '${i.ScreenId[e]}'`);
            const t = n.default[e];
            if (!t)
                throw s.error(`Can't load the screen by id: ${e} (${i.ScreenId[e]})`),
                new Error("Being unable to initialize a screen is non-recoverable.");
            return this._screens[e] = new t(this.api).appendTo("body")
        }
        getVisibleScreen() {
            return this.getScreen(this.overlayScreen !== i.ScreenId.None ? this.overlayScreen : this.visibleScreen)
        }
        isScreenVisible(e) {
            return this.overlayScreen !== i.ScreenId.None ? this.overlayScreen === e : this.visibleScreen === e
        }
        show(e) {
            const t = this.getScreen(e);
            return this.api.tooltips.hide(),
            t.isOverlayScreen ? this.overlayScreen !== e && this.hide(this.overlayScreen) : this.visibleScreen !== e && this.hide(this.visibleScreen),
            a.bindingManager.disableBindsUntil(400),
            this._screens[e].show(),
            t.isOverlayScreen ? this.overlayScreen = e : this.visibleScreen = e,
            this._screens[e]
        }
        hide(e) {
            const t = this.getScreenId(e);
            t !== i.ScreenId.None && (a.bindingManager.disableBindsUntil(400),
            this.hideAndRemoveScreen(t),
            this._screens[t] && ((e = this.getScreen(t)).isOverlayScreen ? this.overlayScreen = i.ScreenId.None : this.visibleScreen = i.ScreenId.None))
        }
        getScreenId(e) {
            if ("number" == typeof e)
                return e;
            let t = i.ScreenId.None;
            for (const a in this._screens)
                e === this._screens[a] && (t = +a);
            return t
        }
        hideAndRemoveScreen(e) {
            const t = this._screens[e];
            t && (t.hide(),
            o.sleep(1e3).then(()=>{
                const a = t.isOverlayScreen ? this.overlayScreen : this.visibleScreen;
                a !== e && this.remove(e)
            }
            ))
        }
        remove(e) {
            const t = this.getScreenId(e);
            (e = this._screens[t]) && (e.remove(),
            delete this._screens[t])
        }
    }
    t.default = l
}),
/*!
* Copyright Unlok, Vaughn Royko 2011-2018
* http://www.unlok.ca
*
* Credits & Thanks:
* http://www.unlok.ca/credits-thanks/
*
* Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
* https://waywardgame.github.io/
*/
define("newui/tooltip/TooltipManager", ["require", "exports", "newui/BindingManager", "newui/component/Component", "newui/INewUi", "newui/tooltip/Tooltip", "utilities/Objects"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class s {
        constructor(e) {
            this.api = e,
            e.on(n.UiApiEvent.Resize, this.onScreenResize),
            this.tooltipWrapper = new i.default(e).setId("tooltips").appendTo(document.body),
            setInterval(this.hideLoop, 100)
        }
        show(e, t=!1) {
            if (!t && a.bindingManager.areBindsDisabled())
                return;
            if (this.host === e)
                return this.tooltip.show();
            this.host && this.hide(this.host, !0),
            this.host = e,
            this.api.on(n.UiApiEvent.Resize, this.onScreenResize);
            const i = this.tooltip = new o.default(this.api,e).appendTo(this.tooltipWrapper).on("Remove", ()=>{
                i === this.tooltip && (this.tooltip = void 0,
                this.host = void 0)
            }
            );
            return this.tooltip
        }
        hide(e=this.host, t=!0) {
            if (!this.host || this.host !== e)
                return;
            const a = this.tooltip;
            a.hide(),
            a.cache && !t || a.remove()
        }
        hideLoop() {
            this.host && !a.bindingManager.isMouseWithin(this.host) && this.hide()
        }
        onScreenResize() {
            this.tooltip && this.tooltip.updatePosition()
        }
    }
    __decorate([r.Bound], s.prototype, "hideLoop", null),
    __decorate([r.Bound], s.prototype, "onScreenResize", null),
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/util/HighlightManager", ["require", "exports", "newui/component/Component", "newui/component/IComponent"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        constructor() {
            this.highlights = new Map,
            this.highlightComponents = new Map
        }
        start(e, t) {
            this.highlights.set(e, t);
            for (const e of t.selectors)
                this.startHighlight(e, t.iterations)
        }
        end(e) {
            const t = this.highlights.get(e);
            if (t)
                e: for (const e of t.selectors) {
                    for (const t of this.highlights.values())
                        for (const a of t.selectors)
                            if (a === e)
                                continue e;
                    const t = this.getHighlightComponents(e);
                    if (t)
                        for (const e of t)
                            e.classes.remove("continue-highlight")
                }
        }
        register(e, t, a="Remove") {
            const i = this.getHighlightSelectorId(...t);
            this.highlightComponents.set(i, e),
            e.once(a, ()=>this.highlightComponents.delete(i))
        }
        getHighlightSelectorId(e, t) {
            return `${e}:${t}`
        }
        getHighlightComponents([e,t]) {
            if (e === i.HighlightType.Selector)
                return a.default.all(`${t}`);
            const n = this.highlightComponents.get(this.getHighlightSelectorId(e, t));
            return n ? [n] : []
        }
        startHighlight(e, t=3) {
            const a = this.getHighlightComponents(e);
            if (a)
                for (const e of a) {
                    e.classes.add("highlight", "continue-highlight"),
                    e.style.animationIterationCount = `${t}`;
                    const a = ()=>{
                        e.classes.remove("highlight", "continue-highlight").element.removeEventListener("animationend", a)
                    }
                    ;
                    e.listen("animationend", a);
                    const i = ()=>{
                        e.classes.has("continue-highlight") || e.classes.remove("highlight").element.removeEventListener("animationiteration", i)
                    }
                    ;
                    e.listen("animationiteration", i)
                }
        }
    }
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/util/InterruptFactory", ["require", "exports", "language/segment/LinkSegment", "newui/component/Text", "newui/INewUi", "newui/screen/IScreen", "newui/util/IInterrupt", "utilities/Async", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const d = new l.default(l.LogSource.NewUi,"InterruptFactory");
    class p {
        constructor(e, t, a) {
            this.canCancel = !1,
            this.isTopMenu = !1,
            this.executed = !1,
            this.api = e,
            this.title = t,
            this.description = a,
            s.sleep(1).then(this.warnIfNeverShown)
        }
        setTopMenu(e=!0) {
            return this.isTopMenu = e,
            this
        }
        setCanCancel(e=!0) {
            return this.canCancel = e,
            this
        }
        withDescription(e) {
            return this.description = e,
            this
        }
        async withChoice(...e) {
            return this.execute({
                choices: e
            })
        }
        async withConfirmation() {
            return this.execute({
                type: r.InterruptType.Confirm
            })
        }
        async withInfo() {
            await this.execute({type:r.InterruptType.Info})
        }
        async withInput(e) {
            return this.execute({
                input: e,
                canCancel: this.canCancel
            })
        }
        async withMenu(e, t) {
            await this.execute({menuId:e,initializer:t})
        }
        async withLoading(e, t, a) {
            await this.execute({type:r.InterruptType.Loading,canCancel:t,specialType:a}),
            e && (await("function"==typeof e?e():e),
            await this.api.hideLoadingInterrupt())
        }
        async execute(e) {
            this.executed = !0,
            e = Object.assign({
                title: this.title,
                description: this.description,
                isTopMenu: this.isTopMenu
            }, e),
            await this.api.emitAsync(n.UiApiEvent.Interrupt,e);
            const t = this.api.getScreen(o.ScreenId.Interrupt);
            this.api.showScreen(o.ScreenId.Interrupt);
            const a = await t.interrupt(e);
            return t.interruptType === r.InterruptType.Loading || t.visibleMenu || this.api.hideScreen(o.ScreenId.Interrupt),
            t.interruptType === r.InterruptType.Loading ? t.visibleMenu.waitFor().then(async t=>{
                await this.api.emitAsync(n.UiApiEvent.InterruptClose,e,t)
            }
            ) : await this.api.emitAsync(n.UiApiEvent.InterruptClose,e),
            a
        }
        warnIfNeverShown() {
            if (!this.executed) {
                const e = i.default.toString(this.title)
                  , t = i.default.toString(this.description, [a.default]);
                d.warn(`An interrupt was created but never finished. Title: ${e}, Description: ${t}`)
            }
        }
    }
    __decorate([u.Bound], p.prototype, "warnIfNeverShown", null),
    t.default = p
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/util/ScaleManager", ["require", "exports", "newui/INewUi"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i {
        constructor(e) {
            this.api = e
        }
        getMinimum() {
            return .5
        }
        getMaximum() {
            const e = Math.min(Math.max(VIEWPORT_MIN_WIDTH, window.innerWidth) / 1920, Math.max(VIEWPORT_MIN_HEIGHT, window.innerHeight) / 1080);
            return Math.max(.25, Math.round(4 * e * 1.3) / 4)
        }
        getCurrent() {
            return +document.documentElement.style.getPropertyValue("--scale")
        }
        getRequested() {
            return saveDataGlobal.options.uiScale
        }
        request(e) {
            saveDataGlobal.options.uiScale = Math.min(this.getMaximum(), Math.max(this.getMinimum(), e)),
            this.update()
        }
        update() {
            const e = Math.min(this.getMaximum(), Math.max(this.getMinimum(), saveDataGlobal.options.uiScale));
            this.getCurrent() !== e && (document.documentElement.style.setProperty("--scale", `${e}`),
            document.documentElement.style.setProperty("--scale-floor", `${Math.max(1, e)}`),
            document.documentElement.style.setProperty("--scale-floor-quarter", `${Math.max(.75, e)}`),
            document.documentElement.style.setProperty("--scale-floor-half", `${Math.max(.5, e)}`),
            this.api.emit(a.UiApiEvent.Resize))
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/NewUi", ["require", "exports", "Enums", "game/IGame", "mod/IHookHost", "newui/BindingManager", "newui/component/Component", "newui/INewUi", "newui/screen/IScreen", "newui/screen/ScreenManager", "newui/tooltip/TooltipManager", "newui/util/HighlightManager", "newui/util/InterruptFactory", "newui/util/ScaleManager", "save/clientStore/IClientStore", "utilities/Emitter", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class f extends y.default {
        constructor() {
            super(),
            this.tooltips = new d.default(this),
            this.scale = new m.default(this),
            this.highlights = new p.default,
            this.screenManager = new u.default(this),
            this.dataHosts = new Map,
            window.addEventListener("resize", ()=>{
                this.scale.update(),
                this.emit(s.UiApiEvent.Resize)
            }
            ),
            steamworks.onMessage("fullscreen_update", (e,t)=>{
                saveDataGlobal.options.fullscreen = t,
                this.toggleFullscreen(t)
            }
            );
            const e = document
              , t = ()=>{
                const t = !(!e.fullscreenElement && !e.webkitFullscreenElement);
                saveDataGlobal.options.fullscreen = t
            }
            ;
            document.addEventListener("fullscreenchange", t),
            document.addEventListener("webkitfullscreenchange", t),
            game && game.once(i.GameEvent.GlobalSlotLoaded, ()=>{
                this.scale.update(),
                this.setDialogOpacity(),
                document.documentElement.classList.toggle("default-cursor", saveDataGlobal.options.defaultCursor)
            }
            ),
            this.on(s.UiApiEvent.InterruptClose, ()=>{
                const e = this.getVisibleScreen();
                e && e.element.focus()
            }
            ),
            o.bindingManager.registerBindCatcher(document.body, !0),
            hookManager.register(n.IHookHost.createHost({
                onLanguageChange: this.onLanguageChange
            }))
        }
        screens() {
            return this.screenManager.screens()
        }
        getScreen(e) {
            return this.screenManager.getScreen(e)
        }
        getVisibleScreen() {
            return this.screenManager.getVisibleScreen()
        }
        isScreenVisible(e) {
            return this.screenManager.isScreenVisible(e)
        }
        showScreen(e) {
            return this.screenManager.show(e)
        }
        hideScreen(e) {
            this.screenManager.hide(e)
        }
        interrupt(e, t) {
            return new c.default(this,e,t)
        }
        async interruptWithConfirmation(e, t) {
            return this.interrupt(e, t).withConfirmation()
        }
        async interruptWithInfo(e, t) {
            await this.interrupt(e,t).withInfo()
        }
        async interruptWithMenu(e, t) {
            await this.interrupt().withMenu(e,t)
        }
        async showLoadingInterrupt(e, t, a, i) {
            await this.interrupt(e,t).withLoading(void 0,a,i)
        }
        async hideLoadingInterrupt() {
            const e = this.screenManager.getScreen(l.ScreenId.Interrupt);
            e && !e.classes.has("hidden") && await e.hideLoadingInterrupt()
        }
        refreshTranslations(...e) {
            0 === e.length && e.push(document.body);
            for (const t of e) {
                if (!t)
                    continue;
                const e = r.default.findDescendants(t, ".text", !0);
                for (const t of e)
                    t.dispatchEvent(new Event("refresh"))
            }
        }
        storeElements(...e) {
            this.storageElement || (this.storageElement = new r.default(this).setId("element-storage")),
            this.storageElement.append(e)
        }
        registerDataHost(e, t) {
            if (this.dataHosts.values().any(e=>e === t))
                return;
            this.dataHosts.set(e, t);
            const a = localPlayer.clientStore.get(h.ClientDataType.NewUi)
              , i = saveDataGlobal.newui[e] = saveDataGlobal.newui[e] || {};
            for (const [n,o] of s.savedProperties(t))
                o === s.SaveLocation.Local || n in i || (i[n] = t[n]),
                o === s.SaveLocation.Global || a.has(e, n) || a.set(e, n, o === s.SaveLocation.Both ? i[n] : t[n]),
                o === s.SaveLocation.Both && (i[n] = a.get(e, n)),
                Object.defineProperty(t, n, {
                    get() {
                        let t = o === s.SaveLocation.Global ? i[n] : a.get(e, n);
                        return o !== s.SaveLocation.Global && "object" == typeof t && (t = new Proxy(t,{
                            set: (t,i,o)=>(t[i] = o,
                            a.update(e, n),
                            !0),
                            get: (t,i)=>{
                                if (Array.isArray(t)) {
                                    const o = ["push", "pop", "unshift", "shift", "splice"];
                                    if (o.includes(i))
                                        return (...o)=>{
                                            const r = t[i](...o);
                                            return a.update(e, n),
                                            r
                                        }
                                }
                                return t[i]
                            }
                        })),
                        t
                    },
                    set(t) {
                        o !== s.SaveLocation.Global && a.set(e, n, t),
                        o !== s.SaveLocation.Local && (i[n] = t)
                    }
                });
            "emit"in t && t.emit(s.UiApiEvent.LoadedFromSave)
        }
        playActivateSound() {
            audio.queueEffect(a.SfxType.UiActivate, 0, 0, 0, void 0, void 0, !0)
        }
        playSelectSound() {
            audio.queueEffect(a.SfxType.UiSelect, 0, 0, 0, void 0, void 0, !0)
        }
        toggleFullscreen(e=!saveDataGlobal.options.fullscreen) {
            if (steamworks.isElectron())
                steamworks.sendMessage("fullscreen", e),
                saveDataGlobal.options.fullscreen = e;
            else if (e) {
                const e = document.documentElement;
                (e.requestFullscreen || e.webkitRequestFullScreen).call(e),
                document.fullscreenEnabled || (saveDataGlobal.options.fullscreen = !1)
            } else {
                const e = document;
                (e.exitFullscreen || e.webkitExitFullscreen).call(e)
            }
        }
        setDialogOpacity(e=100*saveDataGlobal.options.dialogOpacity, t=!0) {
            document.documentElement.style.setProperty("--dialog-opacity", `${e / 100}`),
            t && (saveDataGlobal.options.dialogOpacity = e / 100)
        }
        addStylesheet(e) {
            const t = document.createElement("link");
            t.setAttribute("rel", "stylesheet"),
            t.setAttribute("type", "text/css"),
            t.setAttribute("href", e),
            document.head.appendChild(t)
        }
        removeStylesheet(e) {
            const t = document.querySelector(`link[href="${e}"]`);
            t && t.remove()
        }
        onLanguageChange() {
            document.documentElement.dataset.language = languageManager.language,
            this.refreshTranslations()
        }
    }
    __decorate([g.Bound], f.prototype, "refreshTranslations", null),
    __decorate([g.Bound], f.prototype, "onLanguageChange", null),
    t.default = f
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("npc/INPCManager", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/fieldofview/IFieldOfView", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/ISpriteAtlas", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/ITileAtlas", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("tile/ITileEventManager", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("Global", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("game/IGenericManager", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("command/ICommandManager", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("ui/functional/IFunctionalTooltip", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("OldEnums", ["require", "exports"], function(e, t) {
    var a, i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.DeepSeawater = 0] = "DeepSeawater",
        e[e.Seawater = 1] = "Seawater",
        e[e.ShallowSeawater = 2] = "ShallowSeawater",
        e[e.DeepFreshWater = 3] = "DeepFreshWater",
        e[e.FreshWater = 4] = "FreshWater",
        e[e.ShallowFreshWater = 5] = "ShallowFreshWater",
        e[e.Grass = 6] = "Grass",
        e[e.Tree = 7] = "Tree",
        e[e.BareTree = 8] = "BareTree",
        e[e.TreeWithVines = 9] = "TreeWithVines",
        e[e.TreeWithBerries = 10] = "TreeWithBerries",
        e[e.TreeWithFungus = 11] = "TreeWithFungus",
        e[e.PalmTree = 12] = "PalmTree",
        e[e.BarePalmTree = 13] = "BarePalmTree",
        e[e.PalmTreeWithCoconuts = 14] = "PalmTreeWithCoconuts",
        e[e.Gravel = 15] = "Gravel",
        e[e.Dirt = 16] = "Dirt",
        e[e.BeachSand = 17] = "BeachSand",
        e[e.Snow = 18] = "Snow",
        e[e.Swamp = 19] = "Swamp",
        e[e.Clay = 20] = "Clay",
        e[e.Ash = 21] = "Ash",
        e[e.Rocks = 22] = "Rocks",
        e[e.RocksWithIron = 23] = "RocksWithIron",
        e[e.RocksWithTalc = 24] = "RocksWithTalc",
        e[e.RocksWithCoal = 25] = "RocksWithCoal",
        e[e.RocksWithLimestone = 26] = "RocksWithLimestone",
        e[e.CobblestoneFlooring = 27] = "CobblestoneFlooring",
        e[e.Sandstone = 28] = "Sandstone",
        e[e.SandstoneFlooring = 29] = "SandstoneFlooring",
        e[e.SandstoneWithIron = 30] = "SandstoneWithIron",
        e[e.SandstoneWithNiter = 31] = "SandstoneWithNiter",
        e[e.WoodenFlooring = 32] = "WoodenFlooring",
        e[e.ClayBrickFlooring = 33] = "ClayBrickFlooring",
        e[e.CaveEntrance = 34] = "CaveEntrance",
        e[e.RedCarpet = 35] = "RedCarpet",
        e[e.Lava = 36] = "Lava",
        e[e.FertileDirt = 37] = "FertileDirt"
    }(a = t.Pre240TerrainType || (t.Pre240TerrainType = {})),
    function(e) {
        e[e.WoodenDoor = 0] = "WoodenDoor",
        e[e.WoodenFence = 1] = "WoodenFence",
        e[e.WoodenWall = 2] = "WoodenWall",
        e[e.ClayBrickWall = 3] = "ClayBrickWall",
        e[e.SandstoneWall = 4] = "SandstoneWall",
        e[e.StoneWall = 5] = "StoneWall",
        e[e.SetExplosiveTrap = 6] = "SetExplosiveTrap",
        e[e.SetDeadfall = 7] = "SetDeadfall",
        e[e.SetSnare = 8] = "SetSnare",
        e[e.SetHobgoblinSnare = 9] = "SetHobgoblinSnare",
        e[e.SolarStill = 10] = "SolarStill",
        e[e.WoodenChest = 11] = "WoodenChest",
        e[e.LockedWoodenChest = 12] = "LockedWoodenChest",
        e[e.CreatureIdol = 13] = "CreatureIdol",
        e[e.GrowingGrass = 14] = "GrowingGrass",
        e[e.Clematis = 15] = "Clematis",
        e[e.MilkThistles = 16] = "MilkThistles",
        e[e.GrowingMushroom = 17] = "GrowingMushroom",
        e[e.ButtonMushrooms = 18] = "ButtonMushrooms",
        e[e.FlyAmanita = 19] = "FlyAmanita",
        e[e.Switchgrass = 20] = "Switchgrass",
        e[e.Badderlocks = 21] = "Badderlocks",
        e[e.Chives = 22] = "Chives",
        e[e.Pineapple = 23] = "Pineapple",
        e[e.PileOfRocks = 24] = "PileOfRocks",
        e[e.RaspberryBush = 25] = "RaspberryBush",
        e[e.Beggarticks = 26] = "Beggarticks",
        e[e.Sapling = 27] = "Sapling",
        e[e.GrowingPlant = 28] = "GrowingPlant",
        e[e.Cotton = 29] = "Cotton",
        e[e.Tree = 30] = "Tree",
        e[e.TreeWithVines = 31] = "TreeWithVines",
        e[e.TreeWithBerries = 32] = "TreeWithBerries",
        e[e.TreeWithFungus = 33] = "TreeWithFungus",
        e[e.BareTree = 34] = "BareTree",
        e[e.PalmTreeWithCoconuts = 35] = "PalmTreeWithCoconuts",
        e[e.PalmTree = 36] = "PalmTree",
        e[e.BarePalmTree = 37] = "BarePalmTree",
        e[e.PricklyPears = 38] = "PricklyPears",
        e[e.DeadBush = 39] = "DeadBush",
        e[e.StoneWaterStill = 40] = "StoneWaterStill",
        e[e.LitStoneWaterStill = 41] = "LitStoneWaterStill",
        e[e.StoneCampfire = 42] = "StoneCampfire",
        e[e.LitStoneCampfire = 43] = "LitStoneCampfire",
        e[e.SandstoneKiln = 44] = "SandstoneKiln",
        e[e.LitSandstoneKiln = 45] = "LitSandstoneKiln",
        e[e.StoneFurnace = 46] = "StoneFurnace",
        e[e.LitStoneFurnace = 47] = "LitStoneFurnace",
        e[e.TorchStand = 48] = "TorchStand",
        e[e.LitTorchStand = 49] = "LitTorchStand",
        e[e.StoneAnvil = 50] = "StoneAnvil",
        e[e.Acid = 51] = "Acid",
        e[e.CaveEntrance = 52] = "CaveEntrance",
        e[e.WoodenDoorOpen = 53] = "WoodenDoorOpen",
        e[e.WoodenGate = 54] = "WoodenGate",
        e[e.WoodenGateOpen = 55] = "WoodenGateOpen",
        e[e.PoisonIvy = 56] = "PoisonIvy",
        e[e.WroughtIronChest = 57] = "WroughtIronChest",
        e[e.IronChest = 58] = "IronChest",
        e[e.OrnateWoodenChest = 59] = "OrnateWoodenChest",
        e[e.SkeletalRemains = 60] = "SkeletalRemains",
        e[e.ClayKiln = 61] = "ClayKiln",
        e[e.LitClayKiln = 62] = "LitClayKiln",
        e[e.ClayCampfire = 63] = "ClayCampfire",
        e[e.LitClayCampfire = 64] = "LitClayCampfire",
        e[e.ClayFurnace = 65] = "ClayFurnace",
        e[e.LitClayFurnace = 66] = "LitClayFurnace",
        e[e.ClayWaterStill = 67] = "ClayWaterStill",
        e[e.LitClayWaterStill = 68] = "LitClayWaterStill",
        e[e.SandstoneCampfire = 69] = "SandstoneCampfire",
        e[e.LitSandstoneCampfire = 70] = "LitSandstoneCampfire",
        e[e.SandstoneFurnace = 71] = "SandstoneFurnace",
        e[e.LitSandstoneFurnace = 72] = "LitSandstoneFurnace",
        e[e.SandstoneWaterStill = 73] = "SandstoneWaterStill",
        e[e.LitSandstoneWaterStill = 74] = "LitSandstoneWaterStill",
        e[e.StoneKiln = 75] = "StoneKiln",
        e[e.LitStoneKiln = 76] = "LitStoneKiln",
        e[e.WroughtIronAnvil = 77] = "WroughtIronAnvil",
        e[e.IronAnvil = 78] = "IronAnvil"
    }(i = t.Pre240DoodadType || (t.Pre240DoodadType = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Collect", ["require", "exports"], function(e, t) {
    function a(e, t, ...a) {
        if ("function" == typeof e && (void 0 !== t && a.unshift(t),
        t = e,
        e = !1),
        e) {
            const e = this;
            return function*() {
                yield t(e, ...a)
            }()
        }
        return t(this, ...a)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.collect = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Conditionals", ["require", "exports"], function(e, t) {
    function a(e) {
        let t = 0;
        for (const a of this)
            if (e(a, t++))
                return !0;
        return !1
    }
    function i(e) {
        let t = 0;
        for (const a of this)
            if (!e(a, t++))
                return !0;
        return !1
    }
    function n(e) {
        let t = 0;
        for (const a of this)
            if (!e(a, t++))
                return !1;
        return !0
    }
    function o(e) {
        let t = 0;
        for (const a of this)
            if (e(a, t++))
                return !1;
        return !0
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.any = a,
    t.nevery = i,
    t.every = n,
    t.none = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Entries", ["require", "exports"], function(e, t) {
    function *a() {
        let e = 0;
        for (const t of this)
            yield[e++, t]
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.entries = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Filter", ["require", "exports"], function(e, t) {
    function *a(e) {
        for (const t of this)
            e(t) && (yield t)
    }
    function *i(e) {
        for (const t of this)
            e(t) && (yield t)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.filter = a,
    t.filter2 = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Flat", ["require", "exports", "utilities/iterable/Iterables"], function(e, t, a) {
    function *i(e) {
        for (let t of this)
            if (e && (t = e(t)),
            a.isIterable(t))
                for (const e of t)
                    yield e;
            else
                yield t
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.flatMap = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/ForEach", ["require", "exports"], function(e, t) {
    function a(e, t) {
        if (t)
            return i(this, e);
        let a = 0;
        for (const t of this)
            if (!1 === e(t, a++))
                break
    }
    function *i(e, t) {
        let a = 0;
        for (const i of e)
            if (yield i,
            !1 === t(i, a++))
                return
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.forEach = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Include", ["require", "exports"], function(e, t) {
    function *a(...e) {
        for (const e of this)
            yield e;
        for (const t of e)
            for (const e of t)
                yield e
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.include = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Length", ["require", "exports"], function(e, t) {
    function a() {
        return this.reduce((e,t)=>t + 1, 0)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.length = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Map", ["require", "exports"], function(e, t) {
    function *a(e) {
        let t = 0;
        for (const a of this)
            yield e(a, t++)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.map = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Reduce", ["require", "exports"], function(e, t) {
    function a(e, t) {
        let a = t;
        for (const t of this)
            a = e(t, a);
        return a
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.reduce = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Slice", ["require", "exports", "utilities/iterable/Collectors"], function(e, t, a) {
    function *i(e, t=1/0) {
        let i = this;
        if (Math.min(e, t) < 0 && (i = this.collect(a.default.toArray),
        e < 0 && (e = i.length + e),
        t < 0 && (t = i.length + t)),
        t <= e)
            return;
        let n = 0;
        for (const a of i)
            if (n >= e && (yield a),
            ++n >= t)
                break
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.slice = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype/Values", ["require", "exports"], function(e, t) {
    function a() {
        return this
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.values = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/IterableIterator", ["require", "exports", "utilities/iterable/prototype/Collect", "utilities/iterable/prototype/Conditionals", "utilities/iterable/prototype/Entries", "utilities/iterable/prototype/Filter", "utilities/iterable/prototype/Flat", "utilities/iterable/prototype/ForEach", "utilities/iterable/prototype/Include", "utilities/iterable/prototype/Length", "utilities/iterable/prototype/Map", "utilities/iterable/prototype/Reduce", "utilities/iterable/prototype/Slice", "utilities/iterable/prototype/Values"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m) {
    function h() {}
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = h;
    const y = [Object.getPrototypeOf(function*() {}).prototype, Object.getPrototypeOf([][Symbol.iterator]()), Object.getPrototypeOf((new Map).keys()), Object.getPrototypeOf((new Set).values())]
      , g = {
        map: d.map,
        include: l.include,
        filter: o.filter,
        filter2: o.filter2,
        reduce: p.reduce,
        collect: a.collect,
        forEach: s.forEach,
        any: i.any,
        none: i.none,
        every: i.every,
        nevery: i.nevery,
        flatMap: r.flatMap,
        length: u.length,
        values: m.values,
        entries: n.entries,
        slice: c.slice
    };
    for (const e of y)
        for (const t in g)
            e[t] = g[t]
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype_array/Collect", ["require", "exports", "utilities/iterable/prototype/Collect"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.collect = a.collect
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/prototype_array/Values", ["require", "exports"], function(e, t) {
    function *a(e=1) {
        if (1 !== (e = Math.round(e)) && 0 !== e)
            for (let t = e < 0 ? this.length - 1 : 0; e < 0 ? t > -1 : t < this.length; t += e)
                yield this[t];
        else
            for (const e of this)
                yield e
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.values = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/iterable/OtherExtensions", ["require", "exports", "utilities/iterable/prototype_array/Collect", "utilities/iterable/prototype_array/Values"], function(e, t, a, i) {
    function n() {}
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = n,
    Object.defineProperty(Array.prototype, "collect", {
        value: a.collect
    }),
    Object.defineProperty(Array.prototype, "values", {
        value: i.values
    }),
    Object.defineProperty(RegExp.prototype, "matches", {
        *value(e) {
            for (; ; ) {
                const t = this.exec(e);
                if (!t)
                    break;
                yield t
            }
        }
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("Wayward", ["require", "exports", "utilities/iterable/IterableIterator", "utilities/iterable/OtherExtensions"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    a.default(),
    i.default();
    const n = window;
    n.Override = (()=>{}
    ),
    Promise.all = Promise.all.bind(Promise)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("audio/DefaultMusicHandler", ["require", "exports", "entity/IStats", "Enums", "newui/screen/IScreen", "save/data/ISaveDataGlobal", "utilities/enum/EnumCursor", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Log", "utilities/Objects", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class m extends r.default {
        constructor() {
            super(i.Music),
            this.history = [],
            this.setDefault(saveDataGlobal.options.musicPlaylist === o.MusicPlaylist.Ordered ? ()=>i.Music.Shipwrecked : this.getRandom)
        }
        next() {
            if (saveDataGlobal.options.musicPlaylist === o.MusicPlaylist.Ordered)
                return super.next();
            for (this.history.unshift(this.cursor); this.history.length > this.getMaxHistoryLength(); )
                this.history.pop();
            const e = this.getRandom();
            if (this.moveTo(e),
            saveDataGlobal.options.musicPlaylist === o.MusicPlaylist.Dynamic)
                try {
                    steamworks.incrementStat(`Music_PlayedCount_${i.Music[e]}`)
                } catch (e) {}
            return e
        }
        getMaxHistoryLength() {
            return saveDataGlobal.options.musicPlaylist === o.MusicPlaylist.Dynamic ? 4 : 8
        }
        getRandom() {
            return this.getPlayable().map(this.weightAgainstRecentlyPlayed).collect(e=>{
                const t = new Map;
                for (const [a,i] of e)
                    t.set(i, a + (t.get(i) || 0));
                return d.default.info(d.LogSource.Audio, "DefaultMusicHandler")("Music weights:", t.entries().collect(l.default.toArray).sort(([,e],[,t])=>t - e).map(([e,t])=>`${i.Music[e]} (${t})`).join(", ")),
                c.generalRandom.weightedChoice(e)
            }
            )
        }
        weightAgainstRecentlyPlayed([e,t]) {
            let a = -1;
            for (; -1 !== (a = this.history.indexOf(t, a + 1)); )
                e *= a / (2 * this.getMaxHistoryLength());
            return u.tuple(e, t)
        }
        getPlayable() {
            if (saveDataGlobal.options.musicPlaylist === o.MusicPlaylist.Shuffle)
                return s.default.values(i.Music).map(e=>u.tuple(1, e)).collect(l.default.toArray);
            if (!newui.isScreenVisible(n.ScreenId.Game))
                return [u.tuple(3, i.Music.OpeningTheme), u.tuple(2, i.Music.HauntingInterlude), u.tuple(1, i.Music.Shipwrecked)];
            const e = [u.tuple(2, i.Music.DarkerWorld), u.tuple(1, i.Music.TheWildBorn), u.tuple(1, i.Music.TheFirstSpark), u.tuple(1, i.Music.Underworld), u.tuple(2, i.Music.NomadsHeartBeat), u.tuple(1, i.Music.PerilsOfPlunder), u.tuple(.2, i.Music.OpeningTheme), u.tuple(1, i.Music.NightOwl)];
            return game.time.isNight() || localPlayer.z === i.WorldZ.Cave ? e.push(u.tuple(1, i.Music.DarkerWorld), u.tuple(4, i.Music.Crux), u.tuple(6, i.Music.HauntingInterlude), u.tuple(6, i.Music.LootStep), u.tuple(6, i.Music.ShudderSounds), u.tuple(6, i.Music.Savage), u.tuple(4, i.Music.PerilsOfPlunder), u.tuple(localPlayer.z === i.WorldZ.Cave ? 3 : 1, i.Music.SurvivalInstinct), u.tuple(localPlayer.z === i.WorldZ.Cave ? 0 : 4, i.Music.NightOwl), u.tuple(1, i.Music.OpeningTheme)) : (e.push(u.tuple(1, i.Music.WistfulInterlude), u.tuple(1, i.Music.ThirdSunrise), u.tuple(.5, i.Music.DreamInterlude)),
            game.getReputation() > 1e4 && e.push(u.tuple(6, i.Music.DreamInterlude), u.tuple(3, i.Music.ThirdSunrise), u.tuple(1, i.Music.TheWildBorn)),
            s.default.values(i.SkillType).map(e=>localPlayer.getSkill(e)).reduce((e,t)=>e + t, 0) > 100 && e.push(u.tuple(3, i.Music.TheFirstSpark), u.tuple(3, i.Music.Underworld), u.tuple(1, i.Music.Crux), u.tuple(1, i.Music.ThirdSunrise), u.tuple(1, i.Music.WistfulInterlude), u.tuple(2, i.Music.DreamInterlude))),
            (localPlayer.getStatValue(a.Stat.Health) / localPlayer.getMaxHealth() <= .2 || localPlayer.getStatValue(a.Stat.Hunger) < 0 || localPlayer.getStatValue(a.Stat.Thirst) < 0) && e.push(u.tuple(12, i.Music.SurvivalInstinct)),
            e
        }
    }
    __decorate([Override], m.prototype, "next", null),
    __decorate([p.Bound], m.prototype, "getRandom", null),
    __decorate([p.Bound], m.prototype, "weightAgainstRecentlyPlayed", null),
    t.default = m
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("audio/Audio", ["require", "exports", "audio/DefaultMusicHandler", "audio/SoundEffects", "Enums", "mod/IHookManager", "resources/IResourceLoader", "resources/ResourcePath", "utilities/enum/EnumCursor", "utilities/Files", "utilities/Log", "utilities/math/Vector2", "utilities/promise/ResolvablePromise"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const m = Math.pow(75, 2)
      , h = new d.default(d.LogSource.Audio);
    var y;
    !function(e) {
        e[e.None = 0] = "None",
        e[e.In = 1] = "In",
        e[e.Out = 2] = "Out"
    }(y = t.Fading || (t.Fading = {}));
    class g {
        constructor() {
            this._musicInfo = {},
            this._sfxInfo = {},
            this._soundQueue = [],
            this._recentlyPlayedSounds = [],
            this._fileFormat = "mp3",
            this._musicSpeed = 1,
            this._soundDelay = 0,
            this.initializeAudio()
        }
        getMusicHandler() {
            return this._musicHandler || this.resetMusicHandler(),
            this._musicHandler
        }
        async setMusicHandler(e) {
            this._stopMusic(),
            this._musicHandler = e,
            this._musicHandler.on(l.EnumCursorEvent.Change, (e,t)=>{
                this._playMusic(t)
            }
            )
        }
        async resetMusicHandler() {
            this.setMusicHandler(new a.default)
        }
        async playMusic() {
            await this.waitForAudioContext(),
            this._stopMusic(),
            this.getMusicHandler().moveToDefault()
        }
        stopMusic() {
            this._stopMusic()
        }
        async updateMusicSpeed(e) {
            await this.waitForAudioContext(),
            this._musicSpeed = e;
            const t = this._musicInfo[this.getMusicHandler().get()];
            t && t.sourceNode && (t.sourceNode.playbackRate.value = e)
        }
        async updateVolume() {
            await this.waitForAudioContext();
            let e = saveDataGlobal.options.volumeMusic
              , t = saveDataGlobal.options.volumeEffects;
            saveDataGlobal.options.muteMusic && (e = 0),
            saveDataGlobal.options.muteEffects && (t = 0),
            this._musicGainNode.gain.value = e,
            this._effectsGainNode.gain.value = t
        }
        async updatePosition() {
            await this.waitForAudioContext();
            try {
                this._audioContext.listener.positionX.value = localPlayer.x,
                this._audioContext.listener.positionY.value = localPlayer.y
            } catch (e) {}
        }
        queueEffect(e, t, a, i, n=0, r=1, s=!1) {
            if (!multiplayer.isConnected() && localPlayer && localPlayer.isResting() && !localPlayer.isRestingCancelled() || game.playing && !ui.isInGameScreenShown())
                return;
            s || (t = game.wrapCoordinate(t, localPlayer.x),
            a = game.wrapCoordinate(a, localPlayer.y));
            const l = modManager.getHook(o.Hook.OnQueueSoundEffect, e).call(e, t, a, i);
            if (!1 === l)
                return;
            "number" == typeof l && (e = l);
            const u = Date.now();
            for (let o = this._soundQueue.length - 1; o >= 0; o--) {
                const l = this._soundQueue[o];
                if (this._isComparableSound(l, t, a, i, e, n, r, u, s))
                    return
            }
            for (const o of this._recentlyPlayedSounds)
                if (this._isComparableSound(o, t, a, i, e, n, r, u, s))
                    return;
            this._soundDelay += n,
            this._soundQueue.push({
                type: e,
                x: t,
                y: a,
                z: i,
                delay: this._soundDelay,
                speed: r,
                queueTime: u,
                noPosition: s
            })
        }
        processEffects() {
            this._soundDelay = 0;
            for (let e = 0; e < this._soundQueue.length; e++) {
                const t = this._soundQueue[e];
                t.delay <= 0 ? (this._playEffect(t),
                this._soundQueue.splice(e, 1),
                e--) : t.delay--
            }
        }
        _stopMusic() {
            for (const e in this._musicInfo) {
                const t = this._musicInfo[e];
                t && t.sourceNode && (t.sourceNode.disconnect(),
                t.sourceNode = void 0)
            }
        }
        async _playMusic(e) {
            if (await this.waitForAudioContext(),
            this._stopMusic(),
            saveDataGlobal.options.muteMusic)
                return;
            const t = this._musicInfo[e];
            if (void 0 !== t) {
                h.info(`Playing music track "${n.Music[e]}"`);
                const a = t.buffer;
                if (void 0 === a)
                    return;
                t.sourceNode = this._audioContext.createBufferSource(),
                t.sourceNode.buffer = a,
                t.sourceNode.playbackRate.value = this._musicSpeed,
                t.sourceNode.onended = this._musicHandler.next.bind(this._musicHandler),
                t.sourceNode.connect(this._musicGainNode),
                t.sourceNode.start(0)
            } else {
                this._musicInfo[e] = {};
                const t = s.default.getPath(r.PathType.Music, e)
                  , a = await this._getAudioBuffer(t);
                this._musicInfo[e].buffer || (this._musicInfo[e] = {
                    buffer: a
                },
                this._playMusic(e))
            }
        }
        async _playEffect(e, t) {
            if (await this.waitForAudioContext(),
            saveDataGlobal.options.muteEffects)
                return;
            const a = n.SfxType[e.type];
            if (void 0 === a)
                return;
            const o = localPlayer && game && game.playing
              , l = o && !e.noPosition;
            if (l && localPlayer.z !== e.z)
                return;
            if (l && p.default.squaredDistance(localPlayer, e) >= m)
                return;
            let u = t;
            if (void 0 === u) {
                let t = 3;
                const a = i.soundEffectDescriptions[e.type];
                a && void 0 !== a.variations && a.variations > 0 && (t = a.variations),
                u = Math.floor(Math.random() * t + 1)
            }
            const d = a.toLowerCase() + u.toString()
              , c = this._sfxInfo[d];
            if (void 0 !== c) {
                const t = c.buffer;
                if (void 0 === t)
                    return;
                const a = this._audioContext.createBufferSource();
                if (a.buffer = t,
                a.playbackRate.value = void 0 !== e.speed ? e.speed : 1,
                l) {
                    const t = this._audioContext.createPanner();
                    t.panningModel = "HRTF",
                    t.distanceModel = "inverse",
                    t.refDistance = 5,
                    t.maxDistance = 1e4,
                    t.rolloffFactor = 25,
                    t.coneInnerAngle = 360,
                    t.coneOuterAngle = 0,
                    t.coneOuterGain = 0,
                    t.orientationX.value = 1,
                    t.orientationY.value = 0,
                    t.orientationZ.value = 0,
                    t.positionX.value = e.x,
                    t.positionY.value = e.y,
                    t.positionZ.value = 5,
                    t.connect(this._effectsGainNode),
                    a.connect(t)
                } else
                    a.connect(this._effectsGainNode);
                a.start(0),
                this._recentlyPlayedSounds.unshift(e),
                this._recentlyPlayedSounds.length >= 5 && this._recentlyPlayedSounds.pop()
            } else {
                this._sfxInfo[d] = {};
                const t = s.default.getPath(r.PathType.SoundEffect, e.type)
                  , a = u > 1 ? `${u}` : ""
                  , i = await this._getAudioBuffer(`${t}${a}`);
                this._sfxInfo[d].buffer || (this._sfxInfo[d] = {
                    buffer: i
                },
                this._playEffect(e, u))
            }
        }
        _isComparableSound(e, t, a, i, n, o, r, s, l) {
            return e && e.type === n && e.delay === o && e.speed === r && s - e.queueTime <= 100 && (e.noPosition && l || !e.noPosition && !l && e.x === t && e.y === a && e.z === i)
        }
        async _getAudioBuffer(e) {
            return u.default.getArrayBuffer(`${e}.${this._fileFormat}`).then(async e=>this._audioContext.decodeAudioData(e))
        }
        initializeAudio(e=!1) {
            if (!steamworks.isElectron() && !e)
                return this.initializeAudio = this.initializeAudio.bind(this, !0),
                document.documentElement.addEventListener("click", this.initializeAudio),
                document.documentElement.addEventListener("contextmenu", this.initializeAudio),
                document.documentElement.addEventListener("keydown", this.initializeAudio),
                void h.info("Unable to automatically start audio instance. Waiting for user input.");
            h.info("Audio instance initialized"),
            document.documentElement.removeEventListener("click", this.initializeAudio),
            document.documentElement.removeEventListener("contextmenu", this.initializeAudio),
            document.documentElement.removeEventListener("keydown", this.initializeAudio),
            this._audioContext = new AudioContext;
            try {
                this._audioContext.listener.forwardX.value = 0,
                this._audioContext.listener.forwardY.value = 0,
                this._audioContext.listener.forwardZ.value = -1,
                this._audioContext.listener.upX.value = 0,
                this._audioContext.listener.upY.value = 1,
                this._audioContext.listener.upZ.value = 0,
                this._audioContext.listener.positionX.value = 0,
                this._audioContext.listener.positionY.value = 0,
                this._audioContext.listener.positionZ.value = 0
            } catch (e) {
                h.error("Failed to set audio listener positions", e)
            }
            this._musicGainNode = this._audioContext.createGain(),
            this._musicGainNode.connect(this._audioContext.destination),
            this._effectsGainNode = this._audioContext.createGain(),
            this._effectsGainNode.connect(this._audioContext.destination);
            const t = new Audio
              , a = "function" == typeof t.canPlayType && "" !== t.canPlayType("audio/mpeg");
            a || (h.info("Switching audio file format to ogg"),
            this._fileFormat = "ogg"),
            this._onInitializedPromise && this._onInitializedPromise.resolve()
        }
        waitForAudioContext() {
            if (!this._audioContext)
                return this._onInitializedPromise || (this._onInitializedPromise = new c.default),
                this._onInitializedPromise
        }
    }
    t.default = g
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("command/commands/Ban", ["require", "exports", "Enums", "language/dictionary/Message", "language/dictionary/UiTranslation", "player/IMessageManager"], function(e, t, a, i, n, o) {
    function r(e, t) {
        if (multiplayer.isServer() && void 0 !== t) {
            const a = game.getPlayerByName(t);
            void 0 === a || a.isLocalPlayer() || multiplayer.setBanned(a.identifier, !0) && (e.messages.source(o.Source.Command).send(i.default.ChatBanCommand, a.identifier),
            multiplayer.kick(a, n.default.GameMultiplayerInterruptBanned))
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.command = {
        type: a.Command.Ban,
        callback: r
    },
    t.default = t.command
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("command/commands/Banned", ["require", "exports", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager"], function(e, t, a, i, n, o) {
    function r(e, t) {
        if (!multiplayer.isServer())
            return;
        const a = multiplayer.getBannedPlayers().values().map(e=>[{
            content: e,
            color: "var(--text-color-player)"
        }]).collect(n.default.formatList);
        e.messages.source(o.Source.Command).send(i.default.ChatBannedCommand, a)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.command = {
        type: a.Command.Banned,
        callback: r
    },
    t.default = t.command
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("command/commands/Commands", ["require", "exports", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "utilities/enum/Enums"], function(e, t, a, i, n, o, r) {
    function s(e, t) {
        const s = r.default.keys(a.Command).map(e=>[{
            content: `/${e.toLowerCase()}`,
            color: "var(--text-color-command)"
        }]).collect(n.default.formatList);
        e.messages.source(o.Source.Command).send(i.default.ChatCommandsCommand, s)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.command = {
        type: a.Command.Commands,
        callback: s
    },
    t.default = t.command
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("command/commands/Kick", ["require", "exports", "Enums", "language/dictionary/UiTranslation"], function(e, t, a, i) {
    function n(e, t) {
        if (multiplayer.isServer() && void 0 !== t) {
            const e = game.getPlayerByName(t);
            void 0 === e || e.isLocalPlayer() || multiplayer.kick(e, i.default.GameMultiplayerInterruptKicked)
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.command = {
        type: a.Command.Kick,
        callback: n
    },
    t.default = t.command
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("command/commands/Pause", ["require", "exports", "Enums"], function(e, t, a) {
    function i(e, t) {
        multiplayer.isConnected() && !multiplayer.isServer() || !(game.paused || !game.paused && game.isRealTimeMode()) || game.setPaused(!game.paused, !0)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.command = {
        type: a.Command.Pause,
        callback: i
    },
    t.default = t.command
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("command/commands/Ping", ["require", "exports", "Enums", "language/dictionary/Message", "multiplayer/packets/server/PingPacket", "player/IMessageManager"], function(e, t, a, i, n, o) {
    function r(e, t) {
        if (!multiplayer.isConnected() || multiplayer.isServer())
            e.messages.source(o.Source.Command).send(i.default.ChatPingCommand, "0");
        else {
            const e = new n.default;
            e.sendTime = performance.now(),
            e.send()
        }
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.command = {
        type: a.Command.Ping,
        callback: r
    },
    t.default = t.command
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("command/commands/Players", ["require", "exports", "Enums", "language/dictionary/Message", "language/Translation", "player/IMessageManager"], function(e, t, a, i, n, o) {
    function r(e, t) {
        const a = players.values().filter(e=>!e.isServer()).map(e=>e.getName()).collect(n.default.formatList);
        e.messages.source(o.Source.Command).send(i.default.ChatPlayersCommand, players.filter(e=>!e.isServer()).length, a)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.command = {
        type: a.Command.Players,
        callback: r
    },
    t.default = t.command
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("command/commands/Save", ["require", "exports", "Enums"], function(e, t, a) {
    function i(e, t) {
        multiplayer.isConnected() && !multiplayer.isServer() || game.saveGame(a.SaveType.InGame)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.command = {
        type: a.Command.Save,
        callback: i
    },
    t.default = t.command
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("command/commands/Unban", ["require", "exports", "Enums", "language/dictionary/Message", "player/IMessageManager"], function(e, t, a, i, n) {
    function o(e, t) {
        multiplayer.isServer() && void 0 !== t && multiplayer.setBanned(t, !1) && e.messages.source(n.Source.Command).send(i.default.ChatUnbanCommand, t)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.command = {
        type: a.Command.Unban,
        callback: o
    },
    t.default = t.command
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("command/Commands", ["require", "exports", "command/commands/Ban", "command/commands/Banned", "command/commands/Commands", "command/commands/Kick", "command/commands/Pause", "command/commands/Ping", "command/commands/Players", "command/commands/Save", "command/commands/Unban"], function(e, t, a, i, n, o, r, s, l, u, d) {
    function p(e) {
        e.add(a.default),
        e.add(i.default),
        e.add(n.default),
        e.add(o.default),
        e.add(s.default),
        e.add(l.default),
        e.add(d.default),
        e.add(r.default),
        e.add(u.default)
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.default = p
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("game/GenericManager", ["require", "exports", "utilities/enum/Enums", "utilities/Log"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        constructor() {
            this.registered = {},
            this.setup(this),
            this.check()
        }
        add(e) {
            this.registered[e.type] && i.default.warn(this.getSource())(`Overwriting a callback for ${this.getEnumObject()[e.type]}`),
            this.registered[e.type] = e
        }
        get(e) {
            const t = this.registered[e];
            return t || i.default.error(this.getSource())(`Missing registration for ${this.getEnumObject()[e]} (${e})`),
            t
        }
        remove(e) {
            delete this.registered[e]
        }
        check() {
            const e = this.getEnumObject();
            for (const t of a.default.values(e)) {
                const a = e[t];
                this.registered[t] || "ModEnd" === a || "Max" === a || i.default.warn(this.getSource())(`Missing callback for ${a}`)
            }
            i.default.info(this.getSource())(`${Object.keys(this.registered).length} registrations`)
        }
    }
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("command/CommandManager", ["require", "exports", "command/Commands", "Enums", "game/GenericManager", "mod/IHookManager", "utilities/Log"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class s extends n.default {
        setup(e) {
            a.default(e)
        }
        execute(e, t, a) {
            if (!1 === modManager.getHook(o.Hook.PreExecuteCommand).call(e, t, a))
                return;
            const i = this.get(t);
            i && i.callback(e, a || "")
        }
        getSource() {
            return r.LogSource.CommandManager
        }
        getEnumObject() {
            return i.Command
        }
    }
    __decorate([Override], s.prototype, "setup", null),
    __decorate([Override], s.prototype, "getSource", null),
    __decorate([Override], s.prototype, "getEnumObject", null),
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("entity/EntityManager", ["require", "exports", "Enums", "multiplayer/IMultiplayer", "utilities/math/Bound3"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o {
        remove(e) {
            const t = e.getTile();
            game.updateFlowFieldTile(t, e.x, e.y, e.z),
            delete this.getEntities()[e.id],
            renderer && renderer.computeSpritesInViewport()
        }
        updateFov(e) {
            this.moveTypesInFov = [];
            let t = 0;
            const o = this.getEntities();
            for (const i of o) {
                if (!i)
                    continue;
                const o = e.some(e=>n.default.containsIgnoreZ(e, i.x, i.y));
                if (i.setInFov(o),
                o) {
                    t++;
                    const e = i.getMoveType();
                    e !== a.MoveType.None && (this.moveTypesInFov.some(t=>t.moveType === e && t.z === i.z) || this.moveTypesInFov.push({
                        moveType: e,
                        z: i.z
                    }))
                }
            }
            return multiplayer.addSyncCheck(i.MultiplayerSyncCheck.BaseEntityManager, t),
            multiplayer.addSyncCheck(i.MultiplayerSyncCheck.BaseEntityManager, this.moveTypesInFov),
            t
        }
        getMoveTypesInFov() {
            return this.moveTypesInFov
        }
    }
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/Misc", ["require", "exports", "multiplayer/IMultiplayer", "utilities/Log"], function(e, t, a, i) {
    function n(e, t) {
        void 0 === game.lastCreationIds[e] && (game.lastCreationIds[e] = 0),
        multiplayer.addSyncCheck(a.MultiplayerSyncCheck.LastCreationIds, `1.${i.LogSource[e]},${game.lastCreationIds[e]}`);
        for (let i = game.lastCreationIds[e]; i < t.length; i++)
            if (void 0 === t[i])
                return game.lastCreationIds[e] = i,
                multiplayer.addSyncCheck(a.MultiplayerSyncCheck.LastCreationIds, `2.${i}`),
                i;
        for (let i = 0; i < game.lastCreationIds[e]; i++)
            if (void 0 === t[i])
                return game.lastCreationIds[e] = i,
                multiplayer.addSyncCheck(a.MultiplayerSyncCheck.LastCreationIds, `3.${i}`),
                i;
        return multiplayer.addSyncCheck(a.MultiplayerSyncCheck.LastCreationIds, "4.-1"),
        t.length
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.findUnusedId = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("creature/CreatureManager", ["require", "exports", "creature/Creature", "creature/Creatures", "creature/ICreature", "entity/EntityManager", "entity/Human", "entity/IEntity", "entity/IStats", "Enums", "flowfield/IFlowFieldManager", "language/dictionary/Message", "mod/IHookManager", "player/IMessageManager", "player/MessageManager", "player/quest/quest/Challenge", "tile/ITileEvent", "tile/Terrains", "utilities/enum/Enums", "utilities/Log", "utilities/Misc", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class M extends o.default {
        getEntities() {
            return game.creatures
        }
        getHappinessLevel(e, t) {
            if (!t)
                return 0;
            const a = t.description();
            if (!a)
                return 0;
            let i = 1;
            0 == (a.ai & s.AiType.Scared) && 0 == (a.ai & s.AiType.Neutral) || (i = 2);
            const n = t.getStatValue(l.Stat.Tamed);
            return Math.ceil((e.getSkill(u.SkillType.Taming) + 1 * (n || 1)) / a.tamingDifficulty * 3e3 * i)
        }
        spawn(e, t, o, r, s, l, d) {
            const p = game.getTile(t, o, r);
            if (!p)
                return;
            const m = i.creatureDescriptions[e];
            if (!m)
                return;
            let h = !1;
            const y = p.doodad;
            if (y) {
                const t = y.description();
                t && (t.blockMove && (m.moveType & u.MoveType.Flying) !== u.MoveType.Flying && (h = !0),
                t.providesFire && e !== u.CreatureType.FireElemental && (h = !0))
            }
            if (tileEventManager.get(p, g.TileEventType.Fire) && e !== u.CreatureType.FireElemental && (h = !0),
            void 0 !== p.creature || void 0 !== p.npc || h && !s)
                return;
            if (players)
                for (const e of game.getPlayers())
                    if (t === e.x && o === e.y && r === e.z)
                        return;
            if (e === u.CreatureType.Shark && r === u.WorldZ.Cave)
                return;
            let T = !0;
            const M = w.default.getType(p)
              , b = d || m.spawnTiles;
            if (d !== n.SpawnableTiles.None && -1 === i.spawnableTiles[b].indexOf(M)) {
                if (!s)
                    return;
                T = !1
            }
            const k = void 0 === l ? 1 === Math.ceil(125 * v.default.float() + this.getReputationAberrantBonus()) : l;
            if (!1 === modManager.getHook(c.Hook.CanCreatureSpawn).call(e, t, o, r, k))
                return;
            const C = I.findUnusedId(S.LogSource.CreatureManager, game.creatures)
              , D = new a.default(e,t,o,r,k);
            if (!T) {
                const e = f.default[M];
                let t = D.getMoveType(), a;
                D.originalMoveType = t,
                e && e.isMountain ? a = u.MoveType.Mountain | u.MoveType.Flying : e && (e.deepWater || e.water) ? (a = u.MoveType.Water | u.MoveType.ShallowWater,
                t &= ~u.MoveType.Fire) : e && e.shallowWater ? (a = u.MoveType.ShallowWater,
                t &= ~u.MoveType.Fire) : M === u.TerrainType.Lava ? a = u.MoveType.Fire : (a = u.MoveType.Land,
                (t & u.MoveType.Water) === u.MoveType.Water && (a |= u.MoveType.ShallowWater)),
                D.setMoveType(a | t)
            }
            return D.id = C,
            game.creatures[C] = D,
            p.creature = D,
            game.updateFlowFieldTile(p, t, o, r),
            modManager.getHook(c.Hook.OnCreatureSpawn).call(D),
            D
        }
        spawnFromGroup(e, t, a, i, n) {
            const {pool: o, aberrantChance: r} = this.getSpawnableCreatures(e, i);
            if (game.isChallenge) {
                const e = y.default.getCreaturesOfRequirements();
                for (const t of e)
                    o.push(t)
            }
            if (!1 !== modManager.getHook(c.Hook.OnSpawnCreatureFromGroup).call(e, o, t, a, i) && o.length > 0) {
                const e = v.default.getElement(o);
                let s = !1;
                return v.default.chance((.01 + 2e-4 * r) * this.getReputationAberrantBonus()) && (s = !0),
                game.getReputation() > 0 && (s = !1),
                this.spawn(e, t, a, i, n, s)
            }
        }
        getSpawnableCreatures(e, t, a=game.getReputation() , i=game.time.getTime() ) {
            let o = []
              , r = 0;
            switch (e) {
            case n.SpawnGroup.Guardians:
                r = a <= -38e3 ? 25 : 15,
                o = this.getCreaturesWithSpawnGroup(a <= -38e3 ? n.SpawnGroup.StrongGuardians : n.SpawnGroup.Guardians, void 0, a);
                break;
            case n.SpawnGroup.Seawater:
            case n.SpawnGroup.FreshWater:
                o = this.getCreaturesWithSpawnGroup(e, !0, a);
                break;
            case n.SpawnGroup.CaveWater:
                o = this.getCreaturesWithSpawnGroup(e, void 0, a);
                break;
            case n.SpawnGroup.Any:
                t === u.WorldZ.Cave ? (r = 5,
                o = this.getCreaturesWithSpawnGroup(n.SpawnGroup.Cave, void 0, a)) : game.time.isNight(i) && players && a < 4e3 ? (r = 5,
                o = this.getCreaturesWithSpawnGroup(a <= -4e3 ? n.SpawnGroup.Night : n.SpawnGroup.EasyNight, void 0, a)) : o = this.getCreaturesWithSpawnGroup(void 0, void 0, a)
            }
            return {
                pool: o,
                aberrantChance: r
            }
        }
        maybeSpawnClawWorm(e) {
            0 === v.default.int(350 + Math.floor(e.getReputation() / 400)) && this.spawn(u.CreatureType.ClawWorm, e.x + v.default.int(3) - 1, e.y + v.default.int(3) - 1, e.z) && h.default.get(e).source(m.Source.Combat, m.Source.Action, m.Source.Creature).send(p.default.StirredUpClawWorm)
        }
        remove(e) {
            const t = e.getTile();
            t && delete t.creature,
            e.release(),
            super.remove(e)
        }
        updateAll() {
            for (const e of game.creatures)
                if (e && e.update()) {
                    const t = e.description();
                    t && t.makeNoise && 0 === v.default.int(30) && e.queueSoundEffect(u.SfxType.CreatureNoise)
                }
        }
        getMovePenalty(e, t, a=!1) {
            if (e === u.MoveType.None)
                return d.blockedPenalty;
            const i = w.default.getType(t)
              , n = f.default[i];
            if ((e & u.MoveType.Flying) === u.MoveType.Flying) {
                if (n) {
                    if (t.doodad && t.doodad.blocksMove())
                        return 3;
                    if (n.isMountain && (e & u.MoveType.Mountain) !== u.MoveType.Mountain)
                        return d.blockedPenalty;
                    if ((n.water || n.shallowWater) && (e & u.MoveType.Fire) === u.MoveType.Fire)
                        return d.blockedPenalty
                }
                return void 0 !== t.creature || void 0 !== t.npc ? d.blockedPenalty : 1
            }
            if (n) {
                if (n.shallowWater && (e & u.MoveType.ShallowWater) !== u.MoveType.ShallowWater)
                    return d.blockedPenalty;
                if (n.water && (e & u.MoveType.Water) !== u.MoveType.Water)
                    return d.blockedPenalty;
                if (!n.water && !n.shallowWater && (e & u.MoveType.Land) !== u.MoveType.Land) {
                    if ((e & u.MoveType.WetLand) !== u.MoveType.WetLand)
                        return d.blockedPenalty;
                    if (!n.wet)
                        return d.blockedPenalty
                }
                if ((e & u.MoveType.Tree) !== u.MoveType.Tree && t.doodad && t.doodad.blocksMove()) {
                    const e = t.doodad.description();
                    if (e && e.isTree)
                        return d.blockedPenalty
                }
                if (n.isMountain && (e & u.MoveType.Mountain) !== u.MoveType.Mountain)
                    return d.blockedPenalty
            }
            if ((e & u.MoveType.Fire) !== u.MoveType.Fire && (i === u.TerrainType.Lava || tileEventManager.get(t, g.TileEventType.Fire)))
                return d.blockedPenalty;
            if (game.isTileFull(t))
                return d.blockedPenalty;
            const o = t.doodad;
            if (o) {
                const t = o.blocksMove();
                if (t) {
                    const t = o.description();
                    return t && t.canBreak && (e & u.MoveType.BreakDoodads) === u.MoveType.BreakDoodads ? 3 : d.blockedPenalty
                }
            }
            return void 0 === t.creature && void 0 === t.npc || a ? 1 : d.blockedPenalty
        }
        checkSpawnReputation(e, t=game.getReputation() , a=!1) {
            const i = e.spawnReputation;
            return !(!a || i && !(t <= i)) || (!(!i && 0 !== i || !(i <= 0 && t <= i || e.spawnOnBenignity)) || !!(i && i > 0 && t >= i))
        }
        getCreaturesWithSpawnGroup(e, t, a) {
            const o = [];
            for (const r of T.default.values(u.CreatureType)) {
                const s = i.creatureDescriptions[r];
                if (s && s.spawnTiles !== n.SpawnableTiles.None)
                    if (e) {
                        if (s.spawnGroup)
                            for (const i of s.spawnGroup)
                                e === i && (t ? this.checkSpawnReputation(s, a, !0) && o.push(r) : o.push(r))
                    } else
                        this.checkSpawnReputation(s, a) && o.push(r)
            }
            return o
        }
        getReputationAberrantBonus() {
            const e = game.getBenignity() / r.REPUTATION_MAX
              , t = game.getMalignity() / r.REPUTATION_MAX;
            return 1 + .5 * t - .25 * e
        }
    }
    __decorate([Override], M.prototype, "getEntities", null),
    __decorate([Override], M.prototype, "remove", null),
    t.default = M
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("creature/corpse/CorpseManager", ["require", "exports", "creature/corpse/Corpses", "creature/Creatures", "entity/IStats", "Enums", "game/inspection/IInspection", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Misc", "language/Translation", "player/IMessageManager", "player/MessageManager", "tile/ITileEvent", "tile/Terrains", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Log", "utilities/Misc", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class w {
        create(e, t, i, n, r, s, l) {
            const u = a.default[e];
            if (!u)
                return;
            const d = S.findUnusedId(T.LogSource.CorpseManager, game.corpses)
              , p = u.decay
              , c = {
                id: d,
                type: e,
                x: t,
                y: i,
                z: n,
                decay: void 0 !== r ? r + I.default.int(Math.floor(r / 15)) : p ? p + I.default.int(Math.floor(p / 15)) : void 0
            };
            void 0 !== l && (c.renamed = l),
            game.corpses[d] = c,
            s && (c.aberrant = !0);
            const h = game.getTileFromPoint(c);
            h.corpses || (h.corpses = []),
            h.corpses.push(c);
            const y = v.default.getType(h);
            return y !== o.TerrainType.Lava && y !== o.TerrainType.CoolingLava || tileEventManager.get(h, m.TileEventType.Fire) || tileEventManager.create(m.TileEventType.Fire, c.x, c.y, c.z),
            c
        }
        updateAll() {
            for (const e of game.corpses) {
                if (!e)
                    continue;
                const t = e.type
                  , a = i.default[t];
                if (a && a.respawn && 0 === I.default.int(200)) {
                    const a = creatureManager.spawn(t, e.x, e.y, e.z, !1, e.aberrant || void 0);
                    if (a) {
                        c.default.toAll(t=>t.ifVisible(e).source(p.Source.Creature).send(l.default.ReturnsToLife, a.getName())),
                        a.setStat(n.Stat.Health, 3),
                        a.respawned = !0,
                        this.remove(e);
                        continue
                    }
                }
                if (void 0 !== e.decay)
                    if (e.decay >= 1)
                        e.decay--;
                    else if (e.decay <= 0) {
                        const a = this.getResources(e);
                        if (a)
                            for (let t = void 0 !== e.step ? e.step : 0; t < a.length; t++)
                                a[t] && a[t] !== o.ItemType.None && itemManager.create(a[t], itemManager.getTileContainer(e.x, e.y, e.z), o.ItemQuality.Random);
                        t === o.CreatureType.LavaBeetle && (game.changeTile(o.TerrainType.Lava, e.x, e.y, e.z, !1),
                        tileEventManager.create(m.TileEventType.Fire, e.x, e.y, e.z)),
                        this.remove(e)
                    }
            }
        }
        getResources(e) {
            const t = []
              , i = a.default[e.type];
            if (!i)
                return t;
            const n = e.aberrant && i.aberrantResource ? i.aberrantResource : i.resource;
            if (n)
                for (const e of n) {
                    const a = e.chance;
                    a ? I.default.percent() <= a ? t.push(e.item) : t.push(o.ItemType.None) : t.push(e.item)
                }
            return t
        }
        remove(e) {
            const t = game.getTileFromPoint(e);
            if (t.corpses) {
                const a = t.corpses.length;
                for (let i = 0; i < a; i++)
                    if (t.corpses[i] === e) {
                        t.corpses.splice(i, 1);
                        break
                    }
                0 === t.corpses.length && delete t.corpses
            }
            delete game.corpses[e.id],
            world.updateTile(e.x, e.y, e.z, t)
        }
        createBlood(e, t, i) {
            const n = [];
            for (let e = -1; e <= 1; e++)
                for (let t = -1; t <= 1; t++)
                    n.push([e, t]);
            const r = I.default.shuffle(n);
            n.unshift([0, 0]);
            for (const n of r) {
                const r = game.getTile(n[0] + e, n[1] + t, i);
                if (!r)
                    continue;
                if (r.corpses) {
                    let e = !1;
                    for (const t of r.corpses) {
                        const i = a.default[t.type];
                        if (i && i.blood) {
                            e = !0;
                            break
                        }
                    }
                    if (e)
                        continue
                }
                const s = v.default.getType(r);
                let l;
                const u = h.default[s];
                l = u && (u.water || u.shallowWater) ? o.CreatureType.WaterBlood : o.CreatureType.Blood,
                this.create(l, n[0] + e, n[1] + t, i);
                break
            }
        }
        getName(e, t, a, i=!1) {
            const n = "number" == typeof e ? e : e.type
              , o = "object" == typeof e && e.aberrant
              , r = d.default.nameOf(s.Dictionary.Creature, n, a, t).setFailWith(new d.default(s.Dictionary.Corpse,n)).addReformatter(new d.default(s.Dictionary.Misc,u.MiscTranslation.CorpseOf).addArgs(n), !0).addReformatter(d.default.message(l.default.Aberrant).addArgs(o), !0);
            return a && 1 !== a && i && r.addReformatter(new d.default(s.Dictionary.Misc,u.MiscTranslation.CountThing).addArgs(a)),
            r
        }
        getCorpseTranslations(e) {
            if (!e.length)
                return f.pipe();
            const t = new Map;
            for (const a of e) {
                const e = t.get(a.type) || new Map;
                t.set(a.type, e);
                const i = e.get(!!a.aberrant) || [];
                e.set(!!a.aberrant, i),
                i.push(a)
            }
            return t.values().map(e=>e.values()).flatMap().collect(g.default.toArray).sort((e,t)=>t.length - e.length).map(e=>this.getName(e[0], !0, e.length, !0)).values()
        }
        getCorpseListTranslation(e) {
            return this.getCorpseTranslations(e).collect(d.default.formatList)
        }
        inspect({context: e}, ...t) {
            return t.length ? [[{
                name: !0,
                text: e !== r.InspectionContext.Tooltip ? this.getCorpseListTranslation(t) : this.getCorpseTranslations(t).map(e=>e.inContext(3)).collect(d.default.formatList)
            }]] : []
        }
        is(e) {
            return "object" == typeof e && y.default.isValid(o.CreatureType, e.type) && void 0 !== game.corpses[e.id]
        }
    }
    t.default = w
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("doodad/doodads/ItemDoodad", ["require", "exports", "action/IAction", "doodad/doodads/Doodad", "Enums", "item/Items", "language/Dictionaries", "language/Translation", "save/ISerializer"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class u extends i.default {
        constructor(e, t=0, a=0, i=0, o={}) {
            super(n.DoodadType.Item, t, a, i, o),
            void 0 !== e && void 0 !== o.item && (this.itemType = o.item.type)
        }
        description() {
            const e = super.description();
            if (!e)
                return;
            const t = this._itemDescription();
            if (!t)
                return;
            const a = t.doodad || {};
            return Object.assign({}, e, a)
        }
        getDoodadInfo() {
            const e = tileAtlas.doodadItems[this.itemType];
            if (e)
                return e
        }
        getPickupTypes() {
            return [this.itemType]
        }
        getActions() {
            const e = this._itemDescription();
            if (!e)
                return;
            let t = e.use;
            if (!t)
                return;
            const i = t.indexOf(a.ActionType.PlaceDown);
            return -1 !== i && (t = t.slice()).splice(i, 1),
            t
        }
        getNameTranslation(e, t) {
            return s.default.nameOf(r.Dictionary.DoodadItem, {
                type: this.itemType,
                renamed: this.renamed
            }, t, e).setFailWith(new s.default(r.Dictionary.Item,this.itemType))
        }
        getDescriptionTranslation() {
            return new s.default(r.Dictionary.DoodadItem,this.itemType,1).setFailWith(new s.default(r.Dictionary.Item,this.itemType,1))
        }
        _itemDescription() {
            return o.default[this.itemType]
        }
    }
    __decorate([l.SaveProperty()], u.prototype, "itemType", void 0),
    __decorate([Override], u.prototype, "description", null),
    __decorate([Override], u.prototype, "getDoodadInfo", null),
    __decorate([Override], u.prototype, "getPickupTypes", null),
    __decorate([Override], u.prototype, "getActions", null),
    __decorate([Override], u.prototype, "getNameTranslation", null),
    __decorate([Override], u.prototype, "getDescriptionTranslation", null),
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("doodad/DoodadRegistrar", ["require", "exports", "doodad/doodads/Doodad", "doodad/doodads/ItemDoodad", "Enums", "game/Registrar", "item/Items", "utilities/enum/Enums"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.registrar = new o.default,
    t.registrar.registerBase(a.default),
    t.registrar.register(i.default, n.DoodadType.Item);
    for (const e of s.default.values(n.ItemType)) {
        const a = r.default[e];
        a && a.doodad && t.registrar.usesBase(e) && t.registrar.register(i.default, n.DoodadType.Item, e)
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("doodad/DoodadManager", ["require", "exports", "doodad/DoodadRegistrar", "doodad/Doodads", "Enums", "mod/IHookManager", "utilities/enum/Enums", "utilities/Log", "utilities/Misc"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class u {
        constructor() {
            this.cachedGroups = {},
            this.generateLookups()
        }
        generateLookups() {
            this.cachedGroups = {};
            for (const e of r.default.values(n.DoodadTypeGroup)) {
                this.cachedGroups[e] = {};
                const t = this.getGroupDoodads(e);
                for (const a of t)
                    this.cachedGroups[e][a] = !0
            }
        }
        create(e, t, i, r, u={}) {
            if (!1 === modManager.getHook(o.Hook.CanDoodadSpawn).call(e, t, i, r, u))
                return;
            const d = e === n.DoodadType.Item ? a.registrar.get(u.item.type, !0) : a.registrar.get(e);
            if (void 0 === d)
                return;
            const p = game.getTile(t, i, r)
              , c = l.findUnusedId(s.LogSource.DoodadManager, game.doodads)
              , m = new d(e,t,i,r,u);
            return m.id = c,
            game.doodads[c] = m,
            p.doodad = m,
            world.updateTile(t, i, r, p),
            modManager.getHook(o.Hook.OnDoodadSpawn).call(m),
            m
        }
        remove(e, t=!1) {
            const a = e.x
              , i = e.y
              , n = e.z
              , o = game.getTile(a, i, n);
            o && (o.doodad === e && delete o.doodad,
            world.updateTile(a, i, n, o)),
            itemManager.isContainer(e) && e.containedItems.length > 0 && (t || (s.default.warn(s.LogSource.DoodadManager)("Removing doodad with items in it", [...e.containedItems]),
            s.default.trace(s.LogSource.DoodadManager)("Tracing doodadManager.remove issue")),
            itemManager.removeContainerItems(e)),
            delete game.doodads[e.id]
        }
        updateAll() {
            for (const e of game.doodads)
                e && e.update()
        }
        isDoodadTypeGroup(e) {
            return e > n.DoodadTypeGroup.Invalid
        }
        isInGroup(e, t) {
            const a = this.cachedGroups[t];
            return !!a && !0 === a[e]
        }
        getGroupDoodads(e) {
            const t = new Set;
            for (const a of r.default.values(n.DoodadType)) {
                const n = i.default[a];
                n && n.group === e && t.add(a)
            }
            return t
        }
        verifyAndFixItemWeights() {
            for (const e of game.doodads)
                if (e && void 0 !== e.weight) {
                    const t = e.getPickupTypes();
                    if (t) {
                        const a = t[0]
                          , i = e.weight;
                        let o = !1;
                        const r = itemManager.getWeight(a, n.WeightType.Min);
                        e.weight < r && (e.weight = r,
                        o = !0);
                        const l = itemManager.getWeight(a, n.WeightType.Max);
                        e.weight > l && (e.weight = l,
                        o = !0),
                        o && s.default.warn(s.LogSource.DoodadManager)(`Detected doodad [${n.DoodadType[e.type]}] with invalid item weight, new weight: ${e.weight}, before: ${i}`, e)
                    }
                }
        }
    }
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("doodad/doodads/SolarStill", ["require", "exports", "doodad/doodads/ItemDoodad", "Enums"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n extends a.default {
        getRegistrarId() {
            return i.ItemType.SolarStill
        }
        description() {
            const e = super.description();
            return e && (e.decayMax = -1,
            e.isWaterSource = !0,
            e.particles = {
                r: 206,
                g: 208,
                b: 210
            },
            e.reduceDurabilityOnGather = !0),
            e
        }
        update() {
            if (super.update(),
            void 0 !== this.decay && this.decay >= 1 && game.time.getTime() <= .5) {
                const e = this.getTile()
                  , t = e;
                if (t.containedItems && t.containedItems.length > 0)
                    return;
                this.decay--,
                this.decay <= 0 && (this.gatherReady = !0,
                world.updateTile(this.x, this.y, this.z, this.getTile()))
            }
        }
    }
    __decorate([Override], n.prototype, "getRegistrarId", null),
    __decorate([Override], n.prototype, "description", null),
    __decorate([Override], n.prototype, "update", null),
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("flowfield/FlowField", ["require", "exports", "multiplayer/IMultiplayer"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i {
        constructor(e, t, a) {
            this.z = t,
            this.moveType = a,
            this.instance = new Module.FlowField(e,t,a),
            this.flowField = this.instance.getFlowField(),
            this.penaltyField = this.instance.getPenaltyField()
        }
        getZ() {
            return this.z
        }
        delete() {
            this.instance && (this.instance.delete(),
            delete this.instance)
        }
        getHashCodes() {
            let e = ""
              , t = "";
            for (let a = 0; a < game.mapSize * game.mapSize; a++)
                e += this.flowField[a],
                t += this.penaltyField[a];
            return [e, t]
        }
        getFieldValue(e, t) {
            const i = this.flowField[game.getWrappedCoord(t) * game.mapSize + game.getWrappedCoord(e)];
            return multiplayer.addSyncCheck(a.MultiplayerSyncCheck.FlowFieldValue, `${e},${t}-${i}`),
            i
        }
        updateField(e) {
            const t = [];
            try {
                for (const e of game.getPlayers())
                    e.z === this.z && t.push({
                        x: e.x,
                        y: e.y
                    });
                if (t.length > 0) {
                    this.instance.prepareUpdate();
                    for (const e of t)
                        this.instance.addPlayer(e.x, e.y);
                    this.instance.finalizeUpdate()
                }
            } catch (e) {
                throw new Error(`updateField failed ${JSON.stringify(t)} ${e}`)
            }
        }
        updateTile(e, t) {
            this.penaltyField[e] = creatureManager.getMovePenalty(this.moveType, t)
        }
        reset() {
            this.instance.reset()
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("flowfield/FlowFieldDebugRenderer", ["require", "exports", "renderer/RendererConstants", "renderer/Shaders"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        constructor(e, t) {
            this.ff = t,
            this.gl = e;
            const n = [.5, 0, 0, 1, 1, 0, 1, 1, 1, .5, 1, 0, .5, 0, 0, 1, 1, .5, 1, 0, .5, .5, 0, 0]
              , o = e.createBuffer()
              , r = e.createTexture();
            o && r && (this.viewQuadBuffer = o,
            e.bindBuffer(e.ARRAY_BUFFER, this.viewQuadBuffer),
            e.bufferData(e.ARRAY_BUFFER, new Float32Array(n), e.STATIC_DRAW),
            this.shaderProgramAlphaDebug = new i.CompiledProgram(e,"basic-texture-vertex","alpha-debug-fragment"),
            t.setDelegate(this),
            this.tex = r,
            e.bindTexture(e.TEXTURE_2D, this.tex),
            e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, this.ff.getWidth(), this.ff.getHeight(), 0, e.ALPHA, e.UNSIGNED_BYTE, a.emptyUint8Array),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE))
        }
        update() {
            const e = this.ff.flowFields[localPlayer.z];
            if (!e)
                return;
            if (!this.field)
                return;
            const t = this.gl;
            t.bindTexture(t.TEXTURE_2D, this.tex),
            t.texImage2D(t.TEXTURE_2D, 0, t.ALPHA, this.field.width, this.field.height, 0, t.ALPHA, t.UNSIGNED_BYTE, this.field.data)
        }
        renderDebug() {
            const e = this.gl
              , t = this.shaderProgramAlphaDebug;
            e.useProgram(t.program),
            e.enable(e.BLEND),
            e.enableVertexAttribArray(t.attribs.position),
            e.enableVertexAttribArray(t.attribs.texture),
            e.activeTexture(e.TEXTURE0),
            e.bindTexture(e.TEXTURE_2D, this.tex),
            e.uniform1i(t.uniforms.data, 0),
            e.bindBuffer(e.ARRAY_BUFFER, this.viewQuadBuffer),
            e.vertexAttribPointer(t.attribs.position, 2, e.FLOAT, !1, 16, 0),
            e.vertexAttribPointer(t.attribs.texture, 2, e.FLOAT, !1, 16, 8),
            e.drawArrays(e.TRIANGLES, 0, 6)
        }
    }
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("flowfield/FlowFieldManager", ["require", "exports", "Enums", "flowfield/FlowField", "utilities/enum/Enums", "utilities/Log", "utilities/Random"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const s = !1
      , l = new o.default(o.LogSource.FlowFieldManager);
    class u {
        constructor(e) {
            this.size = e,
            this.flowFields = {}
        }
        delete() {
            const e = this.getFlowFields();
            for (const t of e)
                t.delete()
        }
        setDelegate(e) {
            this.delegate = e
        }
        getWidth() {
            return this.size
        }
        getHeight() {
            return this.size
        }
        isInFlowField(e) {
            return this.plys.some(t=>{
                if (t.z !== e.z)
                    return !1;
                const a = t.x
                  , i = t.y
                  , n = game.wrapCoordinate(e.x, a)
                  , o = game.wrapCoordinate(e.y, i);
                return Math.abs(n - a) + Math.abs(o - i) < this.size
            }
            )
        }
        isPlayerInFlowField(e) {
            return this.plys.some(t=>t === e)
        }
        getMoveDirection(e, t, a, i) {
            return this.getDirection(i, e, t, a, !0)
        }
        getOpposingMoveDirection(e, t, a, i) {
            return this.getDirection(i, e, t, a, !1)
        }
        updateTile(e, t, a) {
            const i = game.getTile(e, t, a)
              , n = t * game.mapSize + e
              , o = this.getFlowFields();
            for (const e of o)
                e.getZ() === a && e.updateTile(n, i)
        }
        setPlayers(e) {
            this.plys = e
        }
        update() {
            const e = creatureManager.getMoveTypesInFov().concat(npcManager.getMoveTypesInFov());
            if (0 !== e.length) {
                for (const t of e) {
                    const e = `${t.z}-${t.moveType}`;
                    let o = this.flowFields[e];
                    if (!o) {
                        if (!world.layers[t.z])
                            continue;
                        l.info(`Creating flow field "${e}" [MoveType: ${n.default.toString(a.MoveType, t.moveType)}]`),
                        o = this.flowFields[e] = new i.default(this.size,t.z,t.moveType)
                    }
                    o.updateField(this.plys)
                }
                this.delegate && this.delegate.update()
            }
        }
        reset() {
            l.info("Reset");
            const e = this.getFlowFields();
            for (const t of e)
                t.reset();
            this.update()
        }
        getDirection(e, t, i, n, o) {
            const u = this.getFlowField(e, n);
            if (!u)
                return a.Direction.None;
            s && (l.info(`      ${u.getFieldValue(t, i - 1)}      `),
            l.info(`  ${u.getFieldValue(t - 1, i)}  C  ${u.getFieldValue(t + 1, i)}  `),
            l.info(`      ${u.getFieldValue(t, i + 1)}      `));
            let d = u.getFieldValue(t, i) * (o ? 1 : -1);
            const p = [];
            let c = 0;
            if ((c = u.getFieldValue(t - 1, i)) >= d && (c > d && (d = c),
            p.push(a.Direction.West)),
            (c = u.getFieldValue(t, i - 1)) >= d && (c > d && (p.length = 0,
            d = c),
            p.push(a.Direction.North)),
            (c = u.getFieldValue(t + 1, i)) >= d && (c > d && (p.length = 0,
            d = c),
            p.push(a.Direction.East)),
            (c = u.getFieldValue(t, i + 1)) >= d) {
                if (c > d)
                    return a.Direction.South;
                p.push(a.Direction.South)
            }
            return s && l.info(`Possible direction: ${p.join(", ")}`),
            0 === p.length ? a.Direction.None : 1 === p.length ? p[0] : r.default.getElement(p)
        }
        getFlowField(e, t) {
            const i = `${t}-${e}`
              , o = this.flowFields[i];
            if (o)
                return o;
            l.warn(`Missing flow field for "${i}" [MoveType: ${n.default.toString(a.MoveType, e)}]`)
        }
        getFlowFields() {
            const e = []
              , t = Object.keys(this.flowFields);
            for (const a of t)
                e.push(this.flowFields[a]);
            return e
        }
    }
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("item/ItemManager", ["require", "exports", "action/ActionExecutor", "action/IAction", "doodad/Doodads", "entity/Entity", "entity/IEntity", "entity/IStats", "Enums", "game/inspection/IInspection", "item/IItem", "item/Item", "item/Items", "language/Dictionaries", "language/dictionary/Message", "language/dictionary/Note", "language/Translation", "mod/IHookManager", "multiplayer/IMultiplayer", "multiplayer/packets/shared/UpdateItemOrderPacket", "newui/screen/IScreen", "player/IMessageManager", "player/IMilestone", "player/MessageManager", "player/note/NoteManager", "player/Skills", "save/ISaveManager", "tile/ITileEvent", "tile/Terrains", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators", "utilities/Log", "utilities/math/Math2", "utilities/Misc", "utilities/Objects", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L, O, F) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const _ = new x.default(x.LogSource.ItemManager);
    class H {
        constructor() {
            this.worldContainer = {
                weightCapacity: 0,
                containedItems: []
            },
            this.cachedWeights = {},
            this.cachedDecaysIntoWeights = {},
            this.cachedDefaultItemForGroup = {},
            this.cachedItemGroups = {},
            this.generateLookups()
        }
        getContainerReference(e, t, a=!0) {
            let i;
            if (void 0 === e)
                i = {
                    type: d.ContainerReferenceType.Invalid
                };
            else if (e === this.worldContainer)
                i = {
                    type: d.ContainerReferenceType.World
                };
            else if (e.containedWithin === this.worldContainer) {
                const t = e;
                i = {
                    type: d.ContainerReferenceType.Tile,
                    x: t.x,
                    y: t.y,
                    z: t.z
                }
            } else {
                const n = this.getPlayerFromInventoryContainer(e);
                if (void 0 !== n)
                    i = {
                        type: d.ContainerReferenceType.PlayerInventory,
                        pid: n.id
                    };
                else {
                    const n = this.getAbsentPlayerFromInventoryContainer(e);
                    if (void 0 !== n)
                        i = {
                            type: d.ContainerReferenceType.PlayerInventory,
                            pid: n.id,
                            identifier: n.identifier
                        };
                    else {
                        const n = this.getNPCFromInventoryContainer(e);
                        if (void 0 !== n)
                            i = {
                                type: d.ContainerReferenceType.NPCInventory,
                                id: n.id
                            };
                        else if (void 0 === e.containedWithin) {
                            const n = e;
                            !a || void 0 !== n.x && void 0 !== n.y && void 0 !== n.z || _.warn("Getting an invalid container reference a doodad", e, t),
                            i = {
                                type: d.ContainerReferenceType.Doodad,
                                x: n.x,
                                y: n.y,
                                z: n.z
                            }
                        } else
                            i = {
                                type: d.ContainerReferenceType.Item,
                                id: e.id
                            }
                    }
                }
            }
            return i
        }
        derefenceContainerReference(e) {
            if (e)
                switch (e.type) {
                case d.ContainerReferenceType.PlayerInventory:
                    const t = e;
                    if (t) {
                        let e = void 0 !== t.identifier ? game.getPlayerByIdentifier(t.identifier) : void 0;
                        return void 0 === e && void 0 !== t.pid && (e = void 0 !== t.identifier ? absentPlayers[t.pid] : players[t.pid]),
                        e ? e.inventory : localPlayer.inventory
                    }
                    return void _.warn("Invalid container reference for player inventory");
                case d.ContainerReferenceType.NPCInventory:
                    if (e) {
                        const t = game.npcs[e.id];
                        if (t)
                            return t.inventory
                    }
                    return void _.warn("Invalid container reference for npc inventory");
                case d.ContainerReferenceType.Doodad:
                    const a = e;
                    if (a) {
                        const e = game.getTile(a.x, a.y, a.z);
                        if (e) {
                            const t = e.doodad;
                            if (t)
                                return t
                        }
                    }
                    return void _.warn("Invalid container reference for doodad", e);
                case d.ContainerReferenceType.World:
                    return this.worldContainer;
                case d.ContainerReferenceType.Tile:
                    const i = e;
                    return game.getTileFromPoint(i);
                case d.ContainerReferenceType.Item:
                    const n = e;
                    return game.items[n.id];
                default:
                    return
                }
        }
        addToContainerInternal(e, t, a=!1, i) {
            let n;
            if (this.isContainer(e) && this.isContainableInContainer(t, e))
                return (n = this.getPlayerWithItemInInventory(e)) && n.messages.source(v.Source.Action, v.Source.Item).send(h.default.CannotPlaceContainerInItself),
                !1;
            if (e.containedWithin === t)
                return _.warn("Tried to add an item to the same container", L.default.stringify(e, 4, !0), L.default.stringify(t, 4, !0)),
                !1;
            const o = void 0 !== (n = this.getPlayerWithItemInInventory(e))
              , r = this.getPlayerWithItemInInventory(t)
              , s = void 0 !== r
              , u = e.containedWithin
              , d = !o && s
              , p = o && !s
              , c = o && (!s || void 0 === this.getPlayerFromInventoryContainer(t));
            if (this.removeFromContainerInternal(e),
            t.containedItems.push(e),
            multiplayer.addSyncCheck(T.MultiplayerSyncCheck.Container, `A${e.id}[${l.ItemType[e.type]}]T[L${t.containedItems.length}]`),
            void 0 !== t.itemOrders && t.itemOrders.push(e.id),
            e.containedWithin = t,
            t.containedWithin === this.worldContainer) {
                const e = t;
                game.updateFlowFieldTile(e, e.x, e.y, e.z)
            }
            if (ui.addItemToContainer(e, t, !1, a),
            u && modManager.getHook(f.Hook.OnContainerItemRemove).call(e, u),
            modManager.getHook(f.Hook.OnContainerItemUpdate).call(e, u, t),
            modManager.getHook(f.Hook.OnContainerItemAdd).call(e, t),
            d ? modManager.getHook(f.Hook.OnInventoryItemAdd).call(r, e, t) : p ? modManager.getHook(f.Hook.OnInventoryItemRemove).call(n, e, t) : modManager.getHook(f.Hook.OnInventoryItemUpdate).call(r || n, e, t),
            d)
                r && (e.acquireNotify(r),
                e.quality !== l.ItemQuality.None && newui.getScreen(I.ScreenId.Game).isVisible() && r.notes.write(y.default.ItemQualities, e.getName(!0, 1, !1, !1), l.ItemQuality[e.quality].toLowerCase(), new g.default(m.Dictionary.ItemQuality,e.quality)));
            else if (c) {
                const a = this.getItemsInContainer(t, !0);
                a.push(e);
                for (let e = 0; e < a.length; e++)
                    this.updateUiOnItemRemove(n, a[e], s, i)
            }
            return !0
        }
        removeContainerItems(e) {
            for (let t = e.containedItems.length - 1; t >= 0; t--)
                this.remove(e.containedItems[t])
        }
        exists(e) {
            return e && game.items[e.id] === e
        }
        remove(e) {
            if (!e)
                return;
            const t = e
              , a = this.getPlayerWithItemInInventory(e);
            if (void 0 !== t.containedItems) {
                if (!t.containedWithin)
                    throw new Error("Removed a container that's not contained within anything.");
                this.moveAllFromContainerToContainer(a, t, t.containedWithin),
                a && a.updateTablesAndWeight()
            }
            const i = a || this.getNPCWithItemInInventory(e);
            i && (i.raft === e.id ? i.setRaft(void 0) : void 0 !== i.restData && i.restData.itemId === e.id && delete i.restData.itemId),
            this.removeFromContainerInternal(e),
            this.updateUiOnItemRemove(i, e),
            delete game.items[e.id]
        }
        getDisassemblyComponents(e, t) {
            const a = [];
            if (!e)
                return a;
            if (e.inheritWeight) {
                const a = c.itemDescriptions[e.inheritWeight];
                if (a && a.recipe && a.disassemble)
                    return this.getDisassemblyComponents(a, t)
            }
            if (e.recipe)
                for (const i of e.recipe.components) {
                    const e = i.consumedAmount;
                    if (e >= 1 && i.disassembleAmount && i.disassembleAmount > 0) {
                        let n = i.type;
                        this.isGroup(n) && (n = this.getGroupDefault(n));
                        for (let i = 0; i < e; i++) {
                            const e = new p.default(n,t)
                              , i = e.description();
                            i && i.disassemble && i.recipe && (e.disassembly = this.getDisassemblyComponents(i, t)),
                            a.push(e)
                        }
                    }
                }
            return a
        }
        getDisassemblyComponentsAsItemTypes(e) {
            const t = [];
            if (!e)
                return t;
            if (e.inheritWeight) {
                const t = c.itemDescriptions[e.inheritWeight];
                if (t && t.recipe && t.disassemble)
                    return this.getDisassemblyComponentsAsItemTypes(t)
            }
            if (e.recipe)
                for (const a of e.recipe.components) {
                    const e = a.consumedAmount;
                    e >= 1 && a.disassembleAmount && a.disassembleAmount > 0 && t.push(a.type)
                }
            return t
        }
        getWeight(e, t=l.WeightType.Normal) {
            let a, i;
            const n = this.cachedWeights[e];
            if (n)
                switch (t) {
                case l.WeightType.Static:
                    a = n.static;
                    break;
                case l.WeightType.Min:
                    a = (i = this.cachedDecaysIntoWeights[e]) ? void 0 === n.min ? i.min : Math.min(n.min, i.min) : n.min;
                    break;
                case l.WeightType.Max:
                    a = (i = this.cachedDecaysIntoWeights[e]) ? void 0 === n.max ? i.max : Math.max(n.max, i.max) : n.max;
                    break;
                default:
                    void 0 !== n.min && void 0 !== n.max && (a = O.default.float() * (n.max - n.min) + n.min)
                }
            return void 0 === a && (a = this.weightTree(e, t)),
            (a = B.default.roundNumber(a, 1)) < .1 && (a = .1),
            a
        }
        weightTree(e, t=l.WeightType.Normal, a=!1, i=0) {
            let n = this.cachedWeights[e];
            if (n && !a)
                switch (t) {
                case l.WeightType.Static:
                    if (void 0 !== n.static)
                        return n.static;
                    break;
                case l.WeightType.Min:
                    if (void 0 !== n.min)
                        return n.min;
                    break;
                case l.WeightType.Max:
                    if (void 0 !== n.max)
                        return n.max
                }
            const o = c.itemDescriptions[e];
            if (!o)
                return 0;
            let r = "";
            if (a)
                for (let e = 0; e < i; e++)
                    r += "\t";
            if (0 === i && a) {
                const a = g.default.nameOf(m.Dictionary.Item, e, 1, !1).inContext(3).getString();
                console.log(`Weight Tree™ for ${a}, weight type ${l.WeightType[t]}, item type ${e}`),
                r += "\t"
            }
            let s = o.weight, u = o.reducedWeight, d = o.minimumWeight, p = o.recipe, h, y;
            if (void 0 === s && void 0 !== o.inheritWeight) {
                const e = c.itemDescriptions[o.inheritWeight];
                e && (void 0 !== e.weight ? (s = e.weight,
                h = e) : e.recipe && (p = e.recipe,
                y = e),
                void 0 !== e.reducedWeight && (u = e.reducedWeight),
                void 0 !== e.minimumWeight && (d = e.minimumWeight))
            }
            if (void 0 === s && (s = 0),
            void 0 !== o.weight && a) {
                const e = new g.default(m.Dictionary.Item,o.inheritWeight).getString();
                console.log(`${r}Weight`, o.weight, h ? `Inherited from ${e}` : "")
            }
            if (void 0 !== u && (a && console.log(`${r}Reduced Weight`, u),
            s -= u,
            a && console.log(`${r}New Weight: ${s} [Reduced weight]`)),
            p) {
                if (a) {
                    const e = new g.default(m.Dictionary.Item,o.inheritWeight).getString();
                    console.log(`${r}Recipe Components`, y ? `Inherited from ${e}` : ""),
                    r += "\t"
                }
                for (const n of p.components) {
                    if (n.consumedAmount < 1 && !a)
                        continue;
                    let o = n.type;
                    this.isGroup(o) && (o = this.getGroupDefault(o, t));
                    const l = c.itemDescriptions[o];
                    if (!l)
                        continue;
                    const u = n.consumedAmount;
                    let d;
                    if (a && (d = g.default.nameOf(m.Dictionary.Item, e, 1, !1).inContext(3).getString(),
                    console.log(`${r}${d} (Consumed x${u}), item type ${o}`)),
                    u >= 1)
                        if (n.ignoreWeight)
                            a && console.log(`${r}\tIgnored Weight`);
                        else {
                            const e = this.weightTree(o, t, a, i + 3) * u;
                            s += e,
                            a && console.log(`${r}New Weight: ${s} [Added ${e} from ${d}]`)
                        }
                    a && console.log("")
                }
            }
            if (void 0 !== d && s < d && (a && console.log(`${r}Minimum Weight`, d),
            s = d,
            a && console.log(`${r}Minimum Weight: ${s} [Minimum weight]`)),
            !p) {
                a && console.log(`${r}Weight before weight type applied: ${s}`);
                const e = .75 * s
                  , i = 1.2 * s;
                switch (t) {
                case l.WeightType.Normal:
                    s = O.default.float() * (i - e) + e;
                    break;
                case l.WeightType.Min:
                    s = B.default.roundNumber(e, 1);
                    break;
                case l.WeightType.Max:
                    s = B.default.roundNumber(i, 1)
                }
                a && console.log(`${r}Weight after weight type applied: ${s}`)
            }
            switch (a && console.log(`${r}Total Weight after rounding: ${s}`),
            (n = this.cachedWeights[e]) || (n = this.cachedWeights[e] = {}),
            t) {
            case l.WeightType.Static:
                void 0 === n.static && (n.static = s);
                break;
            case l.WeightType.Min:
                void 0 === n.min && (n.min = s);
                break;
            case l.WeightType.Max:
                void 0 === n.max && (n.max = s)
            }
            return s
        }
        create(e, t, a=l.ItemQuality.Random) {
            const i = this.createFake(e, a)
              , n = E.findUnusedId(x.LogSource.ItemManager, game.items);
            return i.id = n,
            game.items[i.id] = i,
            this.addToContainerInternal(i, t),
            i
        }
        createFake(e, t=l.ItemQuality.Random) {
            return new p.default(e,t)
        }
        isContainer(e) {
            return "object" == typeof e && void 0 !== e.containedItems
        }
        moveAllFromContainerToInventory(e, t, a) {
            return M.default.get(e).source(v.Source.Action, v.Source.Item).send(h.default.DumpContentsOfContainerInInventory),
            this.moveAllFromContainerToContainer(e, t, e.inventory, void 0, a)
        }
        computeContainerWeight(e) {
            let t = 0;
            for (const a of e.containedItems)
                t += a.getTotalWeight();
            return t
        }
        getLegendaryWeightCapacity(e) {
            const t = this.getContainerReference(e, void 0, !1);
            if (t.type === d.ContainerReferenceType.Item) {
                const t = e;
                if (t.legendary && t.legendary.type === l.LegendaryType.WeightCapacity)
                    return t.legendary.value
            }
            return 0
        }
        moveAllFromContainerToContainer(e, t, a, i, n, o=!0, r) {
            let s = o ? this.computeContainerWeight(a) : void 0;
            const u = void 0 !== a.weightCapacity ? B.default.roundNumber(a.weightCapacity + this.getLegendaryWeightCapacity(a), 1) : void 0
              , d = [];
            for (const e of t.containedItems)
                void 0 !== i && e.type !== i || void 0 !== n && e.quality !== n || d.push(e);
            const p = []
              , c = [];
            for (const e of d) {
                const t = void 0 !== s ? e.getTotalWeight() : void 0;
                if (void 0 === t || void 0 === s || void 0 === u || s + t <= u) {
                    if (void 0 !== t) {
                        if (a.containedWithin && !this.hasRoomInContainer(t, a.containedWithin, e)) {
                            c.push(e);
                            continue
                        }
                        void 0 !== s && (s += t)
                    }
                    p.push(e),
                    this.addToContainerInternal(e, a, !0),
                    r && r(e)
                } else
                    c.push(e)
            }
            return c.length > 0 && M.default.get(e).source(v.Source.Action, v.Source.Item).send(h.default.NoMoreRoomInContainer, g.default.formatList(this.getItemTranslations(c))),
            p.length ? (ui.afterAddingMultipleItemsToContainer(a),
            void 0 !== e && e.queueSoundEffect(l.SfxType.PickUp),
            p) : []
        }
        moveToContainer(e, t, a) {
            let i = !1;
            return this.hasRoomInContainer(t.getTotalWeight(), a, t) ? this.addToContainerInternal(t, a) && (i = !0) : M.default.get(e).source(v.Source.Action, v.Source.Item).send(h.default.NoMoreRoomInContainer, t.getName()),
            void 0 !== e && e.queueSoundEffect(l.SfxType.PickUp),
            i
        }
        hasRoomInContainer(e, t, a) {
            let i = this.computeContainerWeight(t) + e;
            return void 0 !== a && this.isContainableInContainer(a, t) && (i -= e),
            i = B.default.roundNumber(i, 1),
            (void 0 === t.weightCapacity || i <= B.default.roundNumber(t.weightCapacity + this.getLegendaryWeightCapacity(t), 1)) && (!t.containedWithin || this.hasRoomInContainer(e, t.containedWithin, a))
        }
        breakContainerOnTile(e, t, a, i) {
            this.isContainer(e) && this.placeItemsAroundLocation(e, t, a, i),
            e.spawnOnBreak(),
            this.remove(e)
        }
        placeItemsAroundLocation(e, t, a, i, n=!0) {
            for (; e.containedItems.length > 0; ) {
                const o = e.containedItems[e.containedItems.length - 1];
                o.placeOnTile(t + O.default.intInRange(-1, 1), a + O.default.intInRange(-1, 1), i, !0, n),
                o.damage("P")
            }
        }
        spawn(e, t, a, i) {
            void 0 === e && (e = i === l.WorldZ.Cave ? [l.ItemType.SharpRock, l.ItemType.LargeRock, l.ItemType.Stones, l.ItemType.SmoothRock, l.ItemType.Copal, l.ItemType.Fossil, l.ItemType.IronOre, l.ItemType.Talc, l.ItemType.Limestone, l.ItemType.Coal, l.ItemType.AnimalSkull, l.ItemType.Shale, l.ItemType.Bone, l.ItemType.WoodenSpear, l.ItemType.WoodenSword, l.ItemType.WoodenArrow, l.ItemType.OldInstructionalScroll, l.ItemType.AnimalClaw, l.ItemType.TatteredMap, l.ItemType.MossCoveredBook, l.ItemType.OldEducationalScroll] : [l.ItemType.Feather, l.ItemType.LargeRock, l.ItemType.Bone, l.ItemType.Branch, l.ItemType.Twigs, l.ItemType.StoneArrowhead, l.ItemType.Stones, l.ItemType.SharpRock, l.ItemType.AnimalSkull, l.ItemType.TreeBark, l.ItemType.Shale, l.ItemType.Copal, l.ItemType.Fossil, l.ItemType.Egg, l.ItemType.AnimalClaw]);
            const n = O.default.getElement(e);
            this.create(n, this.getTileContainer(t, a, i), l.ItemQuality.Random)
        }
        resetMapsInContainer(e) {
            const t = this.getItemsInContainerByType(e, l.ItemType.TatteredMap, !0);
            for (const e of t)
                e.initializeMap()
        }
        getTileContainer(e, t, a) {
            const i = game.getTile(e, t, a)
              , n = i;
            return void 0 === n.containedItems && (n.containedWithin = this.worldContainer,
            n.containedItems = [],
            n.x = e,
            n.y = t,
            n.z = a),
            n
        }
        getRandomQuality(e, t=0) {
            return game.getRandomQuality(e, t)
        }
        hasAdditionalRequirements(e, t, o, r, s) {
            const u = c.itemDescriptions[t]
              , d = u ? u.recipe : void 0;
            let p = d && d.requiresFire;
            !p && s && (p = u && u.repairAndDisassemblyRequiresFire);
            const y = {
                requirementsMet: !0,
                fireRequirementMet: !1,
                doodadRequirementMet: !1,
                x: 0,
                y: 0,
                z: 0
            };
            if (d && (d.requiredDoodad || p)) {
                let s, u;
                const c = [[e.direction.x, e.direction.y], [0, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [1, -1], [-1, 1], [1, 1], [-1, -1]];
                for (let t = 0; t < c.length; t++) {
                    const a = c[t][0]
                      , i = c[t][1]
                      , o = game.getTile(e.x + a, e.y + i, e.z)
                      , r = F.default.getType(o);
                    let m;
                    m = a <= -1 && i <= 0 ? l.Direction.West : i <= -1 ? l.Direction.North : a >= 1 ? l.Direction.East : l.Direction.South;
                    const h = o.doodad;
                    if (h) {
                        const e = h.type
                          , t = n.doodadDescriptions[e];
                        (e === d.requiredDoodad || t && d.requiredDoodad && t.group === d.requiredDoodad) && (s = m,
                        y.doodadRequirementMet = !0),
                        t && t.providesFire && p && (u = m,
                        y.fireRequirementMet = !0)
                    }
                    if (!u && p)
                        if (tileEventManager.get(o, D.TileEventType.Fire))
                            u = m,
                            y.fireRequirementMet = !0;
                        else if (r === l.TerrainType.Lava || r === l.TerrainType.CoolingLava)
                            u = m,
                            y.fireRequirementMet = !0,
                            y.isLava = !0,
                            y.x = e.x + a,
                            y.y = e.y + i,
                            y.z = e.z;
                        else if (o.creature) {
                            const e = o.creature.description();
                            e && e.providesFire && (u = m,
                            y.fireRequirementMet = !0)
                        }
                    if (p && d.requiredDoodad && void 0 !== u && void 0 !== s || !p && d.requiredDoodad && void 0 !== s || !d.requiredDoodad && p && void 0 !== u)
                        break
                }
                if (p && d.requiredDoodad && void 0 !== u && void 0 !== s)
                    return r && a.default.get(i.ActionType.UpdateDirection).execute(e, s),
                    y;
                if (!p && d.requiredDoodad && void 0 !== s)
                    return r && a.default.get(i.ActionType.UpdateDirection).execute(e, s),
                    y;
                if (!d.requiredDoodad && p && void 0 !== u)
                    return r && a.default.get(i.ActionType.UpdateDirection).execute(e, u),
                    y;
                if (o) {
                    let a;
                    if (void 0 === u && p)
                        a = g.default.message(h.default.FireSource).inContext(1);
                    else if (void 0 === s && d.requiredDoodad) {
                        const e = doodadManager.isDoodadTypeGroup(d.requiredDoodad);
                        a = g.default.nameOf(e ? m.Dictionary.DoodadGroup : m.Dictionary.Doodad, d.requiredDoodad)
                    } else
                        a = g.default.message(h.default.Unknown);
                    M.default.get(e).source(v.Source.Action).send(h.default.RequiresYouToBeAround, g.default.nameOf(m.Dictionary.Item, t), a, g.default.message(o))
                }
                return y.requirementsMet = !1,
                y
            }
            return y
        }
        getItemTypeGroupName(e, t, a) {
            const i = this.isGroup(e);
            return g.default.nameOf(i ? m.Dictionary.ItemGroup : m.Dictionary.Item, e, a, t)
        }
        isInGroup(e, t) {
            const a = this.cachedItemGroups[e];
            return !!a && !0 === a[t]
        }
        craft(e, t, a, i, n) {
            multiplayer.addSyncCheck(T.MultiplayerSyncCheck.ItemCraft, {
                itemType: t,
                itemsToRequire: a.map(e=>void 0 === e ? -1 : e.id),
                itemsToConsume: i.map(e=>void 0 === e ? -1 : e.id),
                baseItem: void 0 === n ? -1 : n.id
            });
            const o = e.getTile()
              , r = A.default[F.default.getType(o)];
            if (r && r.water)
                return M.default.get(e).source(v.Source.Action).send(h.default.CannotInWater, g.default.message(h.default.Craft)),
                l.CraftStatus.Invalid;
            const u = this.hasAdditionalRequirements(e, t, h.default.Craft, !0);
            if (!u.requirementsMet)
                return l.CraftStatus.Invalid;
            const p = c.itemDescriptions[t];
            if (!p)
                return l.CraftStatus.Invalid;
            const S = g.default.nameOf(m.Dictionary.Item, t)
              , I = p.recipe;
            if (!I)
                return l.CraftStatus.Invalid;
            u.isLava && game.doLavaEvents(u.x, u.y, u.z),
            e.queueSoundEffect(l.SfxType.Craft),
            e.skillGain(I.skill);
            const C = this.computeCraftQualityBonus(a, i)
              , D = this.isCraftSuccessful(e, I, C);
            for (const e of a)
                e.damage("CR");
            if (D === d.CraftResult.Fail) {
                for (const e of i)
                    e.damage("CC");
                let a;
                return b.default.get(e).write(y.default.FailureInCrafting, S, new g.default(m.Dictionary.Skill,I.skill)),
                e.getSkill(I.skill) <= k.skillChance(I.level) - 40 && (a = g.default.message(h.default.LikelyFailures).addArgs(S)),
                M.default.get(e).source(v.Source.Action, v.Source.Item).type(M.MessageType.Bad).send(h.default.YouFailedTo, g.default.message(I.skill === l.SkillType.Cooking ? h.default.Cook : h.default.Craft), S, a),
                e.reduceStat(s.Stat.Stamina, Math.max(Math.floor(this.getWeight(t) / 2), 1)),
                l.CraftStatus.Failed
            }
            e.reduceStat(s.Stat.Stamina, Math.max(Math.floor(this.getWeight(t)), 1));
            let P = l.ItemQuality.None, G;
            if (n)
                void 0 !== n.quality && (P = n.quality);
            else if (D === d.CraftResult.CritSuccess) {
                const t = O.default.percent();
                t <= 1 + C ? (P = l.ItemQuality.Legendary,
                e.queueSoundEffect(l.SfxType.Exceptional)) : P = t <= 25 + C ? l.ItemQuality.Exceptional : l.ItemQuality.Remarkable
            }
            if (n ? (G = n).changeInto(t) : G = e.createItemInInventory(t, P),
            G.ownerIdentifier = e.identifier,
            p.decayMax && (G.decay = p.decayMax + Math.floor(10 * e.getSkill(I.skill)) + 10 * C),
            i.length > 0 && !p.keepDurabilityOnCraft) {
                let t = 0
                  , a = 0
                  , n = 0
                  , o = 0
                  , r = 0;
                const s = [];
                for (const e of i) {
                    for (const t of I.components)
                        t.ignoreWeight || 0 === t.consumedAmount || (e.type === t.type || this.isGroup(t.type) && this.isInGroup(e.type, t.type)) && (r += e.weight,
                        t.disassembleAmount > 0 && s.push(e));
                    const i = e.maxDur;
                    if (void 0 !== i) {
                        const r = e.minDur;
                        void 0 !== r && (t += r / i,
                        a++);
                        const s = c.itemDescriptions[e.type];
                        let l = s ? s.durability : void 0;
                        l || (l = this.getDefaultDurability()),
                        n += i / l,
                        o++
                    }
                }
                p.disassemble && (G.disassembly = s),
                p.reducedWeight && (r -= p.reducedWeight),
                p.minimumWeight && r < p.minimumWeight && (r = p.minimumWeight),
                t /= a,
                n /= o;
                let u = p.durability;
                u || (u = this.getDefaultDurability()),
                G.maxDur = u,
                r <= 0 && (r = .1),
                G.weight = B.default.roundNumber(r, 1),
                G.setQuality(G.quality || l.ItemQuality.None),
                G.maxDur = Math.floor(G.maxDur * n) + Math.floor(e.getSkill(I.skill) / 10),
                (G.maxDur <= 0 || isNaN(G.maxDur)) && (G.maxDur = 1),
                G.maxDur >= 7.5 * u && (G.maxDur = Math.floor(7.5 * u) + this.getDefaultDurability()),
                G.minDur = Math.floor(G.maxDur * t),
                (G.minDur <= 0 || isNaN(G.minDur)) && (G.minDur = 1)
            }
            for (const e of i)
                this.remove(e);
            return modManager.getHook(f.Hook.OnCraft).call(e, G),
            ui.updateItem(G),
            M.default.get(e).source(v.Source.Action, v.Source.Item).send(h.default.YouCrafted, g.default.message(I.skill === l.SkillType.Cooking ? h.default.Cooked : h.default.Crafted), S),
            e.addMilestone(w.MilestoneType.Crafter),
            I.skill === l.SkillType.Cooking && e.addMilestone(w.MilestoneType.Chef),
            e.updateReputation(I.reputation),
            l.CraftStatus.Success
        }
        decayItems() {
            let e = !1;
            const t = O.default.int(5);
            for (const a of game.items) {
                if (void 0 === a || void 0 === a.decay)
                    continue;
                const i = a.type
                  , n = this.getContainerReference(a.containedWithin, void 0, !1);
                if (n.type !== d.ContainerReferenceType.PlayerInventory && n.type !== d.ContainerReferenceType.Tile && 0 !== t)
                    continue;
                if (n.type === d.ContainerReferenceType.PlayerInventory && void 0 !== n.identifier || n.type === d.ContainerReferenceType.Item && void 0 !== this.getAbsentPlayerWithItemInInventory(a))
                    continue;
                const o = c.itemDescriptions[i];
                if (o && void 0 !== o.decayMax)
                    if (a.decay > 0) {
                        if (a.decay--,
                        a.isDecayed() && n.type !== d.ContainerReferenceType.World && n.type !== d.ContainerReferenceType.Tile && ui.updateItem(a),
                        o.isTorch && 0 === O.default.int(75)) {
                            const e = this.getPlayerWithItemInInventory(a);
                            e && this.create(l.ItemType.PileOfAsh, this.getTileContainer(e.x, e.y, e.z))
                        }
                    } else {
                        if (n.type === d.ContainerReferenceType.PlayerInventory) {
                            const t = n
                              , i = players[t.pid];
                            i && a.isEquipped() && i.unequip(a, !0, !0, !0),
                            i.messages.source(v.Source.Item).send(h.default.HasDecayed, a.getName(!1)),
                            e = !0
                        }
                        a.spawnOnDecay();
                        const t = o.decaysInto;
                        if (t) {
                            const e = c.itemDescriptions[t];
                            if (e) {
                                a.decay = e.decayMax,
                                a.changeInto(t);
                                continue
                            }
                        }
                        this.remove(a)
                    }
            }
            return e
        }
        getPlayerWithItemInInventory(e) {
            for (const t of players)
                if (this.isContainableInContainer(e, t.inventory))
                    return t
        }
        getAbsentPlayerWithItemInInventory(e) {
            for (const t of absentPlayers)
                if (this.isContainableInContainer(e, t.inventory))
                    return t
        }
        getNPCWithItemInInventory(e) {
            for (const t of game.npcs)
                if (t && this.isContainableInContainer(e, t.inventory))
                    return t
        }
        countItemsInContainer(e, t, a) {
            let i = 0;
            Array.isArray(e) || (e = [e]);
            for (const n of e)
                for (let e = 0; e < n.containedItems.length; e++) {
                    const o = n.containedItems[e];
                    o !== a && o.type === t && i++;
                    const r = c.itemDescriptions[o.type];
                    r && void 0 !== r.weightCapacity && (i += this.countItemsInContainer(o, t, a))
                }
            return i
        }
        countItemsInContainerByGroup(e, t, a) {
            let i = 0;
            Array.isArray(e) || (e = [e]);
            for (const n of e)
                for (let e = 0; e < n.containedItems.length; e++) {
                    const o = n.containedItems[e];
                    o !== a && this.isInGroup(o.type, t) && i++;
                    const r = c.itemDescriptions[o.type];
                    r && void 0 !== r.weightCapacity && (i += this.countItemsInContainerByGroup(o, t, a))
                }
            return i
        }
        getItemInContainer(e, t, a, i) {
            const n = this.getOrderedContainerItems(e, i);
            for (const e of n) {
                if (e !== a && e.type === t)
                    return e;
                const n = c.itemDescriptions[e.type];
                if (n && void 0 !== n.weightCapacity) {
                    const n = this.getItemInContainer(e, t, a, i);
                    if (n)
                        return n
                }
            }
        }
        getItemForHuman(e, t) {
            const a = e.getProtectedItemsOptions();
            let i = this.isGroup(t) ? this.getItemInContainerByGroup(e.inventory, t, void 0, a) : this.getItemInContainer(e.inventory, t, void 0, a);
            if (i)
                return i;
            for (const n of this.getAdjacentContainers(e))
                if (i = this.isGroup(t) ? this.getItemInContainerByGroup(n, t, void 0, a) : this.getItemInContainer(n, t, void 0, a))
                    return i
        }
        getItemInContainerByGroup(e, t, a, i) {
            const n = this.getOrderedContainerItems(e, i);
            for (const e of n) {
                if (e.id !== a && this.isInGroup(e.type, t))
                    return e;
                const n = c.itemDescriptions[e.type];
                if (n && void 0 !== n.weightCapacity) {
                    const n = this.getItemInContainerByGroup(e, t, a, i);
                    if (n)
                        return n
                }
            }
        }
        getItemsInContainer(e, t=!1, a) {
            let i = [];
            if (!e.containedItems)
                return i;
            const n = this.getOrderedContainerItems(e, a);
            for (const e of n) {
                i.push(e);
                const n = c.itemDescriptions[e.type];
                t && n && void 0 !== n.weightCapacity && (i = i.concat(this.getItemsInContainer(e, t, a)))
            }
            return i
        }
        getItemsInContainerByType(e, t, a=!1, i) {
            let n = [];
            const o = this.getOrderedContainerItems(e);
            for (const e of o) {
                if (i && e.shouldBeProtected())
                    continue;
                e.type === t && n.push(e);
                const o = c.itemDescriptions[e.type];
                a && o && void 0 !== o.weightCapacity && (n = n.concat(this.getItemsInContainerByType(e, t, a, i)))
            }
            return n
        }
        getItemsInContainerByGroup(e, t, a=!1, i) {
            let n = [];
            const o = this.getOrderedContainerItems(e, i);
            for (const e of o) {
                this.isInGroup(e.type, t) && n.push(e);
                const o = c.itemDescriptions[e.type];
                a && o && void 0 !== o.weightCapacity && (n = n.concat(this.getItemsInContainerByGroup(e, t, a, i)))
            }
            return n
        }
        getItemInInventoryByGroup(e, t, a) {
            return this.getItemInContainerByGroup(e.inventory, t, a)
        }
        isItemInContainer(e, t, a) {
            return void 0 !== this.getItemInContainer(e, t, a)
        }
        isContainableInContainer(e, t) {
            let a = e;
            for (; void 0 !== a; ) {
                if (a === t)
                    return !0;
                a = a.containedWithin
            }
            return !1
        }
        getAdjacentContainers(e, t, a) {
            const i = [];
            if (!a && !e.options.useAdjacentContainers)
                return i;
            const n = F.default.getTilesAround(e, !0);
            for (const e of n) {
                if (!e)
                    continue;
                const a = e;
                a && void 0 !== a.containedItems && i.push(a);
                const n = e.doodad;
                if (void 0 !== n) {
                    const t = e.doodad
                      , a = n.description();
                    a && !a.isLocked && void 0 !== t.weightCapacity && i.push(t)
                }
                t && void 0 !== e.npc && i.push(e.npc.inventory)
            }
            return i
        }
        isContainableInAdjacentContainer(e, t, a, i) {
            const n = this.getAdjacentContainers(e, a, i);
            for (const e of n)
                if (this.isContainableInContainer(t, e))
                    return !0;
            return !1
        }
        isInInventory(e) {
            return void 0 !== this.getPlayerWithItemInInventory(e)
        }
        isTileContainer(e) {
            return !(!e || e.containedWithin !== this.worldContainer)
        }
        getOrderedContainerItems(e, t) {
            const a = e.itemOrders ? e.itemOrders.map(e=>game.items[e]) : e.containedItems;
            return void 0 !== t && t.protect ? a.filter(e=>!e.shouldBeProtected() || !!this.isContainer(e) && !t.protectContainers) : a
        }
        reduceDismantleWeight(e, t, a=0) {
            let i = 0;
            for (const t of e)
                t.weight = this.getWeight(t.type, l.WeightType.Min),
                i += t.weight;
            if ((i = B.default.roundNumber(i, 1)) > t)
                _.warn("Items dismantled from item would be too low of weight to be realistic, keeping them as minimum", t, e);
            else
                for (; i < t; )
                    for (const a of e)
                        if (a.weight < this.getWeight(a.type, l.WeightType.Max) && (a.weight = B.default.roundNumber(a.weight + .1, 1)),
                        (i = B.default.roundNumber(i + .1, 1)) >= t)
                            break
        }
        getItemTranslations(e, t=!0) {
            if (!e.length)
                return R.pipe();
            const a = new Map;
            for (const i of e) {
                const e = a.get(i.type) || new Map;
                a.set(i.type, e);
                const n = e.get(i.quality) || new Map;
                e.set(i.quality, n);
                const o = i.getName(t)
                  , r = o.getString()
                  , s = n.get(r) || [];
                n.set(r, s),
                s.push(i)
            }
            return a.values().flatMap(e=>e.values()).flatMap(e=>e.values()).collect(G.default.toArray).sort((e,t)=>t.length - e.length).map(e=>e[0].getName(t, e.length, !0)).values()
        }
        getItemListTranslation(e, t) {
            return this.getItemTranslations(e, t).collect(g.default.formatList)
        }
        loadReferences(e) {
            const t = [];
            for (let e = 0; e < game.items.length; e++) {
                const a = game.items[e];
                if (a) {
                    const e = this.loadReference(a);
                    e || t.push(a)
                }
            }
            for (const e of players)
                this.loadReference(e.inventory);
            for (const e of absentPlayers)
                this.loadReference(e.inventory);
            if (!e) {
                for (let e = 0; e < game.npcs.length; e++) {
                    const a = game.npcs[e];
                    a && (this.loadReference(a.inventory) || t.push(a.inventory))
                }
                for (let e = 0; e < game.doodads.length; e++) {
                    const a = game.doodads[e];
                    a && (this.loadReference(a) || t.push(a))
                }
            }
            t.length > 0 && _.warn(`${t.length} broken references`)
        }
        saveTileReferences() {
            const e = []
              , t = {};
            for (const e of game.items)
                if (e && this.isTileContainer(e.containedWithin)) {
                    const a = e.containedWithin;
                    if (0 === a.containedItems.length)
                        continue;
                    const i = `${a.x},${a.y},${a.z}`;
                    t[i] || (t[i] = {
                        containedWithin: this.worldContainer,
                        containedItems: a.containedItems,
                        x: a.x,
                        y: a.y,
                        z: a.z
                    })
                }
            const a = Object.keys(t);
            for (let i = 0; i < a.length; i++)
                e.push(t[a[i]]);
            game.tileContainers = e
        }
        loadTileReferences() {
            for (const e of game.tileContainers) {
                const t = game.getTileFromPoint(e)
                  , a = Object.keys(e);
                for (const i of a)
                    "weightCapacity" !== i && (t[i] = e[i]);
                this.loadReference(t)
            }
        }
        isGroup(e) {
            return "number" == typeof e && e > l.ItemTypeGroup.Invalid && e < P.default.getModStart(l.ItemType)
        }
        getGroupItems(e, t=[]) {
            const a = new Set;
            if (!c.itemGroupDescriptions[e])
                return a;
            for (const i of c.itemGroupDescriptions[e].types)
                this.isGroup(i) ? (t.push(e),
                t.includes(i) ? _.error(`Item type group "${l.ItemTypeGroup[i]}" includes itself.`) : this.getGroupItems(i, t).forEach(e=>a.add(e))) : a.add(i);
            return a
        }
        getGroupDefault(e, t=l.WeightType.Normal, a=[]) {
            if (t === l.WeightType.Normal) {
                if (c.itemGroupDescriptions[e]) {
                    const i = c.itemGroupDescriptions[e].default;
                    return this.isGroup(i) ? (a.push(e),
                    a.includes(i) ? (_.error(`Item type group "${l.ItemTypeGroup[i]}" includes itself.`),
                    l.ItemType.None) : this.getGroupDefault(i, t, a)) : i
                }
                return _.warn("No default item found for group", g.default.nameOf(m.Dictionary.ItemGroup, e).getString()),
                l.ItemType.None
            }
            let i = this.cachedDefaultItemForGroup[e];
            if (!i) {
                let a = 999999, n, o = 0, r;
                for (const t of this.getGroupItems(e)) {
                    const e = this.getWeight(t, l.WeightType.Min);
                    e < a && (a = e,
                    n = t);
                    const i = this.getWeight(t, l.WeightType.Max);
                    i > o && (o = i,
                    r = t)
                }
                if (void 0 === n || void 0 === r)
                    throw new Error(`Invalid default itemtype for ${e}, ${t}`);
                i = this.cachedDefaultItemForGroup[e] = {
                    min: n,
                    max: r
                }
            }
            return t === l.WeightType.Min ? i.min : i.max
        }
        getGroups(e) {
            return P.default.values(l.ItemTypeGroup).filter(t=>this.isInGroup(e, t))
        }
        checkMilestones(e, t) {
            if (P.default.isModded(l.ItemType, t.type) || e.addMilestone(w.MilestoneType.Collector, t.type),
            this.isInGroup(t.type, l.ItemTypeGroup.Treasure) && e.addMilestone(w.MilestoneType.Treasurer, t.type),
            t.isEquipped()) {
                const a = t.getEquipSlot();
                void 0 !== a && (e.addMilestone(w.MilestoneType.Prepared, a),
                t.legendary && (e.addMilestone(w.MilestoneType.Pulchritudinous, a),
                e.checkSkillMilestones()))
            }
            e.updateMilestones()
        }
        getDefaultDurability() {
            return 7 - O.default.int(3)
        }
        generateLookups() {
            this.cachedWeights = {},
            this.cachedDecaysIntoWeights = {},
            this.cachedDefaultItemForGroup = {},
            this.cachedItemGroups = {};
            const e = (e,t)=>{
                for (const a of this.getGroupItems(t)) {
                    if (a === e)
                        return !0;
                    if (this.isGroup(a))
                        return this.isInGroup(e, a)
                }
                return !1
            }
            ;
            for (const t of P.default.values(l.ItemType)) {
                const a = c.itemDescriptions[t];
                if (a) {
                    a.recipes = [],
                    this.cachedItemGroups[t] = {};
                    for (const a of P.default.values(l.ItemTypeGroup))
                        e(t, a) && (this.cachedItemGroups[t][a] = !0);
                    for (const e of P.default.values(l.ItemType)) {
                        const i = c.itemDescriptions[e];
                        if (!i)
                            continue;
                        const n = i.recipe;
                        if (n)
                            if (void 0 !== n.baseComponent && (this.isGroup(n.baseComponent) && this.isInGroup(t, n.baseComponent) || t === n.baseComponent))
                                a.recipes.push(e);
                            else
                                for (const i of n.components) {
                                    const n = i.type;
                                    if (this.isGroup(n) && this.isInGroup(t, n) || t === n) {
                                        a.recipes.push(e);
                                        break
                                    }
                                }
                    }
                }
            }
            let t = 0;
            for (const e of P.default.values(l.ItemType)) {
                t++;
                let a = this.cachedWeights[e];
                a || (a = this.cachedWeights[e] = {}),
                void 0 === a.static && (a.static = this.getWeight(e, l.WeightType.Static)),
                void 0 === a.min && (a.min = this.getWeight(e, l.WeightType.Min)),
                void 0 === a.max && (a.max = this.getWeight(e, l.WeightType.Max));
                const i = c.itemDescriptions[e];
                if (i) {
                    const e = i.decaysInto;
                    if (void 0 !== e) {
                        let t = this.cachedDecaysIntoWeights[e];
                        t || (t = this.cachedDecaysIntoWeights[e] = {
                            min: a.min,
                            max: a.max
                        }),
                        t.min > a.min && (t.min = a.min),
                        t.max < a.max && (t.max = a.max)
                    }
                }
            }
            _.info("Cached weights", t)
        }
        updateItemOrder(e, t) {
            if (multiplayer.isConnected()) {
                const a = new S.default;
                a.container = e,
                a.itemOrder = t,
                multiplayer.syncPacket(a, ()=>{
                    this.updateItemOrderInternal(e, t)
                }
                , !0)
            } else
                this.updateItemOrderInternal(e, t)
        }
        getQualityBasedOnSkill(e, t, a=!1) {
            const i = O.default.percent()
              , n = Math.ceil(300 * O.default.float());
            if (e === l.ItemQuality.Legendary) {
                if (t <= i - 30)
                    return l.ItemQuality.None;
                if (t <= i)
                    return l.ItemQuality.Remarkable;
                if (t <= i + 30)
                    return l.ItemQuality.Exceptional
            } else if (e === l.ItemQuality.Exceptional) {
                if (a && t >= n + 75)
                    return l.ItemQuality.Legendary;
                if (t <= i)
                    return l.ItemQuality.None;
                if (t <= i + 30)
                    return l.ItemQuality.Remarkable
            } else if (e === l.ItemQuality.Remarkable) {
                if (a && t >= n + 50)
                    return l.ItemQuality.Exceptional;
                if (t <= i + 30)
                    return l.ItemQuality.None
            } else if (a && t >= n + 25)
                return l.ItemQuality.Remarkable;
            return e
        }
        getNPCFromInventoryContainer(e) {
            for (const t of game.npcs)
                if (t && t.inventory === e)
                    return t
        }
        getItemsByWeight(e, t) {
            let a = 0
              , i = 0;
            const n = game.items[e]
              , o = game.items[t];
            return n && (a = n.legendary && n.legendary.type === l.LegendaryType.ItemWeight ? n.weight - n.legendary.value : n.weight),
            o && (i = o.legendary && o.legendary.type === l.LegendaryType.ItemWeight ? o.weight - o.legendary.value : o.weight),
            a < i ? 1 : -1
        }
        getItemsWeight(e) {
            let t = 0;
            for (const a of e)
                t += a.getTotalWeight();
            return t
        }
        inspect({context: e}, ...t) {
            return t.length ? [[{
                name: !0,
                text: e !== u.InspectionContext.Tooltip ? this.getItemListTranslation(t) : this.getItemTranslations(t).map(e=>e.inContext(3)).collect(g.default.formatList)
            }]] : []
        }
        updateItemOrderInternal(e, t) {
            if (void 0 === t)
                delete e.itemOrders;
            else {
                for (const a of e.containedItems)
                    -1 === t.indexOf(a.id) && t.push(a.id);
                for (let a = 0; a < t.length; a++) {
                    const i = t[a];
                    game.items[i] && -1 !== e.containedItems.findIndex(e=>e.id === i) || (t.splice(a, 1),
                    a--)
                }
                e.itemOrders = t
            }
        }
        loadReference(e) {
            const t = e.containedItems;
            if (t) {
                let a = !1
                  , i = []
                  , n = {};
                for (let o = 0; o < t.length; o++) {
                    const r = game.items[t[o]];
                    r && !n[r.id] ? (n[r.id] = !0,
                    game.slot !== C.SLOT_MULTIPLAYER && r.verifyAndFixItem(),
                    i.push(r)) : (a = !0,
                    _.warn("Invalid item, skipping", o, r, t[o], e))
                }
                if (e.itemOrders) {
                    const t = e.itemOrders.length;
                    if (a || t !== i.length) {
                        _.warn(`Conflict between item orders and contained items. ${t}, ${i.length}`);
                        const a = e.itemOrders.filter(e=>!!game.items[e])
                          , o = [];
                        n = {};
                        for (const e of a)
                            n[e] ? _.warn("Invalid item in item orders, skipping", e) : (n[e] = !0,
                            o.push(e));
                        e.itemOrders = o;
                        const r = o.length;
                        t !== r && _.warn(`Fixed invalid items in container.itemOrders. ${t} -> ${r}`),
                        0 === i.length && (i = e.itemOrders.map(e=>game.items[e]),
                        _.warn(`Fixed broken container. 0 -> ${i.length}`))
                    }
                }
                e.containedItems = i
            } else
                e.itemOrders && (delete e.itemOrders,
                _.warn("Removed item orders for container"));
            const a = e.containedWithin
              , i = this.derefenceContainerReference(a);
            if (i)
                e.containedWithin = i;
            else if (a)
                return !(!localPlayer || !localPlayer.travelData || void 0 !== a.type) || (_.warn("Failed to restore item reference", e, a),
                !1);
            return !0
        }
        removeFromContainerInternal(e) {
            const t = e.containedWithin;
            if (!t)
                return;
            if (!t.containedItems)
                return void _.warn("Invalid container for item", e);
            const a = t.containedItems.indexOf(e);
            if (-1 === a)
                return void _.warn("Cannot remove item from container", L.default.stringify(e, 4, !0), L.default.stringify(t, 4, !0));
            t.containedItems.splice(a, 1),
            delete e.containedWithin;
            const i = t.itemOrders;
            if (void 0 !== i) {
                const a = i.indexOf(e.id);
                -1 !== a ? (i.splice(a, 1),
                0 === i.length && delete t.itemOrders) : _.warn("Attempted to splice missing item orders item", e, i)
            }
            if (multiplayer.addSyncCheck(T.MultiplayerSyncCheck.Container, `R${e.id}[${l.ItemType[e.type]}]F[L${t.containedItems.length}]`),
            t.containedWithin === this.worldContainer) {
                const e = t;
                if (game.updateFlowFieldTile(e, e.x, e.y, e.z),
                0 === t.containedItems.length) {
                    const e = t;
                    delete e.containedWithin,
                    delete e.weightCapacity,
                    delete e.containedItems,
                    delete e.x,
                    delete e.y,
                    delete e.z
                }
            }
            (this.isInInventory(t) || ui.isContainerOpen(t)) && ui.removeItemFromContainer(e, t)
        }
        updateUiOnItemRemove(e, t, a=!1, i) {
            e && t.isEquipped() && void 0 !== e.getEquipSlotForItem(t) && (o.default.is(e, r.EntityType.Player) ? e.unequip(t, void 0, i) : e.unequip(t));
            const n = t.quickSlot;
            n && !a && ((void 0 === e || o.default.is(e, r.EntityType.Player) && e.isLocalPlayer()) && (ui.removeItemFromQuickSlot(t.id),
            ui.refreshQuickSlots()),
            t.clearQuickSlot())
        }
        getCraftQualityBonus(e, t) {
            let a = 0;
            if (t)
                switch (e) {
                case l.ItemQuality.Remarkable:
                    a += 1;
                    break;
                case l.ItemQuality.Exceptional:
                    a += 2;
                    break;
                case l.ItemQuality.Legendary:
                    a += 4
                }
            else
                switch (e) {
                case l.ItemQuality.Remarkable:
                    a += 10;
                    break;
                case l.ItemQuality.Exceptional:
                    a += 20;
                    break;
                case l.ItemQuality.Legendary:
                    a += 40
                }
            return a
        }
        computeCraftQualityBonus(e, t) {
            let a = 0;
            for (let t = 0; t < e.length; t++) {
                const i = e[t];
                i.quality && (a += this.getCraftQualityBonus(i.quality, !0))
            }
            a && (a = Math.floor(a / e.length));
            let i = 0;
            for (let e = 0; e < t.length; e++) {
                const a = t[e];
                a.quality && (i += this.getCraftQualityBonus(a.quality, !1))
            }
            return i && (i = Math.floor(i / t.length)),
            i += a
        }
        isCraftSuccessful(e, t, a) {
            const i = O.default.percent()
              , n = k.skillChance(t.level);
            return e.getSkill(t.skill) >= n + i - a ? d.CraftResult.CritSuccess : e.getSkill(t.skill) >= n + i - (75 + a) ? d.CraftResult.Success : d.CraftResult.Fail
        }
        getPlayerFromInventoryContainer(e) {
            for (const t of players)
                if (t.inventory === e)
                    return t
        }
        getAbsentPlayerFromInventoryContainer(e) {
            for (const t of absentPlayers)
                if (t.inventory === e)
                    return t
        }
    }
    t.default = H
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("mapgen/IMapGen", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("tile/TerrainTemplates", ["require", "exports", "Enums", "tile/ITerrain"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.templates = {},
    t.default = t.templates,
    t.templates[i.TileTemplateType.House] = {
        woodenHouse: {
            terrainTypes: {
                F: a.TerrainType.WoodenFlooring
            },
            terrain: ["FFFFF", "FFFFF", "FFFFF", "FFFFF"],
            doodadTypes: {
                W: a.DoodadType.WoodenWall,
                D: a.DoodadType.WoodenDoor
            },
            doodad: ["WWWWW", "W   W", "W   D", "WWWWW"],
            degrade: .1
        },
        largeWoodenHouse: {
            terrainTypes: {
                F: a.TerrainType.WoodenFlooring
            },
            terrain: ["FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF", "FFFFFF"],
            doodadTypes: {
                W: a.DoodadType.WoodenWall,
                D: a.DoodadType.WoodenDoor
            },
            doodad: ["WWWWWW", "W    W", "W    W", "W    W", "WWDDWW"],
            degrade: .1
        },
        stoneHouse: {
            terrainTypes: {
                F: a.TerrainType.CobblestoneFlooring
            },
            terrain: ["FFFFFFF", "FFFFFFF", "FFFFFFF", "FFFFFFF"],
            doodadTypes: {
                W: a.DoodadType.StoneWall,
                D: a.DoodadType.WoodenDoor
            },
            doodad: ["WWWWDWW", "W     W", "W     W", "WWWWWWW"],
            degrade: .05
        },
        largeStoneHouse: {
            terrainTypes: {
                F: a.TerrainType.CobblestoneFlooring
            },
            terrain: ["FFFFF   ", "FFFFF   ", "FFFFFFFF", "FFFFFFFF", "FFFFFFFF"],
            doodadTypes: {
                W: a.DoodadType.StoneWall,
                D: a.DoodadType.WoodenDoor
            },
            doodad: ["WWDWW   ", "W   W   ", "WWWDWWWW", "W      W", "WWWWDWWW"],
            degrade: .05
        },
        monument: {
            terrainTypes: {
                F: a.TerrainType.CobblestoneFlooring
            },
            terrain: [" FFF ", "FFFFF", " FFF "],
            doodadTypes: {
                W: a.DoodadType.StoneWall
            },
            doodad: ["     ", "  W  ", "     "],
            degrade: 0
        }
    },
    t.templates[i.TileTemplateType.Pond] = {
        pondWithTrees: {
            terrainTypes: {
                D: a.TerrainType.Dirt,
                G: a.TerrainType.Grass,
                W: a.TerrainType.ShallowFreshWater
            },
            terrain: ["   GD   ", " DGDDGD ", " GGDWDG ", "DDWWWWDD", "GGWWWWGG", " DDWWDD ", " DGDGGD ", "   GD   "],
            doodadTypes: {
                F: {
                    type: a.DoodadType.MapleTree,
                    growingStages: [a.GrowingStage.Flowering, a.GrowingStage.Ripening]
                }
            },
            doodad: ["   FF   ", " FF  FF ", " F    F ", "F      F", "F      F", " F    F ", " FF  FF ", "   FF   "],
            degrade: .1
        },
        pond: {
            terrainTypes: {
                W: a.TerrainType.ShallowFreshWater,
                G: a.TerrainType.Grass,
                D: a.TerrainType.Dirt
            },
            terrain: ["  G  ", " GWD ", "DWWWG", " GWD ", "  D  "],
            doodadTypes: {
                F: {
                    type: a.DoodadType.MapleTree,
                    growingStages: [a.GrowingStage.Flowering, a.GrowingStage.Ripening]
                }
            },
            doodad: ["  F  ", " F F ", "F   F", " F F ", "  F  "],
            degrade: 1 / 30
        },
        irrigation: {
            terrainTypes: {
                W: a.TerrainType.ShallowFreshWater,
                D: a.TerrainType.Dirt,
                F: a.TerrainType.FertileSoil
            },
            terrain: ["FDFFFFDFF", "WWWWWWWWW", "FFFFFDFDF"],
            doodadTypes: {
                C: {
                    type: a.DoodadType.Carrots,
                    growingStages: [a.GrowingStage.Seedling, a.GrowingStage.Vegetative, a.GrowingStage.Budding]
                },
                L: {
                    type: a.DoodadType.Lettuce,
                    growingStages: [a.GrowingStage.Seedling, a.GrowingStage.Vegetative, a.GrowingStage.Budding]
                }
            },
            doodad: ["       C ", "         ", "  L      "],
            degrade: .04,
            tilled: !0
        },
        abandonedGarden: {
            terrainTypes: {
                D: a.TerrainType.Dirt,
                F: a.TerrainType.FertileSoil
            },
            terrain: ["DDDFDF", "DFFDFF", "FFFFDD", "DDFFFD"],
            doodadTypes: {
                W: a.DoodadType.WoodenFence,
                G: a.DoodadType.WoodenGate,
                C: {
                    type: a.DoodadType.Chives,
                    growingStages: [a.GrowingStage.Seedling, a.GrowingStage.Vegetative, a.GrowingStage.Budding]
                },
                P: {
                    type: a.DoodadType.PotatoPlant,
                    growingStages: [a.GrowingStage.Seedling, a.GrowingStage.Vegetative, a.GrowingStage.Budding]
                }
            },
            doodad: ["WWWWWW", "W C  W", "W  P W", "WWGGWW"],
            degrade: 1 / 15,
            tilled: !0
        }
    },
    t.templates[i.TileTemplateType.CavePond] = {
        largePond: {
            terrainTypes: {
                R: a.TerrainType.Rocks,
                D: a.TerrainType.Dirt,
                G: a.TerrainType.Gravel,
                W: a.TerrainType.ShallowFreshWater
            },
            terrain: ["   RRR  ", " RRDDRR ", " RGDWDR ", "RDWWWWDR", "RGWWWWGR", " RDWWDR ", " RRDGRR ", "   RR   "],
            degrade: .05
        },
        pond: {
            terrainTypes: {
                R: a.TerrainType.Rocks,
                W: a.TerrainType.ShallowFreshWater
            },
            terrain: ["  R  ", " RWR ", "RWWWR", " RWR ", "  R  "],
            degrade: .025
        }
    },
    t.templates[i.TileTemplateType.Desert] = {
        oasis: {
            terrainTypes: {
                D: a.TerrainType.Gravel,
                G: a.TerrainType.Grass,
                W: a.TerrainType.ShallowFreshWater,
                S: a.TerrainType.DesertSand
            },
            terrain: ["   SGS  ", " SSDDSG ", " SGDWDS ", "GDWWWWDS", "SGWWWWGG", " SDWWDS ", " SGDGSS ", "   SG   "],
            doodadTypes: {
                C: {
                    type: a.DoodadType.CoconutTree,
                    growingStages: [a.GrowingStage.Vegetative, a.GrowingStage.Budding, a.GrowingStage.Flowering, a.GrowingStage.Ripening]
                }
            },
            doodad: ["   C C  ", " C   CC ", " C    C ", "C       ", "       C", " C    C ", "  C  CC ", "   C    "],
            degrade: .1
        },
        pond: {
            terrainTypes: {
                D: a.TerrainType.Gravel,
                G: a.TerrainType.Grass,
                W: a.TerrainType.ShallowFreshWater,
                S: a.TerrainType.DesertSand
            },
            terrain: [" DDD ", "DGSGD", "DSWSD", "DGSGD", " DDD "],
            doodadTypes: {
                C: {
                    type: a.DoodadType.CoconutTree,
                    growingStages: [a.GrowingStage.Flowering, a.GrowingStage.Ripening]
                }
            },
            doodad: ["     ", "  C  ", " C C ", "  C  ", "     "],
            degrade: 1 / 30
        },
        sandstonePond: {
            terrainTypes: {
                S: a.TerrainType.Sandstone,
                W: a.TerrainType.ShallowFreshWater
            },
            terrain: [" SSS ", "SSWSS", "SWWWS", "SSWSS", " SSS "],
            degrade: .04
        },
        sandstoneHouse: {
            terrainTypes: {
                F: a.TerrainType.SandstoneFlooring
            },
            terrain: ["FFFFF", "FFFFF", "FFFFF", "FFFFF"],
            doodadTypes: {
                W: a.DoodadType.SandstoneWall,
                D: a.DoodadType.WoodenDoor
            },
            doodad: ["WWWWW", "W   W", "W   D", "WWWWW"],
            degrade: .05
        },
        clayHouse: {
            terrainTypes: {
                F: a.TerrainType.ClayBrickFlooring
            },
            terrain: ["FFFFF", "FFFFF", "FFFFF", "FFFFF", "FFFFF"],
            doodadTypes: {
                W: a.DoodadType.ClayBrickWall,
                D: a.DoodadType.WoodenDoor
            },
            doodad: ["WWWWW", "D   W", "W W W", "W W D", "WWWWW"],
            degrade: .04
        }
    },
    t.templates[i.TileTemplateType.Beach] = {
        clay: {
            terrainTypes: {
                S: a.TerrainType.BeachSand,
                C: a.TerrainType.Clay
            },
            terrain: ["  SCCS", " SCCCS", "SCCSSC", "CCCCSS", "CSCSCS"],
            degrade: .04
        },
        clayWithWater: {
            terrainTypes: {
                S: a.TerrainType.BeachSand,
                C: a.TerrainType.Clay,
                W: a.TerrainType.ShallowFreshWater
            },
            terrain: [" SCSSCS ", "  SCCS  ", " SCCCCS ", "CSCCWCSC", "S SCCCCS", "   SCS  "],
            degrade: .02
        },
        smallClay: {
            terrainTypes: {
                C: a.TerrainType.Clay
            },
            terrain: [" CC ", "C CC", "  C ", " C  "],
            degrade: .04
        }
    },
    t.templates[i.TileTemplateType.Boat] = {
        raft: {
            terrainTypes: {
                W: a.TerrainType.WoodenFlooring
            },
            terrain: ["WW", "WW"],
            degrade: 0
        },
        smallShip: {
            terrainTypes: {
                W: a.TerrainType.DeepSeawater,
                F: a.TerrainType.WoodenFlooring
            },
            terrain: ["WWFFFWW", "WFFFFFW", "FFFFFFF", "WFFFFFW", "WWFFFWW"],
            doodadTypes: {
                W: a.DoodadType.WoodenWall
            },
            doodad: ["  WWW  ", " W   W ", "W     W", " W   W ", "  WWW  "],
            degrade: .1
        }
    },
    t.templates[i.TileTemplateType.Lava] = {
        river: {
            terrainTypes: {
                L: a.TerrainType.Lava,
                C: a.TerrainType.CoolingLava
            },
            terrain: ["  CCC  C      ", " CLLLCCLCCCC  ", "CLLLLLLLLLLLC ", " CLLCCCLLLCLC ", " CLC   CLCCLLC", "  C     C CLLC", "           CC "],
            degrade: .05
        },
        pool: {
            terrainTypes: {
                L: a.TerrainType.Lava
            },
            terrain: ["  L   ", "  L   ", " LLLL ", "LLLLLL", " LLLL ", "  LL  "],
            degrade: .04
        },
        twopools: {
            terrainTypes: {
                L: a.TerrainType.Lava,
                C: a.TerrainType.CoolingLava,
                O: a.TerrainType.Obsidian
            },
            terrain: ["   O       ", "   CC      ", "  CLLC     ", " CLLLLC    ", "OCLLLC     ", " CLLLC     ", " OCLC   O  ", "  CLC  CC  ", "  CLCOCLLC ", "  CLLCLLLCO", "   CLLLLLC ", "    CCCLC  ", "      OC   "],
            degrade: 1 / 30
        },
        thickriver: {
            terrainTypes: {
                L: a.TerrainType.Lava,
                C: a.TerrainType.CoolingLava
            },
            terrain: ["            CC        ", "         CCLLLC C     ", "       CCLLLLLLCLC    ", " CCC CCLLLLCCLLLLCCC  ", "CLLLCLLLLCC  CCCLLLLC ", " CLLLLLCLC      CCLLLC", "  CLLCC C         CCC ", "   CC                 "],
            degrade: 1 / 35
        },
        coolingpool: {
            terrainTypes: {
                L: a.TerrainType.Lava,
                C: a.TerrainType.CoolingLava,
                O: a.TerrainType.Obsidian
            },
            terrain: ["  O   ", "  O   ", " OCCO ", "OCLCCO", " OCCO ", "  OO  "],
            degrade: 1 / 45
        }
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("mapgen/MapGenHelpers", ["require", "exports", "doodad/Doodads", "Enums", "OldEnums", "save/ISaveManager", "tile/ITileEvent", "tile/Terrains", "tile/TerrainTemplates", "utilities/Log", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    let c = !1;
    function m() {
        return c
    }
    function h() {
        c = !0
    }
    function y() {
        c = !1
    }
    function g(e, t, a) {
        itemManager.spawn([i.ItemType.StoneShovel, i.ItemType.Bone, i.ItemType.WoodenSpear, i.ItemType.WoodenSword, i.ItemType.BarkTorch, i.ItemType.TannedLeather, i.ItemType.BarkTunic, i.ItemType.BarkLeggings, i.ItemType.BarkShield, i.ItemType.LockPick, i.ItemType.OldInstructionalScroll, i.ItemType.TatteredMap, i.ItemType.Waterskin, i.ItemType.MossCoveredBook], e, t, a)
    }
    function f(e, t, a) {
        itemManager.spawn([i.ItemType.Log, i.ItemType.Branch, i.ItemType.Twigs, i.ItemType.Log, i.ItemType.Branch, i.ItemType.Twigs, i.ItemType.RawCod, i.ItemType.MessageInABottle, i.ItemType.Badderlocks], e, t, a)
    }
    function T(e, t, a, n, o) {
        let r;
        if (o ? n === i.WorldZ.Cave ? r = [i.DoodadType.ButtonMushrooms, i.DoodadType.FlyAmanita, i.DoodadType.FlyAmanita] : e === i.TerrainType.Grass ? r = [i.DoodadType.Beggarticks, i.DoodadType.ButtonMushrooms, i.DoodadType.MapleTree, i.DoodadType.SpruceTree, i.DoodadType.AppleTree, i.DoodadType.Switchgrass, i.DoodadType.CucumberPlant, i.DoodadType.TomatoPlant, i.DoodadType.PoisonIvy, i.DoodadType.PoisonIvy, i.DoodadType.FlyAmanita, i.DoodadType.FlyAmanita] : e === i.TerrainType.Dirt ? r = [i.DoodadType.Grass, i.DoodadType.MilkThistles, i.DoodadType.RaspberryBush, i.DoodadType.MapleTree, i.DoodadType.SpruceTree, i.DoodadType.Chives, i.DoodadType.Lettuce, i.DoodadType.PotatoPlant, i.DoodadType.Carrots, i.DoodadType.CornStalks, i.DoodadType.Pumpkin, i.DoodadType.Wheat, i.DoodadType.Cotton, i.DoodadType.Tumbleweed, i.DoodadType.PoisonIvy] : e === i.TerrainType.DesertSand ? r = [i.DoodadType.PricklyPears, i.DoodadType.Pineapple, i.DoodadType.CoconutTree, i.DoodadType.SugarCaneStalks, i.DoodadType.SaguaroCactus, i.DoodadType.AloeVera, i.DoodadType.Tumbleweed, i.DoodadType.Tumbleweed] : e === i.TerrainType.Swamp ? r = [i.DoodadType.Clematis, i.DoodadType.CypressTree, i.DoodadType.RaspberryBush, i.DoodadType.TomatoPlant, i.DoodadType.PoisonIvy, i.DoodadType.PoisonIvy] : e !== i.TerrainType.Seawater && e !== i.TerrainType.ShallowSeawater || (r = [i.DoodadType.Badderlocks]) : n === i.WorldZ.Cave ? r = [i.DoodadType.PileOfRocks, i.DoodadType.PileOfRocks, i.DoodadType.PileOfRocks, i.DoodadType.PileOfRocks, i.DoodadType.ButtonMushrooms, i.DoodadType.FlyAmanita, i.DoodadType.FlyAmanita, i.DoodadType.LockedWoodenChest, i.DoodadType.SkeletalRemains] : e === i.TerrainType.Grass ? r = [i.DoodadType.PileOfRocks, i.DoodadType.Beggarticks, i.DoodadType.ButtonMushrooms, i.DoodadType.MapleTree, i.DoodadType.SpruceTree, i.DoodadType.AppleTree, i.DoodadType.Switchgrass, i.DoodadType.CucumberPlant, i.DoodadType.TomatoPlant, i.DoodadType.PoisonIvy, i.DoodadType.PoisonIvy, i.DoodadType.FlyAmanita, i.DoodadType.FlyAmanita] : e === i.TerrainType.Dirt ? r = [i.DoodadType.PileOfRocks, i.DoodadType.Grass, i.DoodadType.MilkThistles, i.DoodadType.RaspberryBush, i.DoodadType.MapleTree, i.DoodadType.SpruceTree, i.DoodadType.Chives, i.DoodadType.Lettuce, i.DoodadType.PotatoPlant, i.DoodadType.Carrots, i.DoodadType.CornStalks, i.DoodadType.Pumpkin, i.DoodadType.Wheat, i.DoodadType.Cotton, i.DoodadType.Tumbleweed, i.DoodadType.PoisonIvy] : e === i.TerrainType.BeachSand ? r = [i.DoodadType.AloeVera, i.DoodadType.PileOfRocks, i.DoodadType.PileOfRocks] : e === i.TerrainType.DesertSand ? r = [i.DoodadType.PileOfRocks, i.DoodadType.PileOfRocks, i.DoodadType.PricklyPears, i.DoodadType.Pineapple, i.DoodadType.CoconutTree, i.DoodadType.SugarCaneStalks, i.DoodadType.SaguaroCactus, i.DoodadType.AloeVera, i.DoodadType.Tumbleweed, i.DoodadType.Tumbleweed, i.DoodadType.Tumbleweed] : e === i.TerrainType.Swamp ? r = [i.DoodadType.Clematis, i.DoodadType.CypressTree, i.DoodadType.RaspberryBush, i.DoodadType.TomatoPlant, i.DoodadType.PoisonIvy, i.DoodadType.PoisonIvy] : e === i.TerrainType.Seawater || e === i.TerrainType.ShallowSeawater ? r = [i.DoodadType.Badderlocks] : e === i.TerrainType.CobblestoneFlooring || e === i.TerrainType.WoodenFlooring ? r = [i.DoodadType.StoneCampfire, i.DoodadType.LockedWoodenChest, i.DoodadType.StoneFurnace, i.DoodadType.StoneKiln, i.DoodadType.WoodenChest] : e === i.TerrainType.SandstoneFlooring ? r = [i.DoodadType.SandstoneCampfire, i.DoodadType.LockedWoodenChest, i.DoodadType.SandstoneFurnace, i.DoodadType.SandstoneKiln, i.DoodadType.BarkTorchStand] : e === i.TerrainType.ClayBrickFlooring && (r = [i.DoodadType.ClayCampfire, i.DoodadType.LockedWoodenChest, i.DoodadType.ClayFurnace, i.DoodadType.ClayKiln, i.DoodadType.SetHobgoblinSnare]),
        r) {
            const e = doodadManager.create(d.default.getElement(r), t, a, n);
            if (e) {
                const t = e.description();
                t && t.canGrow && e.setGrowingStage(d.default.intInRange(1, 3))
            }
        }
    }
    function S(e, t, a) {
        tileEventManager.create(r.TileEventType.HoneyFungus, e, t, a)
    }
    function I(e) {
        const t = [];
        for (const a of e)
            t.push(a.split("").reverse().join(""));
        return t
    }
    function v(e) {
        const t = e[0].length
          , a = e.length
          , i = [];
        for (const t of e)
            i.push(t.split(""));
        const n = [];
        let o = 0;
        for (let e = a - 1; e >= 0; e--) {
            let a = 0;
            for (let r = 0; r < t; r++)
                n[a] || (n[a] = []),
                n[a][o] = i[e][r],
                a++;
            o++
        }
        const r = [];
        for (const e of n)
            r.push(e.join(""));
        return r
    }
    function w(e, ...t) {
        if (void 0 === e.mirrorVertically ? d.default.chance(.5) : e.mirrorVertically)
            for (let e = 0; e < t.length; e++)
                t[e] && t[e].reverse();
        if (void 0 === e.mirrorHorizontally ? d.default.chance(.5) : e.mirrorHorizontally)
            for (let e = 0; e < t.length; e++)
                t[e] && (t[e] = I(t[e]));
        const a = void 0 === e.rotate ? d.default.int(4) : e.rotate / 90;
        for (let e = 0; e < a; e++)
            for (let e = 0; e < t.length; e++)
                t[e] && (t[e] = v(t[e]));
        return t
    }
    function M(e, t, n, o, r={}) {
        if (!l.default[e])
            return;
        const u = Object.keys(l.default[e])
          , c = r.which ? r.which : d.default.getElement(u)
          , m = l.default[e][c];
        if (!m)
            return;
        let h = m.terrain.slice()
          , y = m.doodad ? m.doodad.slice() : void 0;
        [h,y] = w(r, h, y);
        const f = void 0 === r.degrade ? m.degrade : r.degrade
          , S = []
          , I = h[0].length
          , v = h.length;
        for (let e = 0; e < I; e++)
            for (let r = 0; r < v; r++) {
                if (1 === f || 0 !== f && d.default.chance(f))
                    continue;
                const l = game.getWrappedCoord(t + e)
                  , u = game.getWrappedCoord(n + r)
                  , c = game.getTile(l, u, o);
                let I = c.doodad;
                I && doodadManager.remove(I);
                let v = p.default.getType(c)
                  , w = s.default[v];
                if (v === i.TerrainType.CaveEntrance)
                    continue;
                if (itemManager.isContainer(c) && itemManager.removeContainerItems(c),
                c.creature && creatureManager.remove(c.creature),
                c.events)
                    for (let e = c.events.length - 1; e >= 0; e--)
                        tileEventManager.remove(c.events[e]);
                let M = h[r].charAt(e);
                if (" " !== M) {
                    const e = m.terrainTypes[M];
                    game.changeTile(e, l, u, o, !1),
                    v = e,
                    w = s.default[v]
                }
                if (void 0 !== y)
                    if (" " !== (M = y[r].charAt(e)) && m.doodadTypes) {
                        const e = m.doodadTypes[M];
                        let t, n;
                        "object" == typeof e ? (t = e.type,
                        n = d.default.getElement(e.growingStages)) : t = e,
                        w && !w.passable && (game.changeTile(i.TerrainType.Dirt, l, u, o, !1),
                        v = i.TerrainType.Dirt,
                        w = s.default[v]);
                        const r = a.default[t];
                        if (void 0 !== n && r && r.allowedTiles)
                            for (const e of r.allowedTiles)
                                v === e && (I = doodadManager.create(t, l, u, o));
                        else
                            I = doodadManager.create(t, l, u, o);
                        I && (void 0 !== n && I.setGrowingStage(n, !0),
                        t !== i.DoodadType.WoodenDoor && t !== i.DoodadType.WoodenGate || S.push(I))
                    } else {
                        if (m.tilled) {
                            const e = game.getTile(l, u, o)
                              , a = s.default[p.default.getType(e)];
                            if (a && a.tillable && 0 === d.default.int(2)) {
                                const a = game.getOrCreateTileData(t, n, o);
                                0 === a.length ? a.push({
                                    type: p.default.getType(c),
                                    tilled: !0
                                }) : a[0].tilled = !a[0].tilled,
                                p.default.setTilled(e, !0),
                                world.updateTile(l, u, o, e)
                            }
                        }
                        switch (v) {
                        case i.TerrainType.CobblestoneFlooring:
                        case i.TerrainType.SandstoneFlooring:
                        case i.TerrainType.WoodenFlooring:
                        case i.TerrainType.ClayBrickFlooring:
                            const e = d.default.int(600)
                              , t = d.default.int(325)
                              , a = d.default.int(500);
                            e <= 70 ? g(l, u, o) : t <= 10 ? T(p.default.getType(c), l, u, o) : a <= 30 && doodadManager.create(i.DoodadType.SkeletalRemains, l, u, o)
                        }
                    }
            }
        if (S.length > 0)
            for (let e = 0; e < S.length; e++) {
                const t = S[e]
                  , a = world.layers[o]
                  , n = a.getTile(t.x - 1, t.y)
                  , r = a.getTile(t.x + 1, t.y);
                a.isWall(n) || a.isWall(r) || a.isFence(n) || a.isFence(r) || (t.orientation = i.DoorOrientation.Vertical,
                world.updateTile(t.x, t.y, t.z, t.getTile()))
            }
    }
    function b(e, t, n, o, r) {
        const s = p.default.getTileVariation(t, n)
          , l = a.default[o];
        if (l && l.spawnOnTerrain) {
            const t = l.spawnOnTerrain[Math.floor(s * l.spawnOnTerrain.length)];
            p.default.setType(e, t)
        } else
            p.default.setType(e, i.TerrainType.Dirt);
        p.default.setGfx(e, s > .666 ? 0 : s > .333 ? 1 : 2)
    }
    function k(e) {
        let t, a, n, o;
        for (n = i.WorldZ.Min; n <= i.WorldZ.Max; n++)
            for (t = 0; t < game.mapSize; t++)
                for (a = 0; a < game.mapSize; a++) {
                    (o = game.getOrCreateTile(t, a, n)).data = e[n * game.mapSizeSq + a * game.mapSize + t];
                    const r = p.default.getTypeRaw(o.data);
                    switch (r) {
                    case i.DoodadType.MapleTree:
                    case i.DoodadType.CoconutTree:
                    case i.DoodadType.JoshuaTree:
                    case i.DoodadType.SpruceTree:
                    case i.DoodadType.CypressTree:
                    case i.DoodadType.AppleTree:
                        if (game.previousSaveVersion && 2 === game.previousSaveVersion.major && game.previousSaveVersion.minor < 4) {
                            let e = !1;
                            const i = game.getTileData(t, a, n);
                            if (i && i.length > 0 && (e = !0),
                            !e) {
                                const e = doodadManager.create(r, t, a, n);
                                e && (e.gfx = p.default.getGfx(o))
                            }
                        }
                        b(o, t, a, r)
                    }
                }
    }
    function C(e) {
        for (let t = 0; t < e.length; t++)
            null === e[t] && (e[t] = void 0)
    }
    function D() {
        let e, t;
        const a = d.default.generator.getSeed();
        for (game.slot !== o.SLOT_MULTIPLAYER && (C(game.corpses),
        C(game.creatures),
        C(game.doodads),
        C(game.npcs),
        C(game.tileEvents)),
        e = 0; e < game.doodads.length; e++) {
            const a = game.doodads[e];
            a && (void 0 === a.id && (a.id = e),
            (t = a.getTile()) && (t.doodad = a))
        }
        for (const e of game.tileEvents)
            e && (t = game.getTileFromPoint(e)) && (t.events || (t.events = []),
            t.events.push(e));
        for (e = 0; e < game.creatures.length; e++) {
            const a = game.creatures[e];
            a && (void 0 === a.id && (a.id = e),
            (t = a.getTile()) && (t.creature = a))
        }
        for (const e of game.corpses)
            e && (t = game.getTileFromPoint(e)) && (t.corpses || (t.corpses = []),
            t.corpses.push(e));
        for (e = 0; e < game.npcs.length; e++) {
            const a = game.npcs[e];
            a && (void 0 === a.id && (a.id = e),
            (t = a.getTile()) && (t.npc = a))
        }
        const r = game.previousSaveVersion
          , s = Object.keys(game.tileData);
        for (const a of s) {
            const o = parseInt(a, 10)
              , s = game.tileData[o];
            if (!s)
                continue;
            const l = Object.keys(s);
            for (const a of l) {
                const l = parseInt(a, 10)
                  , d = s[l];
                if (d)
                    for (const a of world.layers) {
                        const s = a.level
                          , c = d[s];
                        if (c && c.length > 0) {
                            let a = !1;
                            if (r && 2 === r.major && r.minor < 4)
                                for (e = 0; e < c.length; e++) {
                                    const r = c[e]
                                      , d = r.type
                                      , m = n.Pre240TerrainType[d]
                                      , h = i.TerrainType[m];
                                    if (void 0 === h)
                                        if (0 !== e || a)
                                            u.default.warn(u.LogSource.MapGen)(`Cannot upgrade tile data for tile at ${o}, ${l}, ${s}. #${e} [${m}].. upgrading to dirt`),
                                            r.type = i.TerrainType.Dirt;
                                        else {
                                            let e;
                                            switch (a = !0,
                                            t = game.getTile(o, l, s),
                                            d) {
                                            case n.Pre240TerrainType.Tree:
                                                (e = doodadManager.create(i.DoodadType.MapleTree, o, l, s)) && e.setGrowingStage(i.GrowingStage.Budding);
                                                break;
                                            case n.Pre240TerrainType.PalmTree:
                                                (e = doodadManager.create(i.DoodadType.CoconutTree, o, l, s)) && e.setGrowingStage(i.GrowingStage.Budding);
                                                break;
                                            case n.Pre240TerrainType.BareTree:
                                                (e = doodadManager.create(i.DoodadType.MapleTree, o, l, s)) && e.setGrowingStage(i.GrowingStage.Dead);
                                                break;
                                            case n.Pre240TerrainType.BarePalmTree:
                                                (e = doodadManager.create(i.DoodadType.CoconutTree, o, l, s)) && e.setGrowingStage(i.GrowingStage.Dead);
                                                break;
                                            case n.Pre240TerrainType.TreeWithVines:
                                                (e = doodadManager.create(i.DoodadType.CypressTree, o, l, s)) && e.setGrowingStage(i.GrowingStage.Budding);
                                                break;
                                            case n.Pre240TerrainType.TreeWithBerries:
                                                (e = doodadManager.create(i.DoodadType.AppleTree, o, l, s)) && e.setGrowingStage(i.GrowingStage.Ripening);
                                                break;
                                            case n.Pre240TerrainType.TreeWithFungus:
                                                (e = doodadManager.create(i.DoodadType.SpruceTree, o, l, s)) && e.setGrowingStage(i.GrowingStage.Budding);
                                                break;
                                            case n.Pre240TerrainType.PalmTreeWithCoconuts:
                                                (e = doodadManager.create(i.DoodadType.CoconutTree, o, l, s)) && e.setGrowingStage(i.GrowingStage.Ripening);
                                                break;
                                            default:
                                                u.default.warn(u.LogSource.MapGen)(`Unable to convert terrain type ${m}`)
                                            }
                                            if (e) {
                                                b(t, o, l, e.type),
                                                r.type = p.default.getType(t),
                                                r.gfx = p.default.getGfx(t);
                                                const a = r;
                                                delete a.strength,
                                                delete r.minDur,
                                                delete r.maxDur,
                                                delete r.quality,
                                                delete r.tilled
                                            }
                                        }
                                    else
                                        d !== h && (r.type = h)
                                }
                            if (0 === c.length)
                                delete d[s];
                            else if (!a) {
                                const e = c[0];
                                void 0 !== e.type && (t = game.getTile(o, l, s),
                                p.default.setType(t, e.type),
                                void 0 !== e.gfx && p.default.setGfx(t, e.gfx),
                                void 0 !== e.tilled && p.default.setTilled(t, e.tilled))
                            }
                        }
                    }
            }
        }
        if (r && 2 === r.major && (r.minor < 6 || 6 === r.minor && r.patch < 3)) {
            const e = npcManager.getEntities().some(e=>!!e && e.getRegistrarId() === i.NPCType.Merchant);
            if (!e) {
                u.default.info(u.LogSource.MapGen)("Spawning a merchant");
                const e = p.default.getSuitableSpawnPoint();
                npcManager.spawn(i.NPCType.Merchant, e.x, e.y, e.z)
            }
        }
        d.default.generator.setSeed(a)
    }
    t.hasFinishedLoading = m,
    t.setFinishedLoading = h,
    t.clearFinishedLoading = y,
    t.spawnHouseItem = g,
    t.spawnShoreItem = f,
    t.spawnDoodad = T,
    t.spawnTileEvent = S,
    t.manipulateTemplates = w,
    t.spawnTemplate = M,
    t.setTileUnderDoodad = b,
    t.setupTiles = k,
    t.loadDifferences = D
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/WebWorkerHelpers", ["require", "exports", "Enums", "tile/ITerrain", "utilities/Log", "utilities/Random", "utilities/TileHelpers"], function(e, t, a, i, n, o, r) {
    var s;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        class t {
            constructor(e) {
                const t = e.toString().replace(/TileHelpers_\d+/g, "TileHelpers").replace(/Random_\d+/g, "Random");
                this.blobUrl = URL.createObjectURL(new Blob([u("Source", n.LogSource, !0), u("TerrainType", a.TerrainType), u("GrowingStage", a.GrowingStage), u("DoodadType", a.DoodadType), u("TileTemplateType", i.TileTemplateType), d("Random", "default", o.default), d("TileHelpers", "default", r.default), "Random.default.generator.setDebug(false);\n", `var workerFunction2 = ${t};\n`, "var workerFunction = function(evt) { workerFunction2(evt.data); };\n", '(function () { this.addEventListener("message", workerFunction, false); })()\n'],{
                    type: "application/javascript"
                })),
                this.worker = new Worker(this.blobUrl),
                this.worker.addEventListener("message", e=>{
                    this.callback && this.callback(e)
                }
                , !1)
            }
            getWorker() {
                return this.worker
            }
            setCallback(e) {
                this.callback = e
            }
            free() {
                this.worker && (this.worker.terminate(),
                delete this.worker),
                this.blobUrl && (URL.revokeObjectURL(this.blobUrl),
                delete this.blobUrl)
            }
        }
        function s(e, a) {
            const i = new t(e);
            return i.setCallback(e=>{
                i.free(),
                a(e)
            }
            ),
            i.getWorker()
        }
        function l(e) {
            return new t(e)
        }
        function u(e, t, a=!1) {
            let i = "";
            const n = e.split(".");
            if (n.length > 0) {
                let e = "";
                for (const t of n)
                    0 === e.length ? (e = t,
                    i += `var ${t} = {}\n`) : (i += `${e}.${t} = {}\n`,
                    e += `.${t}`)
            } else
                i += `var ${e} = {}\n`;
            const o = Object.keys(t);
            for (let n = 0; n < o.length; n++) {
                const r = o[n]
                  , s = t[r];
                "number" == typeof s ? i += `${e}.${r} = ${s};\n` : a && (i += `${e}[${r}] = "${s}";\n`)
            }
            return i
        }
        function d(e, t, a, i) {
            let n = !1, o;
            "default" === t && (n = !0,
            t = e);
            let r = `var ${e} = ${e} || {};\n`;
            if (r += `(function (${t}) {\n`,
            i) {
                for (r += "/* Global variables */\n",
                o = 0; o < i.length; o++)
                    r += `var ${i[o]};\n`;
                r += "\n"
            }
            const s = -1 === a.constructor.toString().indexOf("[native code]")
              , l = Object.keys(a);
            for (o = 0; o < l.length; o++) {
                const e = l[o]
                  , i = a[e];
                if ("function" == typeof i)
                    r += `${i} ${t}.${e} = ${i.name}`;
                else if (Array.isArray(i))
                    r += `${t}.${e} = []`;
                else if ("object" == typeof i) {
                    const a = -1 === i.constructor.toString().indexOf("[native code]")
                      , n = a ? `new (${i.constructor})()` : JSON.stringify(i);
                    r += `${t}.${e} = ${n}`
                } else
                    r += `${t}.${e} = ${i}`;
                r += ";\n\n"
            }
            const u = `${e}.${n ? "default" : t}`
              , d = s ? `new (${a.constructor})()` : "{}";
            return r += `})(${u} = ${d});\n\n`
        }
        e.WebWorker = t,
        e.create = s,
        e.createReusable = l,
        e.enumToString = u,
        e.moduleToString = d
    }(s = t.WebWorkerHelpers || (t.WebWorkerHelpers = {}))
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("mapgen/version/2.0.0", ["require", "exports", "Enums", "language/dictionary/UiTranslation", "mapgen/MapGenHelpers", "mod/IHookManager", "tile/ITerrain", "utilities/Log", "utilities/Random", "utilities/TileHelpers", "utilities/WebWorkerHelpers"], function(require, exports, Enums, UiTranslation_83, MapGenHelpers, IHookManager_50, Terrain, Log_53, Random_64, TileHelpers_48, WebWorkerHelpers_1) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    const DoodadType = Enums.DoodadType
      , GrowingStage = Enums.GrowingStage
      , TerrainType = Enums.TerrainType
      , WorldZ = Enums.WorldZ
      , TileTemplateType = Terrain.TileTemplateType;
    class MapGen200 {
        generateWorld(generateNewWorld) {
            if (eval("let mangle_fix = 0;"),
            Log_53.default.info(Log_53.LogSource.MapGen)("generateTileTypes", generateNewWorld),
            generateNewWorld)
                throw Error("You cannot generate a new world for this version");
            const loadingTitle = generateNewWorld ? UiTranslation_83.default.GameInterruptLoadingGeneratingWorld : UiTranslation_83.default.GameInterruptLoadingWorld
              , loadingDescription = generateNewWorld ? UiTranslation_83.default.GameInterruptLoadingGeneratingWorldDescription : UiTranslation_83.default.GameInterruptLoadingWorldDescription;
            newui.showLoadingInterrupt(loadingTitle, loadingDescription);
            const worker = WebWorkerHelpers_1.WebWorkerHelpers.create(e=>{
                const t = e.mapSize
                  , a = e.seed
                  , i = e.zMin
                  , n = e.zMax
                  , o = e.zNormal
                  , r = e.generateNewWorld
                  , s = new Uint16Array(t * t * (n + 1))
                  , l = new Float64Array((t + 1) * (t + 1))
                  , u = new Float64Array((t + 1) * (t + 1));
                Random_64.default.generator.setSeed(a);
                const d = (e,a)=>l[e * (t + 1) + a]
                  , p = (e,a)=>u[e * (t + 1) + a]
                  , c = (e,a,i)=>{
                    l[e * (t + 1) + a] = i
                }
                  , m = (e,a,i)=>{
                    u[e * (t + 1) + a] = i
                }
                  , h = (e,t,a)=>{
                    const i = a * Random_64.default.float() - .5 * a;
                    return .5 * (e + t) + i
                }
                ;
                for (let e = 0; e <= t; e++)
                    for (let a = 0; a <= t; a++)
                        c(e, a, e < 19 || a < 19 || e > t - 19 || a > t - 19 ? -1 : 256 === e && 256 === a || 128 === e && 128 === a || 384 === e && 384 === a || 128 === e && 384 === a || 384 === e && 128 === a ? 50 : 0),
                        m(e, a, a >= 300 ? 100 : -1);
                let y = t, g, f, T, S;
                for (; y > 1; ) {
                    for (let e = 0; e < t; e += y)
                        for (let a = 0; a < t; a += y)
                            g = e + y,
                            f = a + y,
                            T = Math.round(.5 * (e + g)),
                            S = Math.round(.5 * (a + f)),
                            -1 !== d(e, a) && -1 !== d(g, a) && (c(T, a, h(d(e, a), d(g, a), g - e)),
                            m(T, a, h(p(e, a), p(g, a), g - e))),
                            -1 !== d(e, a) && -1 !== d(e, f) && (c(e, S, h(d(e, a), d(e, f), f - a)),
                            m(e, S, h(p(e, a), p(e, f), f - a))),
                            -1 !== d(g, a) && -1 !== d(g, f) && (c(g, S, h(d(g, a), d(g, f), f - a)),
                            m(g, S, h(p(g, a), p(g, f), f - a))),
                            -1 !== d(e, f) && -1 !== d(g, f) && (c(T, f, h(d(e, f), d(g, f), g - e)),
                            m(T, f, h(p(e, f), p(g, f), g - e))),
                            -1 !== d(e, S) && -1 !== d(g, S) && (c(T, S, h(d(e, S), d(g, S), g - e)),
                            m(T, S, h(p(e, S), p(g, S), g - e)));
                    y = Math.round(.5 * y)
                }
                const I = {
                    x: 0,
                    y: 0
                }
                  , v = []
                  , w = []
                  , M = 250
                  , b = 25
                  , k = 25
                  , C = t / 225 + 1;
                let D = t / 2 + 50, A, P, G, R, x;
                const B = (e,a,i,n)=>{
                    s[i * t * t + a * t + e] = n
                }
                  , E = (e,a,i,n)=>{
                    0 === Random_64.default.int(4) && (s[i * t * t + a * t + (e - 1)] = n),
                    0 === Random_64.default.int(4) && (s[i * t * t + a * t + (e + 1)] = n),
                    0 === Random_64.default.int(4) && (s[i * t * t + (a * t - 1) + e] = n),
                    0 === Random_64.default.int(4) && (s[i * t * t + (a * t + 1) + e] = n),
                    0 === Random_64.default.int(6) && (s[i * t * t + (a * t + 1) + (e + 1)] = n),
                    0 === Random_64.default.int(6) && (s[i * t * t + (a * t - 1) + (e - 1)] = n),
                    0 === Random_64.default.int(6) && (s[i * t * t + (a * t - 1) + (e + 1)] = n),
                    0 === Random_64.default.int(6) && (s[i * t * t + (a * t + 1) + (e - 1)] = n)
                }
                  , L = (e,t)=>TileHelpers_48.default.setGfxRaw(TileHelpers_48.default.setTypeRaw(0, e), 3 * t + Random_64.default.int(3));
                for (let e = i; e <= n; e++)
                    for (let a = 0; a < t; a++)
                        for (let i = 0; i < t; i++) {
                            A = l[a * (t + 1) + i],
                            x = u[a * (t + 1) + i],
                            D = Math.round(x * C) + 25,
                            P = Math.round(A * C) + 25,
                            G = Math.round(1e3 * A) + 25,
                            R = P + 50;
                            let n = 0;
                            if (e === o) {
                                if (P < 40 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.DeepSeawater) : P < 65 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Seawater) : P < 80 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.ShallowSeawater) : P < 100 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.BeachSand) : P < 110 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel),
                                D > 250 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.BeachSand))) : P < 130 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Grass),
                                G % 50 == 0 && (n = L(DoodadType.MapleTree, GrowingStage.Budding)),
                                D > 250 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.BeachSand),
                                G >= 3e4 && G <= 30060 ? (n = L(DoodadType.CoconutTree, GrowingStage.Budding),
                                G % 8 != 0 && G % 9 != 0 || (n = L(DoodadType.CoconutTree, GrowingStage.Ripening))) : G % 64 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Grass))),
                                D > 240 && D < 250 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel))) : P < 160 ? (n = L(DoodadType.MapleTree, GrowingStage.Budding),
                                G % 5 == 0 || G % 6 == 0 || G % 7 == 0 || G % 8 == 0 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Grass) : G % 19 != 0 && G % 20 != 0 && G % 21 != 0 || (n = L(DoodadType.MapleTree, GrowingStage.Dead)),
                                G % 256 == 0 && (n = L(DoodadType.AppleTree, GrowingStage.Ripening)),
                                G % 257 == 0 && (n = L(DoodadType.SpruceTree, GrowingStage.Budding)),
                                D > 250 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.BeachSand),
                                G % 4 == 0 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel) : G % 16 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Grass))),
                                D > 240 && D < 250 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel))) : P < 165 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Grass),
                                D > 250 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.BeachSand),
                                G % 2 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel))),
                                D > 240 && D < 250 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel))) : P < 185 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt),
                                G % 50 == 0 ? n = L(DoodadType.MapleTree, GrowingStage.Budding) : G % 449 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.ShallowFreshWater)),
                                D < 150 && D > 120 && (G % 2 == 0 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Swamp) : G % 3 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Grass)),
                                G % 5 == 0 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : G % 6 == 0 && (n = L(DoodadType.CypressTree, GrowingStage.Budding))),
                                D > 250 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel),
                                G % 449 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.ShallowFreshWater))) : D > 210 && D <= 250 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt))) : P < 186 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Rocks),
                                D > 250 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Sandstone),
                                G % 257 != 0 && G % 259 != 0 || E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.SandstoneWithIron))) : D > 220 && D <= 250 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel) : D > 190 && D <= 220 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt)),
                                G % 30 == 0 && w.push([a, i])) : P < 230 ? D > 250 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Sandstone),
                                G % 357 != 0 && G % 359 != 0 || E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.SandstoneWithIron)),
                                G % 361 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.SandstoneWithNiter))) : D > 240 && D < 260 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel),
                                G % 3 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt))) : D >= 260 && D < 300 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel) : D > 190 && D <= 240 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Rocks),
                                G % 264 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithIron)),
                                G % 265 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                G % 266 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                G % 267 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : P < 250 ? D > 250 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel) : D > 240 && D < 260 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel),
                                G % 3 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt))) : D >= 260 && D < 300 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel) : D > 190 && D <= 240 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Rocks),
                                G % 164 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithIron)),
                                G % 165 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                G % 166 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                G % 167 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : P < 290 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Rocks),
                                D > 250 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel) : D > 210 && D <= 250 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt) : D > 160 && D <= 210 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Rocks))) : (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Snow),
                                G % 8 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Rocks)),
                                D > 250 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Sandstone),
                                G % 257 != 0 && G % 259 != 0 || E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.SandstoneWithIron))) : D > 230 && D <= 250 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel) : D > 220 && D <= 230 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt) : D > 160 && D <= 220 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Rocks))),
                                P > 140 && P < 160 && D > 75 && D < 150 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Grass),
                                G % 16 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt))),
                                P > 185 && (D > 0 && D < 25 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt) : D > 150 && D < 175 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt))),
                                0 === I.x && 0 === I.y && P > 186)
                                    for (let e = a; e > 1; e--)
                                        if (Math.round(l[e * (t + 1) + i] * C) + 25 < 80) {
                                            I.x = e,
                                            I.y = i;
                                            break
                                        }
                            } else
                                R < 180 ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Rocks),
                                D > 100 && D < 130 ? n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt) : D > 200 && D < 250 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.ShallowFreshWater),
                                D > 220 && D < 230 && G % 2 == 0 && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.FreshWater))),
                                G % 328 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithIron)),
                                G % 329 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                G % 330 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                G % 331 == 0 && E(a, i, e, n = TileHelpers_48.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : n = R > 260 ? R < 270 ? TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel) : R < 285 ? TileHelpers_48.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : R < 330 ? G % 10 == 0 ? TileHelpers_48.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_48.default.setTypeRaw(n, TerrainType.FreshWater) : G % 20 == 0 ? TileHelpers_48.default.setTypeRaw(n, TerrainType.FreshWater) : TileHelpers_48.default.setTypeRaw(n, TerrainType.DeepFreshWater) : G % 15 == 0 ? TileHelpers_48.default.setTypeRaw(n, TerrainType.Rocks) : G % 25 == 0 ? TileHelpers_48.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt);
                            r && (e === o ? (D < 250 ? (32850 === G && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt),
                            v.push([TileTemplateType.House, a, i, e])),
                            37250 !== G && 37500 !== G && 37750 !== G || (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt),
                            v.push([TileTemplateType.Pond, a, i, e]))) : 31250 !== G && 33250 !== G && 34250 !== G && 35250 !== G || (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.BeachSand),
                            v.push([TileTemplateType.Desert, a, i, e])),
                            21500 === G && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.BeachSand),
                            v.push([TileTemplateType.Beach, a, i, e])),
                            P < 10 && -9e3 === G && (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.DeepSeawater),
                            v.push([TileTemplateType.Boat, a, i, e]))) : 43850 === G || 43851 === G ? (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt),
                            v.push([TileTemplateType.House, a, i, e])) : 45850 !== G && 45851 !== G || (n = TileHelpers_48.default.setTypeRaw(n, TerrainType.Dirt),
                            v.push([TileTemplateType.CavePond, a, i, e])));
                            const s = TileHelpers_48.default.getTypeRaw(n);
                            s !== DoodadType.MapleTree && s !== DoodadType.AppleTree && s !== DoodadType.SpruceTree && s !== DoodadType.CypressTree && s !== DoodadType.CoconutTree && (n = G % 4 == 0 ? TileHelpers_48.default.setGfxRaw(n, 2) : G % 2 == 0 ? TileHelpers_48.default.setGfxRaw(n, 1) : TileHelpers_48.default.setGfxRaw(n, 0)),
                            B(a, i, e, n)
                        }
                postMessage({
                    tileGenArray: s.buffer,
                    templateSpawns: v,
                    caveSpawns: w,
                    spawnCoords: I
                }, [s.buffer])
            }
            , e=>{
                const t = e.data;
                Log_53.default.info(Log_53.LogSource.MapGen)("msg posted");
                const a = new Uint16Array(t.tileGenArray)
                  , i = t.templateSpawns
                  , n = t.caveSpawns
                  , o = t.spawnCoords;
                game.spawnCoords = o,
                this.setupTiles(a, i, n, generateNewWorld)
            }
            );
            worker.postMessage({
                mapSize: game.mapSize,
                seed: Random_64.default.generator.getSeed(),
                zMin: WorldZ.Min,
                zMax: WorldZ.Max,
                zNormal: WorldZ.Overworld,
                generateNewWorld: generateNewWorld
            })
        }
        setupTiles(e, t, a, i) {
            Log_53.default.info(Log_53.LogSource.MapGen)("setupTiles", Random_64.default.generator.getSeed()),
            game.tile = new Array(game.mapSizeSq * (WorldZ.Max + 1)),
            MapGenHelpers.setupTiles(e),
            modManager.getHook(IHookManager_50.Hook.PreLoadWorldDifferences).call(i),
            MapGenHelpers.loadDifferences(),
            Log_53.default.info(Log_53.LogSource.MapGen)("PostGenerateWorld", Random_64.default.generator.getSeed()),
            modManager.getHook(IHookManager_50.Hook.PostGenerateWorld).call(i),
            Log_53.default.info(Log_53.LogSource.MapGen)("finishedLoading", Random_64.default.generator.getSeed()),
            MapGenHelpers.setFinishedLoading()
        }
    }
    exports.default = MapGen200
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("mapgen/version/2.1.0", ["require", "exports", "Enums", "language/dictionary/UiTranslation", "mapgen/MapGenHelpers", "mod/IHookManager", "tile/ITerrain", "utilities/Log", "utilities/Random", "utilities/TileHelpers", "utilities/WebWorkerHelpers"], function(require, exports, Enums, UiTranslation_84, MapGenHelpers, IHookManager_51, Terrain, Log_54, Random_65, TileHelpers_49, WebWorkerHelpers_2) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    const DoodadType = Enums.DoodadType
      , GrowingStage = Enums.GrowingStage
      , TerrainType = Enums.TerrainType
      , WorldZ = Enums.WorldZ
      , TileTemplateType = Terrain.TileTemplateType;
    class MapGen210 {
        generateWorld(generateNewWorld) {
            if (eval("let mangle_fix = 0;"),
            Log_54.default.info(Log_54.LogSource.MapGen)("generateTileTypes", generateNewWorld),
            generateNewWorld)
                throw Error("You cannot generate a new world for this version");
            const loadingTitle = generateNewWorld ? UiTranslation_84.default.GameInterruptLoadingGeneratingWorld : UiTranslation_84.default.GameInterruptLoadingWorld
              , loadingDescription = generateNewWorld ? UiTranslation_84.default.GameInterruptLoadingGeneratingWorldDescription : UiTranslation_84.default.GameInterruptLoadingWorldDescription;
            newui.showLoadingInterrupt(loadingTitle, loadingDescription);
            const worker = WebWorkerHelpers_2.WebWorkerHelpers.create(e=>{
                const t = e.mapSize
                  , a = e.seed
                  , i = e.zMin
                  , n = e.zMax
                  , o = e.zNormal
                  , r = e.generateNewWorld
                  , s = new Uint16Array(t * t * (n + 1))
                  , l = new Float64Array((t + 1) * (t + 1))
                  , u = new Float64Array((t + 1) * (t + 1));
                Random_65.default.generator.setSeed(a);
                const d = (e,a)=>l[e * (t + 1) + a]
                  , p = (e,a)=>u[e * (t + 1) + a]
                  , c = (e,a,i)=>{
                    l[e * (t + 1) + a] = i
                }
                  , m = (e,a,i)=>{
                    u[e * (t + 1) + a] = i
                }
                  , h = (e,t,a)=>{
                    const i = a * Random_65.default.float() - .5 * a;
                    return .5 * (e + t) + i
                }
                ;
                for (let e = 0; e <= t; e++)
                    for (let a = 0; a <= t; a++)
                        c(e, a, e < 19 || a < 19 || e > t - 19 || a > t - 19 ? -1 : 256 === e && 256 === a || 128 === e && 128 === a || 384 === e && 384 === a || 128 === e && 384 === a || 384 === e && 128 === a ? 50 : 0),
                        m(e, a, a >= 300 ? 100 : -1);
                let y = t, g, f, T, S;
                for (; y > 1; ) {
                    for (let e = 0; e < t; e += y)
                        for (let a = 0; a < t; a += y)
                            g = e + y,
                            f = a + y,
                            T = Math.round(.5 * (e + g)),
                            S = Math.round(.5 * (a + f)),
                            -1 !== d(e, a) && -1 !== d(g, a) && (c(T, a, h(d(e, a), d(g, a), g - e)),
                            m(T, a, h(p(e, a), p(g, a), g - e))),
                            -1 !== d(e, a) && -1 !== d(e, f) && (c(e, S, h(d(e, a), d(e, f), f - a)),
                            m(e, S, h(p(e, a), p(e, f), f - a))),
                            -1 !== d(g, a) && -1 !== d(g, f) && (c(g, S, h(d(g, a), d(g, f), f - a)),
                            m(g, S, h(p(g, a), p(g, f), f - a))),
                            -1 !== d(e, f) && -1 !== d(g, f) && (c(T, f, h(d(e, f), d(g, f), g - e)),
                            m(T, f, h(p(e, f), p(g, f), g - e))),
                            -1 !== d(e, S) && -1 !== d(g, S) && (c(T, S, h(d(e, S), d(g, S), g - e)),
                            m(T, S, h(p(e, S), p(g, S), g - e)));
                    y = Math.round(.5 * y)
                }
                const I = {
                    x: 0,
                    y: 0
                }
                  , v = []
                  , w = []
                  , M = 250
                  , b = 25
                  , k = 25
                  , C = t / 225 + 1;
                let D = t / 2 + 50, A, P, G, R, x;
                const B = (e,a,i,n)=>{
                    s[i * t * t + a * t + e] = n
                }
                  , E = (e,a,i,n)=>{
                    0 === Random_65.default.int(4) && (s[i * t * t + a * t + (e - 1)] = n),
                    0 === Random_65.default.int(4) && (s[i * t * t + a * t + (e + 1)] = n),
                    0 === Random_65.default.int(4) && (s[i * t * t + (a * t - 1) + e] = n),
                    0 === Random_65.default.int(4) && (s[i * t * t + (a * t + 1) + e] = n),
                    0 === Random_65.default.int(6) && (s[i * t * t + (a * t + 1) + (e + 1)] = n),
                    0 === Random_65.default.int(6) && (s[i * t * t + (a * t - 1) + (e - 1)] = n),
                    0 === Random_65.default.int(6) && (s[i * t * t + (a * t - 1) + (e + 1)] = n),
                    0 === Random_65.default.int(6) && (s[i * t * t + (a * t + 1) + (e - 1)] = n)
                }
                  , L = (e,t)=>TileHelpers_49.default.setGfxRaw(TileHelpers_49.default.setTypeRaw(0, e), 3 * t + Random_65.default.int(3));
                for (let e = i; e <= n; e++)
                    for (let a = 0; a < t; a++)
                        for (let i = 0; i < t; i++) {
                            A = l[a * (t + 1) + i],
                            x = u[a * (t + 1) + i],
                            D = Math.round(x * C) + 25,
                            P = Math.round(A * C) + 25,
                            G = Math.round(1e3 * A) + 25,
                            R = P + 50;
                            let n = 0;
                            if (e === o) {
                                if (P < 40 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.DeepSeawater) : P < 65 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Seawater) : P < 80 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.ShallowSeawater) : P < 100 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.BeachSand) : P < 110 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel),
                                D > 250 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.BeachSand))) : P < 130 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Grass),
                                G % 50 == 0 && (n = L(DoodadType.MapleTree, GrowingStage.Budding)),
                                D > 250 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.BeachSand),
                                G >= 3e4 && G <= 30060 ? (n = L(DoodadType.CoconutTree, GrowingStage.Budding),
                                G % 8 != 0 && G % 9 != 0 || (n = L(DoodadType.CoconutTree, GrowingStage.Ripening))) : G % 64 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Grass))),
                                D > 240 && D < 250 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel))) : P < 160 ? (n = L(DoodadType.MapleTree, GrowingStage.Budding),
                                G % 5 == 0 || G % 6 == 0 || G % 7 == 0 || G % 8 == 0 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Grass) : G % 19 != 0 && G % 20 != 0 && G % 21 != 0 || (n = L(DoodadType.MapleTree, GrowingStage.Dead)),
                                G % 256 == 0 && (n = L(DoodadType.AppleTree, GrowingStage.Ripening)),
                                G % 257 == 0 && (n = L(DoodadType.SpruceTree, GrowingStage.Budding)),
                                D > 250 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.BeachSand),
                                G % 4 == 0 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel) : G % 16 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Grass))),
                                D > 240 && D < 250 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel))) : P < 165 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Grass),
                                D > 250 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.BeachSand),
                                G % 2 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel))),
                                D > 240 && D < 250 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel))) : P < 185 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt),
                                G % 50 == 0 ? n = L(DoodadType.MapleTree, GrowingStage.Budding) : G % 449 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.ShallowFreshWater)),
                                D < 150 && D > 120 && (G % 2 == 0 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Swamp) : G % 3 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Grass)),
                                G % 5 == 0 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : G % 6 == 0 && (n = L(DoodadType.CypressTree, GrowingStage.Budding))),
                                D > 250 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel),
                                G % 449 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.ShallowFreshWater))) : D > 210 && D <= 250 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt))) : P < 186 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Rocks),
                                D > 250 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Sandstone),
                                G % 260 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.SandstoneWithIron))) : D > 220 && D <= 250 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel) : D > 190 && D <= 220 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt)),
                                G % 30 == 0 && w.push([a, i])) : P < 230 ? D > 250 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Sandstone),
                                G % 360 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.SandstoneWithIron)),
                                G % 361 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.SandstoneWithNiter))) : D > 240 && D < 260 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel),
                                G % 3 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt))) : D >= 260 && D < 300 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel) : D > 190 && D <= 240 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Rocks),
                                G % 264 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithIron)),
                                G % 265 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                G % 266 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                G % 267 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : P < 250 ? D > 250 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel) : D > 240 && D < 260 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel),
                                G % 3 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt))) : D >= 260 && D < 300 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel) : D > 190 && D <= 240 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Rocks),
                                G % 165 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                G % 166 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                G % 167 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : P < 290 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Rocks),
                                D > 250 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel) : D > 210 && D <= 250 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt) : D > 160 && D <= 210 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Rocks))) : (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Snow),
                                G % 8 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Rocks)),
                                D > 250 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Sandstone),
                                G % 260 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.SandstoneWithIron))) : D > 230 && D <= 250 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel) : D > 220 && D <= 230 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt) : D > 160 && D <= 220 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Rocks))),
                                P > 140 && P < 160 && D > 75 && D < 150 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Grass),
                                G % 16 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt))),
                                P > 185 && (D > 0 && D < 25 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt) : D > 150 && D < 175 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt))),
                                0 === I.x && 0 === I.y && P > 186)
                                    for (let e = a; e > 1; e--)
                                        if (Math.round(l[e * (t + 1) + i] * C) + 25 < 80) {
                                            I.x = e,
                                            I.y = i;
                                            break
                                        }
                            } else
                                R < 180 ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Rocks),
                                D > 100 && D < 130 ? n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt) : D > 200 && D < 250 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.ShallowFreshWater),
                                D > 220 && D < 230 && G % 2 == 0 && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.FreshWater))),
                                G % 328 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithIron)),
                                G % 329 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                G % 330 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                G % 331 == 0 && E(a, i, e, n = TileHelpers_49.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : n = R > 260 ? R < 270 ? TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel) : R < 285 ? TileHelpers_49.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : R < 330 ? G % 10 == 0 ? TileHelpers_49.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_49.default.setTypeRaw(n, TerrainType.FreshWater) : G % 20 == 0 ? TileHelpers_49.default.setTypeRaw(n, TerrainType.FreshWater) : TileHelpers_49.default.setTypeRaw(n, TerrainType.DeepFreshWater) : G % 15 == 0 ? TileHelpers_49.default.setTypeRaw(n, TerrainType.Rocks) : G % 25 == 0 ? TileHelpers_49.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt);
                            r && (e === o ? (D < 250 ? (32850 === G && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt),
                            v.push([TileTemplateType.House, a, i, e])),
                            37250 !== G && 37500 !== G && 37750 !== G || (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt),
                            v.push([TileTemplateType.Pond, a, i, e]))) : 32250 !== G && 33250 !== G && 34250 !== G && 35250 !== G || (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.BeachSand),
                            v.push([TileTemplateType.Desert, a, i, e])),
                            21500 === G && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.BeachSand),
                            v.push([TileTemplateType.Beach, a, i, e])),
                            P < 10 && -9e3 === G && (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.DeepSeawater),
                            v.push([TileTemplateType.Boat, a, i, e]))) : 43850 === G || 43851 === G ? (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt),
                            v.push([TileTemplateType.House, a, i, e])) : 45850 !== G && 45851 !== G || (n = TileHelpers_49.default.setTypeRaw(n, TerrainType.Dirt),
                            v.push([TileTemplateType.CavePond, a, i, e])));
                            const s = TileHelpers_49.default.getTypeRaw(n);
                            s !== DoodadType.MapleTree && s !== DoodadType.AppleTree && s !== DoodadType.SpruceTree && s !== DoodadType.CypressTree && s !== DoodadType.CoconutTree && (n = G % 4 == 0 ? TileHelpers_49.default.setGfxRaw(n, 2) : G % 2 == 0 ? TileHelpers_49.default.setGfxRaw(n, 1) : TileHelpers_49.default.setGfxRaw(n, 0)),
                            B(a, i, e, n)
                        }
                postMessage({
                    tileGenArray: s.buffer,
                    templateSpawns: v,
                    caveSpawns: w,
                    spawnCoords: I
                }, [s.buffer])
            }
            , e=>{
                const t = e.data;
                Log_54.default.info(Log_54.LogSource.MapGen)("msg posted");
                const a = new Uint16Array(t.tileGenArray)
                  , i = t.templateSpawns
                  , n = t.caveSpawns
                  , o = t.spawnCoords;
                game.spawnCoords = o,
                this.setupTiles(a, i, n, generateNewWorld)
            }
            );
            worker.postMessage({
                mapSize: game.mapSize,
                seed: Random_65.default.generator.getSeed(),
                zMin: WorldZ.Min,
                zMax: WorldZ.Max,
                zNormal: WorldZ.Overworld,
                generateNewWorld: generateNewWorld
            })
        }
        setupTiles(e, t, a, i) {
            Log_54.default.info(Log_54.LogSource.MapGen)("setupTiles", Random_65.default.generator.getSeed()),
            game.tile = new Array(game.mapSizeSq * (WorldZ.Max + 1)),
            MapGenHelpers.setupTiles(e),
            modManager.getHook(IHookManager_51.Hook.PreLoadWorldDifferences).call(i),
            MapGenHelpers.loadDifferences(),
            Log_54.default.info(Log_54.LogSource.MapGen)("PostGenerateWorld", Random_65.default.generator.getSeed()),
            modManager.getHook(IHookManager_51.Hook.PostGenerateWorld).call(i),
            Log_54.default.info(Log_54.LogSource.MapGen)("finishedLoading", Random_65.default.generator.getSeed()),
            MapGenHelpers.setFinishedLoading()
        }
    }
    exports.default = MapGen210
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("mapgen/version/2.2.0", ["require", "exports", "Enums", "language/dictionary/UiTranslation", "mapgen/MapGenHelpers", "mod/IHookManager", "tile/ITerrain", "utilities/Log", "utilities/Random", "utilities/TileHelpers", "utilities/WebWorkerHelpers"], function(require, exports, Enums, UiTranslation_85, MapGenHelpers, IHookManager_52, Terrain, Log_55, Random_66, TileHelpers_50, WebWorkerHelpers_3) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    const DoodadType = Enums.DoodadType
      , GrowingStage = Enums.GrowingStage
      , TerrainType = Enums.TerrainType
      , WorldZ = Enums.WorldZ
      , TileTemplateType = Terrain.TileTemplateType;
    class MapGen220 {
        generateWorld(generateNewWorld) {
            if (eval("let mangle_fix = 0;"),
            Log_55.default.info(Log_55.LogSource.MapGen)("generateTileTypes", generateNewWorld),
            generateNewWorld)
                throw Error("You cannot generate a new world for this version");
            const loadingTitle = generateNewWorld ? UiTranslation_85.default.GameInterruptLoadingGeneratingWorld : UiTranslation_85.default.GameInterruptLoadingWorld
              , loadingDescription = generateNewWorld ? UiTranslation_85.default.GameInterruptLoadingGeneratingWorldDescription : UiTranslation_85.default.GameInterruptLoadingWorldDescription;
            newui.showLoadingInterrupt(loadingTitle, loadingDescription);
            const worker = WebWorkerHelpers_3.WebWorkerHelpers.create(e=>{
                const t = e.mapSize
                  , a = e.seed
                  , i = e.zMin
                  , n = e.zMax
                  , o = e.zNormal
                  , r = e.zCave
                  , s = e.generateNewWorld
                  , l = new Uint16Array(t * t * (n + 1))
                  , u = new Float64Array((t + 1) * (t + 1))
                  , d = new Float64Array((t + 1) * (t + 1));
                Random_66.default.generator.setSeed(a);
                const p = (e,a)=>u[e * (t + 1) + a]
                  , c = (e,a)=>d[e * (t + 1) + a]
                  , m = (e,a,i)=>{
                    u[e * (t + 1) + a] = i
                }
                  , h = (e,a,i)=>{
                    d[e * (t + 1) + a] = i
                }
                  , y = (e,t,a)=>{
                    const i = a * Random_66.default.float() - .5 * a;
                    return .5 * (e + t) + i
                }
                ;
                for (let e = 0; e <= t; e++)
                    for (let a = 0; a <= t; a++)
                        m(e, a, e < 19 || a < 19 || e > t - 19 || a > t - 19 ? -1 : 256 === e && 256 === a || 128 === e && 128 === a || 384 === e && 384 === a || 128 === e && 384 === a || 384 === e && 128 === a ? 50 : 0),
                        h(e, a, a >= 300 ? 100 : -1);
                let g = t, f, T, S, I;
                for (; g > 1; ) {
                    for (let e = 0; e < t; e += g)
                        for (let a = 0; a < t; a += g)
                            f = e + g,
                            T = a + g,
                            S = Math.round(.5 * (e + f)),
                            I = Math.round(.5 * (a + T)),
                            -1 !== p(e, a) && -1 !== p(f, a) && (m(S, a, y(p(e, a), p(f, a), f - e)),
                            h(S, a, y(c(e, a), c(f, a), f - e))),
                            -1 !== p(e, a) && -1 !== p(e, T) && (m(e, I, y(p(e, a), p(e, T), T - a)),
                            h(e, I, y(c(e, a), c(e, T), T - a))),
                            -1 !== p(f, a) && -1 !== p(f, T) && (m(f, I, y(p(f, a), p(f, T), T - a)),
                            h(f, I, y(c(f, a), c(f, T), T - a))),
                            -1 !== p(e, T) && -1 !== p(f, T) && (m(S, T, y(p(e, T), p(f, T), f - e)),
                            h(S, T, y(c(e, T), c(f, T), f - e))),
                            -1 !== p(e, I) && -1 !== p(f, I) && (m(S, I, y(p(e, I), p(f, I), f - e)),
                            h(S, I, y(c(e, I), c(f, I), f - e)));
                    g = Math.round(.5 * g)
                }
                const v = {
                    x: 0,
                    y: 0
                }
                  , w = []
                  , M = []
                  , b = 250
                  , k = 25
                  , C = 25
                  , D = t / 225 + 1;
                let A = t / 2 + 50, P, G, R, x, B;
                const E = (e,a,i,n)=>{
                    l[i * t * t + a * t + e] = n
                }
                  , L = (e,a,i,n)=>{
                    0 === Random_66.default.int(4) && (l[i * t * t + a * t + (e - 1)] = n),
                    0 === Random_66.default.int(4) && (l[i * t * t + a * t + (e + 1)] = n),
                    0 === Random_66.default.int(4) && (l[i * t * t + (a * t - 1) + e] = n),
                    0 === Random_66.default.int(4) && (l[i * t * t + (a * t + 1) + e] = n),
                    0 === Random_66.default.int(6) && (l[i * t * t + (a * t + 1) + (e + 1)] = n),
                    0 === Random_66.default.int(6) && (l[i * t * t + (a * t - 1) + (e - 1)] = n),
                    0 === Random_66.default.int(6) && (l[i * t * t + (a * t - 1) + (e + 1)] = n),
                    0 === Random_66.default.int(6) && (l[i * t * t + (a * t + 1) + (e - 1)] = n)
                }
                  , O = (e,t)=>TileHelpers_50.default.setGfxRaw(TileHelpers_50.default.setTypeRaw(0, e), 3 * t + Random_66.default.int(3));
                for (let e = i; e <= n; e++)
                    for (let a = 0; a < t; a++)
                        for (let i = 0; i < t; i++) {
                            P = u[a * (t + 1) + i],
                            B = d[a * (t + 1) + i],
                            A = Math.round(B * D) + 25,
                            G = Math.round(P * D) + 25,
                            R = Math.round(1e3 * P) + 25,
                            x = G + 50;
                            let n = 0;
                            if (e === o) {
                                if (G < 40 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.DeepSeawater) : G < 65 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Seawater) : G < 80 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.ShallowSeawater) : G < 100 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.BeachSand) : G < 110 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel),
                                A > 250 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.BeachSand))) : G < 130 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Grass),
                                R % 50 == 0 && (n = O(DoodadType.MapleTree, GrowingStage.Budding)),
                                A > 250 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.BeachSand),
                                R >= 3e4 && R <= 30060 ? (n = O(DoodadType.CoconutTree, GrowingStage.Budding),
                                R % 8 != 0 && R % 9 != 0 || (n = O(DoodadType.CoconutTree, GrowingStage.Ripening))) : R % 64 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Grass))),
                                A > 240 && A < 250 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel))) : G < 160 ? (n = O(DoodadType.MapleTree, GrowingStage.Budding),
                                R % 5 == 0 || R % 6 == 0 || R % 7 == 0 || R % 8 == 0 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Grass) : R % 19 != 0 && R % 20 != 0 && R % 21 != 0 || (n = O(DoodadType.MapleTree, GrowingStage.Dead)),
                                R % 256 == 0 && (n = O(DoodadType.AppleTree, GrowingStage.Ripening)),
                                R % 257 == 0 && (n = O(DoodadType.SpruceTree, GrowingStage.Budding)),
                                A > 250 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.BeachSand),
                                R % 4 == 0 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel) : R % 16 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Grass))),
                                A > 240 && A < 250 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel))) : G < 165 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Grass),
                                A > 250 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.BeachSand),
                                R % 2 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel))),
                                A > 240 && A < 250 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel))) : G < 185 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt),
                                R % 50 == 0 ? n = O(DoodadType.MapleTree, GrowingStage.Budding) : R % 449 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.ShallowFreshWater)),
                                A < 150 && A > 120 && (R % 2 == 0 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Swamp) : R % 3 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Grass)),
                                R % 5 == 0 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : R % 6 == 0 && (n = O(DoodadType.CypressTree, GrowingStage.Budding))),
                                A > 250 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel),
                                R % 449 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.ShallowFreshWater))) : A > 210 && A <= 250 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt))) : G < 186 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Rocks),
                                A > 250 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Sandstone),
                                R % 260 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.SandstoneWithIron))) : A > 220 && A <= 250 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel) : A > 190 && A <= 220 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt)),
                                R % 30 == 0 && M.push([a, i])) : G < 230 ? A > 250 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Sandstone),
                                R % 360 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.SandstoneWithIron)),
                                R % 361 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.SandstoneWithNiter))) : A > 240 && A < 260 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel),
                                R % 3 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt))) : A >= 260 && A < 300 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel) : A > 190 && A <= 240 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Rocks),
                                R % 264 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithIron)),
                                R % 265 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                R % 266 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                R % 267 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : G < 250 ? A > 250 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel) : A > 240 && A < 260 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel),
                                R % 3 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt))) : A >= 260 && A < 300 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel) : A > 190 && A <= 240 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Rocks),
                                R % 165 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                R % 166 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                R % 167 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : G < 290 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Rocks),
                                A > 250 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel) : A > 210 && A <= 250 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt) : A > 160 && A <= 210 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Rocks))) : (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Snow),
                                R % 8 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Rocks)),
                                A > 250 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Sandstone),
                                R % 260 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.SandstoneWithIron))) : A > 230 && A <= 250 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel) : A > 220 && A <= 230 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt) : A > 160 && A <= 220 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Rocks))),
                                G > 140 && G < 160 && A > 75 && A < 150 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Grass),
                                R % 16 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt))),
                                G > 185 && (A > 0 && A < 25 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt) : A > 150 && A < 175 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt))),
                                0 === v.x && 0 === v.y && G > 186)
                                    for (let e = a; e > 1; e--)
                                        if (Math.round(u[e * (t + 1) + i] * D) + 25 < 80) {
                                            v.x = e,
                                            v.y = i;
                                            break
                                        }
                            } else
                                x < 180 ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Rocks),
                                A > 100 && A < 130 ? n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt) : A > 200 && A < 250 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.ShallowFreshWater),
                                A > 220 && A < 230 && R % 2 == 0 && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.FreshWater))),
                                R % 328 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithIron)),
                                R % 329 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                R % 330 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                R % 331 == 0 && L(a, i, e, n = TileHelpers_50.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : n = x > 280 ? x < 290 ? TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel) : x < 305 ? TileHelpers_50.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : x < 350 ? R % 10 == 0 ? TileHelpers_50.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_50.default.setTypeRaw(n, TerrainType.FreshWater) : R % 20 == 0 ? TileHelpers_50.default.setTypeRaw(n, TerrainType.FreshWater) : TileHelpers_50.default.setTypeRaw(n, TerrainType.DeepFreshWater) : R % 15 == 0 ? TileHelpers_50.default.setTypeRaw(n, TerrainType.Rocks) : R % 25 == 0 ? TileHelpers_50.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt);
                            s && (e === o ? (A < 250 ? 58850 === R || 58950 === R || 59050 === R ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.Lava, a, i, e]),
                            w.push([TileTemplateType.Lava, a, i, r])) : 32850 === R ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.House, a, i, e])) : 37250 !== R && 37500 !== R && 37750 !== R || (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.Pond, a, i, e])) : 32250 !== R && 33250 !== R && 34250 !== R && 35250 !== R || (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.BeachSand),
                            w.push([TileTemplateType.Desert, a, i, e])),
                            21500 === R && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.BeachSand),
                            w.push([TileTemplateType.Beach, a, i, e])),
                            G < 10 && -9e3 === R && (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.DeepSeawater),
                            w.push([TileTemplateType.Boat, a, i, e]))) : 22850 === R || 22950 === R || 23050 === R ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.Lava, a, i, e])) : 43850 === R || 43851 === R ? (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.House, a, i, e])) : 45850 !== R && 45851 !== R || (n = TileHelpers_50.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.CavePond, a, i, e])));
                            const l = TileHelpers_50.default.getTypeRaw(n);
                            l !== DoodadType.MapleTree && l !== DoodadType.AppleTree && l !== DoodadType.SpruceTree && l !== DoodadType.CypressTree && l !== DoodadType.CoconutTree && (n = R % 4 == 0 ? TileHelpers_50.default.setGfxRaw(n, 2) : R % 2 == 0 ? TileHelpers_50.default.setGfxRaw(n, 1) : TileHelpers_50.default.setGfxRaw(n, 0)),
                            E(a, i, e, n)
                        }
                postMessage({
                    tileGenArray: l.buffer,
                    templateSpawns: w,
                    caveSpawns: M,
                    spawnCoords: v
                }, [l.buffer])
            }
            , e=>{
                const t = e.data
                  , a = new Uint16Array(t.tileGenArray)
                  , i = t.templateSpawns
                  , n = t.caveSpawns
                  , o = t.spawnCoords;
                game.spawnCoords = o,
                this.setupTiles(a, i, n, generateNewWorld)
            }
            );
            worker.postMessage({
                mapSize: game.mapSize,
                seed: Random_66.default.generator.getSeed(),
                zMin: WorldZ.Min,
                zMax: WorldZ.Max,
                zNormal: WorldZ.Overworld,
                zCave: WorldZ.Cave,
                generateNewWorld: generateNewWorld
            })
        }
        setupTiles(e, t, a, i) {
            Log_55.default.info(Log_55.LogSource.MapGen)("setupTiles", Random_66.default.generator.getSeed()),
            game.tile = new Array(game.mapSizeSq * (WorldZ.Max + 1)),
            MapGenHelpers.setupTiles(e),
            modManager.getHook(IHookManager_52.Hook.PreLoadWorldDifferences).call(i),
            MapGenHelpers.loadDifferences(),
            Log_55.default.info(Log_55.LogSource.MapGen)("PostGenerateWorld", Random_66.default.generator.getSeed()),
            modManager.getHook(IHookManager_52.Hook.PostGenerateWorld).call(i),
            Log_55.default.info(Log_55.LogSource.MapGen)("finishedLoading", Random_66.default.generator.getSeed()),
            MapGenHelpers.setFinishedLoading()
        }
    }
    exports.default = MapGen220
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("mapgen/version/2.3.0", ["require", "exports", "Enums", "language/dictionary/UiTranslation", "mapgen/MapGenHelpers", "mod/IHookManager", "tile/ITerrain", "utilities/Log", "utilities/Random", "utilities/TileHelpers", "utilities/WebWorkerHelpers"], function(require, exports, Enums, UiTranslation_86, MapGenHelpers, IHookManager_53, Terrain, Log_56, Random_67, TileHelpers_51, WebWorkerHelpers_4) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    const DoodadType = Enums.DoodadType
      , GrowingStage = Enums.GrowingStage
      , TerrainType = Enums.TerrainType
      , WorldZ = Enums.WorldZ
      , TileTemplateType = Terrain.TileTemplateType;
    class MapGen230 {
        generateWorld(generateNewWorld) {
            if (eval("let mangle_fix = 0;"),
            Log_56.default.info(Log_56.LogSource.MapGen)("generateTileTypes", generateNewWorld),
            generateNewWorld)
                throw Error("You cannot generate a new world for this version");
            const loadingTitle = generateNewWorld ? UiTranslation_86.default.GameInterruptLoadingGeneratingWorld : UiTranslation_86.default.GameInterruptLoadingWorld
              , loadingDescription = generateNewWorld ? UiTranslation_86.default.GameInterruptLoadingGeneratingWorldDescription : UiTranslation_86.default.GameInterruptLoadingWorldDescription;
            newui.showLoadingInterrupt(loadingTitle, loadingDescription);
            const worker = WebWorkerHelpers_4.WebWorkerHelpers.create(e=>{
                const t = e.mapSize
                  , a = e.seed
                  , i = e.zMin
                  , n = e.zMax
                  , o = e.zNormal
                  , r = e.zCave
                  , s = e.generateNewWorld
                  , l = new Uint16Array(t * t * (n + 1))
                  , u = new Float64Array((t + 1) * (t + 1))
                  , d = new Float64Array((t + 1) * (t + 1));
                Random_67.default.generator.setSeed(a);
                const p = (e,a)=>u[e * (t + 1) + a]
                  , c = (e,a)=>d[e * (t + 1) + a]
                  , m = (e,a,i)=>{
                    u[e * (t + 1) + a] = i
                }
                  , h = (e,a,i)=>{
                    d[e * (t + 1) + a] = i
                }
                  , y = (e,t,a)=>{
                    const i = a * Random_67.default.float() - .5 * a;
                    return .5 * (e + t) + i
                }
                ;
                for (let e = 0; e <= t; e++)
                    for (let a = 0; a <= t; a++)
                        m(e, a, e < 19 || a < 19 || e > t - 19 || a > t - 19 ? -1 : 256 === e && 256 === a || 128 === e && 128 === a || 384 === e && 384 === a || 128 === e && 384 === a || 384 === e && 128 === a ? 50 : 0),
                        h(e, a, a >= 300 ? 100 : -1);
                let g = t, f, T, S, I;
                for (; g > 1; ) {
                    for (let e = 0; e < t; e += g)
                        for (let a = 0; a < t; a += g)
                            f = e + g,
                            T = a + g,
                            S = Math.round(.5 * (e + f)),
                            I = Math.round(.5 * (a + T)),
                            -1 !== p(e, a) && -1 !== p(f, a) && (m(S, a, y(p(e, a), p(f, a), f - e)),
                            h(S, a, y(c(e, a), c(f, a), f - e))),
                            -1 !== p(e, a) && -1 !== p(e, T) && (m(e, I, y(p(e, a), p(e, T), T - a)),
                            h(e, I, y(c(e, a), c(e, T), T - a))),
                            -1 !== p(f, a) && -1 !== p(f, T) && (m(f, I, y(p(f, a), p(f, T), T - a)),
                            h(f, I, y(c(f, a), c(f, T), T - a))),
                            -1 !== p(e, T) && -1 !== p(f, T) && (m(S, T, y(p(e, T), p(f, T), f - e)),
                            h(S, T, y(c(e, T), c(f, T), f - e))),
                            -1 !== p(e, I) && -1 !== p(f, I) && (m(S, I, y(p(e, I), p(f, I), f - e)),
                            h(S, I, y(c(e, I), c(f, I), f - e)));
                    g = Math.round(.5 * g)
                }
                const v = {
                    x: 0,
                    y: 0
                }
                  , w = []
                  , M = []
                  , b = 250
                  , k = 25
                  , C = 25
                  , D = t / 225 + 1;
                let A = t / 2 + 50, P, G, R, x, B;
                const E = (e,a,i,n)=>{
                    l[i * t * t + a * t + e] = n
                }
                  , L = (e,a,i,n)=>{
                    0 === Random_67.default.int(4) && (l[i * t * t + a * t + (e - 1)] = n),
                    0 === Random_67.default.int(4) && (l[i * t * t + a * t + (e + 1)] = n),
                    0 === Random_67.default.int(4) && (l[i * t * t + (a * t - 1) + e] = n),
                    0 === Random_67.default.int(4) && (l[i * t * t + (a * t + 1) + e] = n),
                    0 === Random_67.default.int(6) && (l[i * t * t + (a * t + 1) + (e + 1)] = n),
                    0 === Random_67.default.int(6) && (l[i * t * t + (a * t - 1) + (e - 1)] = n),
                    0 === Random_67.default.int(6) && (l[i * t * t + (a * t - 1) + (e + 1)] = n),
                    0 === Random_67.default.int(6) && (l[i * t * t + (a * t + 1) + (e - 1)] = n)
                }
                  , O = (e,t)=>TileHelpers_51.default.setGfxRaw(TileHelpers_51.default.setTypeRaw(0, e), 3 * t + Random_67.default.int(3));
                for (let e = i; e <= n; e++)
                    for (let a = 0; a < t; a++)
                        for (let i = 0; i < t; i++) {
                            P = u[a * (t + 1) + i],
                            B = d[a * (t + 1) + i],
                            A = Math.round(B * D) + 25,
                            G = Math.round(P * D) + 25,
                            R = Math.round(1e3 * P) + 25,
                            x = G + 50;
                            let n = 0;
                            if (e === o) {
                                if (G < 40 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.DeepSeawater) : G < 65 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Seawater) : G < 80 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.ShallowSeawater) : G < 100 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.BeachSand) : G < 110 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel),
                                A > 250 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.BeachSand))) : G < 130 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Grass),
                                R % 50 == 0 && (n = O(DoodadType.MapleTree, GrowingStage.Budding)),
                                A > 250 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.BeachSand),
                                R >= 3e4 && R <= 30060 ? (n = O(DoodadType.CoconutTree, GrowingStage.Budding),
                                R % 8 != 0 && R % 9 != 0 || (n = O(DoodadType.CoconutTree, GrowingStage.Ripening))) : R % 64 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Grass))),
                                A > 240 && A < 250 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel))) : G < 160 ? (n = O(DoodadType.MapleTree, GrowingStage.Budding),
                                R % 5 == 0 || R % 6 == 0 || R % 7 == 0 || R % 8 == 0 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Grass) : R % 19 != 0 && R % 20 != 0 && R % 21 != 0 || (n = O(DoodadType.MapleTree, GrowingStage.Dead)),
                                R % 256 == 0 && (n = O(DoodadType.AppleTree, GrowingStage.Ripening)),
                                R % 257 == 0 && (n = O(DoodadType.SpruceTree, GrowingStage.Budding)),
                                A > 250 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.BeachSand),
                                R % 4 == 0 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel) : R % 16 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Grass))),
                                A > 240 && A < 250 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel))) : G < 165 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Grass),
                                A > 250 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.BeachSand),
                                R % 2 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel))),
                                A > 240 && A < 250 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel))) : G < 185 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt),
                                R % 50 == 0 ? n = O(DoodadType.MapleTree, GrowingStage.Budding) : R % 449 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.ShallowFreshWater)),
                                A < 150 && A > 120 && (R % 2 == 0 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Swamp) : R % 3 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Grass)),
                                R % 5 == 0 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : R % 6 == 0 && (n = O(DoodadType.CypressTree, GrowingStage.Budding))),
                                A > 250 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel),
                                R % 449 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.ShallowFreshWater))) : A > 210 && A <= 250 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt))) : G < 186 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Rocks),
                                A > 250 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Sandstone),
                                R % 260 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.SandstoneWithIron))) : A > 220 && A <= 250 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel) : A > 190 && A <= 220 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt)),
                                R % 30 == 0 && M.push([a, i])) : G < 230 ? A > 250 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Sandstone),
                                R % 360 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.SandstoneWithIron)),
                                R % 361 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.SandstoneWithNiter))) : A > 240 && A < 260 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel),
                                R % 3 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt))) : A >= 260 && A < 300 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel) : A > 190 && A <= 240 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Rocks),
                                R % 264 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithIron)),
                                R % 265 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                R % 266 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                R % 267 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : G < 250 ? A > 250 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel) : A > 240 && A < 260 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel),
                                R % 3 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt))) : A >= 260 && A < 300 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel) : A > 190 && A <= 240 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Rocks),
                                R % 165 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                R % 166 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                R % 167 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : G < 290 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Rocks),
                                A > 250 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel) : A > 210 && A <= 250 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt) : A > 160 && A <= 210 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Rocks))) : (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Snow),
                                R % 8 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Rocks)),
                                A > 250 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Sandstone),
                                R % 260 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.SandstoneWithIron))) : A > 230 && A <= 250 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel) : A > 220 && A <= 230 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt) : A > 160 && A <= 220 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Rocks))),
                                G > 140 && G < 160 && A > 75 && A < 150 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Grass),
                                R % 16 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt))),
                                G > 185 && (A > 0 && A < 25 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt) : A > 150 && A < 175 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt))),
                                0 === v.x && 0 === v.y && G > 186)
                                    for (let e = a; e > 1; e--)
                                        if (Math.round(u[e * (t + 1) + i] * D) + 25 < 80) {
                                            v.x = e,
                                            v.y = i;
                                            break
                                        }
                            } else
                                x < 180 ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Rocks),
                                A > 100 && A < 130 ? n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt) : A > 200 && A < 250 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.ShallowFreshWater),
                                A > 220 && A < 230 && R % 2 == 0 && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.FreshWater))),
                                R % 328 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithIron)),
                                R % 329 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithTalc)),
                                R % 330 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithLimestone)),
                                R % 331 == 0 && L(a, i, e, n = TileHelpers_51.default.setTypeRaw(n, TerrainType.RocksWithCoal))) : n = x > 280 ? x < 290 ? TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel) : x < 305 ? TileHelpers_51.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : x < 350 ? R % 10 == 0 ? TileHelpers_51.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_51.default.setTypeRaw(n, TerrainType.FreshWater) : R % 20 == 0 ? TileHelpers_51.default.setTypeRaw(n, TerrainType.FreshWater) : TileHelpers_51.default.setTypeRaw(n, TerrainType.DeepFreshWater) : R % 15 == 0 ? TileHelpers_51.default.setTypeRaw(n, TerrainType.Rocks) : R % 25 == 0 ? TileHelpers_51.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt);
                            s && (e === o ? (A < 250 ? 58850 === R || 58950 === R || 59050 === R ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.Lava, a, i, e]),
                            w.push([TileTemplateType.Lava, a, i, r])) : 32850 === R ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.House, a, i, e])) : 37250 !== R && 37500 !== R && 37750 !== R || (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.Pond, a, i, e])) : 32250 !== R && 33250 !== R && 34250 !== R && 35250 !== R || (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.BeachSand),
                            w.push([TileTemplateType.Desert, a, i, e])),
                            21500 === R && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.BeachSand),
                            w.push([TileTemplateType.Beach, a, i, e])),
                            G < 10 && -9e3 === R && (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.DeepSeawater),
                            w.push([TileTemplateType.Boat, a, i, e]))) : 22850 === R || 22950 === R || 23050 === R ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.Lava, a, i, e])) : 43850 === R || 43851 === R ? (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.House, a, i, e])) : 45850 !== R && 45851 !== R || (n = TileHelpers_51.default.setTypeRaw(n, TerrainType.Dirt),
                            w.push([TileTemplateType.CavePond, a, i, e])));
                            const l = TileHelpers_51.default.getTypeRaw(n);
                            l !== DoodadType.MapleTree && l !== DoodadType.AppleTree && l !== DoodadType.SpruceTree && l !== DoodadType.CypressTree && l !== DoodadType.CoconutTree && (n = R % 4 == 0 ? TileHelpers_51.default.setGfxRaw(n, 2) : R % 2 == 0 ? TileHelpers_51.default.setGfxRaw(n, 1) : TileHelpers_51.default.setGfxRaw(n, 0)),
                            E(a, i, e, n)
                        }
                postMessage({
                    tileGenArray: l.buffer,
                    templateSpawns: w,
                    caveSpawns: M,
                    spawnCoords: v
                }, [l.buffer])
            }
            , e=>{
                const t = e.data
                  , a = new Uint16Array(t.tileGenArray)
                  , i = t.templateSpawns
                  , n = t.caveSpawns
                  , o = t.spawnCoords;
                game.spawnCoords = o,
                this.setupTiles(a, i, n, generateNewWorld)
            }
            );
            worker.postMessage({
                mapSize: game.mapSize,
                seed: Random_67.default.generator.getSeed(),
                zMin: WorldZ.Min,
                zMax: WorldZ.Max,
                zNormal: WorldZ.Overworld,
                zCave: WorldZ.Cave,
                generateNewWorld: generateNewWorld
            })
        }
        setupTiles(e, t, a, i) {
            Log_56.default.info(Log_56.LogSource.MapGen)("setupTiles", Random_67.default.generator.getSeed()),
            game.tile = new Array(game.mapSizeSq * (WorldZ.Max + 1)),
            MapGenHelpers.setupTiles(e),
            modManager.getHook(IHookManager_53.Hook.PreLoadWorldDifferences).call(i),
            MapGenHelpers.loadDifferences(),
            Log_56.default.info(Log_56.LogSource.MapGen)("PostGenerateWorld", Random_67.default.generator.getSeed()),
            modManager.getHook(IHookManager_53.Hook.PostGenerateWorld).call(i),
            Log_56.default.info(Log_56.LogSource.MapGen)("finishedLoading", Random_67.default.generator.getSeed()),
            MapGenHelpers.setFinishedLoading()
        }
    }
    exports.default = MapGen230
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("mapgen/version/2.4.0", ["require", "exports", "creature/ICreature", "Enums", "language/dictionary/UiTranslation", "mapgen/MapGenHelpers", "mod/IHookManager", "tile/ITerrain", "utilities/Log", "utilities/Random", "utilities/TileHelpers", "utilities/WebWorkerHelpers"], function(require, exports, Creature, Enums, UiTranslation_87, MapGenHelpers, IHookManager_54, Terrain, Log_57, Random_68, TileHelpers_52, WebWorkerHelpers_5) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    const DoodadType = Enums.DoodadType
      , GrowingStage = Enums.GrowingStage
      , SpawnGroup = Creature.SpawnGroup
      , TerrainType = Enums.TerrainType
      , WorldZ = Enums.WorldZ
      , TileTemplateType = Terrain.TileTemplateType;
    class MapGen240 {
        generateWorld(generateNewWorld) {
            eval("let mangle_fix = 0;"),
            Log_57.default.info(Log_57.LogSource.MapGen)("generateTileTypes", generateNewWorld);
            const loadingTitle = generateNewWorld ? UiTranslation_87.default.GameInterruptLoadingGeneratingWorld : UiTranslation_87.default.GameInterruptLoadingWorld
              , loadingDescription = generateNewWorld ? UiTranslation_87.default.GameInterruptLoadingGeneratingWorldDescription : UiTranslation_87.default.GameInterruptLoadingWorldDescription;
            newui.showLoadingInterrupt(loadingTitle, loadingDescription);
            const worker = WebWorkerHelpers_5.WebWorkerHelpers.create(e=>{
                const t = e.mapSize
                  , a = e.seed
                  , i = e.zMin
                  , n = e.zMax
                  , o = e.zNormal
                  , r = e.zCave
                  , s = e.generateNewWorld
                  , l = new Uint16Array(t * t * (n + 1))
                  , u = new Float64Array((t + 1) * (t + 1))
                  , d = new Float64Array((t + 1) * (t + 1))
                  , p = [GrowingStage.Vegetative, GrowingStage.Budding, GrowingStage.Flowering, GrowingStage.Ripening];
                Random_68.default.generator.setSeed(a);
                const c = (e,a)=>u[e * (t + 1) + a]
                  , m = (e,a)=>d[e * (t + 1) + a]
                  , h = (e,a,i)=>{
                    u[e * (t + 1) + a] = i
                }
                  , y = (e,a,i)=>{
                    d[e * (t + 1) + a] = i
                }
                  , g = (e,t,a)=>{
                    const i = a * Random_68.default.float() - .5 * a;
                    return .5 * (e + t) + i
                }
                ;
                for (let e = 0; e <= t; e++)
                    for (let a = 0; a <= t; a++)
                        h(e, a, 0 === e || 0 === a || e === t || a === t ? -1 : 256 === e && 256 === a || 128 === e && 128 === a || 384 === e && 384 === a || 128 === e && 384 === a || 384 === e && 128 === a ? 50 : 0),
                        y(e, a, a >= 300 ? 100 : -1);
                let f = t, T, S, I, v;
                for (; f > 1; ) {
                    for (let e = 0; e < t; e += f)
                        for (let a = 0; a < t; a += f)
                            T = e + f,
                            S = a + f,
                            I = Math.round(.5 * (e + T)),
                            v = Math.round(.5 * (a + S)),
                            -1 !== c(e, a) && -1 !== c(T, a) && (h(I, a, g(c(e, a), c(T, a), T - e)),
                            y(I, a, g(m(e, a), m(T, a), T - e))),
                            -1 !== c(e, a) && -1 !== c(e, S) && (h(e, v, g(c(e, a), c(e, S), S - a)),
                            y(e, v, g(m(e, a), m(e, S), S - a))),
                            -1 !== c(T, a) && -1 !== c(T, S) && (h(T, v, g(c(T, a), c(T, S), S - a)),
                            y(T, v, g(m(T, a), m(T, S), S - a))),
                            -1 !== c(e, S) && -1 !== c(T, S) && (h(I, S, g(c(e, S), c(T, S), T - e)),
                            y(I, S, g(m(e, S), m(T, S), T - e))),
                            -1 !== c(e, v) && -1 !== c(T, v) && (h(I, v, g(c(e, v), c(T, v), T - e)),
                            y(I, v, g(m(e, v), m(T, v), T - e)));
                    f = Math.round(.5 * f)
                }
                const w = {
                    x: 0,
                    y: 0
                }
                  , M = []
                  , b = []
                  , k = 250
                  , C = 25
                  , D = 25
                  , A = t / 225 + 1;
                let P = t / 2 + 50, G, R, x, B, E;
                const L = (e,a,i,n)=>{
                    l[i * t * t + a * t + e] = n
                }
                  , O = (e,t,a,i,n)=>{
                    e % 400 == 0 && (t = TileHelpers_52.default.setTypeRaw(t, TerrainType.RocksWithIron),
                    F(a, i, n, t, TerrainType.RocksWithIron)),
                    e % 401 == 0 && (t = TileHelpers_52.default.setTypeRaw(t, TerrainType.RocksWithTalc),
                    F(a, i, n, t, TerrainType.RocksWithTalc)),
                    e % 402 == 0 && (t = TileHelpers_52.default.setTypeRaw(t, TerrainType.RocksWithLimestone),
                    F(a, i, n, t, TerrainType.RocksWithLimestone)),
                    e % 403 == 0 && (t = TileHelpers_52.default.setTypeRaw(t, TerrainType.RocksWithCoal),
                    F(a, i, n, t, TerrainType.RocksWithCoal))
                }
                  , F = (e,t,a,i,n)=>{
                    const o = TileHelpers_52.default.setTypeRaw(i, n);
                    L(e, t, a, o);
                    for (let i = 0; i < 6 && 0 === Random_68.default.int(2); i++)
                        L(e - i, t, a, o),
                        0 === Random_68.default.int(2) && L(e - i, t - 1, a, o);
                    for (let i = 0; i < 6 && 0 === Random_68.default.int(2); i++)
                        L(e, t - i, a, o),
                        0 === Random_68.default.int(2) && L(e - 1, t - i, a, o)
                }
                  , _ = (e,t)=>(void 0 === t && (t = Random_68.default.getElement(p)),
                TileHelpers_52.default.setGfxRaw(TileHelpers_52.default.setTypeRaw(0, e), 3 * t + Random_68.default.int(3)));
                for (let e = i; e <= n; e++)
                    for (let a = 0; a < t; a++)
                        for (let i = 0; i < t; i++) {
                            G = u[a * (t + 1) + i],
                            E = d[a * (t + 1) + i],
                            P = Math.round(E * A) + 25,
                            R = Math.round(G * A) + 25,
                            x = Math.round(1e3 * G) + 25,
                            B = R + 50;
                            let n = 0;
                            if (e === o) {
                                if (R < 40 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.DeepSeawater) : R < 65 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Seawater) : R < 80 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.ShallowSeawater) : R < 100 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.BeachSand) : R < 110 ? n = P > 250 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.BeachSand) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : R < 130 ? n = P > 250 ? x >= 30005 && x <= 30055 ? _(DoodadType.CoconutTree) : x % 64 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Grass) : TileHelpers_52.default.setTypeRaw(n, TerrainType.BeachSand) : P > 240 && P < 250 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : x % 50 == 0 ? _(DoodadType.MapleTree) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Grass) : R < 160 ? (n = x % 5 == 0 || x % 6 == 0 || x % 7 == 0 || x % 8 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Grass) : x % 19 == 0 || x % 20 == 0 || x % 21 == 0 ? _(DoodadType.MapleTree, GrowingStage.Dead) : _(x % 11 == 0 || x % 12 == 0 || x % 13 == 0 ? DoodadType.SpruceTree : DoodadType.MapleTree),
                                x % 256 == 0 && (n = _(DoodadType.AppleTree, GrowingStage.Ripening)),
                                P > 250 ? n = x % 4 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : x % 16 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Grass) : TileHelpers_52.default.setTypeRaw(n, TerrainType.BeachSand) : P > 240 && P < 250 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel))) : R < 165 ? n = P > 250 ? x % 2 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_52.default.setTypeRaw(n, TerrainType.BeachSand) : P > 240 && P < 250 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Grass) : R < 185 ? (n = x % 50 == 0 ? _(DoodadType.MapleTree) : x % 449 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt),
                                P < 150 && P > 120 ? (x % 2 == 0 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Swamp) : x % 3 == 0 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Grass)),
                                x % 5 == 0 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : x % 6 == 0 && (n = _(DoodadType.CypressTree))) : P > 250 ? n = x % 449 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : P > 210 && P <= 250 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt))) : R < 186 ? (P > 250 ? x % 460 == 0 ? (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.SandstoneWithIron),
                                F(a, i, e, n, TerrainType.SandstoneWithIron)) : n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Sandstone) : n = P > 220 && P <= 250 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : P > 190 && P <= 220 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 30 == 0 && b.push([a, i])) : R < 230 ? P > 250 ? (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Sandstone),
                                x % 560 == 0 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.SandstoneWithIron),
                                F(a, i, e, n, TerrainType.SandstoneWithIron)),
                                x % 561 == 0 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.SandstoneWithNiter),
                                F(a, i, e, n, TerrainType.SandstoneWithNiter))) : P > 240 && P < 260 ? n = x % 3 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : P >= 260 && P < 300 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : P > 190 && P <= 240 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 460 == 0 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.RocksWithIron),
                                F(a, i, e, n, TerrainType.RocksWithIron)),
                                x % 461 == 0 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.RocksWithTalc),
                                F(a, i, e, n, TerrainType.RocksWithTalc)),
                                x % 462 == 0 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.RocksWithLimestone),
                                F(a, i, e, n, TerrainType.RocksWithLimestone)),
                                x % 463 == 0 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.RocksWithCoal),
                                F(a, i, e, n, TerrainType.RocksWithCoal))) : R < 250 ? P > 250 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : P > 240 && P < 260 ? n = x % 3 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : P >= 260 && P < 300 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : P > 190 && P <= 240 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 460 == 0 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.RocksWithTalc),
                                F(a, i, e, n, TerrainType.RocksWithTalc)),
                                x % 461 == 0 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.RocksWithLimestone),
                                F(a, i, e, n, TerrainType.RocksWithLimestone)),
                                x % 462 == 0 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.RocksWithCoal),
                                F(a, i, e, n, TerrainType.RocksWithCoal))) : R < 290 ? n = P > 250 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : P > 210 && P <= 250 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Rocks) : P > 250 ? x % 460 == 0 ? (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.SandstoneWithIron),
                                F(a, i, e, n, TerrainType.SandstoneWithIron)) : n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Sandstone) : n = P > 230 && P <= 250 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : P > 220 && P <= 230 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : P > 160 && P <= 220 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Rocks) : x % 8 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Rocks) : x % 13 == 0 ? _(DoodadType.SpruceTree) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Snow),
                                R > 140 && R < 160 && P > 75 && P < 150 && (n = x % 16 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Grass)),
                                R > 185 && (P > 0 && P < 25 ? n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : P > 150 && P < 175 && (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt))),
                                0 === w.x && 0 === w.y && R > 186)
                                    for (let e = a; e > 1; e--)
                                        if (Math.round(u[e * (t + 1) + i] * A) + 25 < 80) {
                                            w.x = e,
                                            w.y = i;
                                            break
                                        }
                            } else
                                B < 215 ? (n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Rocks),
                                P > 75 && P < 100 || P > -50 && P < 0 || P > 250 && P < 300 ? n = x % 25 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : P > 150 && P < 200 && (n = P > 160 && P < 190 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : P > 170 && P < 180 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel)),
                                O(x, n, a, i, e)) : B > 270 ? B < 330 ? P > 0 && P < 25 || P > 175 && P < 200 || P > -75 && P < -50 ? n = x % 15 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Rocks) : x % 25 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt) : O(x, n = TileHelpers_52.default.setTypeRaw(n, TerrainType.Rocks), a, i, e) : n = B < 340 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : B < 360 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : B < 380 ? x % 10 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_52.default.setTypeRaw(n, TerrainType.FreshWater) : x % 20 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.FreshWater) : TileHelpers_52.default.setTypeRaw(n, TerrainType.DeepFreshWater) : n = x % 15 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Rocks) : x % 25 == 0 ? TileHelpers_52.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_52.default.setTypeRaw(n, TerrainType.Dirt);
                            s && (e === o ? (P < 250 ? 58850 === x || 58950 === x || 59050 === x ? (M.push([TileTemplateType.Lava, a, i, e]),
                            M.push([TileTemplateType.Lava, a, i, r])) : 32850 === x ? M.push([TileTemplateType.House, a, i, e]) : 37250 !== x && 37500 !== x && 37750 !== x || M.push([TileTemplateType.Pond, a, i, e]) : 32250 !== x && 33250 !== x && 34250 !== x && 35250 !== x || M.push([TileTemplateType.Desert, a, i, e]),
                            21500 === x && M.push([TileTemplateType.Beach, a, i, e]),
                            R < 10 && -9e3 === x && M.push([TileTemplateType.Boat, a, i, e])) : 22850 === x || 22950 === x || 23050 === x ? M.push([TileTemplateType.Lava, a, i, e]) : 44850 === x || 44851 === x ? M.push([TileTemplateType.House, a, i, e]) : 46850 !== x && 46851 !== x || M.push([TileTemplateType.CavePond, a, i, e]));
                            const l = TileHelpers_52.default.getTypeRaw(n);
                            l !== DoodadType.MapleTree && l !== DoodadType.AppleTree && l !== DoodadType.SpruceTree && l !== DoodadType.CypressTree && l !== DoodadType.CoconutTree && (n = x % 4 == 0 ? TileHelpers_52.default.setGfxRaw(n, 2) : x % 2 == 0 ? TileHelpers_52.default.setGfxRaw(n, 1) : TileHelpers_52.default.setGfxRaw(n, 0)),
                            L(a, i, e, n)
                        }
                postMessage({
                    tileGenArray: l.buffer,
                    templateSpawns: M,
                    caveSpawns: b,
                    spawnCoords: w
                }, [l.buffer])
            }
            , e=>{
                const t = e.data
                  , a = new Uint16Array(t.tileGenArray)
                  , i = t.templateSpawns
                  , n = t.caveSpawns
                  , o = t.spawnCoords;
                game.spawnCoords = o,
                this.setupTiles(a, i, n, generateNewWorld)
            }
            );
            worker.postMessage({
                mapSize: game.mapSize,
                seed: Random_68.default.generator.getSeed(),
                zMin: WorldZ.Min,
                zMax: WorldZ.Max,
                zNormal: WorldZ.Overworld,
                zCave: WorldZ.Cave,
                generateNewWorld: generateNewWorld
            })
        }
        setupTiles(e, t, a, i) {
            let n, o, r, s;
            if (Log_57.default.info(Log_57.LogSource.MapGen)("setupTiles", Random_68.default.generator.getSeed()),
            game.tile = new Array(game.mapSizeSq * (WorldZ.Max + 1)),
            i) {
                const t = 325
                  , a = 1300
                  , i = 1e3
                  , l = 950
                  , u = 600
                  , d = game.isChallenge ? 1 : 0;
                for (r = WorldZ.Min; r <= WorldZ.Max; r++)
                    for (n = 0; n < game.mapSize; n++)
                        for (o = 0; o < game.mapSize; o++) {
                            (s = game.setTile(n, o, r, {})).data = e[r * game.mapSizeSq + o * game.mapSize + n];
                            const p = TileHelpers_52.default.getType(s);
                            switch (p) {
                            case DoodadType.MapleTree:
                            case DoodadType.CoconutTree:
                            case DoodadType.SpruceTree:
                            case DoodadType.CypressTree:
                            case DoodadType.AppleTree:
                                doodadManager.create(p, n, o, r, {
                                    gfx: TileHelpers_52.default.getGfx(s)
                                }),
                                MapGenHelpers.setTileUnderDoodad(s, n, o, p),
                                0 === Random_68.default.int(i) && p === DoodadType.MapleTree && MapGenHelpers.spawnTileEvent(n, o, r);
                                continue
                            }
                            if (r === WorldZ.Overworld)
                                switch (p) {
                                case TerrainType.Seawater:
                                    Random_68.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.Seawater, n, o, r, !0),
                                    0 === Random_68.default.int(a) && MapGenHelpers.spawnDoodad(TileHelpers_52.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.Dirt:
                                case TerrainType.Grass:
                                case TerrainType.Swamp:
                                    Random_68.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r, !0),
                                    0 === Random_68.default.int(u) ? itemManager.spawn(void 0, n, o, r) : 0 === Random_68.default.int(t) && MapGenHelpers.spawnDoodad(TileHelpers_52.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.Gravel:
                                case TerrainType.Snow:
                                    Random_68.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r, !0),
                                    0 === Random_68.default.int(u) && itemManager.spawn(void 0, n, o, r);
                                    break;
                                case TerrainType.ShallowSeawater:
                                    0 === Random_68.default.int(a) && MapGenHelpers.spawnDoodad(TileHelpers_52.default.getType(s), n, o, r),
                                    0 === Random_68.default.int(u) && MapGenHelpers.spawnShoreItem(n, o, r);
                                    break;
                                case TerrainType.BeachSand:
                                    0 === Random_68.default.int(t) && 0 !== Random_68.default.int(u) && MapGenHelpers.spawnDoodad(TileHelpers_52.default.getType(s), n, o, r)
                                }
                            else
                                switch (TileHelpers_52.default.getType(s)) {
                                case TerrainType.Dirt:
                                    const e = Random_68.default.int(u);
                                    Random_68.default.int(l) <= d + 1 && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r, !0),
                                    e <= 2 && itemManager.spawn(void 0, n, o, r),
                                    Random_68.default.int(t) <= 1 && e > 2 && MapGenHelpers.spawnDoodad(TileHelpers_52.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.FreshWater:
                                case TerrainType.ShallowFreshWater:
                                case TerrainType.DeepFreshWater:
                                    Random_68.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.CaveWater, n, o, r)
                                }
                        }
            } else
                MapGenHelpers.setupTiles(e);
            if (modManager.getHook(IHookManager_54.Hook.PreLoadWorldDifferences).call(i),
            i) {
                for (let e = 0; e < t.length; e++)
                    MapGenHelpers.spawnTemplate(t[e][0], t[e][1], t[e][2], t[e][3]);
                for (let e = 0; e < a.length; e++) {
                    const t = a[e][0]
                      , i = a[e][1];
                    game.changeTile(TerrainType.CaveEntrance, t, i, WorldZ.Overworld, !1),
                    game.changeTile(TerrainType.CaveEntrance, t, i, WorldZ.Cave, !1)
                }
            } else
                MapGenHelpers.loadDifferences();
            Log_57.default.info(Log_57.LogSource.MapGen)("PostGenerateWorld", Random_68.default.generator.getSeed()),
            modManager.getHook(IHookManager_54.Hook.PostGenerateWorld).call(i),
            Log_57.default.info(Log_57.LogSource.MapGen)("finishedLoading", Random_68.default.generator.getSeed()),
            MapGenHelpers.setFinishedLoading()
        }
    }
    exports.default = MapGen240
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mapgen/version/2.5.0", ["require", "exports", "creature/ICreature", "Enums", "language/dictionary/UiTranslation", "mapgen/MapGenHelpers", "mod/IHookManager", "tile/ITerrain", "utilities/Log", "utilities/Random", "utilities/TileHelpers", "utilities/WebWorkerHelpers"], function(require, exports, Creature, Enums, UiTranslation_88, MapGenHelpers, IHookManager_55, Terrain, Log_58, Random_69, TileHelpers_53, WebWorkerHelpers_6) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    const DoodadType = Enums.DoodadType
      , GrowingStage = Enums.GrowingStage
      , SpawnGroup = Creature.SpawnGroup
      , TerrainType = Enums.TerrainType
      , WorldZ = Enums.WorldZ
      , TileTemplateType = Terrain.TileTemplateType;
    class MapGen250 {
        generateWorld(generateNewWorld) {
            eval("let mangle_fix = 0;"),
            Log_58.default.info(Log_58.LogSource.MapGen)("generateTileTypes", generateNewWorld);
            const loadingTitle = generateNewWorld ? UiTranslation_88.default.GameInterruptLoadingGeneratingWorld : UiTranslation_88.default.GameInterruptLoadingWorld
              , loadingDescription = generateNewWorld ? UiTranslation_88.default.GameInterruptLoadingGeneratingWorldDescription : UiTranslation_88.default.GameInterruptLoadingWorldDescription;
            newui.showLoadingInterrupt(loadingTitle, loadingDescription);
            const worker = WebWorkerHelpers_6.WebWorkerHelpers.create(e=>{
                const t = e.mapSize
                  , a = e.seed
                  , i = e.zMin
                  , n = e.zMax
                  , o = e.zNormal
                  , r = e.zCave
                  , s = e.generateNewWorld
                  , l = new Uint16Array(t * t * (n + 1))
                  , u = new Float64Array((t + 1) * (t + 1))
                  , d = new Float64Array((t + 1) * (t + 1))
                  , p = [GrowingStage.Vegetative, GrowingStage.Budding, GrowingStage.Flowering, GrowingStage.Ripening];
                Random_69.default.generator.setSeed(a);
                const c = (e,a)=>u[e * (t + 1) + a]
                  , m = (e,a)=>d[e * (t + 1) + a]
                  , h = (e,a,i)=>{
                    u[e * (t + 1) + a] = i
                }
                  , y = (e,a,i)=>{
                    d[e * (t + 1) + a] = i
                }
                  , g = (e,t,a)=>{
                    const i = a * Random_69.default.float() - .5 * a;
                    return .5 * (e + t) + i
                }
                ;
                for (let e = 0; e <= t; e++)
                    for (let a = 0; a <= t; a++)
                        h(e, a, 0 === e || 0 === a || e === t || a === t ? -1 : 256 === e && 256 === a || 128 === e && 128 === a || 384 === e && 384 === a || 128 === e && 384 === a || 384 === e && 128 === a ? 50 : 0),
                        y(e, a, a >= 300 ? 100 : -1);
                let f = t, T, S, I, v;
                for (; f > 1; ) {
                    for (let e = 0; e < t; e += f)
                        for (let a = 0; a < t; a += f)
                            T = e + f,
                            S = a + f,
                            I = Math.round(.5 * (e + T)),
                            v = Math.round(.5 * (a + S)),
                            -1 !== c(e, a) && -1 !== c(T, a) && (h(I, a, g(c(e, a), c(T, a), T - e)),
                            y(I, a, g(m(e, a), m(T, a), T - e))),
                            -1 !== c(e, a) && -1 !== c(e, S) && (h(e, v, g(c(e, a), c(e, S), S - a)),
                            y(e, v, g(m(e, a), m(e, S), S - a))),
                            -1 !== c(T, a) && -1 !== c(T, S) && (h(T, v, g(c(T, a), c(T, S), S - a)),
                            y(T, v, g(m(T, a), m(T, S), S - a))),
                            -1 !== c(e, S) && -1 !== c(T, S) && (h(I, S, g(c(e, S), c(T, S), T - e)),
                            y(I, S, g(m(e, S), m(T, S), T - e))),
                            -1 !== c(e, v) && -1 !== c(T, v) && (h(I, v, g(c(e, v), c(T, v), T - e)),
                            y(I, v, g(m(e, v), m(T, v), T - e)));
                    f = Math.round(.5 * f)
                }
                const w = {
                    x: 0,
                    y: 0,
                    z: o
                }
                  , M = []
                  , b = []
                  , k = 250
                  , C = 25
                  , D = 25
                  , A = t / 225 + 1;
                let P = t / 2 + 50, G, R, x, B, E;
                const L = (e,a,i,n)=>{
                    l[i * t * t + a * t + e] = n
                }
                  , O = (e,t,a,i,n)=>{
                    e % 400 == 0 && (t = TileHelpers_53.default.setTypeRaw(t, TerrainType.RocksWithCopper),
                    F(a, i, n, t, TerrainType.RocksWithCopper)),
                    e % 401 == 0 && (t = TileHelpers_53.default.setTypeRaw(t, TerrainType.RocksWithTalc),
                    F(a, i, n, t, TerrainType.RocksWithTalc)),
                    e % 402 == 0 && (t = TileHelpers_53.default.setTypeRaw(t, TerrainType.RocksWithLimestone),
                    F(a, i, n, t, TerrainType.RocksWithLimestone)),
                    e % 403 == 0 && (t = TileHelpers_53.default.setTypeRaw(t, TerrainType.RocksWithIron),
                    F(a, i, n, t, TerrainType.RocksWithIron)),
                    e % 404 == 0 && (t = TileHelpers_53.default.setTypeRaw(t, TerrainType.RocksWithCoal),
                    F(a, i, n, t, TerrainType.RocksWithCoal))
                }
                  , F = (e,t,a,i,n)=>{
                    const o = TileHelpers_53.default.setTypeRaw(i, n);
                    L(e, t, a, o);
                    for (let i = 0; i < 6 && 0 === Random_69.default.int(2); i++)
                        L(e - i, t, a, o),
                        0 === Random_69.default.int(2) && L(e - i, t - 1, a, o);
                    for (let i = 0; i < 6 && 0 === Random_69.default.int(2); i++)
                        L(e, t - i, a, o),
                        0 === Random_69.default.int(2) && L(e - 1, t - i, a, o)
                }
                  , _ = (e,t)=>(void 0 === t && (t = Random_69.default.getElement(p)),
                TileHelpers_53.default.setGfxRaw(TileHelpers_53.default.setTypeRaw(0, e), 3 * t + Random_69.default.int(3)));
                for (let e = i; e <= n; e++)
                    for (let a = 0; a < t; a++)
                        for (let i = 0; i < t; i++) {
                            G = u[a * (t + 1) + i],
                            E = d[a * (t + 1) + i],
                            P = Math.round(E * A) + 25,
                            R = Math.round(G * A) + 25,
                            x = Math.round(1e3 * G) + 25,
                            B = R + 50;
                            let n = 0;
                            if (e === o) {
                                if (R < 40 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.DeepSeawater) : R < 65 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Seawater) : R < 80 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.ShallowSeawater) : R < 100 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.BeachSand) : R < 110 ? n = P > 250 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.BeachSand) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : R < 130 ? n = P > 250 ? x >= 30005 && x <= 30055 ? _(DoodadType.CoconutTree) : x % 64 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Grass) : TileHelpers_53.default.setTypeRaw(n, TerrainType.BeachSand) : P > 240 && P < 250 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : x % 50 == 0 ? _(DoodadType.MapleTree) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Grass) : R < 160 ? (n = x % 5 == 0 || x % 6 == 0 || x % 7 == 0 || x % 8 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Grass) : x % 19 == 0 || x % 20 == 0 || x % 21 == 0 ? _(DoodadType.MapleTree, GrowingStage.Dead) : _(x % 11 == 0 || x % 12 == 0 || x % 13 == 0 ? DoodadType.SpruceTree : DoodadType.MapleTree),
                                x % 256 == 0 && (n = _(DoodadType.AppleTree)),
                                P > 250 ? n = x % 4 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : x % 16 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Grass) : TileHelpers_53.default.setTypeRaw(n, TerrainType.BeachSand) : P > 240 && P < 250 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel))) : R < 165 ? n = P > 250 ? x % 2 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_53.default.setTypeRaw(n, TerrainType.BeachSand) : P > 240 && P < 250 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Grass) : R < 185 ? (n = x % 50 == 0 ? _(DoodadType.MapleTree) : x % 449 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt),
                                P < 150 && P > 120 ? (x % 2 == 0 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Swamp) : x % 3 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Grass)),
                                x % 5 == 0 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : x % 6 == 0 && (n = _(DoodadType.CypressTree))) : P > 250 ? n = x % 449 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : P > 210 && P <= 250 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt))) : R < 186 ? (P > 250 ? x % 460 == 0 ? (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.SandstoneWithCopper),
                                F(a, i, e, n, TerrainType.SandstoneWithCopper)) : n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Sandstone) : n = P > 220 && P <= 250 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : P > 190 && P <= 220 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 30 == 0 && b.push([a, i])) : R < 230 ? P > 250 ? (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Sandstone),
                                x % 561 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.SandstoneWithCopper),
                                F(a, i, e, n, TerrainType.SandstoneWithCopper)),
                                x % 562 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.SandstoneWithNiter),
                                F(a, i, e, n, TerrainType.SandstoneWithNiter)),
                                x % 563 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.SandstoneWithIron),
                                F(a, i, e, n, TerrainType.SandstoneWithIron))) : P > 240 && P < 260 ? n = x % 3 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : P >= 260 && P < 300 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : P > 190 && P <= 240 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 460 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.RocksWithCopper),
                                F(a, i, e, n, TerrainType.RocksWithCopper)),
                                x % 461 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.RocksWithTalc),
                                F(a, i, e, n, TerrainType.RocksWithTalc)),
                                x % 462 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.RocksWithLimestone),
                                F(a, i, e, n, TerrainType.RocksWithLimestone)),
                                x % 463 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.RocksWithIron),
                                F(a, i, e, n, TerrainType.RocksWithIron)),
                                x % 464 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.RocksWithCoal),
                                F(a, i, e, n, TerrainType.RocksWithCoal))) : R < 250 ? P > 250 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : P > 240 && P < 260 ? n = x % 3 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : P >= 260 && P < 300 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : P > 190 && P <= 240 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 460 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.RocksWithTalc),
                                F(a, i, e, n, TerrainType.RocksWithTalc)),
                                x % 461 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.RocksWithLimestone),
                                F(a, i, e, n, TerrainType.RocksWithLimestone)),
                                x % 462 == 0 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.RocksWithCoal),
                                F(a, i, e, n, TerrainType.RocksWithCoal))) : R < 290 ? n = P > 250 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : P > 210 && P <= 250 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Rocks) : P > 250 ? x % 460 == 0 ? (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.SandstoneWithCopper),
                                F(a, i, e, n, TerrainType.SandstoneWithCopper)) : n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Sandstone) : n = P > 230 && P <= 250 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : P > 220 && P <= 230 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : P > 160 && P <= 220 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Rocks) : x % 8 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Rocks) : x % 13 == 0 ? _(DoodadType.SpruceTree) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Snow),
                                R > 140 && R < 160 && P > 75 && P < 150 && (n = x % 16 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Grass)),
                                R > 185 && (P > 0 && P < 25 ? n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : P > 150 && P < 175 && (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt))),
                                0 === w.x && 0 === w.y && R > 186)
                                    for (let e = a; e > 1; e--)
                                        if (Math.round(u[e * (t + 1) + i] * A) + 25 < 80) {
                                            w.x = e,
                                            w.y = i;
                                            break
                                        }
                            } else
                                B < 215 ? (n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Rocks),
                                P > 75 && P < 100 || P > -50 && P < 0 || P > 250 && P < 300 ? n = x % 25 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : P > 150 && P < 200 && (n = P > 160 && P < 190 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : P > 170 && P < 180 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel)),
                                O(x, n, a, i, e)) : B > 270 ? B < 330 ? P > 0 && P < 25 || P > 175 && P < 200 || P > -75 && P < -50 ? n = x % 15 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Rocks) : x % 25 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt) : O(x, n = TileHelpers_53.default.setTypeRaw(n, TerrainType.Rocks), a, i, e) : n = B < 340 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : B < 360 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : B < 380 ? x % 10 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_53.default.setTypeRaw(n, TerrainType.FreshWater) : x % 20 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.FreshWater) : TileHelpers_53.default.setTypeRaw(n, TerrainType.DeepFreshWater) : n = x % 15 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Rocks) : x % 25 == 0 ? TileHelpers_53.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_53.default.setTypeRaw(n, TerrainType.Dirt);
                            s && (e === o ? (P < 250 ? 58850 === x || 58950 === x || 59050 === x ? (M.push([TileTemplateType.Lava, a, i, e]),
                            M.push([TileTemplateType.Lava, a, i, r])) : 32850 === x ? M.push([TileTemplateType.House, a, i, e]) : 37250 !== x && 37500 !== x && 37750 !== x || M.push([TileTemplateType.Pond, a, i, e]) : 32250 !== x && 33250 !== x && 34250 !== x && 35250 !== x || M.push([TileTemplateType.Desert, a, i, e]),
                            21500 === x && M.push([TileTemplateType.Beach, a, i, e]),
                            R < 10 && -9e3 === x && M.push([TileTemplateType.Boat, a, i, e])) : 22850 === x || 22950 === x || 23050 === x || 23150 === x ? M.push([TileTemplateType.Lava, a, i, e]) : 44850 === x || 44851 === x ? M.push([TileTemplateType.House, a, i, e]) : 46850 !== x && 46851 !== x || M.push([TileTemplateType.CavePond, a, i, e]));
                            const l = TileHelpers_53.default.getTypeRaw(n);
                            l !== DoodadType.MapleTree && l !== DoodadType.AppleTree && l !== DoodadType.SpruceTree && l !== DoodadType.CypressTree && l !== DoodadType.CoconutTree && (n = x % 4 == 0 ? TileHelpers_53.default.setGfxRaw(n, 2) : x % 2 == 0 ? TileHelpers_53.default.setGfxRaw(n, 1) : TileHelpers_53.default.setGfxRaw(n, 0)),
                            L(a, i, e, n)
                        }
                postMessage({
                    tileGenArray: l.buffer,
                    templateSpawns: M,
                    caveSpawns: b,
                    spawnCoords: w
                }, [l.buffer])
            }
            , e=>{
                const t = e.data
                  , a = new Uint16Array(t.tileGenArray)
                  , i = t.templateSpawns
                  , n = t.caveSpawns
                  , o = t.spawnCoords;
                game.spawnCoords = o,
                this.setupTiles(a, i, n, generateNewWorld)
            }
            );
            worker.postMessage({
                mapSize: game.mapSize,
                seed: Random_69.default.generator.getSeed(),
                zMin: WorldZ.Min,
                zMax: WorldZ.Max,
                zNormal: WorldZ.Overworld,
                zCave: WorldZ.Cave,
                generateNewWorld: generateNewWorld
            })
        }
        setupTiles(e, t, a, i) {
            let n, o, r, s;
            if (Log_58.default.info(Log_58.LogSource.MapGen)("setupTiles", Random_69.default.generator.getSeed()),
            game.tile = new Array(game.mapSizeSq * (WorldZ.Max + 1)),
            i) {
                const t = 325
                  , a = 1300
                  , i = 1e3
                  , l = 950
                  , u = 600
                  , d = game.isChallenge ? 1 : 0;
                for (r = WorldZ.Min; r <= WorldZ.Max; r++)
                    for (n = 0; n < game.mapSize; n++)
                        for (o = 0; o < game.mapSize; o++) {
                            (s = game.setTile(n, o, r, {})).data = e[r * game.mapSizeSq + o * game.mapSize + n];
                            const p = TileHelpers_53.default.getType(s);
                            switch (p) {
                            case DoodadType.MapleTree:
                            case DoodadType.CoconutTree:
                            case DoodadType.SpruceTree:
                            case DoodadType.CypressTree:
                            case DoodadType.AppleTree:
                                doodadManager.create(p, n, o, r, {
                                    gfx: TileHelpers_53.default.getGfx(s)
                                }),
                                MapGenHelpers.setTileUnderDoodad(s, n, o, p),
                                0 === Random_69.default.int(i) && p === DoodadType.MapleTree && MapGenHelpers.spawnTileEvent(n, o, r);
                                continue
                            }
                            if (r === WorldZ.Overworld)
                                switch (p) {
                                case TerrainType.Seawater:
                                    Random_69.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.Seawater, n, o, r, !0),
                                    0 === Random_69.default.int(a) && MapGenHelpers.spawnDoodad(TileHelpers_53.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.Dirt:
                                case TerrainType.Grass:
                                case TerrainType.Swamp:
                                    Random_69.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r, !0),
                                    0 === Random_69.default.int(u) ? itemManager.spawn(void 0, n, o, r) : 0 === Random_69.default.int(t) && MapGenHelpers.spawnDoodad(TileHelpers_53.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.Gravel:
                                case TerrainType.Snow:
                                    Random_69.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r, !0),
                                    0 === Random_69.default.int(u) && itemManager.spawn(void 0, n, o, r);
                                    break;
                                case TerrainType.ShallowSeawater:
                                    0 === Random_69.default.int(a) && MapGenHelpers.spawnDoodad(TileHelpers_53.default.getType(s), n, o, r),
                                    0 === Random_69.default.int(u) && MapGenHelpers.spawnShoreItem(n, o, r);
                                    break;
                                case TerrainType.BeachSand:
                                    0 === Random_69.default.int(t) && 0 !== Random_69.default.int(u) && MapGenHelpers.spawnDoodad(TileHelpers_53.default.getType(s), n, o, r)
                                }
                            else
                                switch (TileHelpers_53.default.getType(s)) {
                                case TerrainType.Dirt:
                                    const e = Random_69.default.int(u);
                                    Random_69.default.int(l) <= d + 1 && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r, !0),
                                    e <= 2 && itemManager.spawn(void 0, n, o, r),
                                    Random_69.default.int(t) <= 1 && e > 2 && MapGenHelpers.spawnDoodad(TileHelpers_53.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.FreshWater:
                                case TerrainType.ShallowFreshWater:
                                case TerrainType.DeepFreshWater:
                                    Random_69.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.CaveWater, n, o, r)
                                }
                        }
            } else
                MapGenHelpers.setupTiles(e);
            if (modManager.getHook(IHookManager_55.Hook.PreLoadWorldDifferences).call(i),
            i) {
                for (let e = 0; e < t.length; e++)
                    MapGenHelpers.spawnTemplate(t[e][0], t[e][1], t[e][2], t[e][3]);
                for (let e = 0; e < a.length; e++) {
                    const t = a[e][0]
                      , i = a[e][1];
                    game.changeTile(TerrainType.CaveEntrance, t, i, WorldZ.Overworld, !1),
                    game.changeTile(TerrainType.CaveEntrance, t, i, WorldZ.Cave, !1);
                    const n = game.getTile(t, i, WorldZ.Overworld);
                    void 0 !== n.doodad && doodadManager.remove(n.doodad);
                    const o = game.getTile(t, i, WorldZ.Cave);
                    void 0 !== o.doodad && doodadManager.remove(o.doodad)
                }
            } else
                MapGenHelpers.loadDifferences();
            Log_58.default.info(Log_58.LogSource.MapGen)("PostGenerateWorld", Random_69.default.generator.getSeed()),
            modManager.getHook(IHookManager_55.Hook.PostGenerateWorld).call(i),
            Log_58.default.info(Log_58.LogSource.MapGen)("finishedLoading", Random_69.default.generator.getSeed()),
            MapGenHelpers.setFinishedLoading()
        }
    }
    exports.default = MapGen250
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("mapgen/version/2.6.0", ["require", "exports", "creature/ICreature", "Enums", "language/dictionary/UiTranslation", "mapgen/MapGenHelpers", "mod/IHookManager", "tile/ITerrain", "utilities/Log", "utilities/Random", "utilities/TileHelpers", "utilities/WebWorkerHelpers"], function(require, exports, Creature, Enums, UiTranslation_89, MapGenHelpers, IHookManager_56, Terrain, Log_59, Random_70, TileHelpers_54, WebWorkerHelpers_7) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    const DoodadType = Enums.DoodadType
      , GrowingStage = Enums.GrowingStage
      , SpawnGroup = Creature.SpawnGroup
      , TerrainType = Enums.TerrainType
      , WorldZ = Enums.WorldZ
      , TileTemplateType = Terrain.TileTemplateType;
    class MapGen260 {
        generateWorld(generateNewWorld) {
            eval("let mangle_fix = 0;"),
            Log_59.default.info(Log_59.LogSource.MapGen)("generateTileTypes", generateNewWorld);
            const loadingTitle = generateNewWorld ? UiTranslation_89.default.GameInterruptLoadingGeneratingWorld : UiTranslation_89.default.GameInterruptLoadingWorld
              , loadingDescription = generateNewWorld ? UiTranslation_89.default.GameInterruptLoadingGeneratingWorldDescription : UiTranslation_89.default.GameInterruptLoadingWorldDescription;
            newui.showLoadingInterrupt(loadingTitle, loadingDescription);
            const worker = WebWorkerHelpers_7.WebWorkerHelpers.create(e=>{
                const t = e.mapSize
                  , a = e.seed
                  , i = e.zMin
                  , n = e.zMax
                  , o = e.zNormal
                  , r = e.zCave
                  , s = e.generateNewWorld
                  , l = new Uint16Array(t * t * (n + 1))
                  , u = new Float64Array((t + 1) * (t + 1))
                  , d = new Float64Array((t + 1) * (t + 1))
                  , p = [GrowingStage.Vegetative, GrowingStage.Budding, GrowingStage.Flowering, GrowingStage.Ripening];
                Random_70.default.generator.setSeed(a);
                const c = (e,a)=>u[e * (t + 1) + a]
                  , m = (e,a)=>d[e * (t + 1) + a]
                  , h = (e,a,i)=>{
                    u[e * (t + 1) + a] = i
                }
                  , y = (e,a,i)=>{
                    d[e * (t + 1) + a] = i
                }
                  , g = (e,t,a)=>{
                    const i = a * Random_70.default.float() - .5 * a;
                    return .5 * (e + t) + i
                }
                ;
                for (let e = 0; e <= t; e++)
                    for (let a = 0; a <= t; a++)
                        h(e, a, 0 === e || 0 === a || e === t || a === t ? -1 : 256 === e && 256 === a || 128 === e && 128 === a || 384 === e && 384 === a || 128 === e && 384 === a || 384 === e && 128 === a ? 50 : 0),
                        y(e, a, a >= 300 ? 100 : -1);
                let f = t, T, S, I, v;
                for (; f > 1; ) {
                    for (let e = 0; e < t; e += f)
                        for (let a = 0; a < t; a += f)
                            T = e + f,
                            S = a + f,
                            I = Math.round(.5 * (e + T)),
                            v = Math.round(.5 * (a + S)),
                            -1 !== c(e, a) && -1 !== c(T, a) && (h(I, a, g(c(e, a), c(T, a), T - e)),
                            y(I, a, g(m(e, a), m(T, a), T - e))),
                            -1 !== c(e, a) && -1 !== c(e, S) && (h(e, v, g(c(e, a), c(e, S), S - a)),
                            y(e, v, g(m(e, a), m(e, S), S - a))),
                            -1 !== c(T, a) && -1 !== c(T, S) && (h(T, v, g(c(T, a), c(T, S), S - a)),
                            y(T, v, g(m(T, a), m(T, S), S - a))),
                            -1 !== c(e, S) && -1 !== c(T, S) && (h(I, S, g(c(e, S), c(T, S), T - e)),
                            y(I, S, g(m(e, S), m(T, S), T - e))),
                            -1 !== c(e, v) && -1 !== c(T, v) && (h(I, v, g(c(e, v), c(T, v), T - e)),
                            y(I, v, g(m(e, v), m(T, v), T - e)));
                    f = Math.round(.5 * f)
                }
                const w = {
                    x: 0,
                    y: 0,
                    z: o
                }
                  , M = []
                  , b = []
                  , k = 250
                  , C = 25
                  , D = 25
                  , A = t / 225 + 1;
                let P = t / 2 + 50, G, R, x, B, E;
                const L = (e,a,i,n)=>{
                    l[i * t * t + a * t + e] = n
                }
                  , O = (e,t,a,i,n)=>{
                    e % 600 != 0 && e % 601 != 0 || (t = TileHelpers_54.default.setTypeRaw(t, TerrainType.RocksWithCopper),
                    F(a, i, n, t, TerrainType.RocksWithCopper)),
                    e % 602 != 0 && e % 603 != 0 || (t = TileHelpers_54.default.setTypeRaw(t, TerrainType.RocksWithTalc),
                    F(a, i, n, t, TerrainType.RocksWithTalc)),
                    e % 604 != 0 && e % 605 != 0 || (t = TileHelpers_54.default.setTypeRaw(t, TerrainType.RocksWithLimestone),
                    F(a, i, n, t, TerrainType.RocksWithLimestone)),
                    e % 606 == 0 && (t = TileHelpers_54.default.setTypeRaw(t, TerrainType.RocksWithIron),
                    F(a, i, n, t, TerrainType.RocksWithIron)),
                    e % 607 == 0 && (t = TileHelpers_54.default.setTypeRaw(t, TerrainType.RocksWithCoal),
                    F(a, i, n, t, TerrainType.RocksWithCoal))
                }
                  , F = (e,t,a,i,n)=>{
                    const o = TileHelpers_54.default.setTypeRaw(i, n);
                    L(e, t, a, o);
                    for (let i = 0; i < 5 && 0 === Random_70.default.int(2); i++)
                        L(e - i, t, a, o),
                        0 === Random_70.default.int(2) && L(e - i, t - 1, a, o);
                    for (let i = 0; i < 5 && 0 === Random_70.default.int(2); i++)
                        L(e, t - i, a, o),
                        0 === Random_70.default.int(2) && L(e - 1, t - i, a, o)
                }
                  , _ = (e,t)=>(void 0 === t && (t = Random_70.default.getElement(p)),
                TileHelpers_54.default.setGfxRaw(TileHelpers_54.default.setTypeRaw(0, e), 3 * t + Random_70.default.int(3)));
                for (let e = i; e <= n; e++)
                    for (let a = 0; a < t; a++)
                        for (let i = 0; i < t; i++) {
                            G = u[a * (t + 1) + i],
                            E = d[a * (t + 1) + i],
                            P = Math.round(E * A) + 25,
                            R = Math.round(G * A) + 25,
                            x = Math.round(1e3 * G) + 25,
                            B = R + 50;
                            let n = 0;
                            if (e === o) {
                                if (R < 40 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.DeepSeawater) : R < 65 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Seawater) : R < 80 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.ShallowSeawater) : R < 100 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.BeachSand) : R < 110 ? n = P > 250 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.BeachSand) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : R < 130 ? n = P > 250 ? x >= 30005 && x <= 30055 ? _(DoodadType.CoconutTree) : x % 64 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Grass) : TileHelpers_54.default.setTypeRaw(n, TerrainType.BeachSand) : P > 240 && P < 250 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : x % 50 == 0 ? _(DoodadType.MapleTree) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Grass) : R < 160 ? (n = x % 5 == 0 || x % 6 == 0 || x % 7 == 0 || x % 8 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Grass) : x % 19 == 0 || x % 20 == 0 || x % 21 == 0 ? _(DoodadType.MapleTree, GrowingStage.Dead) : _(x % 11 == 0 || x % 12 == 0 || x % 13 == 0 ? DoodadType.SpruceTree : DoodadType.MapleTree),
                                x % 256 == 0 && (n = _(DoodadType.AppleTree)),
                                P > 250 ? n = x % 4 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : x % 16 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Grass) : TileHelpers_54.default.setTypeRaw(n, TerrainType.BeachSand) : P > 240 && P < 250 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel))) : R < 165 ? n = P > 250 ? x % 2 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_54.default.setTypeRaw(n, TerrainType.BeachSand) : P > 240 && P < 250 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Grass) : R < 185 ? (n = x % 50 == 0 ? _(DoodadType.MapleTree) : x % 449 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt),
                                P < 150 && P > 120 ? (x % 2 == 0 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Swamp) : x % 3 == 0 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Grass)),
                                x % 5 == 0 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : x % 6 == 0 && (n = _(DoodadType.CypressTree))) : P > 250 ? x % 449 == 0 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : x % 512 == 0 ? (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Clay),
                                F(a, i, e, n, TerrainType.Clay)) : n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : P > 210 && P <= 250 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt))) : R < 186 ? (P > 250 ? x % 460 == 0 ? (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.SandstoneWithCopper),
                                F(a, i, e, n, TerrainType.SandstoneWithCopper)) : n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Sandstone) : P > 220 && P <= 250 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : P > 190 && P <= 220 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : x % 48 == 0 ? (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Clay),
                                F(a, i, e, n, TerrainType.Clay)) : n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 30 == 0 && b.push([a, i])) : R < 230 ? P > 250 ? (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Sandstone),
                                x % 860 != 0 && x % 861 != 0 || (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.SandstoneWithCopper),
                                F(a, i, e, n, TerrainType.SandstoneWithCopper)),
                                x % 862 == 0 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.SandstoneWithNiter),
                                F(a, i, e, n, TerrainType.SandstoneWithNiter)),
                                x % 863 == 0 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.SandstoneWithIron),
                                F(a, i, e, n, TerrainType.SandstoneWithIron))) : P > 240 && P < 260 ? n = x % 3 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : P >= 260 && P < 300 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : P > 190 && P <= 240 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 660 != 0 && x % 661 != 0 || (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.RocksWithCopper),
                                F(a, i, e, n, TerrainType.RocksWithCopper)),
                                x % 662 != 0 && x % 663 != 0 || (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.RocksWithTalc),
                                F(a, i, e, n, TerrainType.RocksWithTalc)),
                                x % 664 != 0 && x % 665 != 0 || (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.RocksWithLimestone),
                                F(a, i, e, n, TerrainType.RocksWithLimestone)),
                                x % 666 == 0 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.RocksWithIron),
                                F(a, i, e, n, TerrainType.RocksWithIron)),
                                x % 667 == 0 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.RocksWithCoal),
                                F(a, i, e, n, TerrainType.RocksWithCoal))) : R < 250 ? P > 250 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : P > 240 && P < 260 ? n = x % 3 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : P >= 260 && P < 300 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : P > 190 && P <= 240 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 660 == 0 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.RocksWithTalc),
                                F(a, i, e, n, TerrainType.RocksWithTalc)),
                                x % 661 == 0 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.RocksWithLimestone),
                                F(a, i, e, n, TerrainType.RocksWithLimestone)),
                                x % 662 == 0 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.RocksWithCoal),
                                F(a, i, e, n, TerrainType.RocksWithCoal))) : R < 290 ? n = P > 250 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : P > 210 && P <= 250 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Rocks) : P > 250 ? x % 460 == 0 ? (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.SandstoneWithCopper),
                                F(a, i, e, n, TerrainType.SandstoneWithCopper)) : n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Sandstone) : n = P > 230 && P <= 250 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : P > 220 && P <= 230 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : P > 160 && P <= 220 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Rocks) : x % 8 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Rocks) : x % 13 == 0 ? _(DoodadType.SpruceTree) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Snow),
                                R > 140 && R < 160 && P > 75 && P < 150 && (n = x % 16 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Grass)),
                                R > 185 && (P > 0 && P < 25 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : P > 150 && P < 175 && (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt))),
                                0 === w.x && 0 === w.y && R > 186)
                                    for (let e = a; e > 1; e--)
                                        if (Math.round(u[e * (t + 1) + i] * A) + 25 < 80) {
                                            w.x = e,
                                            w.y = i;
                                            break
                                        }
                            } else
                                B < 215 ? (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Rocks),
                                P > 75 && P < 100 || P > -50 && P < 0 || P > 250 && P < 300 ? n = x % 25 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : P > 150 && P < 200 && (P > 160 && P < 190 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : P > 170 && P < 180 ? n = TileHelpers_54.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : x % 128 == 0 ? (n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Clay),
                                F(a, i, e, n, TerrainType.Clay)) : n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel)),
                                O(x, n, a, i, e)) : B > 270 ? B < 330 ? P > 0 && P < 25 || P > 175 && P < 200 || P > -75 && P < -50 ? n = x % 15 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Rocks) : x % 25 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt) : O(x, n = TileHelpers_54.default.setTypeRaw(n, TerrainType.Rocks), a, i, e) : n = B < 340 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : B < 360 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : B < 380 ? x % 10 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_54.default.setTypeRaw(n, TerrainType.FreshWater) : x % 20 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.FreshWater) : TileHelpers_54.default.setTypeRaw(n, TerrainType.DeepFreshWater) : n = x % 15 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Rocks) : x % 25 == 0 ? TileHelpers_54.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_54.default.setTypeRaw(n, TerrainType.Dirt);
                            s && (e === o ? (P < 250 ? 58850 === x || 58950 === x || 59050 === x ? (M.push([TileTemplateType.Lava, a, i, e]),
                            M.push([TileTemplateType.Lava, a, i, r])) : 32850 === x ? M.push([TileTemplateType.House, a, i, e]) : 37250 !== x && 37500 !== x && 37750 !== x || M.push([TileTemplateType.Pond, a, i, e]) : 32250 !== x && 33250 !== x && 34250 !== x && 35250 !== x || M.push([TileTemplateType.Desert, a, i, e]),
                            21500 === x && M.push([TileTemplateType.Beach, a, i, e]),
                            R < 10 && -9e3 === x && M.push([TileTemplateType.Boat, a, i, e])) : 22850 === x || 22950 === x || 23050 === x || 23150 === x ? M.push([TileTemplateType.Lava, a, i, e]) : 44850 === x || 44851 === x ? M.push([TileTemplateType.House, a, i, e]) : 46850 !== x && 46851 !== x || M.push([TileTemplateType.CavePond, a, i, e]));
                            const l = TileHelpers_54.default.getTypeRaw(n);
                            l !== DoodadType.MapleTree && l !== DoodadType.AppleTree && l !== DoodadType.SpruceTree && l !== DoodadType.CypressTree && l !== DoodadType.CoconutTree && (n = x % 4 == 0 ? TileHelpers_54.default.setGfxRaw(n, 2) : x % 2 == 0 ? TileHelpers_54.default.setGfxRaw(n, 1) : TileHelpers_54.default.setGfxRaw(n, 0)),
                            L(a, i, e, n)
                        }
                postMessage({
                    tileGenArray: l.buffer,
                    templateSpawns: M,
                    caveSpawns: b,
                    spawnCoords: w
                }, [l.buffer])
            }
            , e=>{
                const t = e.data
                  , a = new Uint16Array(t.tileGenArray)
                  , i = t.templateSpawns
                  , n = t.caveSpawns
                  , o = t.spawnCoords;
                game.spawnCoords = o,
                this.setupTiles(a, i, n, generateNewWorld)
            }
            );
            worker.postMessage({
                mapSize: game.mapSize,
                seed: Random_70.default.generator.getSeed(),
                zMin: WorldZ.Min,
                zMax: WorldZ.Max,
                zNormal: WorldZ.Overworld,
                zCave: WorldZ.Cave,
                generateNewWorld: generateNewWorld
            })
        }
        setupTiles(e, t, a, i) {
            let n, o, r, s;
            if (Log_59.default.info(Log_59.LogSource.MapGen)("setupTiles", Random_70.default.generator.getSeed()),
            game.tile = new Array(game.mapSizeSq * (WorldZ.Max + 1)),
            i) {
                const t = 325
                  , a = 1300
                  , i = 1e3
                  , l = 950
                  , u = 600
                  , d = game.isChallenge ? 1 : 0;
                for (r = WorldZ.Min; r <= WorldZ.Max; r++)
                    for (n = 0; n < game.mapSize; n++)
                        for (o = 0; o < game.mapSize; o++) {
                            (s = game.setTile(n, o, r, {})).data = e[r * game.mapSizeSq + o * game.mapSize + n];
                            const p = TileHelpers_54.default.getType(s);
                            switch (p) {
                            case DoodadType.MapleTree:
                            case DoodadType.CoconutTree:
                            case DoodadType.SpruceTree:
                            case DoodadType.CypressTree:
                            case DoodadType.AppleTree:
                                doodadManager.create(p, n, o, r, {
                                    gfx: TileHelpers_54.default.getGfx(s)
                                }),
                                MapGenHelpers.setTileUnderDoodad(s, n, o, p),
                                0 === Random_70.default.int(i) && p === DoodadType.MapleTree && MapGenHelpers.spawnTileEvent(n, o, r);
                                continue
                            }
                            if (r === WorldZ.Overworld)
                                switch (p) {
                                case TerrainType.Seawater:
                                    Random_70.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.Seawater, n, o, r, !0),
                                    0 === Random_70.default.int(a) && MapGenHelpers.spawnDoodad(TileHelpers_54.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.Dirt:
                                case TerrainType.Grass:
                                case TerrainType.Swamp:
                                    Random_70.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r, !0),
                                    0 === Random_70.default.int(u) ? itemManager.spawn(void 0, n, o, r) : 0 === Random_70.default.int(t) && MapGenHelpers.spawnDoodad(TileHelpers_54.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.Gravel:
                                case TerrainType.Snow:
                                    Random_70.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r, !0),
                                    0 === Random_70.default.int(u) && itemManager.spawn(void 0, n, o, r);
                                    break;
                                case TerrainType.ShallowSeawater:
                                    0 === Random_70.default.int(a) && MapGenHelpers.spawnDoodad(TileHelpers_54.default.getType(s), n, o, r),
                                    0 === Random_70.default.int(u) && MapGenHelpers.spawnShoreItem(n, o, r);
                                    break;
                                case TerrainType.BeachSand:
                                    0 === Random_70.default.int(t) && 0 !== Random_70.default.int(u) && MapGenHelpers.spawnDoodad(TileHelpers_54.default.getType(s), n, o, r)
                                }
                            else
                                switch (TileHelpers_54.default.getType(s)) {
                                case TerrainType.Dirt:
                                    const e = Random_70.default.int(u);
                                    Random_70.default.int(l) <= d + 1 && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r, !0),
                                    e <= 2 && itemManager.spawn(void 0, n, o, r),
                                    Random_70.default.int(t) <= 1 && e > 2 && MapGenHelpers.spawnDoodad(TileHelpers_54.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.FreshWater:
                                case TerrainType.ShallowFreshWater:
                                case TerrainType.DeepFreshWater:
                                    Random_70.default.int(l) <= d && creatureManager.spawnFromGroup(SpawnGroup.CaveWater, n, o, r)
                                }
                        }
            } else
                MapGenHelpers.setupTiles(e);
            if (modManager.getHook(IHookManager_56.Hook.PreLoadWorldDifferences).call(i),
            i) {
                for (let e = 0; e < t.length; e++)
                    MapGenHelpers.spawnTemplate(t[e][0], t[e][1], t[e][2], t[e][3]);
                for (let e = 0; e < a.length; e++) {
                    const t = a[e][0]
                      , i = a[e][1];
                    game.changeTile(TerrainType.CaveEntrance, t, i, WorldZ.Overworld, !1),
                    game.changeTile(TerrainType.CaveEntrance, t, i, WorldZ.Cave, !1);
                    const n = game.getTile(t, i, WorldZ.Overworld);
                    void 0 !== n.doodad && doodadManager.remove(n.doodad);
                    const o = game.getTile(t, i, WorldZ.Cave);
                    void 0 !== o.doodad && doodadManager.remove(o.doodad)
                }
                const e = TileHelpers_54.default.getSuitableSpawnPoint();
                npcManager.spawn(Enums.NPCType.Merchant, e.x, e.y, e.z)
            } else
                MapGenHelpers.loadDifferences();
            Log_59.default.info(Log_59.LogSource.MapGen)("PostGenerateWorld", Random_70.default.generator.getSeed()),
            modManager.getHook(IHookManager_56.Hook.PostGenerateWorld).call(i),
            Log_59.default.info(Log_59.LogSource.MapGen)("finishedLoading", Random_70.default.generator.getSeed()),
            MapGenHelpers.setFinishedLoading()
        }
    }
    exports.default = MapGen260
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("mapgen/version/2.7.0", ["require", "exports", "creature/ICreature", "Enums", "language/dictionary/UiTranslation", "mapgen/MapGenHelpers", "mod/IHookManager", "tile/ITerrain", "utilities/Log", "utilities/Random", "utilities/TileHelpers", "utilities/WebWorkerHelpers"], function(require, exports, Creature, Enums, UiTranslation_90, MapGenHelpers, IHookManager_57, Terrain, Log_60, Random_71, TileHelpers_55, WebWorkerHelpers_8) {
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
    const DoodadType = Enums.DoodadType
      , GrowingStage = Enums.GrowingStage
      , SpawnGroup = Creature.SpawnGroup
      , TerrainType = Enums.TerrainType
      , WorldZ = Enums.WorldZ
      , TileTemplateType = Terrain.TileTemplateType;
    class MapGen270 {
        generateWorld(generateNewWorld) {
            eval("let mangle_fix = 0;"),
            Log_60.default.info(Log_60.LogSource.MapGen)("generateTileTypes", generateNewWorld);
            const loadingTitle = generateNewWorld ? UiTranslation_90.default.GameInterruptLoadingGeneratingWorld : UiTranslation_90.default.GameInterruptLoadingWorld
              , loadingDescription = generateNewWorld ? UiTranslation_90.default.GameInterruptLoadingGeneratingWorldDescription : UiTranslation_90.default.GameInterruptLoadingWorldDescription;
            newui.showLoadingInterrupt(loadingTitle, loadingDescription);
            const worker = WebWorkerHelpers_8.WebWorkerHelpers.create(e=>{
                const t = e.mapSize
                  , a = e.seed
                  , i = e.zMin
                  , n = e.zMax
                  , o = e.zNormal
                  , r = e.zCave
                  , s = e.generateNewWorld
                  , l = new Uint16Array(t * t * (n + 1))
                  , u = new Float64Array((t + 1) * (t + 1))
                  , d = new Float64Array((t + 1) * (t + 1))
                  , p = [GrowingStage.Vegetative, GrowingStage.Budding, GrowingStage.Flowering, GrowingStage.Ripening];
                Random_71.default.generator.setSeed(a);
                const c = (e,a)=>u[e * (t + 1) + a]
                  , m = (e,a)=>d[e * (t + 1) + a]
                  , h = (e,a,i)=>{
                    u[e * (t + 1) + a] = i
                }
                  , y = (e,a,i)=>{
                    d[e * (t + 1) + a] = i
                }
                  , g = (e,t,a)=>{
                    const i = a * Random_71.default.float() - .5 * a;
                    return .5 * (e + t) + i
                }
                ;
                for (let e = 0; e <= t; e++)
                    for (let a = 0; a <= t; a++)
                        h(e, a, 0 === e || 0 === a || e === t || a === t ? -1 : 256 === e && 256 === a || 128 === e && 128 === a || 384 === e && 384 === a || 128 === e && 384 === a || 384 === e && 128 === a ? 50 : 0),
                        y(e, a, a >= 300 ? 100 : -1);
                let f = t, T, S, I, v;
                for (; f > 1; ) {
                    for (let e = 0; e < t; e += f)
                        for (let a = 0; a < t; a += f)
                            T = e + f,
                            S = a + f,
                            I = Math.round(.5 * (e + T)),
                            v = Math.round(.5 * (a + S)),
                            -1 !== c(e, a) && -1 !== c(T, a) && (h(I, a, g(c(e, a), c(T, a), T - e)),
                            y(I, a, g(m(e, a), m(T, a), T - e))),
                            -1 !== c(e, a) && -1 !== c(e, S) && (h(e, v, g(c(e, a), c(e, S), S - a)),
                            y(e, v, g(m(e, a), m(e, S), S - a))),
                            -1 !== c(T, a) && -1 !== c(T, S) && (h(T, v, g(c(T, a), c(T, S), S - a)),
                            y(T, v, g(m(T, a), m(T, S), S - a))),
                            -1 !== c(e, S) && -1 !== c(T, S) && (h(I, S, g(c(e, S), c(T, S), T - e)),
                            y(I, S, g(m(e, S), m(T, S), T - e))),
                            -1 !== c(e, v) && -1 !== c(T, v) && (h(I, v, g(c(e, v), c(T, v), T - e)),
                            y(I, v, g(m(e, v), m(T, v), T - e)));
                    f = Math.round(.5 * f)
                }
                const w = {
                    x: 0,
                    y: 0,
                    z: o
                }
                  , M = []
                  , b = []
                  , k = 250
                  , C = 25
                  , D = 25
                  , A = t / 225 + 1;
                let P = t / 2 + 50, G, R, x, B, E;
                const L = (e,a,i,n)=>{
                    l[i * t * t + a * t + e] = n
                }
                  , O = (e,t,a,i,n)=>{
                    e % 600 != 0 && e % 601 != 0 || (t = TileHelpers_55.default.setTypeRaw(t, TerrainType.RocksWithCopper),
                    F(a, i, n, t, TerrainType.RocksWithCopper)),
                    e % 602 != 0 && e % 603 != 0 || (t = TileHelpers_55.default.setTypeRaw(t, TerrainType.RocksWithTalc),
                    F(a, i, n, t, TerrainType.RocksWithTalc)),
                    e % 604 != 0 && e % 605 != 0 || (t = TileHelpers_55.default.setTypeRaw(t, TerrainType.RocksWithLimestone),
                    F(a, i, n, t, TerrainType.RocksWithLimestone)),
                    e % 606 == 0 && (t = TileHelpers_55.default.setTypeRaw(t, TerrainType.RocksWithIron),
                    F(a, i, n, t, TerrainType.RocksWithIron)),
                    e % 607 == 0 && (t = TileHelpers_55.default.setTypeRaw(t, TerrainType.RocksWithCoal),
                    F(a, i, n, t, TerrainType.RocksWithCoal))
                }
                  , F = (e,t,a,i,n)=>{
                    const o = TileHelpers_55.default.setTypeRaw(i, n);
                    L(e, t, a, o);
                    for (let i = 0; i < 5 && 0 === Random_71.default.int(2); i++)
                        L(e - i, t, a, o),
                        0 === Random_71.default.int(2) && L(e - i, t - 1, a, o);
                    for (let i = 0; i < 5 && 0 === Random_71.default.int(2); i++)
                        L(e, t - i, a, o),
                        0 === Random_71.default.int(2) && L(e - 1, t - i, a, o)
                }
                  , _ = (e,t)=>(void 0 === t && (t = Random_71.default.getElement(p)),
                TileHelpers_55.default.setGfxRaw(TileHelpers_55.default.setTypeRaw(0, e), 3 * t + Random_71.default.int(3)));
                for (let e = i; e <= n; e++)
                    for (let a = 0; a < t; a++)
                        for (let i = 0; i < t; i++) {
                            G = u[a * (t + 1) + i],
                            E = d[a * (t + 1) + i],
                            P = Math.round(E * A) + 25,
                            R = Math.round(G * A) + 25,
                            x = Math.round(1e3 * G) + 25,
                            B = R + 50;
                            let n = 0;
                            if (e === o) {
                                if (R < 40 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.DeepSeawater) : R < 65 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Seawater) : R < 80 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.ShallowSeawater) : R < 100 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.BeachSand) : R < 110 ? n = P > 250 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.BeachSand) : TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel) : R < 130 ? P > 250 ? x >= 30005 && x <= 30035 ? n = _(DoodadType.CoconutTree) : x >= 30035 && x <= 30075 ? n = _(DoodadType.JoshuaTree) : x % 256 == 0 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Grass),
                                F(a, i, e, n, TerrainType.Grass)) : n = TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : n = P > 240 && P < 250 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel) : x % 50 == 0 ? _(DoodadType.MapleTree) : TileHelpers_55.default.setTypeRaw(n, TerrainType.Grass) : R < 160 ? (n = x % 5 == 0 || x % 6 == 0 || x % 7 == 0 || x % 8 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Grass) : x % 19 == 0 || x % 20 == 0 || x % 21 == 0 ? _(DoodadType.MapleTree, GrowingStage.Dead) : _(x % 11 == 0 || x % 12 == 0 || x % 13 == 0 ? DoodadType.SpruceTree : DoodadType.MapleTree),
                                x % 256 == 0 && (n = _(DoodadType.AppleTree)),
                                P > 250 ? x % 64 == 0 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel),
                                F(a, i, e, n, TerrainType.Gravel)) : n = TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : P > 240 && P < 250 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel))) : R < 165 ? n = P > 250 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : P > 240 && P < 250 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_55.default.setTypeRaw(n, TerrainType.Grass) : R < 185 ? (n = x % 50 == 0 ? _(DoodadType.MapleTree) : x % 449 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt),
                                P < 150 && P > 120 ? (x % 2 == 0 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Swamp) : x % 3 == 0 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Grass)),
                                x % 5 == 0 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : x % 6 == 0 && (n = _(DoodadType.CypressTree))) : P > 250 ? x % 449 == 0 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : x % 512 == 0 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Clay),
                                F(a, i, e, n, TerrainType.Clay)) : n = TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : P > 210 && P <= 250 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt))) : R < 186 ? (P > 250 ? x % 460 == 0 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.SandstoneWithCopper),
                                F(a, i, e, n, TerrainType.SandstoneWithCopper)) : n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Sandstone) : P > 220 && P <= 250 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : P > 190 && P <= 220 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt) : x % 48 == 0 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Clay),
                                F(a, i, e, n, TerrainType.Clay)) : n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 30 == 0 && b.push([a, i])) : R < 230 ? P > 250 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Sandstone),
                                x % 860 != 0 && x % 861 != 0 || (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.SandstoneWithCopper),
                                F(a, i, e, n, TerrainType.SandstoneWithCopper)),
                                x % 862 == 0 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.SandstoneWithNiter),
                                F(a, i, e, n, TerrainType.SandstoneWithNiter)),
                                x % 863 == 0 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.SandstoneWithIron),
                                F(a, i, e, n, TerrainType.SandstoneWithIron))) : P > 230 && P < 260 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : P > 190 && P <= 240 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 660 != 0 && x % 661 != 0 || (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.RocksWithCopper),
                                F(a, i, e, n, TerrainType.RocksWithCopper)),
                                x % 662 != 0 && x % 663 != 0 || (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.RocksWithTalc),
                                F(a, i, e, n, TerrainType.RocksWithTalc)),
                                x % 664 != 0 && x % 665 != 0 || (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.RocksWithLimestone),
                                F(a, i, e, n, TerrainType.RocksWithLimestone)),
                                x % 666 == 0 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.RocksWithIron),
                                F(a, i, e, n, TerrainType.RocksWithIron)),
                                x % 667 == 0 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.RocksWithCoal),
                                F(a, i, e, n, TerrainType.RocksWithCoal))) : R < 250 ? P > 250 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : P > 240 && P < 260 ? n = x % 3 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : P >= 260 && P < 300 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : P > 190 && P <= 240 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt) : (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Rocks),
                                x % 660 == 0 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.RocksWithTalc),
                                F(a, i, e, n, TerrainType.RocksWithTalc)),
                                x % 661 == 0 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.RocksWithLimestone),
                                F(a, i, e, n, TerrainType.RocksWithLimestone)),
                                x % 662 == 0 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.RocksWithCoal),
                                F(a, i, e, n, TerrainType.RocksWithCoal))) : R < 290 ? P > 250 ? x % 256 == 0 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Clay),
                                F(a, i, e, n, TerrainType.Clay)) : x % 128 == 0 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Grass),
                                F(a, i, e, n, TerrainType.Grass)) : x % 64 == 0 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel),
                                F(a, i, e, n, TerrainType.Gravel)) : n = TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : n = P > 210 && P <= 250 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_55.default.setTypeRaw(n, TerrainType.Rocks) : P > 250 ? x % 460 == 0 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.SandstoneWithCopper),
                                F(a, i, e, n, TerrainType.SandstoneWithCopper)) : n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Sandstone) : n = P > 230 && P <= 250 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.DesertSand) : P > 220 && P <= 230 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt) : P > 160 && P <= 220 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Rocks) : x % 8 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Rocks) : x % 13 == 0 ? _(DoodadType.SpruceTree) : TileHelpers_55.default.setTypeRaw(n, TerrainType.Snow),
                                R > 140 && R < 160 && P > 75 && P < 150 && (n = x % 16 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt) : TileHelpers_55.default.setTypeRaw(n, TerrainType.Grass)),
                                R > 185 && (P > 0 && P < 25 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt) : P > 150 && P < 175 && (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt))),
                                0 === w.x && 0 === w.y && R > 186)
                                    for (let e = a; e > 1; e--)
                                        if (Math.round(u[e * (t + 1) + i] * A) + 25 < 80) {
                                            w.x = e,
                                            w.y = i;
                                            break
                                        }
                            } else
                                B < 215 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Rocks),
                                P > 75 && P < 100 || P > -50 && P < 0 || P > 250 && P < 300 ? n = x % 25 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt) : P > 150 && P < 200 && (P > 160 && P < 190 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : P > 170 && P < 180 ? n = TileHelpers_55.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : x % 128 == 0 ? (n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Clay),
                                F(a, i, e, n, TerrainType.Clay)) : n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel)),
                                O(x, n, a, i, e)) : B > 270 ? B < 330 ? P > 0 && P < 25 || P > 175 && P < 200 || P > -75 && P < -50 ? n = x % 15 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Rocks) : x % 25 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt) : O(x, n = TileHelpers_55.default.setTypeRaw(n, TerrainType.Rocks), a, i, e) : n = B < 340 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel) : B < 360 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : B < 380 ? x % 10 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.ShallowFreshWater) : TileHelpers_55.default.setTypeRaw(n, TerrainType.FreshWater) : x % 20 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.FreshWater) : TileHelpers_55.default.setTypeRaw(n, TerrainType.DeepFreshWater) : n = x % 15 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Rocks) : x % 25 == 0 ? TileHelpers_55.default.setTypeRaw(n, TerrainType.Gravel) : TileHelpers_55.default.setTypeRaw(n, TerrainType.Dirt);
                            s && (e === o ? (P < 250 ? 58850 === x || 58950 === x || 59050 === x ? (M.push([TileTemplateType.Lava, a, i, e]),
                            M.push([TileTemplateType.Lava, a, i, r])) : 32850 === x ? M.push([TileTemplateType.House, a, i, e]) : 37250 !== x && 37500 !== x && 37750 !== x || M.push([TileTemplateType.Pond, a, i, e]) : 32250 !== x && 33250 !== x && 34250 !== x && 35250 !== x || M.push([TileTemplateType.Desert, a, i, e]),
                            21500 !== x && 22e3 !== x || M.push([TileTemplateType.Beach, a, i, e]),
                            R < 10 && -9e3 === x && M.push([TileTemplateType.Boat, a, i, e])) : 22850 === x || 22950 === x || 23050 === x || 23150 === x ? M.push([TileTemplateType.Lava, a, i, e]) : 44850 === x || 44851 === x ? M.push([TileTemplateType.House, a, i, e]) : 46850 !== x && 46851 !== x || M.push([TileTemplateType.CavePond, a, i, e]));
                            const l = TileHelpers_55.default.getTypeRaw(n);
                            l !== DoodadType.MapleTree && l !== DoodadType.AppleTree && l !== DoodadType.SpruceTree && l !== DoodadType.CypressTree && l !== DoodadType.CoconutTree && l !== DoodadType.JoshuaTree && (n = x % 4 == 0 ? TileHelpers_55.default.setGfxRaw(n, 2) : x % 2 == 0 ? TileHelpers_55.default.setGfxRaw(n, 1) : TileHelpers_55.default.setGfxRaw(n, 0)),
                            L(a, i, e, n)
                        }
                postMessage({
                    tileGenArray: l.buffer,
                    templateSpawns: M,
                    caveSpawns: b,
                    spawnCoords: w
                }, [l.buffer])
            }
            , e=>{
                const t = e.data
                  , a = new Uint16Array(t.tileGenArray)
                  , i = t.templateSpawns
                  , n = t.caveSpawns
                  , o = t.spawnCoords;
                game.spawnCoords = o,
                this.setupTiles(a, i, n, generateNewWorld)
            }
            );
            worker.postMessage({
                mapSize: game.mapSize,
                seed: Random_71.default.generator.getSeed(),
                zMin: WorldZ.Min,
                zMax: WorldZ.Max,
                zNormal: WorldZ.Overworld,
                zCave: WorldZ.Cave,
                generateNewWorld: generateNewWorld
            })
        }
        setupTiles(e, t, a, i) {
            let n, o, r, s;
            if (Log_60.default.info(Log_60.LogSource.MapGen)("setupTiles", Random_71.default.generator.getSeed()),
            game.tile = new Array(game.mapSizeSq * (WorldZ.Max + 1)),
            i) {
                const t = 325
                  , a = 1300
                  , i = 1e3
                  , l = game.isChallenge ? 475 : 950
                  , u = 600;
                for (r = WorldZ.Min; r <= WorldZ.Max; r++)
                    for (n = 0; n < game.mapSize; n++)
                        for (o = 0; o < game.mapSize; o++) {
                            (s = game.setTile(n, o, r, {})).data = e[r * game.mapSizeSq + o * game.mapSize + n];
                            const d = TileHelpers_55.default.getType(s);
                            switch (d) {
                            case DoodadType.MapleTree:
                            case DoodadType.CoconutTree:
                            case DoodadType.JoshuaTree:
                            case DoodadType.SpruceTree:
                            case DoodadType.CypressTree:
                            case DoodadType.AppleTree:
                                doodadManager.create(d, n, o, r, {
                                    gfx: TileHelpers_55.default.getGfx(s)
                                }),
                                MapGenHelpers.setTileUnderDoodad(s, n, o, d),
                                0 === Random_71.default.int(i) && d === DoodadType.MapleTree && MapGenHelpers.spawnTileEvent(n, o, r);
                                continue
                            }
                            if (r === WorldZ.Overworld)
                                switch (d) {
                                case TerrainType.Seawater:
                                    0 === Random_71.default.int(l) && creatureManager.spawnFromGroup(SpawnGroup.Seawater, n, o, r),
                                    0 === Random_71.default.int(a) && MapGenHelpers.spawnDoodad(TileHelpers_55.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.Dirt:
                                case TerrainType.Grass:
                                case TerrainType.Swamp:
                                    0 === Random_71.default.int(l) && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r),
                                    0 === Random_71.default.int(u) ? itemManager.spawn(void 0, n, o, r) : 0 === Random_71.default.int(t) && MapGenHelpers.spawnDoodad(TileHelpers_55.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.Gravel:
                                case TerrainType.Snow:
                                    0 === Random_71.default.int(l) && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r),
                                    0 === Random_71.default.int(u) && itemManager.spawn(void 0, n, o, r);
                                    break;
                                case TerrainType.ShallowSeawater:
                                    0 === Random_71.default.int(a) && MapGenHelpers.spawnDoodad(TileHelpers_55.default.getType(s), n, o, r),
                                    0 === Random_71.default.int(u) && MapGenHelpers.spawnShoreItem(n, o, r);
                                    break;
                                case TerrainType.DesertSand:
                                    0 === Random_71.default.int(l) && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r),
                                    Random_71.default.int(t) <= 2 && 0 !== Random_71.default.int(u) && MapGenHelpers.spawnDoodad(TileHelpers_55.default.getType(s), n, o, r)
                                }
                            else
                                switch (TileHelpers_55.default.getType(s)) {
                                case TerrainType.Dirt:
                                    const e = Random_71.default.int(u);
                                    0 === Random_71.default.int(l - 125) && creatureManager.spawnFromGroup(SpawnGroup.Any, n, o, r),
                                    e <= 2 && itemManager.spawn(void 0, n, o, r),
                                    Random_71.default.int(t) <= 1 && e > 2 && MapGenHelpers.spawnDoodad(TileHelpers_55.default.getType(s), n, o, r);
                                    break;
                                case TerrainType.FreshWater:
                                case TerrainType.ShallowFreshWater:
                                case TerrainType.DeepFreshWater:
                                    0 === Random_71.default.int(l) && creatureManager.spawnFromGroup(SpawnGroup.CaveWater, n, o, r)
                                }
                        }
            } else
                MapGenHelpers.setupTiles(e);
            if (modManager.getHook(IHookManager_57.Hook.PreLoadWorldDifferences).call(i),
            i) {
                for (let e = 0; e < t.length; e++)
                    MapGenHelpers.spawnTemplate(t[e][0], t[e][1], t[e][2], t[e][3]);
                for (let e = 0; e < a.length; e++) {
                    const t = a[e][0]
                      , i = a[e][1];
                    game.changeTile(TerrainType.CaveEntrance, t, i, WorldZ.Overworld, !1),
                    game.changeTile(TerrainType.CaveEntrance, t, i, WorldZ.Cave, !1);
                    const n = game.getTile(t, i, WorldZ.Overworld);
                    void 0 !== n.doodad && doodadManager.remove(n.doodad);
                    const o = game.getTile(t, i, WorldZ.Cave);
                    void 0 !== o.doodad && doodadManager.remove(o.doodad)
                }
                const e = TileHelpers_55.default.getSuitableSpawnPoint();
                npcManager.spawn(Enums.NPCType.Merchant, e.x, e.y, e.z)
            } else
                MapGenHelpers.loadDifferences();
            Log_60.default.info(Log_60.LogSource.MapGen)("PostGenerateWorld", Random_71.default.generator.getSeed()),
            modManager.getHook(IHookManager_57.Hook.PostGenerateWorld).call(i),
            Log_60.default.info(Log_60.LogSource.MapGen)("finishedLoading", Random_71.default.generator.getSeed()),
            MapGenHelpers.setFinishedLoading()
        }
    }
    exports.default = MapGen270
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("mapgen/MapGen", ["require", "exports", "mapgen/MapGenHelpers", "mapgen/version/2.0.0", "mapgen/version/2.1.0", "mapgen/version/2.2.0", "mapgen/version/2.3.0", "mapgen/version/2.4.0", "mapgen/version/2.5.0", "mapgen/version/2.6.0", "mapgen/version/2.7.0", "utilities/Log", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c) {
    async function m(e) {
        const t = game.mapGenVersion || game.version
          , m = t.split(".")
          , h = parseInt(m[1], 10);
        let y;
        switch (h) {
        case 0:
            y = new i.default;
            break;
        case 1:
            y = new n.default;
            break;
        case 2:
            y = new o.default;
            break;
        case 3:
            y = new r.default;
            break;
        case 4:
            y = new s.default;
            break;
        case 5:
            y = new l.default;
            break;
        case 6:
            y = new u.default;
            break;
        case 7:
            y = new d.default;
            break;
        default:
            y = new l.default,
            p.default.info(p.LogSource.MapGen)("Falling back to MapGen250")
        }
        return p.default.info(p.LogSource.MapGen)(`Using mapgen for ${t}. Seed: ${c.default.generator.getSeed()}. Challenge mode: ${game.isChallenge}.`),
        y.generateWorld(e),
        new Promise(e=>{
            const t = setInterval(()=>{
                a.hasFinishedLoading() && !game.playing && (a.clearFinishedLoading(),
                clearInterval(t),
                e())
            }
            , 10)
        }
        )
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    t.generateWorld = m
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/HookManager", ["require", "exports", "mod/IHookHost", "mod/IHookManager", "utilities/Emitter", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s, l) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const u = new s.default(s.LogSource.HookManager);
    class d {
        constructor(e) {
            this.hookHosts = [],
            this.cachedHooks = {},
            this.modManager = e,
            this.cacheHooks()
        }
        register(e, t="Anonymous") {
            if (!e)
                throw new Error("Invalid hook host");
            return this.hookHosts.includes(e) ? {
                until(...e) {}
            } : (this.hookHosts.push(e),
            t && (Array.isArray(e[a.SYMBOL_HOST_NAME]) || (e[a.SYMBOL_HOST_NAME] = []),
            e[a.SYMBOL_HOST_NAME].push(t)),
            this.cacheHooksForHost(e),
            this.sortHooks(),
            e instanceof n.default ? {
                until: t=>{
                    e instanceof n.default && e.on(t, this.deregister)
                }
            } : void 0)
        }
        deregister(e, t="Anonymous", i=!0) {
            const n = this.hookHosts.indexOf(e);
            if (n < 0)
                return;
            const o = e[a.SYMBOL_HOST_NAME].join(",");
            if (t) {
                const i = e[a.SYMBOL_HOST_NAME];
                if (i.length > 1) {
                    const e = i.indexOf(t);
                    return void (e >= 0 && i.splice(e, 1))
                }
                i.pop()
            }
            if (this.hookHosts.splice(n, 1),
            i) {
                let t = "";
                for (const a of Object.keys(this.cachedHooks)) {
                    const i = this.cachedHooks[a];
                    for (let n = 0; n < i.priorities.length; n++) {
                        const o = i.priorities[n]
                          , r = i[o].indexOf(e);
                        r >= 0 && (i[o].splice(r, 1),
                        t += `${a}[${o}], `,
                        0 === i[o].length && (i.priorities.splice(n, 1),
                        n--,
                        delete i[o],
                        0 === i.priorities.length && delete this.cachedHooks[a]))
                    }
                }
                s.default.info(s.LogSource.HookManager, o)(`Deregistered hooks: ${t.slice(0, -2)}`)
            }
        }
        *getHostsWithHook(e) {
            const t = this.cachedHooks[e];
            if (t)
                for (const e of t.priorities)
                    for (const a of t[e])
                        yield a
        }
        getCachedHook(e) {
            return this.cachedHooks[e]
        }
        cacheHooks() {
            this.cachedHooks = {};
            const e = this.modManager.getMods();
            for (let t = 0; t < e.length; t++)
                this.modManager.isValid(t) && e[t].instance && this.cacheHooksForHost(e[t].instance, this.modManager.getLog(t), e=>this.modManager.isLoaded(t) || this.modManager.isEnabled(t) && -1 !== i.globalHooks.indexOf(e));
            for (const e of this.hookHosts)
                this.cacheHooksForHost(e);
            this.sortHooks()
        }
        sortHooks() {
            for (const e of Object.keys(this.cachedHooks))
                this.cachedHooks[e].priorities.sort((e,t)=>+t - +e)
        }
        cacheHooksForHost(e, t, n) {
            t || (t = e[a.SYMBOL_HOST_NAME] ? new s.default(s.LogSource.HookManager,e[a.SYMBOL_HOST_NAME].join(",")) : u);
            let d = "";
            const p = o.default.values(i.Hook).collect(r.default.toArray)
              , c = Object.assign({}, e[a.SYMBOL_HOOKS]);
            l.default.keys(c).filter(e=>{
                const a = p.includes(e);
                return a || t.warn(`Tried to register an invalid hook "${e}"`),
                a && (!n || n(e))
            }
            ).forEach(t=>{
                this.cachedHooks[t] || (this.cachedHooks[t] = {
                    priorities: []
                });
                const a = c[t] || i.HookPriority.Normal;
                this.cachedHooks[t][a] || (this.cachedHooks[t][a] = [],
                this.cachedHooks[t].priorities.push(a)),
                this.cachedHooks[t][a].push(e),
                d += `${t}[${a}], `
            }
            ),
            d.length > 0 && t.info(`Registered hooks: ${d.slice(0, -2)}`)
        }
    }
    __decorate([l.Bound], d.prototype, "register", null),
    __decorate([l.Bound], d.prototype, "deregister", null),
    t.default = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/Hooks", ["require", "exports", "mod/HookCallFactory", "mod/IHookManager", "mod/IModInfo"], function(e, t, a, i, n) {
    function o(e) {
        return Array.isArray(e) && 3 === e.length && "number" == typeof e[0] && "number" == typeof e[1] && "number" == typeof e[2]
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const r = {
        [i.Hook.CanClientMove]: new a.default(i.Hook.CanClientMove).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanConsumeItem]: new a.default(i.Hook.CanConsumeItem).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanCreatureAttack]: new a.default(i.Hook.CanCreatureAttack).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanCreatureMove]: new a.default(i.Hook.CanCreatureMove).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanCreatureSpawn]: new a.default(i.Hook.CanCreatureSpawn).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanDoodadSpawn]: new a.default(i.Hook.CanDoodadSpawn).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanDropItem]: new a.default(i.Hook.CanDropItem).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanNPCAttack]: new a.default(i.Hook.CanNPCAttack).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanNPCMove]: new a.default(i.Hook.CanNPCMove).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanNPCSpawn]: new a.default(i.Hook.CanNPCSpawn).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanPickupDoodad]: new a.default(i.Hook.CanPickupDoodad).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanPlayerAttack]: new a.default(i.Hook.CanPlayerAttack).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanSeeCreature]: new a.default(i.Hook.CanSeeCreature).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.CanSeeNPC]: new a.default(i.Hook.CanSeeNPC).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetAmbientColor]: new a.default(i.Hook.GetAmbientColor).setExpectedResult(o).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetAmbientColorCave]: new a.default(i.Hook.GetAmbientColorCave).setExpectedResult(o).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetAmbientColorDay]: new a.default(i.Hook.GetAmbientColorDay).setExpectedResult(o).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetAmbientColorNight]: new a.default(i.Hook.GetAmbientColorNight).setExpectedResult(o).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetFogColor]: new a.default(i.Hook.GetFogColor).setExpectedResult(o).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetAmbientLightLevel]: new a.default(i.Hook.GetAmbientLightLevel).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetCreatureSpriteBatchLayer]: new a.default(i.Hook.GetCreatureSpriteBatchLayer).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetMaxSpritesForLayer]: new a.default(i.Hook.GetMaxSpritesForLayer).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetPlayerFieldOfViewRadius]: new a.default(i.Hook.GetPlayerFieldOfViewRadius).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetPlayerMaxHealth]: new a.default(i.Hook.GetPlayerMaxHealth).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.Reduce, !0),
        [i.Hook.GetPlayerMaxWeight]: new a.default(i.Hook.GetPlayerMaxWeight).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.Reduce, !0),
        [i.Hook.GetPlayerMovementIntent]: new a.default(i.Hook.GetPlayerMovementIntent).setExpectedResult(n.TypeFlag.Object).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetPlayerSpriteBatchLayer]: new a.default(i.Hook.GetPlayerSpriteBatchLayer).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetPlayerWeightMovementPenalty]: new a.default(i.Hook.GetPlayerWeightMovementPenalty).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetPlayerWeightStatus]: new a.default(i.Hook.GetPlayerWeightStatus).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetCameraPosition]: new a.default(i.Hook.GetCameraPosition).setExpectedResult(e=>"object" == typeof e && "number" == typeof e.x && "number" == typeof e.y).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetTileLightLevel]: new a.default(i.Hook.GetTileLightLevel).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.GetTilePenalty]: new a.default(i.Hook.GetTilePenalty).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.Reduce),
        [i.Hook.GetZoomLevel]: new a.default(i.Hook.GetZoomLevel).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.IsHumanSwimming]: new a.default(i.Hook.IsHumanSwimming).setExpectedResult(n.TypeFlag.Boolean).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.IsTileBlocked]: new a.default(i.Hook.IsTileBlocked).setExpectedResult(n.TypeFlag.True).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.OnBindLoop]: new a.default(i.Hook.OnBindLoop).setExpectedResult(n.TypeFlag.Number).setReduceStrategy(a.ReduceStrategy.Reduce, !0),
        [i.Hook.OnBuild]: new a.default(i.Hook.OnBuild),
        [i.Hook.OnContainerItemAdd]: new a.default(i.Hook.OnContainerItemAdd),
        [i.Hook.OnContainerItemRemove]: new a.default(i.Hook.OnContainerItemRemove),
        [i.Hook.OnContainerItemUpdate]: new a.default(i.Hook.OnContainerItemUpdate),
        [i.Hook.OnCraft]: new a.default(i.Hook.OnCraft),
        [i.Hook.OnCreateWorld]: new a.default(i.Hook.OnCreateWorld),
        [i.Hook.OnCreatureDamage]: new a.default(i.Hook.OnCreatureDamage),
        [i.Hook.OnCreatureDeath]: new a.default(i.Hook.OnCreatureDeath),
        [i.Hook.OnCreatureSpawn]: new a.default(i.Hook.OnCreatureSpawn),
        [i.Hook.OnCreatureTamed]: new a.default(i.Hook.OnCreatureTamed),
        [i.Hook.OnDigTreasure]: new a.default(i.Hook.OnDigTreasure),
        [i.Hook.OnDisplayMessage]: new a.default(i.Hook.OnDisplayMessage),
        [i.Hook.OnDoodadSpawn]: new a.default(i.Hook.OnDoodadSpawn),
        [i.Hook.OnGameEnd]: new a.default(i.Hook.OnGameEnd),
        [i.Hook.OnGameStart]: new a.default(i.Hook.OnGameStart),
        [i.Hook.OnGameTickEnd]: new a.default(i.Hook.OnGameTickEnd),
        [i.Hook.OnGameTickStart]: new a.default(i.Hook.OnGameTickStart),
        [i.Hook.OnGetTranslation]: new a.default(i.Hook.OnGetTranslation).setExpectedResult(n.TypeFlag.Array).setReduceStrategy(a.ReduceStrategy.Reduce),
        [i.Hook.OnEntityKill]: new a.default(i.Hook.OnEntityKill),
        [i.Hook.OnHumanSkillChange]: new a.default(i.Hook.OnHumanSkillChange),
        [i.Hook.OnInventoryItemAdd]: new a.default(i.Hook.OnInventoryItemAdd),
        [i.Hook.OnInventoryItemRemove]: new a.default(i.Hook.OnInventoryItemRemove),
        [i.Hook.OnInventoryItemUpdate]: new a.default(i.Hook.OnInventoryItemUpdate),
        [i.Hook.OnItemDamage]: new a.default(i.Hook.OnItemDamage).setExpectedResult(n.TypeFlag.Number),
        [i.Hook.OnItemEquip]: new a.default(i.Hook.OnItemEquip),
        [i.Hook.OnItemQuickslot]: new a.default(i.Hook.OnItemQuickslot),
        [i.Hook.OnLanguageChange]: new a.default(i.Hook.OnLanguageChange),
        [i.Hook.OnMove]: new a.default(i.Hook.OnMove).setExpectedResult(n.TypeFlag.Boolean),
        [i.Hook.OnMoveComplete]: new a.default(i.Hook.OnMoveComplete),
        [i.Hook.OnMoveDirectionUpdate]: new a.default(i.Hook.OnMoveDirectionUpdate),
        [i.Hook.OnNoInputReceived]: new a.default(i.Hook.OnNoInputReceived),
        [i.Hook.OnNPCDamage]: new a.default(i.Hook.OnNPCDamage).setExpectedResult(n.TypeFlag.Number),
        [i.Hook.OnNPCDeath]: new a.default(i.Hook.OnNPCDeath).setExpectedResult(n.TypeFlag.Boolean),
        [i.Hook.OnNPCSpawn]: new a.default(i.Hook.OnNPCSpawn),
        [i.Hook.OnOpenBook]: new a.default(i.Hook.OnOpenBook),
        [i.Hook.OnPickupDoodad]: new a.default(i.Hook.OnPickupDoodad),
        [i.Hook.OnPlayerDamage]: new a.default(i.Hook.OnPlayerDamage).setExpectedResult(n.TypeFlag.Number),
        [i.Hook.OnPlayerDeath]: new a.default(i.Hook.OnPlayerDeath).setExpectedResult(n.TypeFlag.Boolean),
        [i.Hook.OnPlayerJoin]: new a.default(i.Hook.OnPlayerJoin),
        [i.Hook.OnPlayerLeave]: new a.default(i.Hook.OnPlayerLeave),
        [i.Hook.OnPlayerTickEnd]: new a.default(i.Hook.OnPlayerTickEnd),
        [i.Hook.OnPlayerTickStart]: new a.default(i.Hook.OnPlayerTickStart),
        [i.Hook.OnPlayerWalkToTilePath]: new a.default(i.Hook.OnPlayerWalkToTilePath),
        [i.Hook.OnQueueSoundEffect]: new a.default(i.Hook.OnQueueSoundEffect).setExpectedResult(n.TypeFlag.Number | n.TypeFlag.Boolean),
        [i.Hook.OnGameScreenVisible]: new a.default(i.Hook.OnGameScreenVisible),
        [i.Hook.OnReadMap]: new a.default(i.Hook.OnReadMap),
        [i.Hook.OnRenderOverlay]: new a.default(i.Hook.OnRenderOverlay),
        [i.Hook.OnSailToCivilization]: new a.default(i.Hook.OnSailToCivilization),
        [i.Hook.OnSpawnCreatureFromGroup]: new a.default(i.Hook.OnSpawnCreatureFromGroup).setExpectedResult(n.TypeFlag.Boolean),
        [i.Hook.OnTileUpdate]: new a.default(i.Hook.OnTileUpdate),
        [i.Hook.OnTurnEnd]: new a.default(i.Hook.OnTurnEnd),
        [i.Hook.OnTurnStart]: new a.default(i.Hook.OnTurnStart),
        [i.Hook.OnUpdateWeight]: new a.default(i.Hook.OnUpdateWeight).setExpectedResult(n.TypeFlag.Number),
        [i.Hook.OnWriteNote]: new a.default(i.Hook.OnWriteNote).setExpectedResult(n.TypeFlag.False).setReduceStrategy(a.ReduceStrategy.First),
        [i.Hook.OnWrittenNote]: new a.default(i.Hook.OnWrittenNote),
        [i.Hook.PostExecuteAction]: new a.default(i.Hook.PostExecuteAction),
        [i.Hook.PostFieldOfView]: new a.default(i.Hook.PostFieldOfView),
        [i.Hook.PostGenerateWorld]: new a.default(i.Hook.PostGenerateWorld),
        [i.Hook.PostRender]: new a.default(i.Hook.PostRender),
        [i.Hook.PostRenderPostProcess]: new a.default(i.Hook.PostRenderPostProcess),
        [i.Hook.PostRenderWorld]: new a.default(i.Hook.PostRenderWorld),
        [i.Hook.PostSaveGame]: new a.default(i.Hook.PostSaveGame),
        [i.Hook.PreExecuteAction]: new a.default(i.Hook.PreExecuteAction).setExpectedResult(n.TypeFlag.Boolean),
        [i.Hook.PreExecuteCommand]: new a.default(i.Hook.PreExecuteCommand).setExpectedResult(n.TypeFlag.Boolean),
        [i.Hook.PreLoadWorldDifferences]: new a.default(i.Hook.PreLoadWorldDifferences),
        [i.Hook.PreRender]: new a.default(i.Hook.PreRender),
        [i.Hook.PreRenderPostProcess]: new a.default(i.Hook.PreRenderPostProcess),
        [i.Hook.PreRenderWorld]: new a.default(i.Hook.PreRenderWorld),
        [i.Hook.PreSaveGame]: new a.default(i.Hook.PreSaveGame),
        [i.Hook.ProcessInput]: new a.default(i.Hook.ProcessInput).setExpectedResult(n.TypeFlag.Boolean),
        [i.Hook.ShouldRender]: new a.default(i.Hook.ShouldRender).setExpectedResult(n.TypeFlag.Number),
        [i.Hook.ShouldDisplayMessage]: new a.default(i.Hook.ShouldDisplayMessage),
        [i.Hook.ShouldStopWalkToTileMovement]: new a.default(i.Hook.ShouldStopWalkToTileMovement).setExpectedResult(n.TypeFlag.Boolean)
    };
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("mod/ModManager", ["require", "exports", "Enums", "language/dictionary/UiTranslation", "language/Translation", "mod/HookCallFactory", "mod/HookManager", "mod/Hooks", "mod/IMod", "mod/IModInfo", "mod/IModManager", "newui/screen/IScreen", "newui/screen/screens/menu/menus/options/TabMods", "utilities/Color", "utilities/enum/EnumManager", "utilities/enum/IEnum", "utilities/Files", "utilities/Log", "utilities/string/Strings"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const S = "undefined" != typeof requirejs ? requirejs : void 0
      , I = {
        required_mods: "dependencies",
        language_files: "languages",
        files: "file"
    }
      , v = new f.default(f.LogSource.Mods);
    class w {
        constructor() {
            this.mods = [],
            this.internalMods = ["argus", "balancingtools", "debugtools", "piratelanguage", "literallyalanguage", "owowhatsthis", "troposphere", "starterquest", "treesonfire", "reincarnate", "helloworld", "alphatracks", "ridiculoushairdos", "poisoundeffects", "growingtester", "tars"],
            this.internalModsElectron = ["starterquest"],
            this.onModInitializedCallbacks = {},
            window.hookManager = new r.default(this)
        }
        async loadAll(e) {
            let t = 0;
            const a = [];
            if (e.multiplayerWorld && e.multiplayerWorld.mods) {
                v.info("Required multiplayer mods", e.multiplayerWorld.mods);
                const o = [];
                for (const r of e.multiplayerWorld.mods) {
                    let e, s, l;
                    if (0 !== (e = r.publishedFileId ? this.getIndexFromPublishId(r.publishedFileId) : this.getIndexFromName(r.name)).length) {
                        for (const a of e) {
                            if (!this.isValid(a)) {
                                s = n.default.ui(i.default.GameMultiplayerInterruptRequiredModUnableToLoad).getString(r);
                                continue
                            }
                            const e = this.getVersion(a);
                            if (e !== r.version) {
                                s = n.default.ui(i.default.GameMultiplayerInterruptRequiredModVersionMismatch).getString(r, e);
                                continue
                            }
                            if (!this.isMultiplayerCompatible(a)) {
                                s = n.default.ui(i.default.GameMultiplayerInterruptRequiredModNotMultiplayerCompatible).getString(r);
                                continue
                            }
                            if (this.isLoaded(a)) {
                                t++,
                                s = void 0,
                                l = void 0,
                                v.warn("Mod already loaded", r);
                                break
                            }
                            const o = this.canLoad(a);
                            if (o === d.CanLoadState.DisabledInMultiplayer) {
                                await this.load(a,t),
                                t++,
                                s = void 0,
                                l = void 0;
                                break
                            }
                            o === d.CanLoadState.Disabled || o === d.CanLoadState.ReqiredModNotLoaded ? l = a : (v.warn("Cannot load mod", r, d.CanLoadState[o]),
                            s = n.default.ui(i.default.GameMultiplayerInterruptRequiredModUnableToLoad).getString(r))
                        }
                        s ? a.push(s) : void 0 !== l && o.push([r, l, !1])
                    } else
                        a.push(n.default.ui(i.default.GameMultiplayerInterruptRequiredModNotInstalled).getString(r))
                }
                if (0 === a.length && o.length > 0) {
                    for (let e = 0; e < o.length; e++) {
                        const t = o[e]
                          , a = t[1];
                        this.isEnabled(a) || (await this.setState(a,u.ModState.Enabled) ? t[2] = !0 : v.warn(`Unable to enable mod "${t[0].name}", proceeding directly to load phase`))
                    }
                    hookManager.cacheHooks();
                    for (const [e,r,s] of o) {
                        const o = this.canLoad(r);
                        o === d.CanLoadState.DisabledInMultiplayer ? (await this.load(r,t),
                        t++,
                        s && (this.mods[r].state = u.ModState.LoadedInMultiplayer,
                        v.info(`Enabled "${e.name}" mod for the multiplayer server.`))) : (v.warn("Cannot load mod", e, d.CanLoadState[o]),
                        a.push(n.default.ui(i.default.GameMultiplayerInterruptRequiredModUnableToLoad).getString(e)))
                    }
                }
            }
            if (!game.getDifficultyOptions().disableMods) {
                let e, a = 1;
                for (; a > 0; )
                    for (a = 0,
                    e = 0; e < this.mods.length; e++)
                        this.isValid(e) && !this.isLoaded(e) && this.canLoad(e) === d.CanLoadState.Loadable && (await this.load(e,t),
                        t++,
                        a++);
                for (e = 0; e < this.mods.length; e++)
                    this.isValid(e) && !this.isLoaded(e) && this.isEnabled(e) && this.getLog(e).warn(`Failed to load. ${d.CanLoadState[this.canLoad(e)].toString()}`)
            }
            return hookManager.cacheHooks(),
            resourceLoader.updateImageOverrides(),
            a.length > 0 ? a.join("\n") : void 0
        }
        isMultiplayerCompatible(e) {
            const t = this.getModFromIndex(e);
            return t.config.multiplayerCompatible || t.config.multiplayerClientside || !t.provides.scripts
        }
        isMultiplayerClientSide(e) {
            const t = this.getModFromIndex(e);
            return t.config.multiplayerClientside || !t.provides.scripts && !t.provides.customizations
        }
        isUnloadable(e) {
            const t = this.getModFromIndex(e);
            return t.config.unloadable || !t.provides.scripts && !t.provides.customizations
        }
        async unloadAll(e=!1) {
            v.info("Unload all", e);
            for (const t of this.mods) {
                if (!t)
                    continue;
                const a = t.state === u.ModState.LoadedInMultiplayer;
                this.isLoaded(t.index) && (await this.unload(t.index),
                a && e && (await this.setState(t.index,u.ModState.Disabled),
                v.info(`Disabled "${t.config.name}" mod which was enabled for the multiplayer server.`)))
            }
            hookManager.cacheHooks(),
            e && (saveData.modManagerSaveData = {},
            saveData.modManagerUnloadable = {})
        }
        async setupMods() {
            const e = steamworks.isDedicatedServer() ? [] : steamworks.isElectron() ? this.internalModsElectron : this.internalMods;
            if (v.info("Setting up mods:", [...e]),
            !steamworks.isElectron()) {
                const t = localStorage.getItem("wayward.mods");
                if (t) {
                    const a = t.toLowerCase().split(",");
                    a && a.length > 0 && (e.push(...a),
                    v.info("Setting up additional mods from localStorage item 'wayward.mods':", a))
                }
            }
            for (const t of e)
                await this.setupMod(t.trim(),u.ModType.Internal);
            steamworks.isElectron() && await steamworks.setupMods(),
            hookManager.cacheHooks()
        }
        saveAll() {
            let e;
            for (v.info("Save all"),
            e = 0; e < this.mods.length; e++)
                this.isLoaded(e) && this.save(e)
        }
        getFile(e, t, a) {
            if (-1 !== t.indexOf("../") || -1 !== t.indexOf("..\\"))
                return !1;
            const i = this.mods[e]
              , n = steamworks.getModPath(i.folderName, i.type, t, i.type !== u.ModType.Internal);
            return !!n && (g.default.getText(n.uriEncodedPath).then(e=>{
                a(e, !0)
            }
            ).catch(e=>{
                a(e, !1)
            }
            ),
            !0)
        }
        async setupMod(e, t, o=u.ModState.Enabled) {
            const r = steamworks.getModPath(e, t);
            if (!r)
                return void v.info("Invalid mod path");
            const s = this.getIndexFromPath(r.path)
              , d = void 0 !== s;
            d && (this.removeMod(s),
            v.info("Mod is already loaded, reloading...", s, e));
            const c = steamworks.getModPath(e, t, "mod.json", t !== u.ModType.Internal);
            if (!c)
                return void v.info(`Ignoring non-mod in mod folder: ${e}`);
            const m = "Visit https://waywardgame.github.io for more information";
            let h, y = 1, w = 0;
            const M = [];
            let b = v;
            return new Promise(async k=>{
                const C = async e=>{
                    if (w++,
                    void 0 !== e && M.push(e),
                    y === w) {
                        if (M.length > 0) {
                            b.warn("Problems loading mod");
                            for (const e of M)
                                b.warn(`${e}`)
                        }
                        if (void 0 !== h && (t === u.ModType.Workshop && steamworks.fillOutWorkshopMod(h),
                        b.info(`Setup at index ${h}`),
                        0 === M.length)) {
                            let e = o;
                            const t = saveDataGlobal.modManagerModState[r.path];
                            void 0 !== t && t !== u.ModState.Error && (e = t);
                            const a = D.compatibleMinorVersions;
                            a.indexOf(gameVersionMinor) < 0 && (e = u.ModState.Disabled),
                            await this.setState(h,e,!0,!1)
                        }
                        k(h)
                    }
                }
                ;
                let D;
                try {
                    D = await g.default .getJson(c.uriEncodedPath)
                } catch (t) {
                    return void C(`Failed to initialize ${e}, unable to load mod.json file '${c.uriEncodedPath}'`)
                }
                if (!(D && D.name && D.description && D.version && D.author && D.compatibleMinorVersions)) {
                    v.warn(`Failed to initialize ${e}, missing required mod.json properties. ${m}`);
                    try {
                        if (t === u.ModType.Workshop && !saveDataGlobal.modManagerSaveData[e] && void 0 !== newui.getScreen(p.ScreenId.MainMenu)) {
                            const a = D.files;
                            if (a && 1 === a.length && "mod.js" === a[0]) {
                                const a = steamworks.getModPath(e, t, "mod.js", !0);
                                if (a) {
                                    const t = await g.default .getText(a.uriEncodedPath);
                                    t && -1 !== t.indexOf("SaveLoad.getFirstFreeSlot(function(slot) { SaveLoad.importSave(slot, json, function(slot, bytes) { if (bytes > 0) { ui.refreshSlots(); ui.displayConfirmDialog(Message.ModImportedSaveGame, [Message.Ok], function() {}); } }); });") && (saveDataGlobal.modManagerSaveData[e] = {
                                        displayedMessage: !0
                                    },
                                    await newui.interruptWithInfo(i.default .MenuModsInterruptUnloadableSaveGameMod,()=>n.default .ui(i.default .MenuModsInterruptUnloadableSaveGameModDescription).get(e)))
                                }
                            }
                        }
                    } catch (e) {}
                    return void C()
                }
                const A = [];
                for (const e in I)
                    e in D && A.push(`The '${e}' property of mod.json is no longer supported, replaced with '${I[e]}'`);
                if (A.length > 0) {
                    v.warn(`Unable to initialize ${D.name} as it is out of date.`);
                    for (const e of A)
                        v.warn(e);
                    return v.warn(m),
                    void C()
                }
                const P = {
                    index: -1,
                    loadOrder: -1,
                    config: D = T.default.fixObjectCaseStyle(D, a.CaseStyle.CamelCase),
                    type: t,
                    state: u.ModState.Error,
                    folderName: e,
                    path: r.path,
                    provides: {
                        scripts: !!D.file,
                        languages: 0,
                        languageExtensions: 0,
                        stylesheets: 0,
                        imageOverrides: !!D.imageOverrides,
                        customizations: !!D.customizations
                    },
                    publishedFileId: D.publishedFileId,
                    log: new f.default(f.LogSource.Mod,D.name || "ERROR")
                };
                h = this.mods.length,
                void 0 !== s ? (h = s,
                this.mods[h] = P) : this.mods.push(P),
                P.index = h,
                b = P.log;
                const G = D.languages;
                if (G) {
                    P.languages = [];
                    for (const a of G) {
                        const i = steamworks.getModPath(e, t, `${a}.json`, t !== u.ModType.Internal);
                        i ? ((async()=>{
                            const e = await g.default .getJson(i.path).catch (e=>{b.error(`Unable to load the language file '${i.path}': ${e}`),k()});
                            e && ("name"in e ? P.provides.languages++ : P.provides.languageExtensions++)
                        }
                        )(),
                        P.languages.push({
                            path: i.uriEncodedPath
                        })) : b.warn(`The language file '${a}' does not exist`)
                    }
                }
                const R = D.stylesheets;
                if (R) {
                    P.stylesheets = [];
                    for (let a of R)
                        a = `${a}.css`,
                        steamworks.getModPath(e, t, a, t !== u.ModType.Internal) ? (P.stylesheets.push(a),
                        P.provides.stylesheets++) : b.warn(`The stylesheet '${a}' does not exist`)
                }
                if (D.imageOverrides) {
                    const a = steamworks.getModPath(e, t, "imageOverrides.json", t !== u.ModType.Internal);
                    void 0 === a ? b.warn("Unable to load image overrides") : (y++,
                    g.default.getJson(a.uriEncodedPath).then(e=>{
                        P.imageOverrides = e,
                        b.info("Loaded the image overrides"),
                        C()
                    }
                    ).catch(e=>{
                        C(`Unable to load the image overrides file '${a.uriEncodedPath}': ${e}`)
                    }
                    ))
                }
                if (D.customizations) {
                    const i = steamworks.getModPath(e, t, "customizations.json", t !== u.ModType.Internal);
                    void 0 === i ? b.warn("Unable to load customizations") : (y++,
                    g.default.getJson(i.uriEncodedPath).then(e=>{
                        P.customizations = T.default.fixObjectCaseStyle(e, a.CaseStyle.CamelCase),
                        b.info("Loaded the customizations"),
                        C()
                    }
                    ).catch(e=>{
                        C(`Unable to load the customizations file '${i.uriEncodedPath}': ${e}`)
                    }
                    ))
                }
                let x = P.config.file;
                if (x) {
                    function B(...e) {
                        C(`Unable to initialize mod. ${e.join(",")}`)
                    }
                    x.endsWith(".js") && (x = x.slice(0, -3));
                    const a = steamworks.getModPath(e, t, x);
                    if (!a)
                        return void B(`Failed to load file ${x} (Invalid path)`);
                    if (!S)
                        return void B("An internal error occured (0x951a6b11)");
                    try {
                        const e = a.uriEncodedPath.replace(/^mods\/mods\/(?=\.\.\/\.\.\/)/, "");
                        if (d) {
                            const e = r.uriEncodedPath.replace(/^mods\/mods\/(?=\.\.\/\.\.\/)/, "")
                              , t = S.s.contexts._;
                            for (const a of Object.keys(t.defined))
                                a.startsWith(e) && S.undef(a)
                        }
                        S([e], e=>{
                            try {
                                if (P.instance = new e.default(h),
                                !P.instance)
                                    throw new Error("Invalid mod object");
                                P.instance.emit(l.ModEvent.Setup),
                                "hooks"in D && b.warn('is using the "hooks" field in its config, which has been removed. See "mod/Mod/HookMethod"'),
                                C()
                            } catch (e) {
                                B("Failed to initialize mod class.", e.toString())
                            }
                        }
                        , e=>{
                            B(`Could not initialize ${r.path}`, e ? e.toString() : "")
                        }
                        )
                    } catch (e) {
                        B(e.toString())
                    }
                } else
                    C()
            }
            )
        }
        removeMod(e, t=!1) {
            if (t) {
                const t = this.getIdentifier(e);
                delete saveData.modManagerSaveData[t],
                delete saveDataGlobal.modManagerSaveData[t],
                delete saveDataGlobal.modManagerModState[this.getPath(e)]
            }
            delete this.mods[e]
        }
        getMods() {
            return this.mods
        }
        getLoadedMods() {
            const e = [];
            for (let t = 0; t < this.mods.length; t++)
                this.isLoaded(t) && e.push(this.mods[t]);
            return e.sort((e,t)=>e.loadOrder > t.loadOrder ? 1 : -1)
        }
        getLoadedModByName(e) {
            for (let t = 0; t < this.mods.length; t++)
                if (this.isLoaded(t) && this.getName(t) === e)
                    return this.mods[t]
        }
        getModFromIndex(e) {
            return this.mods[e]
        }
        getEnabledMods() {
            const e = [];
            for (let t = 0; t < this.mods.length; t++)
                this.isEnabled(t) && e.push(t);
            return e
        }
        getHook(e, t) {
            const a = s.default[e];
            return a ? (a.setDefault(t),
            a) : (f.default.warn(f.LogSource.HookManager)(`A new hook call factory was created, for the hook ${e}`),
            new o.default(e,t))
        }
        async load(e, t) {
            const a = this.getLog(e);
            try {
                a.info("Loading");
                const i = this.mods[e];
                if (i.loadOrder = t,
                i.provides.scripts) {
                    const e = i.instance;
                    e && (await e.emitAsync(l.ModEvent.PreLoad),
                    e.onLoad())
                }
                await this.setState(e,u.ModState.Loaded),
                a.info("Loaded")
            } catch (t) {
                a.warn("Error loading mod", t),
                await this.setState(e,u.ModState.Error)
            }
        }
        async unload(e, t=!1) {
            const a = this.getLog(e);
            this.save(e);
            try {
                const i = this.mods[e].instance;
                i && (i.onUnload(),
                await i.emitAsync(l.ModEvent.Unload),
                i.emit(l.ModEvent.Unallocate)),
                await this.setState(e,u.ModState.Enabled,!1,t,void 0,!0),
                a.info("Unloaded")
            } catch (e) {
                a.warn("Error unloading mod", e)
            }
        }
        save(e) {
            const t = this.getIdentifier(e);
            saveData.modManagerUnloadable[t] = {
                name: this.getName(e),
                unloadable: this.isUnloadable(e)
            }
        }
        async reloadByName(e, t=!0) {
            const a = this.getIndexFromName(e);
            if (0 === a.length)
                return !1;
            for (const e of a)
                await this.reload(e,!1);
            return t && hookManager.cacheHooks(),
            !0
        }
        async reload(e, t=!0) {
            if (!this.isValid(e))
                return !1;
            const a = this.getLog(e)
              , i = this.getType(e);
            if (i === u.ModType.Workshop)
                return a.warn("Cannot reload workshop mods"),
                !1;
            const n = this.isLoaded(e);
            n && await this.unload(e);
            const o = this.getState(e);
            await this.setState(e,u.ModState.Disabled),
            saveDataGlobal.modManagerModState[this.getPath(e)] = o,
            a.info(`Reloading at index ${e}`);
            const r = await this.setupMod(this.getFolderName(e),this.getType(e));
            if (n && void 0 !== r && await this.load(r,this.mods[r].loadOrder),
            t && hookManager.cacheHooks(),
            void 0 !== r && game.playing) {
                const e = this.mods[r].instance;
                e && e.onGameStart && e.onGameStart(game.isLoadingSave, saveDataGlobal.gamePlayedCount)
            }
            return !0
        }
        isValid(e) {
            return !!this.mods[e]
        }
        isEnabled(e) {
            return this.isValid(e) && this.getState(e) === u.ModState.Enabled
        }
        isLoaded(e) {
            return this.isValid(e) && (this.getState(e) === u.ModState.Loaded || this.getState(e) === u.ModState.LoadedInMultiplayer)
        }
        getIdentifier(e) {
            return this.getPublishFileId(e) || this.getName(e)
        }
        getConfig(e) {
            return "object" == typeof e ? e.config : this.mods[e] ? this.mods[e].config : void 0
        }
        getName(e) {
            return this.isValid(e) ? this.mods[e].config.name : "Unknown"
        }
        getLog(e) {
            return this.mods[e].log
        }
        getDescription(e) {
            return this.mods[e].config.description
        }
        getTags(e) {
            const t = new Set(this.mods[e].config.tags);
            this.isMultiplayerClientSide(e) && t.add("Clientside"),
            this.isMultiplayerCompatible(e) && t.add("Multiplayer");
            const a = this.getProvided(e);
            return a.customizations && t.add("Character"),
            a.languages && t.add("Language"),
            t
        }
        getVersion(e) {
            return this.mods[e].config.version
        }
        getLastUpdatedDate(e) {
            if (this.mods[e].lastUpdated)
                return this.mods[e].lastUpdated
        }
        getInstallDate(e) {
            if (this.mods[e].installDate)
                return this.mods[e].installDate
        }
        getCreatedDate(e) {
            if (this.mods[e].createdDate)
                return this.mods[e].createdDate
        }
        getAuthor(e) {
            return this.mods[e].config.author
        }
        getType(e) {
            return this.mods[e].type
        }
        getRequiredMods(e) {
            const t = this.mods[e].config.dependencies;
            return t || []
        }
        getPath(e) {
            return this.mods[e].path
        }
        getFolderName(e) {
            return this.mods[e].folderName
        }
        getPublishFileId(e) {
            return this.mods[e].publishedFileId
        }
        getSteamIdOwner(e) {
            return this.mods[e].steamIDOwner
        }
        getProvided(e) {
            return this.mods[e].provides
        }
        canLoad(e, t=!1, a=0) {
            if (this.getState(e) === u.ModState.Error)
                return d.CanLoadState.ModLoadError;
            if (a > 10)
                return d.CanLoadState.DependencyIssue;
            const i = this.mods[e].config
              , n = i.compatibleMinorVersions;
            if (n.indexOf(gameVersionMinor) < 0)
                return d.CanLoadState.IncompatibleVersion;
            const o = this.getRequiredMods(e);
            if (o)
                for (const i of o) {
                    const n = this.getIndexFromPublishId(i.toString());
                    if (0 === n.length)
                        return d.CanLoadState.MissingRequiredMod;
                    let o = !1
                      , r = !1;
                    for (const i of n) {
                        if (i === e)
                            return d.CanLoadState.ModRequiresItself;
                        if (t) {
                            const e = this.canLoad(i, !0, a + 1);
                            if (e === d.CanLoadState.Loadable) {
                                o = !0,
                                r = !1;
                                break
                            }
                            e !== d.CanLoadState.Disabled && (r = !0)
                        } else if (this.isLoaded(i)) {
                            o = !0,
                            r = !1;
                            break
                        }
                    }
                    if (r)
                        return d.CanLoadState.CannotLoadRequiredMod;
                    if (!o)
                        return d.CanLoadState.ReqiredModNotLoaded
                }
            if (this.getType(e) === u.ModType.Workshop) {
                const t = this.getPublishFileId(e);
                for (let e = 0; e < this.mods.length; e++)
                    if (this.isValid(e) && (this.isEnabled(e) || this.isLoaded(e)) && this.getType(e) !== u.ModType.Workshop && this.getPublishFileId(e) === t)
                        return d.CanLoadState.LocalModPrecedence
            }
            return this.isEnabled(e) ? multiplayer.isConnected() && !this.isMultiplayerClientSide(e) ? d.CanLoadState.DisabledInMultiplayer : d.CanLoadState.Loadable : d.CanLoadState.Disabled
        }
        canLoadFromIdentifier(e) {
            let t = e;
            for (const a of this.getIndexFromIdentifier(e)) {
                t = this.getName(a);
                const e = this.canLoad(a, !0);
                if (e === d.CanLoadState.Loadable || e === d.CanLoadState.Disabled)
                    return {
                        name: t,
                        loadable: !0
                    }
            }
            return {
                name: t,
                loadable: !1
            }
        }
        getIndexFromIdentifier(e) {
            return this.getIndexFromPublishId(e).concat(this.getIndexFromName(e))
        }
        getIndexFromName(e) {
            const t = [];
            for (let a = 0; a < this.mods.length; a++)
                this.isValid(a) && this.getName(a) === e && t.push(a);
            return t
        }
        getIndexFromPublishId(e) {
            const t = [];
            for (let a = 0; a < this.mods.length; a++)
                this.isValid(a) && this.getPublishFileId(a) === e && t.push(a);
            return t
        }
        getIndexFromPath(e) {
            for (let t = 0; t < this.mods.length; t++)
                if (this.isValid(t) && this.getPath(t) === e)
                    return t
        }
        isEnabledByName(e) {
            const t = this.getIndexFromName(e);
            if (t.length > 0)
                for (const e of t)
                    if (this.isEnabled(e))
                        return !0;
            return !1
        }
        isLoadedByName(e) {
            const t = this.getIndexFromName(e);
            if (t.length > 0)
                for (const e of t)
                    if (this.isLoaded(e))
                        return !0;
            return !1
        }
        setPublishId(e, t) {
            this.mods[e].publishedFileId = t
        }
        setSteamIdOwner(e, t) {
            this.mods[e].steamIDOwner = t
        }
        setLastUpdated(e, t) {
            this.mods[e].lastUpdated = t
        }
        setInstallDate(e, t) {
            this.mods[e].installDate = t
        }
        setCreatedDate(e, t) {
            this.mods[e].createdDate = t
        }
        getState(e) {
            return this.mods[e].state
        }
        isInitializing(e) {
            return this.mods[e].state
        }
        async setState(e, t, a=!1, i=!1, n, o=!1) {
            const r = this.mods[e];
            if (!r || !a && r.state === u.ModState.Error)
                return !1;
            if (r.state === t)
                return !0;
            let s;
            r.state = u.ModState.ChangingState;
            let d = !1;
            if (t !== u.ModState.Enabled || r.initialized || o)
                t === u.ModState.Disabled && (d = this.uninitialize(e));
            else {
                s = r.instance,
                r.initialized = !0,
                s && await s.emitAsync(l.ModEvent.PreInitialize),
                this.initializeCustomizations(e),
                this.initializeStylesheets(e),
                await this.initializeLanguages(e),
                s && s.onInitialize();
                const t = this.onModInitializedCallbacks[e];
                if (t)
                    for (const e of t)
                        e()
            }
            return r.state = t,
            t !== u.ModState.Loaded && t !== u.ModState.LoadedInMultiplayer && (saveDataGlobal.modManagerModState[this.getPath(e)] = t),
            i && hookManager.cacheHooks(),
            r.imageOverrides && resourceLoader.updateImageOverrides(),
            t === u.ModState.Disabled && d && (s = r.instance) && s.onUninitialized && s.onUninitialized(),
            !0
        }
        uninitialize(e) {
            const t = this.getLog(e);
            try {
                const a = this.mods[e];
                if (!a.initialized)
                    return !1;
                if (a.initialized = !1,
                t.info(`uninitialize (${this.getIdentifier(e)})`),
                c.default.deleteModOptions(e),
                a.stylesheets)
                    for (const e of a.stylesheets) {
                        const t = steamworks.getModPath(a.folderName, a.type, e, a.type !== u.ModType.Internal);
                        t && t.path && newui.removeStylesheet(t.path)
                    }
                if (a.languages && a.state !== u.ModState.Enabled)
                    for (const e of a.languages)
                        e.instance && languageManager.remove(e.instance);
                h.default.unallocateMod(e);
                const i = a.instance;
                return i && (i.onUninitialize(),
                i.emit(l.ModEvent.Uninitialize)),
                !0
            } catch (a) {
                return t.warn(`[${this.getName(e)}] Failed to uninitialize`, a),
                !1
            }
        }
        uninitializeAll() {
            for (let e = 0; e < this.mods.length; e++)
                this.isValid(e) && this.uninitialize(e)
        }
        initializeStylesheets(e) {
            const t = this.getModFromIndex(e);
            if (t.stylesheets)
                for (const a of t.stylesheets) {
                    const i = steamworks.getModPath(t.folderName, t.type, a, t.type !== u.ModType.Internal);
                    i && i.path ? (newui.addStylesheet(i.path),
                    this.getLog(e).info(`Loaded the stylesheet '${a}'`)) : this.getLog(e).warn(`Could not retrieve the stylesheet '${a}'`)
                }
        }
        async initializeLanguages(e) {
            const t = this.getModFromIndex(e)
              , a = this.getLog(e);
            if (!t.languages)
                return;
            const i = [];
            for (const e of t.languages)
                e.path ? i.push(new Promise(async t=>{
                    const i = await g.default .getJson(e.path).catch (i=>{a.error(`Unable to load the language file '${e.path}': ${i}`),t()});
                    if (i) {
                        const t = languageManager.deserialize(i);
                        languageManager.add(t),
                        e.instance = t
                    } else
                        a.warn(`Can't parse the language file '${e.path}'`);
                    t()
                }
                )) : e.instance && languageManager.add(e.instance);
            return Promise.all(i)
        }
        initializeCustomizations(e) {
            const t = this.getModFromIndex(e);
            if (t.customizations) {
                if (t.customizations.hairStyles)
                    for (const a of t.customizations.hairStyles) {
                        let t;
                        "string" == typeof a ? t = {
                            name: a,
                            modIndex: e
                        } : (t = {
                            name: a.name,
                            modIndex: e
                        },
                        a.path && (t.imagePath = a.path)),
                        h.default.allocate(e, y.EnumId.HairStyle, t.name, t)
                    }
                if (t.customizations.hairColors)
                    for (const a of t.customizations.hairColors)
                        h.default.allocate(e, y.EnumId.HairColor, a, {
                            color: m.default(a),
                            modIndex: e
                        });
                if (t.customizations.skinColors)
                    for (const a of t.customizations.skinColors)
                        h.default.allocate(e, y.EnumId.SkinColor, a, {
                            color: m.default(a),
                            modIndex: e
                        })
            }
        }
    }
    t.default = w
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/matchmaking/Matchmaking", ["require", "exports", "multiplayer/matchmaking/IMatchmaking", "utilities/Log"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const n = new i.default(i.LogSource.Matchmaking);
    class o {
        constructor(e, t, a, i) {
            this.info = e,
            this.onConnected = t,
            this.onCloseOrError = a,
            this.onMessage = i,
            this.connect()
        }
        getIdentifier() {
            return this.info.identifier
        }
        getChannel() {
            return this.info.channel
        }
        isConnected() {
            return !(!this.webSocket || 1 !== this.webSocket.readyState)
        }
        connect() {
            this.disconnect();
            let e = this.info.matchmakingServer;
            this.info.isDedicatedServer && (e += `/${this.info.identifier}`),
            this.webSocket = new WebSocket(`ws://${e}`),
            this.webSocket.binaryType = "arraybuffer",
            this.webSocket.onopen = (()=>{
                n.info(`Connected to matchmaking server ${this.info.matchmakingServer} [${e}] as ${this.getIdentifier()}`),
                this.onConnected(this)
            }
            ),
            this.webSocket.onclose = this.webSocket.onerror = (e=>{
                const t = e || {};
                n.info(`Disconnected from matchmaking server ${this.info.matchmakingServer}. Code: ${t.code}. Reason: ${t.reason}. Clean: ${t.wasClean}`),
                this.onCloseOrError(this)
            }
            ),
            this.webSocket.onmessage = (e=>{
                if (e.data instanceof ArrayBuffer)
                    return void this.onMessage(this, e.data);
                let t = JSON.parse(e.data);
                t && t.data && (t = t.data),
                t && void 0 !== t.targetMatchmakingIdentifier && t.targetMatchmakingIdentifier !== this.getIdentifier() ? steamworks.multiplayerLog(`onMatchmakingServerMessage - ignoring ${a.MatchmakingMessageDataType[t.type]} message from ${t.matchmakingIdentifier} because it's targeting ${t.targetMatchmakingIdentifier}`) : this.onMessage(this, t)
            }
            )
        }
        disconnect() {
            this.webSocket && (steamworks.multiplayerLog(`Disconnected from matchmaking server ${this.info.matchmakingServer}`),
            this.webSocket.onclose = (()=>{}
            ),
            this.webSocket.onerror = (()=>{}
            ),
            this.webSocket.close(),
            this.webSocket = void 0)
        }
        send(e, t) {
            if (!this.webSocket || !this.isConnected())
                return;
            if (e instanceof ArrayBuffer || e instanceof Uint8Array)
                return void this.webSocket.send(e);
            e.matchmakingIdentifier = this.getIdentifier();
            const i = {
                channel: t,
                data: e
            };
            this.webSocket.send(JSON.stringify(i)),
            e.type !== a.MatchmakingMessageDataType.UpdateDirectory && n.info(`Sent ${a.MatchmakingMessageDataType[e.type]} message to ${void 0 !== e.targetMatchmakingIdentifier ? e.targetMatchmakingIdentifier : "everyone"}`, i)
        }
    }
    t.Matchmaking = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/networking/Connection", ["require", "exports", "Enums", "multiplayer/IMultiplayer", "multiplayer/packets/server/KeepAlivePacket", "utilities/Log"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const r = 12e4;
    class s {
        constructor(e) {
            this._matchmakingInfo = e,
            this._state = a.ConnectionState.Connecting,
            this._queuedData = [],
            this.queuedPackets = []
        }
        close() {
            this.setState(a.ConnectionState.Disconnecting),
            this.clearTimeout(),
            this._clearKeepAliveInterval()
        }
        addConnectionTimeout() {
            this.addTimeout(r, ()=>{
                o.default.warn(o.LogSource.Multiplayer)("Connection timed out", this._matchmakingInfo),
                multiplayer.closeConnection(i.DisconnectReason.ConnectionTimeout, this)
            }
            )
        }
        addTimeout(e, t) {
            this.clearTimeout(),
            this._timeoutId = setTimeout(t, e)
        }
        clearTimeout() {
            void 0 !== this._timeoutId && (clearTimeout(this._timeoutId),
            this._timeoutId = void 0)
        }
        addKeepAliveTimeout() {
            this.addTimeout(i.keepAliveTimeout, ()=>{
                o.default.warn(o.LogSource.Multiplayer)("Player timed out from a keep alive packet", this.playerIdentifier, this.pid),
                multiplayer.closeConnection(i.DisconnectReason.KeepAliveTimeout, this)
            }
            )
        }
        startKeepAlive() {
            this._clearKeepAliveInterval(),
            this._keepAliveIntervalId = setInterval(()=>{
                const e = new n.default;
                e.send()
            }
            , i.keepAliveInterval)
        }
        getState() {
            return this._state
        }
        setState(e) {
            this._state = e,
            e === a.ConnectionState.Ready && this.clearTimeout()
        }
        queuePacketData(e) {
            this._queuedData.push({
                data: e,
                byteOffset: 0,
                sendAfter: i.networkingOptions.fakeRoundTripTime > 0 ? performance.now() + i.networkingOptions.fakeRoundTripTime / 2 : void 0
            }),
            this.processQueuedData()
        }
        processQueuedData() {
            if (0 === this._queuedData.length)
                return;
            const e = this._queuedData[0];
            if (void 0 !== e.sendAfter && e.sendAfter > performance.now())
                return void setTimeout(this.processQueuedData.bind(this), 1);
            let t = !1;
            try {
                const a = e.data;
                a.byteLength - e.byteOffset < i.networkingOptions.chunkSize ? (t = !0,
                this.send(new Uint8Array(a,e.byteOffset))) : this.send(new Uint8Array(a,e.byteOffset,i.networkingOptions.chunkSize)),
                e.byteOffset += i.networkingOptions.chunkSize
            } catch (a) {
                a instanceof Error && "WebSocket is not open: readyState 2 (CLOSING)" === a.message ? t = !0 : (void 0 === e.retries ? e.retries = 1 : e.retries++,
                t = e.retries >= 3,
                o.default.error(o.LogSource.Multiplayer)(`Failed to send data to ${this.playerIdentifier}`, a))
            }
            t ? (this._queuedData.splice(0, 1),
            this.processQueuedData()) : setTimeout(this.processQueuedData.bind(this), 0)
        }
        _clearKeepAliveInterval() {
            void 0 !== this._keepAliveIntervalId && (clearInterval(this._keepAliveIntervalId),
            this._keepAliveIntervalId = void 0)
        }
    }
    t.Connection = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/networking/WebRTCConnection", ["require", "exports", "Enums", "multiplayer/IMultiplayer", "multiplayer/matchmaking/IMatchmaking", "multiplayer/networking/Connection", "utilities/Log"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const s = new r.default(r.LogSource.WebRTCConnection);
    class l extends o.Connection {
        constructor(e, t, a, o, r, l) {
            super(e),
            this.sendMatchmakingMessage = o,
            this.onData = r,
            this.onConnected = l,
            this.matchmakingIdentifier = t,
            this._peerConnection = new RTCPeerConnection(a),
            void 0 !== e ? this._peerConnection.ondatachannel = (e=>{
                s.info("onDataChannelReceived", this.matchmakingIdentifier),
                this._onDataChannelReceived(e.channel)
            }
            ) : (this._onDataChannelReceived(this._peerConnection.createDataChannel("data")),
            i.networkingOptions.stopWebRtc ? s.warn("Not responding to incoming webrtc connection") : steamworks.isElectron() ? this._peerConnection.onnegotiationneeded = (async()=>{
                await this._onNegotiationNeeded()
            }
            ) : this._onNegotiationNeeded()),
            this._peerConnection.onsignalingstatechange = (e=>{
                s.info("onSignalingStateChange", this.matchmakingIdentifier, this._peerConnection.signalingState)
            }
            ),
            this._peerConnection.onicegatheringstatechange = (e=>{
                s.info("onIceGatheringStateChange", this.matchmakingIdentifier, this._peerConnection.iceGatheringState)
            }
            ),
            this._peerConnection.oniceconnectionstatechange = (e=>{
                const t = this._peerConnection.iceConnectionState;
                s.info("onIceConnectionStateChange", this.matchmakingIdentifier, t, this._peerConnection.iceGatheringState, this._peerConnection.signalingState),
                this._onIceConnectionStateChange(t)
            }
            ),
            this._peerConnection.onicecandidate = (e=>{
                if (e.candidate) {
                    this.sendMatchmakingMessage({
                        type: n.MatchmakingMessageDataType.IceCandidate,
                        targetMatchmakingIdentifier: this.matchmakingIdentifier,
                        iceCandidate: e.candidate.toJSON()
                    });
                    const t = e.candidate.candidate;
                    if (t) {
                        const e = this._parseIceCandidate(t);
                        s.info(`Gathered ice candidate. type: ${e.type}, protocol: ${e.protocol}, address: ${e.address}, port: ${e.port}`)
                    }
                }
            }
            )
        }
        isConnected() {
            return !(!this._dataChannel || "open" !== this._dataChannel.readyState)
        }
        close() {
            super.close(),
            this._dataChannel && (this._dataChannel.onmessage = (()=>{}
            ),
            this._dataChannel.close(),
            this._dataChannel = void 0),
            this._peerConnection.ondatachannel = (()=>{}
            ),
            this._peerConnection.onsignalingstatechange = (()=>{}
            ),
            this._peerConnection.onicegatheringstatechange = (()=>{}
            ),
            this._peerConnection.oniceconnectionstatechange = (()=>{}
            );
            try {
                this._peerConnection.close()
            } catch (e) {
                s.warn("Failed to close peer connection", e)
            }
        }
        send(e) {
            void 0 !== this._dataChannel ? this._dataChannel.send(e) : s.error("Cannot send data to an invalid datachannel", this.playerIdentifier)
        }
        async processMatchmakingMessage(e) {
            if (e instanceof ArrayBuffer)
                return !1;
            switch (e.type) {
            case n.MatchmakingMessageDataType.IceCandidate:
            case n.MatchmakingMessageDataType.SessionDescription:
                if (e.type === n.MatchmakingMessageDataType.IceCandidate)
                    try {
                        await this._peerConnection.addIceCandidate(new RTCIceCandidate(e.iceCandidate))
                    } catch (e) {
                        s.error("Failed to add ice candidate", e)
                    }
                else {
                    const t = e.sessionDescription;
                    if (await this._peerConnection.setRemoteDescription(t),
                    "offer" === t.type) {
                        const e = await this._peerConnection.createAnswer();
                        await this._onDescriptionCreated(e)
                    }
                }
                return !0
            }
            return !1
        }
        _onDataChannelMessage(e) {
            e.isTrusted ? this.onData(e.data) : s.info("An untrusted event was received")
        }
        async _onNegotiationNeeded() {
            const e = this._peerConnection.iceConnectionState;
            s.info("onNegotiationNeeded", this.matchmakingIdentifier, e);
            const t = await this._peerConnection.createOffer();
            await this._onDescriptionCreated(t)
        }
        _onDataChannelReceived(e) {
            this._dataChannel = e,
            this._dataChannel.binaryType = "arraybuffer",
            this._dataChannel.onopen = this._dataChannel.onclose = this._dataChannel.onerror = (()=>{
                this._onDataChannelChanged()
            }
            ),
            this._dataChannel.onmessage = (e=>{
                this._onDataChannelMessage(e)
            }
            )
        }
        _onDataChannelChanged() {
            if (this._dataChannel)
                switch (s.info("onDataChannelChanged", this.matchmakingIdentifier, this._dataChannel.readyState),
                this._dataChannel.readyState) {
                case "open":
                    this.setState(a.ConnectionState.Connected),
                    this.onConnected && this.onConnected(this._matchmakingInfo);
                    break;
                case "closed":
                    multiplayer.isServer() ? multiplayer.closeConnection(i.DisconnectReason.Left, this) : multiplayer.disconnectAndResetGameState(i.DisconnectReason.ServerShutdown)
                }
        }
        _onIceConnectionStateChange(e) {
            switch (e) {
            case "completed":
                this._peerConnection.oniceconnectionstatechange = (()=>{
                    "disconnected" === this._peerConnection.iceConnectionState && "complete" === this._peerConnection.iceGatheringState && "stable" === this._peerConnection.signalingState && (s.info("Passing real disconnect signal", this.matchmakingIdentifier),
                    this._onIceConnectionStateChange("disconnected"))
                }
                );
                break;
            case "disconnected":
            case "closed":
                multiplayer.isServer() ? multiplayer.closeConnection(i.DisconnectReason.Left, this) : multiplayer.disconnectAndResetGameState(i.DisconnectReason.LostConnection)
            }
        }
        async _onDescriptionCreated(e) {
            s.info("onDescriptionCreated", this.matchmakingIdentifier);
            try {
                await this._peerConnection.setLocalDescription(e);
                const t = this._peerConnection.localDescription;
                t && this.sendMatchmakingMessage({
                    type: n.MatchmakingMessageDataType.SessionDescription,
                    targetMatchmakingIdentifier: this.matchmakingIdentifier,
                    sessionDescription: t.toJSON()
                })
            } catch (e) {
                s.info("Failed to set local description", e)
            }
        }
        _parseIceCandidate(e) {
            const t = "candidate:"
              , a = e.indexOf("candidate:") + "candidate:".length
              , [i,n,o,r,s,l,,u] = e.substr(a).split(" ");
            return {
                component: n,
                type: u,
                foundation: i,
                protocol: o,
                address: s,
                port: l,
                priority: r
            }
        }
    }
    __decorate([Override], l.prototype, "isConnected", null),
    __decorate([Override], l.prototype, "close", null),
    __decorate([Override], l.prototype, "send", null),
    __decorate([Override], l.prototype, "processMatchmakingMessage", null),
    t.WebRTCConnection = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/networking/WebRTCWithFallbackConnection", ["require", "exports", "multiplayer/matchmaking/IMatchmaking", "multiplayer/networking/Connection", "multiplayer/networking/WebRTCConnection", "newui/INewUi", "utilities/Log"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const s = 6e3;
    class l extends i.Connection {
        constructor(e, t, a, i, l, u) {
            super(e),
            this.onConnected = u,
            this._webRTCTimeoutId = setTimeout(async()=>{
                r.default.warn(r.LogSource.Multiplayer)("WebRTC timed out."),
                this._webRTCTimeoutId = void 0,
                this._webRTCConnection && this._webRTCConnection.close(),
                void 0 !== this._hostIpAddress ? (r.default.warn(r.LogSource.WebRTCConnection)("WebRTC didn't work. Attempting to connect to the players dedicated server", this._hostIpAddress),
                newui.cancel(o.UiApiEvent.InterruptClose),
                await newui.hideLoadingInterrupt(),
                multiplayer.joinServer(multiplayer.getDedicatedServerMatchmakingInfo(this._hostIpAddress))) : multiplayer.displayJoinServerRetryDialog(e)
            }
            , s),
            this._webRTCConnection = new n.WebRTCConnection(e,t,a,i,l,this._onConnected.bind(this))
        }
        getState() {
            return this._webRTCConnection.getState()
        }
        setState(e) {
            this._webRTCConnection.setState(e)
        }
        isConnected() {
            return this._webRTCConnection.isConnected()
        }
        close() {
            super.close(),
            void 0 !== this._webRTCTimeoutId && (clearTimeout(this._webRTCTimeoutId),
            this._webRTCTimeoutId = void 0),
            this._webRTCConnection.close()
        }
        send(e) {
            this._webRTCConnection.send(e)
        }
        async processMatchmakingMessage(e) {
            switch (e.type) {
            case a.MatchmakingMessageDataType.HostIpAddress:
                return this._hostIpAddress = e.ip,
                r.default.info(r.LogSource.Matchmaking)(`Host IP address is ${this._hostIpAddress}`),
                !0
            }
            return this._webRTCConnection.processMatchmakingMessage(e)
        }
        _onConnected() {
            void 0 !== this._webRTCTimeoutId && (clearTimeout(this._webRTCTimeoutId),
            this._webRTCTimeoutId = void 0),
            this.onConnected && this.onConnected(this._matchmakingInfo)
        }
    }
    __decorate([Override], l.prototype, "getState", null),
    __decorate([Override], l.prototype, "setState", null),
    __decorate([Override], l.prototype, "isConnected", null),
    __decorate([Override], l.prototype, "close", null),
    __decorate([Override], l.prototype, "send", null),
    __decorate([Override], l.prototype, "processMatchmakingMessage", null),
    t.WebRTCWithFallbackConnection = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("multiplayer/networking/WebSocketConnection", ["require", "exports", "Enums", "multiplayer/IMultiplayer", "multiplayer/matchmaking/IMatchmaking", "multiplayer/networking/Connection", "utilities/Log"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class s extends o.Connection {
        constructor(e, t, n, o, s) {
            if (super(e),
            this.getMatchmaking = n,
            this.onData = o,
            this.onConnected = s,
            this.matchmakingIdentifier = t,
            multiplayer.isServer()) {
                this.setState(a.ConnectionState.Connected);
                const e = steamworks.getMatchmakingServer();
                if (!e)
                    return void r.default.error(r.LogSource.WebSocketConnection)("Invalid matchmaking server");
                e.messageCallbacks.set(this.matchmakingIdentifier, e=>{
                    try {
                        this.onData(e)
                    } catch (t) {
                        r.default.error(r.LogSource.WebSocketConnection)("onData", t, e)
                    }
                }
                ),
                e.disconnectCallbacks.set(this.matchmakingIdentifier, ()=>{
                    r.default.info(r.LogSource.WebSocketConnection)("Client disconnected from matchmaking server", this.matchmakingIdentifier),
                    multiplayer.closeConnection(i.DisconnectReason.Left, this)
                }
                )
            }
        }
        isConnected() {
            return this.getState() !== a.ConnectionState.Disconnecting
        }
        send(e) {
            if (multiplayer.isServer()) {
                const t = steamworks.getMatchmakingServer();
                if (!t)
                    return;
                const a = t.getConnections()
                  , i = a.get(this.matchmakingIdentifier);
                if (!i)
                    return;
                i.send(e)
            } else {
                const t = this.getMatchmaking();
                if (!t || !t.isConnected())
                    return void multiplayer.disconnectAndResetGameState(i.DisconnectReason.LostConnection);
                t.send(e)
            }
        }
        async processMatchmakingMessage(e) {
            if (e instanceof ArrayBuffer)
                return this.onData(e),
                !0;
            switch (e.type) {
            case n.MatchmakingMessageDataType.Connected:
                return this.setState(a.ConnectionState.Connected),
                this.onConnected && this.onConnected(this._matchmakingInfo),
                !0
            }
            return !1
        }
    }
    __decorate([Override], s.prototype, "isConnected", null),
    __decorate([Override], s.prototype, "send", null),
    __decorate([Override], s.prototype, "processMatchmakingMessage", null),
    t.WebSocketConnection = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("multiplayer/Multiplayer", ["require", "exports", "entity/Entity", "entity/IEntity", "Enums", "game/IGame", "language/dictionary/InterruptChoice", "language/dictionary/Message", "language/dictionary/UiTranslation", "language/Translation", "mod/IHookHost", "multiplayer/IMultiplayer", "multiplayer/matchmaking/IMatchmaking", "multiplayer/matchmaking/Matchmaking", "multiplayer/networking/WebRTCConnection", "multiplayer/networking/WebRTCWithFallbackConnection", "multiplayer/networking/WebSocketConnection", "multiplayer/packets/client/ClearSyncPacketWaitingPacket", "multiplayer/packets/client/DisconnectPacket", "multiplayer/packets/client/HideLoadingScreenPacket", "multiplayer/packets/client/RemovePlayerPacket", "multiplayer/packets/client/ShowLoadingScreenPacket", "multiplayer/packets/client/SynchronizeGameStatePacket", "multiplayer/packets/EntityTargetedSharedPacket", "multiplayer/packets/IPacket", "multiplayer/packets/Packets", "multiplayer/packets/PlayerTargetedClientPacket", "multiplayer/packets/PlayerTargetedServerPacket", "multiplayer/packets/PlayerTargetedSharedPacket", "multiplayer/packets/server/ConnectedPacket", "multiplayer/packets/server/ConnectPacket", "multiplayer/packets/server/DesyncPacket", "multiplayer/packets/ServerPacket", "multiplayer/packets/shared/UpdateMultiplayerOptionsPacket", "newui/screen/IScreen", "player/Customizations", "player/IMessageManager", "player/MessageManager", "player/Player", "steamworks/ISteamworks", "utilities/Emitter", "utilities/Files", "utilities/Log", "utilities/Objects", "utilities/Random", "utilities/UUID"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L, O, F, _, H, W, N, q, U, z, V) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const j = -999999999999
      , Q = new q.default(q.LogSource.Multiplayer)
      , $ = new q.default(q.LogSource.Matchmaking)
      , Y = "host"
      , J = "!!2d666328-0502-4118-8aec-52b5ade5d8d6!!"
      , K = "mmi"
      , X = 15e3
      , Z = {
        iceServers: [{
            urls: "stun:stun.services.mozilla.com"
        }, {
            urls: "stun:stun.l.google.com:19302"
        }, {
            urls: "stun:stun1.l.google.com:19302"
        }, {
            urls: "stun:stun.stunprotocol.org:3478"
        }]
    };
    class ee extends W.default {
        constructor() {
            if (super(),
            this._isServer = !1,
            this._clients = [],
            this._incomingPacketProcessingPaused = !1,
            this._currentSyncPacketsWaiting = {},
            this._currentSyncPacketsProcessing = [],
            this._syncCheckStack = [],
            this._syncChecksSuppressed = !1,
            this._recentPackets = [],
            this._matchmakingSecret = V.default.create(),
            steamworks.isGreenworksEnabled()) {
                const e = steamworks.getSteamId();
                e && e.staticAccountId && (this._playerIdentifier = e.staticAccountId)
            }
            if (!this._playerIdentifier)
                try {
                    const e = localStorage.getItem("wayward.player.identifier");
                    void 0 !== e && null !== e ? this._playerIdentifier = e : (this._playerIdentifier = V.default.create(),
                    localStorage.setItem("wayward.player.identifier", this._playerIdentifier))
                } catch (e) {
                    this._playerIdentifier = V.default.create()
                }
            Q.info("Initialized", this._playerIdentifier),
            steamworks.isElectron() && "development" !== steamworks.getBetaName() || (Q.info("Enabling all sync checks"),
            p.networkingOptions.syncChecks = !0),
            steamworks.isTestMode() && (Q.info("Enabling test mode networking options"),
            p.networkingOptions.syncChecks = !0,
            p.networkingOptions.enablePacketNumberChecks = !0,
            p.networkingOptions.checkSeedHistory = !0),
            this._options = p.getDefaultMultiplayerOptions(),
            hookManager.register(this, "Multiplayer")
        }
        isConnected() {
            return !!this.isServer() || !(!this._server || !this._server.isConnected())
        }
        isReady() {
            return this.isConnected() && this._server.getState() === n.ConnectionState.Ready
        }
        isServer() {
            return this._isServer
        }
        isClient() {
            return !this._isServer
        }
        isProcessingPacket() {
            return void 0 !== this._currentPacketProcessing
        }
        getPlayerIdentifier() {
            return this._playerIdentifier
        }
        getOptions() {
            return this._options
        }
        setOptions(e) {
            this._options = e,
            this.isServer() ? (saveData.multiplayerState.options = e,
            this.updateGlobalServerDirectory()) : (game.setTurnMode(e.turnMode),
            game.setTickSpeed(e.tickSpeed))
        }
        updateOptions(e) {
            const t = this.getOptions()
              , a = {
                lobbyType: void 0 !== e.lobbyType ? e.lobbyType : t.lobbyType,
                description: void 0 !== e.description ? e.description : t.description,
                newPlayerState: void 0 !== e.newPlayerState ? e.newPlayerState : t.newPlayerState,
                pvp: void 0 !== e.pvp ? e.pvp : t.pvp,
                turnMode: void 0 !== e.turnMode ? e.turnMode : t.turnMode,
                maxPlayers: void 0 !== e.maxPlayers ? e.maxPlayers : t.maxPlayers,
                tickSpeed: void 0 !== e.tickSpeed ? e.tickSpeed : t.tickSpeed,
                syncChecks: void 0 !== e.syncChecks ? e.syncChecks : t.syncChecks
            };
            if (this.isConnected() && this.isServer()) {
                const e = new B.default;
                if (e.options = a,
                e.processAndSend(),
                steamworks.isGreenworksEnabled()) {
                    const e = steamworks.setLobbyType(a.lobbyType);
                    e || Q.warn("Unable to update lobby type", H.LobbyType[a.lobbyType])
                }
            } else
                this.setOptions(a)
        }
        getConnectedMatchmakingInfo() {
            return this._connectedMatchmakingInfo
        }
        getConnectedGameCode() {
            const e = steamworks.getDedicatedServerInfo();
            if (e) {
                const t = steamworks.getMatchmakingServer();
                return t && t.isRunning() && t.ipAddress ? `${t.ipAddress}:${e.port}` : void 0
            }
            if (this._connectedMatchmakingInfo) {
                if (this._connectedMatchmakingInfo.isDedicatedServer)
                    return this._connectedMatchmakingInfo.matchmakingServer;
                const e = steamworks.getLobbyId();
                return void 0 !== e ? `${p.steamLobbyPrefix}${e}` : this._connectedMatchmakingInfo.channel
            }
        }
        convertGameCodeToServerInfo(e) {
            return e.startsWith(p.steamLobbyPrefix) ? e : V.default.isValid(e) ? e : this.getDedicatedServerMatchmakingInfo(e)
        }
        getDedicatedServerMatchmakingInfo(e, t=V.default .create() ) {
            return {
                identifier: t,
                channel: J,
                matchmakingServer: -1 !== e.lastIndexOf(":") ? `${e}` : `${e}:${p.defaultServerPort}`,
                isDedicatedServer: !0
            }
        }
        getBannedPlayers() {
            return saveDataGlobal.multiplayerBannedPlayers
        }
        setBanned(e, t) {
            const a = saveDataGlobal.multiplayerBannedPlayers.indexOf(e);
            if (t) {
                if (-1 === a)
                    return saveDataGlobal.multiplayerBannedPlayers.push(e),
                    !0
            } else if (-1 !== a)
                return saveDataGlobal.multiplayerBannedPlayers.splice(a, 1),
                !0;
            return !1
        }
        createServer(e, t) {
            if (!game.playing)
                return void steamworks.multiplayerLogError("You must be in a game to create a server");
            steamworks.setupMultiplayerLog(),
            this._isServer = !0;
            const a = this.convertToMatchmakingInfo(e, Y);
            steamworks.multiplayerLog("Creating server", a, e, t);
            const i = modManager.getLoadedMods();
            if (i && i.length > 0) {
                Q.warn(`You have ${i.length} mods loaded. Proceed with caution!`),
                Q.warn(`Current mods loaded: ${i.map(e=>e.config.name).join(", ")}`);
                for (const e of i)
                    modManager.isMultiplayerCompatible(e.index) || Q.warn(`Mod '${e.config.name}' is not multiplayer compatible!`)
            }
            this.emit(p.MultiplayerEvent.Connect),
            this._disconnectingFromSyncIssue = !1,
            void 0 !== t && (this._options = t),
            saveData.multiplayerState.options = this._options,
            this._incomingPacketQueue = [],
            this._syncCheckStack = [],
            this._incomingPacketProcessingPaused = !1,
            void 0 !== this._packetTickIntervalId && clearInterval(this._packetTickIntervalId),
            this._packetTickIntervalId = setInterval(this.packetTick.bind(this), 16),
            this.onStateChange(a),
            saveData.multiplayerState.enable = !0;
            const n = steamworks.getDedicatedServerInfo()
              , o = this.startMatchmakingServer(n ? n.port : p.defaultServerPort);
            if (void 0 !== o ? this.connectDedicatedMatchmakingServer(this.getDedicatedServerMatchmakingInfo(o, Y)) : steamworks.isElectron() && steamworks.multiplayerLogError("Unable to start matchmaking server!"),
            void 0 === n)
                if (steamworks.isGreenworksEnabled()) {
                    const e = t && void 0 !== t.lobbyType && t.lobbyType >= 0 && t.lobbyType <= 3 ? t.lobbyType : H.LobbyType.Public;
                    steamworks.multiplayerLog(`Creating lobby ${H.LobbyType[e]}`),
                    steamworks.createLobby(e)
                } else
                    steamworks.multiplayerLog("Creating server", a),
                    this.connectGlobalMatchmakingServer(a)
        }
        joinServer(e, t) {
            if (game && game.playing)
                return void Q.error("You are already in a game!");
            this.disconnect();
            const a = this.convertToMatchmakingInfo(e);
            if (void 0 !== t && (this._character = t),
            void 0 === this._character && (this._character = L.generateRandomCharacter()),
            steamworks.setupMultiplayerLog(),
            steamworks.multiplayerLog("joinServer", a, this._character),
            this._joinedMatchmakingInfo = a,
            this._joinServerTimeoutId = setTimeout(()=>{
                this._joinServerTimeoutId = void 0,
                this.displayJoinServerRetryDialog(a)
            }
            , X),
            newui.interrupt(l.default.GameMultiplayerInterruptConnecting).withDescription(l.default.GameMultiplayerInterruptConnectingDescription).withLoading(void 0, async()=>{
                void 0 !== this._joinServerTimeoutId && (steamworks.multiplayerLog("Disconnecting because the join server interrupt was closed"),
                await newui.hideLoadingInterrupt(),
                this.disconnect())
            }
            ),
            a.isDedicatedServer)
                this.connectDedicatedMatchmakingServer(a);
            else {
                const e = a.channel.startsWith(p.steamLobbyPrefix);
                steamworks.isGreenworksEnabled() && e ? steamworks.joinLobby(a.channel.substr(p.steamLobbyPrefix.length)) : e ? this.disconnect(p.DisconnectReason.UnableToJoinGame, l.default.GameMultiplayerInterruptUnableToJoinGameSteamRequired) : this.connectGlobalMatchmakingServer(a)
            }
        }
        async disconnect(e, t, a) {
            let i;
            switch (steamworks.multiplayerLog("disconnect", void 0 !== e ? p.DisconnectReason[e] : ""),
            e) {
            case p.DisconnectReason.ServerShutdown:
                i = l.default.GameMultiplayerInterruptServerShutdown;
                break;
            case p.DisconnectReason.LostConnection:
                i = l.default.GameMultiplayerInterruptLostConnection;
                break;
            case p.DisconnectReason.Desync:
                i = l.default.GameMultiplayerInterruptSynchronizationError,
                t = l.default.GameMultiplayerInterruptSynchronizationErrorDescription;
                break;
            case p.DisconnectReason.UnableToJoinGame:
                i = l.default.GameMultiplayerInterruptUnableToJoinGame;
                break;
            case p.DisconnectReason.Kick:
                i = l.default.GameMultiplayerInterruptKicked;
                break;
            case p.DisconnectReason.UnableToLoadMods:
                i = l.default.GameMultiplayerInterruptFailedToLoadMods
            }
            if (this._disconnectingFromSyncIssue = !1,
            this.clearJoinServerRetryTimeout(),
            this.disconnectGlobalMatchmakingServer(),
            this.disconnectDedicatedMatchmakingServer(),
            this.onStateChange(void 0),
            this._currentPacketProcessing = void 0,
            this._currentSyncPacketsWaiting = {},
            this._currentSyncPacketsProcessing = [],
            this._recentPackets = [],
            void 0 === e && (e = this.isServer() ? p.DisconnectReason.ServerShutdown : p.DisconnectReason.Left),
            this.isServer()) {
                !0 !== a && (saveData.multiplayerState.enable = !1),
                this.stopMatchmakingServer();
                for (let t = this._clients.length - 1; t >= 0; t--)
                    this.closeConnection(e, this._clients[t]);
                void 0 !== this._packetTickIntervalId && (clearInterval(this._packetTickIntervalId),
                this._packetTickIntervalId = void 0)
            } else
                this._server && this.closeConnection(e, this._server);
            const n = !!this._server;
            if (this._isServer = !1,
            this._options = p.getDefaultMultiplayerOptions(),
            !n && void 0 !== i) {
                game.playing && game.setPaused(!0);
                const a = newui.interrupt(i, t).setTopMenu();
                if (e === p.DisconnectReason.Desync) {
                    const e = this._joinedMatchmakingInfo
                      , t = this._character;
                    a.withChoice(r.default.Rejoin, r.default.Cancel).then(a=>{
                        a === r.default.Rejoin && this.joinServer(e, t)
                    }
                    )
                } else
                    a.withInfo()
            }
            game.playing && game.updateRender(o.RenderSource.MultiplayerDisconnect),
            this.emit(p.MultiplayerEvent.Disconnect)
        }
        async displayJoinServerRetryDialog(e) {
            Q.warn("displayJoinServerRetryDialog", e),
            this.disconnect();
            const t = await newui.interrupt(u.default .ui(l.default .GameMultiplayerInterruptUnableToJoinGame)).withDescription(u.default .ui(l.default .GameMultiplayerInterruptFailedToConnect)).withChoice(r.default .Retry,r.default .Cancel);
            t === r.default.Retry ? this.joinServer(e) : newui.hideLoadingInterrupt()
        }
        async disconnectAndResetGameState(e, t) {
            this.isClient() && this._server && this._server.getState() === n.ConnectionState.Disconnecting || (await this.disconnect(e,t),
            game.playing && await game.resetGameState(!0))
        }
        kick(e, t) {
            for (const a of this._clients)
                if (a.pid === e.id) {
                    const i = new T.default;
                    return i.reason = p.DisconnectReason.Kick,
                    i.description = t,
                    i.sendTo(e, !0),
                    void setTimeout(()=>{
                        this.closeConnection(p.DisconnectReason.Kick, a)
                    }
                    , 1e3)
                }
        }
        async onPlaying() {
            const e = this._connectedMatchmakingInfo.isDedicatedServer ? this.getConnectedGameCode() : void 0;
            void 0 !== e && (saveDataGlobal.multiplayerPreviousGames[e] = {
                name: localPlayer.getName().getString(),
                customization: localPlayer.customization
            }),
            newui.showLoadingInterrupt(u.default.ui(l.default.GameInterruptLoadingMultiplayerSyncing)),
            this._server.setState(n.ConnectionState.CatchingUp),
            this._server.startKeepAlive(),
            this.sendPacketInternal(new P.default)
        }
        onLobbyEntered(e, t) {
            if (e) {
                const e = this._connectedMatchmakingInfo;
                if (void 0 !== e && e.isDedicatedServer)
                    steamworks.setLobbyData(K, e.matchmakingServer) ? Q.info("Set lobby data", e.matchmakingServer) : Q.error("Unable to set lobby data", e.matchmakingServer);
                else {
                    const e = steamworks.getLobbyData(K);
                    e ? (Q.info("Got lobby data", e),
                    this.connectDedicatedMatchmakingServer(this.getDedicatedServerMatchmakingInfo(e))) : this.connectGlobalMatchmakingServer(this.convertToMatchmakingInfo(t, this.isServer() ? Y : void 0))
                }
                this.emit(p.MultiplayerEvent.JoinLobby, t)
            } else
                Q.error("Unable to join steam lobby")
        }
        onLobbyExited(e) {
            Q.info("Exited lobby", e),
            this.emit(p.MultiplayerEvent.LeaveLobby, e)
        }
        getClients() {
            if (this.isClient())
                throw new Error("Don't call this clientside");
            return this._clients
        }
        closeConnection(e, t) {
            if (t.getState() !== n.ConnectionState.Disconnecting)
                if (steamworks.multiplayerLog("closeConnection", p.DisconnectReason[e], t.playerIdentifier, t.matchmakingIdentifier, t.pid),
                t.close(),
                this.isServer()) {
                    for (let a = 0; a < this._clients.length; a++)
                        if (this._clients[a] === t) {
                            this._clients.splice(a, 1);
                            const i = t.pid;
                            if (void 0 !== i) {
                                let t;
                                (t = (()=>{
                                    if (steamworks.multiplayerLog("sendRemovePlayerPacket", i),
                                    this._incomingPacketProcessingPaused)
                                        setTimeout(t, 10);
                                    else {
                                        const t = new I.default;
                                        t.pid = i,
                                        t.reason = e,
                                        t.processAndSend()
                                    }
                                }
                                ))()
                            }
                            break
                        }
                } else if (t === this._server) {
                    if (this._connectedMatchmakingInfo = void 0,
                    players)
                        for (let e = players.length - 1; e >= 0; e--) {
                            const t = players[e];
                            t.isLocalPlayer() || game.removePlayer(e)
                        }
                    delete this._server
                }
        }
        sendPacket(e, t) {
            if (void 0 !== t)
                if (Array.isArray(t)) {
                    const a = this._clients.filter(e=>{
                        for (const a of t)
                            if (a === e || a instanceof _.default && e.pid === a.id)
                                return !1;
                        return !0
                    }
                    );
                    this.sendPacketTo(a, e)
                } else
                    this.sendPacketInternal(e, void 0, t instanceof _.default ? this._clients.find(e=>e.pid === t.id) : t);
            else
                this.sendPacketInternal(e)
        }
        sendPacketTo(e, t, a) {
            if (Array.isArray(e))
                for (const i of e)
                    this.sendPacketTo(i, t, a);
            else if (e instanceof _.default) {
                for (const i of this._clients)
                    if (i.pid === e.id)
                        return void this.sendPacketInternal(t, i, void 0, a)
            } else
                this.sendPacketInternal(t, e, void 0, a)
        }
        syncPacket(e, t, a, i) {
            if (!this.isConnected())
                return t ? t() : void 0;
            const n = e.getRegistrarId()
              , o = this.getSyncPacketWaitId(e, i);
            let r, s;
            if (s = a ? this.isServer() && -1 === this._currentSyncPacketsProcessing.indexOf(n) || this.isClient() && a && this._currentPacketProcessing !== n : this.isServer() && 0 === this._currentSyncPacketsProcessing.length || this.isClient() && void 0 === this._currentPacketProcessing,
            this.isClient() ? void 0 !== this._currentPacketProcessing && this._currentPacketProcessing !== n && (a || a || (steamworks.multiplayerLogError(`Possible bug. Currently processing ${this._currentPacketProcessing}. Sync check for ${n}`),
            newui.interrupt(u.default.generator(`Possible bug. Currently processing ${this._currentPacketProcessing}. Tell spacetech`)),
            Q.trace("Tracing issue"))) : this._currentSyncPacketsProcessing.length,
            (this.isServer() || !s) && void 0 !== t) {
                const a = this._options.syncChecks && this.isServer() && s;
                try {
                    this._currentSyncPacketsProcessing.push(n),
                    a && (this._syncCheckStack.push(this._activeSyncCheck),
                    this._activeSyncCheck = {},
                    e.getSynchronizationCheckData().beforeSyncChecks = this.getPacketSyncChecks()),
                    r = t()
                } finally {
                    a && (e.getSynchronizationCheckData().afterSyncChecks = this.getPacketSyncChecks(),
                    this._activeSyncCheck = this._syncCheckStack.pop());
                    const t = this._currentSyncPacketsProcessing.indexOf(n);
                    -1 !== t ? this._currentSyncPacketsProcessing.splice(t, 1) : steamworks.multiplayerLogError(`Error removing packet processing. Sync check for ${n}`, e, this._currentSyncPacketsProcessing),
                    void 0 !== o && this.isClient() && this.clearSyncPacketsWaiting(o)
                }
            }
            if (s) {
                if (void 0 !== o && this.isClient()) {
                    if (!0 === this._currentSyncPacketsWaiting[o])
                        return;
                    this._currentSyncPacketsWaiting[o] = !0
                }
                this.sendPacketInternal(e)
            }
            return r
        }
        clearSyncPacketWaiting(e, t) {
            const n = this.getSyncPacketWaitId(e, t);
            if (void 0 !== n)
                if (this.isServer())
                    if (e instanceof M.default) {
                        const o = e.entity;
                        if (a.default.is(o, i.EntityType.Player)) {
                            const e = new f.default;
                            e.waitId = n,
                            e.sendTo(o)
                        } else
                            Q.warn("Unable to clear sync packet waiting, invalid target", e, t)
                    } else
                        Q.warn("Unable to clear sync packet waiting, unknown target", e, t);
                else
                    this.clearSyncPacketsWaiting(n)
        }
        clearSyncPacketsWaiting(e) {
            void 0 !== e ? delete this._currentSyncPacketsWaiting[e] : this._currentSyncPacketsWaiting = {}
        }
        pausePacketProcessing(e) {
            this._incomingPacketProcessingPaused = e
        }
        updatePlayerId(e, t) {
            if (steamworks.multiplayerLog(`Updating player id ${e} -> ${t}`),
            this.isServer()) {
                for (const a of this._clients)
                    if (a.pid === e) {
                        a.pid = t;
                        break
                    }
                this.updateGlobalServerDirectory()
            } else
                this._server && this._server.pid === e && (this._server.pid = t)
        }
        suppressSyncChecks(e) {
            this._syncChecksSuppressed = e
        }
        syncGameState() {
            if (!this.isConnected() || !this.isServer() || this._incomingPacketProcessingPaused)
                return;
            const e = !game.paused;
            e && game.setPaused(!0),
            this.pausePacketProcessing(!0);
            const t = this._clients.filter(e=>e.getState() !== n.ConnectionState.Ready)
              , a = new v.default;
            a.title = l.default.GameInterruptMultiplayerSynchronizing,
            a.description = l.default.GameInterruptMultiplayerSynchronizingDescription,
            a.processAndSend(t),
            setTimeout(()=>{
                const a = new w.default;
                a.serverGameState = saveManager.getGameStateAsJson(),
                a.send(t);
                const i = new S.default;
                i.processAndSend(t),
                e && game.setPaused(!1),
                this.pausePacketProcessing(!1)
            }
            , 50)
        }
        preSaveGame() {
            if (multiplayer.isServer()) {
                Q.info("Clearing keep alive timeouts");
                for (const e of this._clients) {
                    const t = e.getState();
                    t !== n.ConnectionState.CatchingUp && t !== n.ConnectionState.Ready || e.clearTimeout()
                }
            }
        }
        postSaveGame() {
            if (multiplayer.isServer()) {
                Q.info("Restoring keep alive timeouts");
                for (const e of this._clients) {
                    const t = e.getState();
                    t !== n.ConnectionState.CatchingUp && t !== n.ConnectionState.Ready || e.addKeepAliveTimeout()
                }
            }
        }
        updateGlobalServerDirectory() {
            if (!this.isServer())
                return;
            const e = this.getConnectedGameCode();
            if (!e)
                return void setTimeout(this.updateGlobalServerDirectory.bind(this), 1e3);
            const t = this.getOptions()
              , a = modManager.getLoadedMods()
              , i = {
                worldId: game.worldId,
                name: saveData.gameSlotName,
                description: t.description || "",
                hostPlayerName: localPlayer.name,
                hostPlayerId: this.getPlayerIdentifier(),
                lobbyType: t.lobbyType !== H.LobbyType.FriendsOnly ? t.lobbyType : H.LobbyType.Public,
                code: e,
                isDedicatedServer: steamworks.isDedicatedServer(),
                buildTime: steamworks.getBuildTime()
            }
              , n = {
                players: game.getPlayers(!0, !0).map(e=>e.identifier),
                maxPlayers: t.maxPlayers,
                difficulty: game.getDifficulty(),
                pvp: t.pvp,
                reputation: game.getReputation() || 0,
                days: game.time.day,
                mods: a.filter(e=>!modManager.isMultiplayerClientSide(e.index)).map(e=>({
                    name: modManager.getName(e.index),
                    version: modManager.getVersion(e.index),
                    publishFileId: modManager.getPublishFileId(e.index)
                })),
                peaceful: game.getDifficultyOptions().peaceful
            };
            if (void 0 !== this._globalMatchmaking)
                this._globalMatchmaking.send({
                    type: c.MatchmakingMessageDataType.UpdateDirectory,
                    serverDetails: i,
                    gameDetails: n,
                    secret: this._matchmakingSecret
                }, this._globalMatchmaking.getChannel());
            else {
                const e = steamworks.getMatchmakingServer();
                e && e.isRunning() && e.updateDirectory(i, n)
            }
        }
        isSyncCheckEnabled(e) {
            const t = this._options.syncChecks;
            return "boolean" == typeof t ? t : -1 !== t.indexOf(e)
        }
        addSyncCheck(e, t) {
            if (!this._activeSyncCheck || this._syncChecksSuppressed || !this.isSyncCheckEnabled(e))
                return;
            let a = this._activeSyncCheck[e];
            a || (a = this._activeSyncCheck[e] = []);
            let i = t;
            "string" != typeof i && (i = JSON.stringify(i)),
            a.push(i)
        }
        addBeforeSyncChecks(e) {
            this.isServer() && (this._options.syncChecks && (this._activeSyncCheck = {},
            e.getSynchronizationCheckData().beforeSyncChecks = this.getPacketSyncChecks()),
            p.networkingOptions.checkSeedHistory && z.default.generator.startHistory())
        }
        addAfterSyncChecks(e) {
            this.isServer() && (p.networkingOptions.checkSeedHistory && (e.getSynchronizationCheckData().afterRandomHistory = z.default.generator.stopHistory()),
            this._options.syncChecks && (e.getSynchronizationCheckData().afterSyncChecks = this.getPacketSyncChecks()))
        }
        addDefaultSyncChecks() {
            game && game.time && this.addSyncCheck(p.MultiplayerSyncCheck.Ticks, game.time.ticks),
            this.addSyncCheck(p.MultiplayerSyncCheck.Seed, z.default.generator.getSeed()),
            players && (this.addSyncCheck(p.MultiplayerSyncCheck.Players, players.map(e=>`${e.id}-${e.isConnecting ? 1 : 0}-${e.state}`).join(",")),
            this.addSyncCheck(p.MultiplayerSyncCheck.PlayerPositions, players.map(e=>({
                x: e.x,
                y: e.y,
                z: e.z
            }))))
        }
        getPacketSyncChecks() {
            this.addDefaultSyncChecks();
            const e = JSON.parse(JSON.stringify(this._activeSyncCheck));
            return this._activeSyncCheck = {},
            e
        }
        clearJoinServerRetryTimeout() {
            void 0 !== this._joinServerTimeoutId && (clearTimeout(this._joinServerTimeoutId),
            this._joinServerTimeoutId = void 0)
        }
        startMatchmakingServer(e) {
            const t = steamworks.getMatchmakingServer();
            if (t)
                try {
                    const a = t.start(e, void 0 === steamworks.getDedicatedServerInfo());
                    return this.updateGlobalServerDirectory(),
                    a
                } catch (e) {
                    Q.error("Failed to start matchmaking server", e)
                }
        }
        stopMatchmakingServer() {
            const e = steamworks.getMatchmakingServer();
            e && e.stop()
        }
        connectGlobalMatchmakingServer(e) {
            steamworks.multiplayerLog("Connecting to global matchmaking server", e),
            this.isClient() && (this._server = new y.WebRTCWithFallbackConnection(e,Y,Z,e=>{
                this._globalMatchmaking && this._globalMatchmaking.send(e)
            }
            ,e=>{
                this.onConnectionData(this._server, e)
            }
            ,this._onConnected.bind(this))),
            this._globalMatchmaking && this._globalMatchmaking.disconnect(),
            this._globalMatchmaking = new m.Matchmaking(e,t=>{
                t.send({
                    type: c.MatchmakingMessageDataType.JoinChannel,
                    matchmakingIdentifier: e.identifier,
                    playerIdentifier: this._playerIdentifier,
                    clientVersion: gameVersion,
                    clientBuild: steamworks.getBuildTime(),
                    secret: this._matchmakingSecret
                }, e.channel),
                this.isServer() && (t.send({
                    type: c.MatchmakingMessageDataType.IpAddress
                }),
                this.updateGlobalServerDirectory())
            }
            ,()=>{
                this.disconnectGlobalMatchmakingServer(),
                this.isServer() ? this._globalMatchmakingRetryTimeoutId = setTimeout(()=>{
                    this._globalMatchmakingRetryTimeoutId = void 0,
                    this.connectGlobalMatchmakingServer(e)
                }
                , 1e3) : this.displayJoinServerRetryDialog(e)
            }
            ,(e,t)=>{
                this.onMatchmakingMessage(e, t)
            }
            )
        }
        disconnectGlobalMatchmakingServer() {
            void 0 !== this._globalMatchmakingRetryTimeoutId && (clearTimeout(this._globalMatchmakingRetryTimeoutId),
            this._globalMatchmakingRetryTimeoutId = void 0),
            this._globalMatchmaking && (this._globalMatchmaking.disconnect(),
            this._globalMatchmaking = void 0)
        }
        connectDedicatedMatchmakingServer(e) {
            steamworks.multiplayerLog("Connecting to dedicated matchmaking server", e),
            this.isClient() && (this._server = new g.WebSocketConnection(e,V.default.create(),()=>this._dedicatedMatchmaking,e=>{
                this.onConnectionData(this._server, e)
            }
            ,this._onConnected.bind(this))),
            this._dedicatedMatchmaking && this._dedicatedMatchmaking.disconnect(),
            this._dedicatedMatchmaking = new m.Matchmaking(e,t=>{
                this.isClient() && t.send({
                    type: c.MatchmakingMessageDataType.JoinChannel,
                    matchmakingIdentifier: e.identifier,
                    playerIdentifier: this._playerIdentifier,
                    clientVersion: gameVersion,
                    clientBuild: steamworks.getBuildTime()
                }, e.channel)
            }
            ,()=>{
                this.disconnectDedicatedMatchmakingServer(),
                this.isServer() ? this._dedicatedMatchmakingRetryTimeoutId = setTimeout(()=>{
                    this._dedicatedMatchmakingRetryTimeoutId = void 0,
                    this.connectGlobalMatchmakingServer(e)
                }
                , 1e3) : this._server && this._server instanceof g.WebSocketConnection && this._server.getState() !== n.ConnectionState.Connecting ? this.disconnectAndResetGameState(p.DisconnectReason.ServerShutdown) : this.displayJoinServerRetryDialog(e)
            }
            ,(e,t)=>{
                this.onMatchmakingMessage(e, t)
            }
            )
        }
        disconnectDedicatedMatchmakingServer() {
            void 0 !== this._dedicatedMatchmakingRetryTimeoutId && (clearTimeout(this._dedicatedMatchmakingRetryTimeoutId),
            this._dedicatedMatchmakingRetryTimeoutId = void 0),
            this._dedicatedMatchmaking && (this._dedicatedMatchmaking.disconnect(),
            this._dedicatedMatchmaking = void 0)
        }
        async onMatchmakingMessage(e, t) {
            if (p.networkingOptions.logPackets && Q.info(`Received matchmaking message from "${e.getIdentifier()}".`, t),
            t instanceof ArrayBuffer)
                this._server && await this._server.processMatchmakingMessage(t);
            else if (this.isServer() || t.type !== c.MatchmakingMessageDataType.JoinChannel && (t.type !== c.MatchmakingMessageDataType.IceCandidate && t.type !== c.MatchmakingMessageDataType.SessionDescription || void 0 !== t.targetMatchmakingIdentifier)) {
                if ($.info(`Received ${c.MatchmakingMessageDataType[t.type]} from ${t.matchmakingIdentifier}`, t),
                this.isServer()) {
                    for (const e of this._clients)
                        if (e.matchmakingIdentifier === t.matchmakingIdentifier) {
                            if (await e.processMatchmakingMessage(t))
                                return;
                            break
                        }
                } else if (this._server && await this._server.processMatchmakingMessage(t))
                    return;
                switch (t.type) {
                case c.MatchmakingMessageDataType.IpAddress:
                    if (e === this._dedicatedMatchmaking) {
                        $.info("Ignoring ip address message from the local matchmaking server");
                        break
                    }
                    this._ipAddress = t.ip,
                    $.info(`IP address is ${this._ipAddress}`);
                    break;
                case c.MatchmakingMessageDataType.JoinChannel:
                    if (this.isClient()) {
                        $.warn("Preventing client from processing JoinChannel message");
                        break
                    }
                    if (void 0 === t.matchmakingIdentifier)
                        return $.warn("Preventing a client with an invalid matchmaking identifier from joining", t),
                        void e.send({
                            type: c.MatchmakingMessageDataType.UnableToJoinGame,
                            targetMatchmakingIdentifier: t.matchmakingIdentifier,
                            entry: l.default.GameMultiplayerInterruptUnableToJoinGameUnknownError,
                            args: [3]
                        });
                    if (t.clientVersion !== gameVersion)
                        return $.warn("Preventing a different client version from joining", t),
                        void e.send({
                            type: c.MatchmakingMessageDataType.UnableToJoinGame,
                            targetMatchmakingIdentifier: t.matchmakingIdentifier,
                            entry: l.default.GameMultiplayerInterruptUnableToJoinGameVersionMismatch,
                            args: [gameVersion, t.clientVersion]
                        });
                    const a = steamworks.getBuildTime();
                    if (void 0 !== t.clientBuild && void 0 !== a && a !== t.clientBuild)
                        return $.warn(`Preventing a different client build from joining. Server: ${a}. Client: ${t.clientBuild}`),
                        void e.send({
                            type: c.MatchmakingMessageDataType.UnableToJoinGame,
                            targetMatchmakingIdentifier: t.matchmakingIdentifier,
                            entry: l.default.GameMultiplayerInterruptUnableToJoinGameBuildMismatch,
                            args: [a, t.clientBuild]
                        });
                    if (-1 !== this.getBannedPlayers().indexOf(t.playerIdentifier))
                        return $.warn("Preventing a banned client from joining", t),
                        void e.send({
                            type: c.MatchmakingMessageDataType.UnableToJoinGame,
                            targetMatchmakingIdentifier: t.matchmakingIdentifier,
                            entry: l.default.GameMultiplayerInterruptBanned
                        });
                    const i = this.getOptions()
                      , n = i.maxPlayers;
                    if (this._clients.length >= n)
                        return $.warn("Preventing a client from joining. Max player count reached", t),
                        void e.send({
                            type: c.MatchmakingMessageDataType.UnableToJoinGame,
                            targetMatchmakingIdentifier: t.matchmakingIdentifier,
                            entry: l.default.GameMultiplayerInterruptUnableToJoinGameServerFull
                        });
                    if (steamworks.isGreenworksEnabled() && e !== this._dedicatedMatchmaking) {
                        const a = steamworks.getLobbyMembers();
                        if ($.info("Lobby members", a, t.playerIdentifier),
                        !a || !a.some(e=>e.staticAccountId === t.playerIdentifier))
                            return void e.send({
                                type: c.MatchmakingMessageDataType.UnableToJoinGame,
                                targetMatchmakingIdentifier: t.matchmakingIdentifier,
                                entry: l.default.GameMultiplayerInterruptUnableToJoinGameUnknownError,
                                args: [void 0 === a ? 0 : 1]
                            });
                        if (i.lobbyType === H.LobbyType.FriendsOnly) {
                            const a = steamworks.getFriends();
                            if (a && !a.some(e=>e.staticAccountId === t.playerIdentifier))
                                return $.warn("Preventing a player who is not a friend from joining", t),
                                void e.send({
                                    type: c.MatchmakingMessageDataType.UnableToJoinGame,
                                    targetMatchmakingIdentifier: t.matchmakingIdentifier,
                                    entry: l.default.GameMultiplayerInterruptUnableToJoinGameFriendsOnly
                                })
                        }
                    }
                    const o = game.getPlayerByIdentifier(t.playerIdentifier, !1);
                    if (void 0 !== o)
                        return $.warn("Preventing a player with a duplicate identifier from joining", t),
                        void e.send({
                            type: c.MatchmakingMessageDataType.UnableToJoinGame,
                            targetMatchmakingIdentifier: t.matchmakingIdentifier,
                            entry: l.default.GameMultiplayerInterruptUnableToJoinGameDuplicateIdentifier
                        });
                    let r;
                    (r = e === this._dedicatedMatchmaking ? new g.WebSocketConnection(void 0,t.matchmakingIdentifier,()=>this._dedicatedMatchmaking,e=>{
                        this.onConnectionData(r, e)
                    }
                    ) : new h.WebRTCConnection(void 0,t.matchmakingIdentifier,Z,e=>{
                        this._globalMatchmaking && this._globalMatchmaking.send(e)
                    }
                    ,e=>{
                        this.onConnectionData(r, e)
                    }
                    )).playerIdentifier = t.playerIdentifier,
                    this._clients.push(r),
                    r.addConnectionTimeout(),
                    Q.info("New connection", t.matchmakingIdentifier),
                    r instanceof g.WebSocketConnection ? e.send({
                        type: c.MatchmakingMessageDataType.Connected,
                        targetMatchmakingIdentifier: t.matchmakingIdentifier
                    }) : void 0 !== this._ipAddress && e.send({
                        type: c.MatchmakingMessageDataType.HostIpAddress,
                        targetMatchmakingIdentifier: t.matchmakingIdentifier,
                        ip: this._ipAddress
                    });
                    break;
                case c.MatchmakingMessageDataType.UnableToJoinGame:
                    this.isClient() && this.disconnect(p.DisconnectReason.UnableToJoinGame, ()=>u.default.ui(t.entry).get(...t.args||[]))
                }
            }
        }
        _onConnected(e) {
            this.onStateChange(e),
            this.clearJoinServerRetryTimeout(),
            this.disconnectGlobalMatchmakingServer(),
            newui.showLoadingInterrupt(u.default.ui(l.default.GameMultiplayerInterruptConnected), u.default.ui(l.default.GameMultiplayerInterruptConnectedDescriptionWaitingForWorldData));
            const t = new G.default;
            t.playerOptions = {
                character: this._character,
                options: saveDataGlobal.options,
                completedMilestones: game.getCompletedMilestoneCount()
            },
            t.send(),
            this.emit(p.MultiplayerEvent.Connect)
        }
        onConnectionData(e, t) {
            if (this.isClient() && !this._server)
                return;
            let a, i;
            if (void 0 === e.buffer)
                a = (i = new DataView(t)).getUint32(0),
                e.bufferPacketId = i.getUint8(4),
                e.buffer = new Uint8Array(a),
                e.buffer.set(new Uint8Array(t)),
                e.bufferOffset = t.byteLength;
            else {
                if (void 0 === e.bufferOffset)
                    return void steamworks.multiplayerLogError("Unable to process message", e, e.buffer, t);
                {
                    a = e.buffer.byteLength;
                    const i = Math.min(t.byteLength, a - e.bufferOffset);
                    e.buffer.set(new Uint8Array(t,0,i), e.bufferOffset),
                    e.bufferOffset += i
                }
            }
            if (e.bufferOffset !== a || void 0 === e.bufferPacketId) {
                if (steamworks.multiplayerLog(`Waiting on additional data for packet ${e.bufferPacketId}. ${e.bufferOffset} !== ${a}`),
                this.isClient() && !game.playing && this._server && this._server.getState() === n.ConnectionState.Connected && newui.isScreenVisible(E.ScreenId.Interrupt)) {
                    const t = Math.round(e.bufferOffset / a * 100);
                    newui.showLoadingInterrupt(u.default.ui(l.default.GameMultiplayerInterruptConnected), ()=>u.default.ui(l.default.GameMultiplayerInterruptConnectedDescriptionDownloadingWorldData).get(t.toString()))
                }
                return
            }
            i = new DataView(e.buffer.buffer);
            const o = k.registrar.get(e.bufferPacketId);
            if (!o)
                return void steamworks.multiplayerLogError(`Attempt to construct unknown packet type ${e.bufferPacketId}`);
            const r = new o(e);
            try {
                r.processData(i)
            } catch (t) {
                return void steamworks.multiplayerLogError(`Failed to process packet data from pid ${e.pid}`, r.getRegistrarId(), r.getDebugInfo(), t, t ? t.stack : void 0)
            }
            this.isServer() ? this._incomingPacketQueue.push({
                connection: e,
                packet: r,
                processAfterTime: p.networkingOptions.fakeRoundTripTime > 0 ? performance.now() + p.networkingOptions.fakeRoundTripTime / 2 : void 0
            }) : this.processPacket(e, r),
            e.buffer = void 0,
            e.bufferOffset = void 0
        }
        packetTick() {
            this.processIncomingPackets(),
            this.processOutgoingPackets()
        }
        processIncomingPackets() {
            for (; this._incomingPacketQueue.length > 0 && !this._incomingPacketProcessingPaused; ) {
                const e = this._incomingPacketQueue.shift();
                if (void 0 !== e.processAfterTime && e.processAfterTime > performance.now()) {
                    this._incomingPacketQueue.unshift(e);
                    break
                }
                game.paused && !e.packet.isAllowedWhenPaused() || this.processPacket(e.connection, e.packet)
            }
        }
        processOutgoingPackets() {
            for (const e of this._clients) {
                const t = e.getState();
                if ((t === n.ConnectionState.CatchingUp || t === n.ConnectionState.Ready) && 0 !== e.queuedPackets.length) {
                    for (const t of e.queuedPackets)
                        this._sendData(e, t);
                    e.queuedPackets = []
                }
            }
        }
        processPacket(e, t) {
            let o;
            if (!e.isConnected())
                return;
            p.networkingOptions.logPackets && Q.info(`Processing packet "${t.getDebugInfo()}" from "${e.matchmakingIdentifier}".`, t);
            const r = p.networkingOptions.recentPacketTracking;
            r > 0 && this._recentPackets.push(t) > r && this._recentPackets.unshift();
            try {
                if (this._currentPacketProcessing = t.getRegistrarId(),
                this.isClient() && t.isSyncCheckEnabled()) {
                    const a = t.getSynchronizationCheckData();
                    if (p.networkingOptions.enablePacketNumberChecks) {
                        const i = a.packetNumber;
                        void 0 !== i && (void 0 === e.lastPacketNumberReceived && (e.lastPacketNumberReceived = i - 1),
                        e.lastPacketNumberReceived + 1 !== i && steamworks.multiplayerLogError(`Processed a packet in the wrong order! ${e.lastPacketNumberReceived} + 1 !== ${i}`, t.getRegistrarId(), k.registrar.get(t.getRegistrarId()).name),
                        e.lastPacketNumberReceived = i)
                    }
                    this._options.syncChecks && (this._activeSyncCheck = {}),
                    this.synchronizationCheck(t, !0),
                    this._options.syncChecks && (this._activeSyncCheck = {})
                }
                p.networkingOptions.checkSeedHistory && t.isSyncCheckEnabled() && z.default.generator.startHistory();
                const r = this.isServer();
                t instanceof A.default ? t.player = r ? players[e.pid] : players[t.pid] : t instanceof D.default ? t.player = players[e.pid] : t instanceof C.default ? t.player = players[t.pid] : r && t instanceof M.default && a.default.is(t.entity, i.EntityType.Player) && (t.entity = players[e.pid]);
                const s = e.getState()
                  , l = t.getType()
                  , u = t.getAllowedStates();
                if (u !== n.ConnectionState.All && (u & s) !== s)
                    steamworks.multiplayerLogError(`Skipping packet due to an invalid state. Allowed state: ${u}. Current state: ${s}`, k.registrar.get(t.getRegistrarId()).name);
                else if (r && l === b.PacketType.Client || !r && l === b.PacketType.Server)
                    steamworks.multiplayerLogError(`Skipping packet due to an invalid type '${b.PacketType[l]}'.`, k.registrar.get(t.getRegistrarId()).name);
                else {
                    let e;
                    if (t instanceof x.default && (e = z.default.generator.getSeed()),
                    t.process(),
                    void 0 !== e) {
                        const a = z.default.generator.getSeed();
                        e !== a && steamworks.multiplayerLog(`Server side packet changed seed from ${e} to ${a}! '${b.PacketType[l]}'.`, k.registrar.get(t.getRegistrarId()).name)
                    }
                }
            } catch (e) {
                steamworks.multiplayerLogError("Failed to process packet", t.getRegistrarId(), t.getDebugInfo(), e, e ? e.stack : void 0),
                o = e
            } finally {
                this.isClient() && this.isConnected() && t.isSyncCheckEnabled() && void 0 === o && this.synchronizationCheck(t, !1),
                this._currentPacketProcessing = void 0
            }
        }
        synchronizationCheck(e, t) {
            if (this._disconnectingFromSyncIssue)
                throw new Error("Pending disconnect due to sync issue");
            const a = e.getSynchronizationCheckData();
            let i = !1;
            const o = t ? void 0 : a.afterRandomHistory
              , r = t ? a.beforeSyncChecks : a.afterSyncChecks
              , l = z.default.generator.stopHistory();
            if (p.networkingOptions.checkSeedHistory && void 0 !== o && void 0 !== l && 0 !== l.length) {
                let a = o.length !== l.length;
                for (let t = 0; t < o.length; t++) {
                    const i = o[t]
                      , n = l[t];
                    let r = !0;
                    if (n) {
                        r = i.seeds.length !== n.seeds.length;
                        for (let e = 0; e < o.length; e++) {
                            const a = i.seeds[t]
                              , o = n.seeds[t];
                            a !== o && (r = !0,
                            steamworks.multiplayerLogError(`Synchronization issues! Seed mismatch at ${e}`),
                            steamworks.multiplayerLogError("Expected", a, i.seeds),
                            steamworks.multiplayerLogError("Actual", o, n.seeds))
                        }
                    }
                    if (r) {
                        a = !0,
                        steamworks.multiplayerLogError(`Synchronization issues! Seed mismatch at ${t}`, e.getRegistrarId()),
                        steamworks.multiplayerLogError("Expected", i),
                        steamworks.multiplayerLogError("Actual", n);
                        break
                    }
                }
                a && (i = !0,
                localPlayer.messages.source(O.Source.Meta).type(F.MessageType.Bad).send(s.default.ErrorHasOccured),
                steamworks.multiplayerLogError(`Synchronization issues! Expected history length ${o.length}, actual is ${l.length}. checkBefore: ${t}`, e.getRegistrarId()),
                steamworks.multiplayerLogError("Expected", JSON.stringify(o)),
                steamworks.multiplayerLogError("Actual", JSON.stringify(l)),
                N.default.download("expected.json", JSON.stringify(o, void 0, "\t")),
                N.default.download("actual.json", JSON.stringify(l, void 0, "\t")))
            }
            const u = this._server.getState();
            if (this._options.syncChecks && void 0 !== r && (u === n.ConnectionState.QueuingPackets || u === n.ConnectionState.CatchingUp || u === n.ConnectionState.Ready)) {
                this.addDefaultSyncChecks();
                const t = Object.keys(r)
                  , a = Object.keys(this._activeSyncCheck);
                let n = "boolean" == typeof this._options.syncChecks && t.length !== a.length;
                for (let e = 0; e < t.length; e++) {
                    const a = parseInt(t[e], 10);
                    if (!this.isSyncCheckEnabled(a))
                        continue;
                    const i = r[a]
                      , o = this._activeSyncCheck[a];
                    let s = !0;
                    if (o) {
                        s = i.length !== o.length;
                        for (let e = 0; e < i.length; e++) {
                            const t = i[e]
                              , n = o[e];
                            if (t !== n) {
                                s = !0,
                                steamworks.multiplayerLogError(`Synchronization issues! Sync check mismatch at ${p.MultiplayerSyncCheck[a]}, index ${e}`),
                                steamworks.multiplayerLogError("Expected", t, i),
                                steamworks.multiplayerLogError("Actual", n, o);
                                break
                            }
                        }
                    }
                    s && (n = !0,
                    steamworks.multiplayerLogError(`Synchronization issues! Sync check mismatch at ${p.MultiplayerSyncCheck[a]}`),
                    steamworks.multiplayerLogError("Expected", i),
                    steamworks.multiplayerLogError("Actual", o))
                }
                n && (i = !0,
                steamworks.multiplayerLogError("Synchronization issues! Sync check mismatch", e.getRegistrarId()),
                steamworks.multiplayerLogError("Synchronization issues! expectedSyncChecks", r),
                steamworks.multiplayerLogError("Synchronization issues! this._currentSyncCheck", this._activeSyncCheck))
            }
            i && this.desync(e, a, t)
        }
        async desync(e, t, a) {
            this._disconnectingFromSyncIssue = !0,
            steamworks.multiplayerLogError(`Synchronization issues! Packet id: ${e.getRegistrarId()} (${k.registrar.get(e.getRegistrarId()).name}) [${e.getDebugInfo()}], packet number: ${t.packetNumber}, checkBefore: ${a}`);
            try {
                steamworks.multiplayerLogError(`Raw packet data: ${U.default.stringify(e, 4)}.`)
            } catch (e) {
                steamworks.multiplayerLogError(`Failed to serialize packet ${e}.`)
            }
            steamworks.multiplayerLogError(`Loaded mods: ${modManager.getLoadedMods().map(e=>`${e.folderName}:${e.publishedFileId}`).join(",")}`),
            steamworks.multiplayerLogError("Recent packets:");
            const i = this._recentPackets.reverse();
            for (const e of i)
                steamworks.multiplayerLogError(e.getDebugInfo());
            const n = new R.default;
            n.logs = steamworks.getMultiplayerLogs(),
            n.send()
        }
        sendPacketInternal(e, t, a, i) {
            if (this.isConnected())
                if (this.isServer()) {
                    for (const o of this._clients)
                        if (void 0 === a && void 0 === t || void 0 !== a && o !== a || o === t) {
                            const t = o.getState();
                            i ? this._sendData(o, e) : t !== n.ConnectionState.QueuingPackets && t !== n.ConnectionState.CatchingUp && t !== n.ConnectionState.Ready || o.queuedPackets.push(e)
                        }
                } else
                    this._sendData(this._server, e)
        }
        _sendData(e, t) {
            try {
                if (!e || !e.isConnected())
                    return;
                let a;
                p.networkingOptions.logPackets && Q.info(`Sending packet "${t.getDebugInfo()}" to "${e.matchmakingIdentifier}".`, t),
                p.networkingOptions.enablePacketNumberChecks && this.isServer() && t.isSyncCheckEnabled() ? (void 0 === e.lastPacketNumberSent && (e.lastPacketNumberSent = 0),
                t.getSynchronizationCheckData().packetNumber = e.lastPacketNumberSent,
                a = t.getArrayBuffer(e.lastPacketNumberSent),
                e.lastPacketNumberSent++) : a = t.getArrayBuffer(),
                e.queuePacketData(a)
            } catch (e) {
                Q.error("Send data failure", t.getRegistrarId(), t.getDebugInfo(), e)
            }
        }
        onStateChange(e) {
            if (this._connectedMatchmakingInfo = e,
            steamworks.isGreenworksEnabled())
                if (void 0 !== this._connectedMatchmakingInfo) {
                    const e = steamworks.setSteamRichPresence("status", "Playing Multiplayer");
                    e || steamworks.multiplayerLogError("Failed to set rich presence")
                } else
                    steamworks.leaveLobby(),
                    steamworks.clearSteamRichPresence();
            steamworks.updateDiscordPresence()
        }
        convertToMatchmakingInfo(e, t=V.default .create() ) {
            return "string" == typeof e ? {
                identifier: t,
                channel: e,
                matchmakingServer: `${p.networkingOptions.matchmakingServer}:${p.networkingOptions.matchmakingServerPort}`,
                isDedicatedServer: !1
            } : e
        }
        getSyncPacketWaitId(e, t) {
            const a = e.getRegistrarId();
            let i;
            return void 0 !== t && (i = `${a}`,
            "number" == typeof t && (i += `,${t}`)),
            i
        }
    }
    __decorate([d.HookMethod(-999999999999)], ee.prototype, "preSaveGame", null),
    __decorate([d.HookMethod(-999999999999)], ee.prototype, "postSaveGame", null),
    t.default = ee
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("npc/NPCManager", ["require", "exports", "entity/EntityManager", "Enums", "mod/IHookManager", "npc/NPCS", "utilities/Log", "utilities/Misc"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l extends a.default {
        getEntities() {
            return game.npcs
        }
        spawn(e, t, a, l) {
            const u = game.getTile(t, a, l);
            if (!u)
                return;
            if (void 0 !== u.npc)
                return;
            const d = o.registrar.get(e);
            if (void 0 === d)
                return;
            if (!1 === modManager.getHook(n.Hook.CanNPCSpawn).call(e, t, a, l))
                return;
            const p = s.findUnusedId(r.LogSource.NPCManager, game.npcs)
              , c = new d(p,t,a,l);
            return c.fromX = t,
            c.fromY = a,
            c.facingDirection = i.Direction.South,
            game.npcs[p] = c,
            u.npc = c,
            modManager.getHook(n.Hook.OnNPCSpawn).call(c),
            c
        }
        remove(e) {
            const t = e.getTile();
            t && delete t.npc,
            itemManager.removeContainerItems(e.inventory),
            super.remove(e)
        }
        updateAll() {
            for (const e of game.npcs)
                e && e.update()
        }
    }
    __decorate([Override], l.prototype, "getEntities", null),
    __decorate([Override], l.prototype, "remove", null),
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/fieldofview/FieldOfViewDebugRenderer", ["require", "exports", "renderer/Shaders"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i {
        constructor(e, t) {
            this.fov = t,
            this.gl = e;
            let i = [.5, .5, 0, 0, 1, .5, 1, 0, 1, 1, 1, 1, .5, .5, 0, 0, 1, 1, 1, 1, .5, 1, 0, 1];
            const n = e.createBuffer()
              , o = e.createBuffer();
            n && o && (this.viewQuadBuffer = n,
            e.bindBuffer(e.ARRAY_BUFFER, this.viewQuadBuffer),
            e.bufferData(e.ARRAY_BUFFER, new Float32Array(i), e.STATIC_DRAW),
            i = [.5, 0, 0, 1, 1, 0, 1, 1, 1, .5, 1, 0, .5, 0, 0, 1, 1, .5, 1, 0, .5, .5, 0, 0],
            this.viewQuadBuffer2 = o,
            e.bindBuffer(e.ARRAY_BUFFER, this.viewQuadBuffer2),
            e.bufferData(e.ARRAY_BUFFER, new Float32Array(i), e.DYNAMIC_DRAW),
            this.shaderProgramAlphaDebug = new a.CompiledProgram(e,"basic-texture-vertex","alpha-debug-fragment"))
        }
        renderDebug() {
            const e = this.gl
              , t = this.shaderProgramAlphaDebug;
            e.useProgram(t.program),
            e.enable(e.BLEND),
            e.enableVertexAttribArray(t.attribs.position),
            e.enableVertexAttribArray(t.attribs.texture),
            e.activeTexture(e.TEXTURE0),
            e.bindTexture(e.TEXTURE_2D, this.fov.texLight),
            e.uniform1i(t.uniforms.data, 0),
            e.bindBuffer(e.ARRAY_BUFFER, this.viewQuadBuffer),
            e.vertexAttribPointer(t.attribs.position, 2, e.FLOAT, !1, 16, 0),
            e.vertexAttribPointer(t.attribs.texture, 2, e.FLOAT, !1, 16, 8),
            e.drawArrays(e.TRIANGLES, 0, 6);
            const a = this.fov.getBounds(localPlayer)
              , i = a.min.x / game.mapSize
              , n = a.min.y / game.mapSize
              , o = a.max.x / game.mapSize
              , r = a.max.y / game.mapSize
              , s = [.5, 0, i, r, 1, 0, o, r, 1, .5, o, n, .5, 0, i, r, 1, .5, o, n, .5, .5, i, n];
            e.bindBuffer(e.ARRAY_BUFFER, this.viewQuadBuffer2),
            e.bufferData(e.ARRAY_BUFFER, new Float32Array(s), e.DYNAMIC_DRAW),
            e.activeTexture(e.TEXTURE0),
            e.bindTexture(e.TEXTURE_2D, renderer.layers[localPlayer.z].texExplored),
            e.uniform1i(t.uniforms.data, 0),
            e.bindBuffer(e.ARRAY_BUFFER, this.viewQuadBuffer2),
            e.vertexAttribPointer(t.attribs.position, 2, e.FLOAT, !1, 16, 0),
            e.vertexAttribPointer(t.attribs.texture, 2, e.FLOAT, !1, 16, 8),
            e.drawArrays(e.TRIANGLES, 0, 6)
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/fieldofview/FieldOfView", ["require", "exports", "renderer/fieldofview/FieldOfViewDebugRenderer", "renderer/RendererConstants", "renderer/Shaders", "save/clientStore/IClientStore", "utilities/math/Vector2", "utilities/Random"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l {
        constructor(e, t, a, i=1) {
            this.gl = e,
            this.radius = t,
            this.maxRadius = a,
            this.subdivisions = i,
            this.computeOffset = r.default.ZERO,
            this.transitionProgress = 1,
            this.subdivisions = Math.floor(this.subdivisions),
            this.blurEnabled = !0,
            this.disabled = !1,
            this.seed = s.default.generator.getSeed(),
            e && this.resetGl(e)
        }
        static compileShaders(e) {
            l.shaderProgram = new n.CompiledProgram(e,"fov-vertex","fov-fragment"),
            l.hBlurProgram = new n.CompiledProgram(e,"basic-texture-vertex","blur-horizontal-fragment"),
            l.vBlurProgram = new n.CompiledProgram(e,"basic-texture-vertex","blur-vertical-fragment")
        }
        resetGl(e) {
            this.gl = e,
            this.framebuffer1 && (e.deleteFramebuffer(this.framebuffer1),
            delete this.framebuffer1);
            const t = e.createFramebuffer();
            this.framebuffer2 && (e.deleteFramebuffer(this.framebuffer2),
            delete this.framebuffer2);
            const a = e.createFramebuffer();
            this.texLight01 && (e.deleteTexture(this.texLight01),
            delete this.texLight01);
            const n = e.createTexture();
            this.texLight02 && (e.deleteTexture(this.texLight02),
            delete this.texLight02);
            const o = e.createTexture();
            this.texBlurStorage && (e.deleteTexture(this.texBlurStorage),
            delete this.texBlurStorage);
            const r = e.createTexture();
            this.viewQuadBuffer && (e.deleteBuffer(this.viewQuadBuffer),
            delete this.viewQuadBuffer);
            const s = e.createBuffer();
            this.viewQuadVertexArray && (e.deleteVertexArray(this.viewQuadVertexArray),
            delete this.viewQuadVertexArray);
            const u = e instanceof WebGL2RenderingContext ? e.createVertexArray() : void 0;
            if (!(t && a && n && o && r && s))
                return;
            this.framebuffer1 = t,
            e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer1);
            const d = this.getTextureSize();
            this.texLight01 = n,
            e.bindTexture(e.TEXTURE_2D, this.texLight01),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, d, d, 0, e.RGBA, e.UNSIGNED_BYTE, i.emptyUint8Array),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.texLight01, 0),
            this.framebuffer2 = a,
            e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer2),
            this.texLight02 = o,
            e.bindTexture(e.TEXTURE_2D, this.texLight02),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, d, d, 0, e.RGBA, e.UNSIGNED_BYTE, i.emptyUint8Array),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.texLight02, 0),
            this.texBlurStorage = r,
            e.bindTexture(e.TEXTURE_2D, this.texBlurStorage),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, d, d, 0, e.RGBA, e.UNSIGNED_BYTE, i.emptyUint8Array),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);
            const p = [-1, -1, 0, 1, 1, -1, 1, 1, 1, 1, 1, 0, -1, -1, 0, 1, 1, 1, 1, 0, -1, 1, 0, 0];
            this.viewQuadBuffer = s,
            e.bindBuffer(e.ARRAY_BUFFER, s),
            e.bufferData(e.ARRAY_BUFFER, new Float32Array(p), e.STATIC_DRAW),
            e.bindBuffer(e.ARRAY_BUFFER, null),
            u && (this.viewQuadVertexArray = u,
            e.bindVertexArray(this.viewQuadVertexArray),
            e.bindBuffer(e.ARRAY_BUFFER, s),
            e.enableVertexAttribArray(l.shaderProgram.attribs.position),
            e.vertexAttribPointer(l.shaderProgram.attribs.position, 2, e.FLOAT, !1, 16, 0),
            e.enableVertexAttribArray(l.shaderProgram.attribs.texture),
            e.vertexAttribPointer(l.shaderProgram.attribs.texture, 2, e.FLOAT, !1, 16, 8),
            e.bindBuffer(e.ARRAY_BUFFER, null),
            e.bindVertexArray(null)),
            this.texLight = this.texLight01,
            this.texLightOld = this.texLight02
        }
        updateRadius(e, t) {
            this.radius === e && this.maxRadius === t || (this.radius = e,
            this.maxRadius = t,
            this.resetGl(this.gl),
            this.compute(!0))
        }
        getTextureSize() {
            return Math.floor((2 * this.maxRadius + 1) * this.subdivisions)
        }
        getSubdivisions() {
            return this.subdivisions
        }
        tickSeed() {
            this.seed = s.default.generator.tickSeed(this.seed)
        }
        updateTransitionProgress() {
            return void 0 !== this.transitionFinishTime && (this.transitionProgress = 1 - Math.min(1, Math.max(0, (this.transitionFinishTime - game.absoluteTime) / (10 * game.interval))),
            1 === this.transitionProgress && (this.transitionFinishTime = void 0),
            !0)
        }
        resetTransitionProgress() {
            this.transitionFinishTime = void 0,
            this.transitionProgress = 1
        }
        compute(e) {
            if (e || !localPlayer.isMovingClientside) {
                s.default.generator.pushSeed(this.seed);
                try {
                    const e = this.gl;
                    if (this.computeLights(),
                    this.updateExplored(),
                    !e)
                        return;
                    let t = this.framebuffer1;
                    const a = localPlayer.x
                      , i = localPlayer.y;
                    let n = localPlayer.fromX
                      , o = localPlayer.fromY;
                    a - n > 255 ? n += game.mapSize : n - a > 255 && (n -= game.mapSize),
                    i - o > 255 ? o += game.mapSize : o - i > 255 && (o -= game.mapSize),
                    this.computeOffset.x = a - n,
                    this.computeOffset.y = i - o,
                    this.texLight === this.texLight01 ? (this.texLight = this.texLight02,
                    this.texLightOld = this.texLight01,
                    t = this.framebuffer2) : (this.texLight = this.texLight01,
                    this.texLightOld = this.texLight02),
                    e.bindTexture(e.TEXTURE_2D, renderer.layers[localPlayer.z].texLightLevel);
                    const r = world.layers[localPlayer.z].lightLevelMap;
                    if (e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, r.width, r.height, 0, e.ALPHA, e.UNSIGNED_BYTE, r.data),
                    e.bindFramebuffer(e.FRAMEBUFFER, t),
                    this.disabled)
                        return e.clearColor(0, 0, 0, 1),
                        e.clear(e.COLOR_BUFFER_BIT),
                        void e.bindFramebuffer(e.FRAMEBUFFER, null);
                    e.clearColor(0, 0, 0, 0),
                    e.clear(e.COLOR_BUFFER_BIT),
                    e.disable(e.BLEND);
                    const u = Math.floor((2 * this.radius + 1) * this.subdivisions)
                      , d = this.getTextureSize()
                      , p = .5 * (d - u);
                    e.viewport(p, p, u, u);
                    let c = l.shaderProgram;
                    e.useProgram(c.program),
                    this.viewQuadVertexArray || (e.enableVertexAttribArray(c.attribs.position),
                    e.enableVertexAttribArray(c.attribs.texture));
                    const m = game.getAmbientLightLevel(localPlayer.z);
                    this.lastAmbientLightLevel !== m && (this.transitionFinishTime = game.absoluteTime + 10 * game.interval,
                    this.lastAmbientLightLevel = m),
                    e.activeTexture(e.TEXTURE0),
                    e.bindTexture(e.TEXTURE_2D, renderer.layers[localPlayer.z].texLightBlock),
                    e.uniform1i(c.uniforms.lightBlock, 0),
                    e.activeTexture(e.TEXTURE1),
                    e.bindTexture(e.TEXTURE_2D, renderer.layers[localPlayer.z].texLightLevel),
                    e.uniform1i(c.uniforms.lightLevel, 1),
                    e.uniform1f(c.uniforms.lightAmbient, m),
                    e.uniform1i(c.uniforms.lightBlocking, 1),
                    e.uniform2f(c.uniforms.inverseLightBlockSize, 1 / world.width, 1 / world.height),
                    e.uniform1f(c.uniforms.inverseDetailLevel, 1 / this.subdivisions),
                    e.uniform1f(c.uniforms.viewRadius, this.radius),
                    e.uniform2f(c.uniforms.playerPos, localPlayer.x, localPlayer.y),
                    this.viewQuadVertexArray ? e.bindVertexArray(this.viewQuadVertexArray) : (e.bindBuffer(e.ARRAY_BUFFER, this.viewQuadBuffer),
                    e.vertexAttribPointer(c.attribs.position, 2, e.FLOAT, !1, 16, 0),
                    e.vertexAttribPointer(c.attribs.texture, 2, e.FLOAT, !1, 16, 8)),
                    e.drawArrays(e.TRIANGLES, 0, 6),
                    this.viewQuadVertexArray && e.bindVertexArray(null),
                    e.viewport(0, 0, d, d),
                    this.blurEnabled && (e.bindTexture(e.TEXTURE_2D, this.texBlurStorage),
                    e.copyTexSubImage2D(e.TEXTURE_2D, 0, 0, 0, 0, 0, d, d),
                    e.clear(e.COLOR_BUFFER_BIT),
                    c = l.hBlurProgram,
                    e.useProgram(c.program),
                    e.activeTexture(e.TEXTURE0),
                    e.bindTexture(e.TEXTURE_2D, this.texBlurStorage),
                    e.uniform1i(c.uniforms.data, 0),
                    e.uniform1f(c.uniforms.blurSize, 1 / (this.maxRadius * this.subdivisions * 5)),
                    this.viewQuadVertexArray ? e.bindVertexArray(this.viewQuadVertexArray) : (e.bindBuffer(e.ARRAY_BUFFER, this.viewQuadBuffer),
                    e.vertexAttribPointer(c.attribs.position, 2, e.FLOAT, !1, 16, 0),
                    e.vertexAttribPointer(c.attribs.texture, 2, e.FLOAT, !1, 16, 8)),
                    e.drawArrays(e.TRIANGLES, 0, 6),
                    this.viewQuadVertexArray && e.bindVertexArray(null),
                    e.bindTexture(e.TEXTURE_2D, this.texBlurStorage),
                    e.copyTexSubImage2D(e.TEXTURE_2D, 0, 0, 0, 0, 0, d, d),
                    e.clear(e.COLOR_BUFFER_BIT),
                    c = l.vBlurProgram,
                    e.useProgram(c.program),
                    e.activeTexture(e.TEXTURE0),
                    e.bindTexture(e.TEXTURE_2D, this.texBlurStorage),
                    e.uniform1i(c.uniforms.data, 0),
                    e.uniform1f(c.uniforms.blurSize, 1 / (this.maxRadius * this.subdivisions * 5)),
                    this.viewQuadVertexArray ? e.bindVertexArray(this.viewQuadVertexArray) : (e.bindBuffer(e.ARRAY_BUFFER, this.viewQuadBuffer),
                    e.vertexAttribPointer(c.attribs.position, 2, e.FLOAT, !1, 16, 0),
                    e.vertexAttribPointer(c.attribs.texture, 2, e.FLOAT, !1, 16, 8)),
                    e.drawArrays(e.TRIANGLES, 0, 6),
                    this.viewQuadVertexArray && e.bindVertexArray(null)),
                    e.bindFramebuffer(e.FRAMEBUFFER, null),
                    this.viewQuadVertexArray || (e.disableVertexAttribArray(c.attribs.position),
                    e.disableVertexAttribArray(c.attribs.texture))
                } finally {
                    s.default.generator.popSeed()
                }
            }
        }
        createDebugRenderer() {
            return this.debugRenderer || (this.debugRenderer = new a.default(this.gl,this)),
            this.debugRenderer
        }
        canASeeB(e, t, a, i, n, o, r) {
            if (a !== o)
                return !1;
            const s = game.getWrappedCoord(e)
              , l = game.getWrappedCoord(t)
              , u = world.toLocal(s, i)
              , d = world.toLocal(l, n)
              , p = u * u + d * d;
            return void 0 === r && (r = world.layers[a].lightLevelMap.get(s, l)),
            !(p >= (this.radius * Math.max(game.getAmbientLightLevel(a), r / 255 * 3, 1.6 - p)) ** 2) && Module.FieldOfView.bresenham(world.layers[o].instance, i, n, i + u, n + d)
        }
        getBounds(e, t=this.radius) {
            const a = Math.ceil(t)
              , i = new r.default(e.x - a,e.y - a)
              , n = new r.default(e.x + a,e.y + a);
            return {
                min: i,
                max: n,
                z: e.z
            }
        }
        updateExplored() {
            const e = this.gl
              , t = !this.disabled && e;
            if (t || multiplayer.isServer()) {
                t && e.bindTexture(e.TEXTURE_2D, renderer.layers[localPlayer.z].texExplored);
                try {
                    multiplayer.suppressSyncChecks(!0);
                    for (const t of game.getPlayers(!1, !0)) {
                        const a = t.isLocalPlayer();
                        if (!multiplayer.isServer() && !a)
                            continue;
                        const i = a ? world.layers[localPlayer.z].exploredMap : t.clientStore.get(o.ClientDataType.ExploredMap).getExploreMap(t.z)
                          , n = this.getBounds(t);
                        for (let o = n.min.x; o < n.max.x; o++)
                            for (let r = n.min.y; r < n.max.y; r++) {
                                const n = game.getWrappedCoord(o)
                                  , s = game.getWrappedCoord(r);
                                255 !== i.get(n, s) && t.canSeePosition(n, s, t.z, a) && (i.set(n, s, 255),
                                a && e.texSubImage2D(e.TEXTURE_2D, 0, n, s, 1, 1, e.ALPHA, e.UNSIGNED_BYTE, new Uint8Array([255])))
                            }
                    }
                } finally {
                    multiplayer.suppressSyncChecks(!1)
                }
            }
        }
        computeLights() {
            const e = Math.floor(localPlayer.x - this.radius)
              , t = Math.ceil(localPlayer.x + this.radius)
              , a = Math.floor(localPlayer.y - this.radius)
              , i = Math.ceil(localPlayer.y + this.radius);
            l.instance.computeLights(world.layers[localPlayer.z].instance, e, t, a, i)
        }
    }
    l.instance = new Module.FieldOfView,
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/SpriteBatch", ["require", "exports", "renderer/RendererConstants", "renderer/Shaders"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        constructor(e, t, a=0) {
            this.depthOffset = a,
            this.gl = e,
            this.count = 0,
            this.capacity = t;
            const o = e.createBuffer()
              , r = e.createBuffer()
              , s = e instanceof WebGL2RenderingContext ? e.createVertexArray() : void 0;
            if (!o || !r)
                throw new Error("Failed to create buffer");
            n.shaderProgram || (n.shaderProgram = new i.CompiledProgram(e,"sprite-shader-vertex","sprite-shader-fragment")),
            this.buffer = o,
            this.array = new Float32Array(this.capacity * n.spriteLength),
            e.bindBuffer(e.ARRAY_BUFFER, this.buffer),
            e.bufferData(e.ARRAY_BUFFER, this.array.byteLength, e.DYNAMIC_DRAW),
            this.colorBuffer = r,
            this.colorArray = new Uint8Array(4 * this.capacity),
            e.bindBuffer(e.ARRAY_BUFFER, this.colorBuffer),
            e.bufferData(e.ARRAY_BUFFER, this.colorArray.byteLength, e.DYNAMIC_DRAW),
            s && (this.vertexArray = s,
            e.bindVertexArray(this.vertexArray),
            e.bindBuffer(e.ARRAY_BUFFER, this.buffer),
            e.enableVertexAttribArray(n.shaderProgram.attribs.a_position),
            e.vertexAttribPointer(n.shaderProgram.attribs.a_position, 2, e.FLOAT, !1, 32, 0),
            e.enableVertexAttribArray(n.shaderProgram.attribs.a_pointSize),
            e.vertexAttribPointer(n.shaderProgram.attribs.a_pointSize, 1, e.FLOAT, !1, 32, 8),
            e.enableVertexAttribArray(n.shaderProgram.attribs.a_sourcePosition),
            e.vertexAttribPointer(n.shaderProgram.attribs.a_sourcePosition, 2, e.FLOAT, !1, 32, 12),
            e.enableVertexAttribArray(n.shaderProgram.attribs.a_sourceSize),
            e.vertexAttribPointer(n.shaderProgram.attribs.a_sourceSize, 1, e.FLOAT, !1, 32, 20),
            e.enableVertexAttribArray(n.shaderProgram.attribs.a_offset),
            e.vertexAttribPointer(n.shaderProgram.attribs.a_offset, 2, e.FLOAT, !1, 32, 24),
            e.bindBuffer(e.ARRAY_BUFFER, this.colorBuffer),
            e.enableVertexAttribArray(n.shaderProgram.attribs.a_color),
            e.vertexAttribPointer(n.shaderProgram.attribs.a_color, 4, e.UNSIGNED_BYTE, !0, 0, 0),
            e.bindBuffer(e.ARRAY_BUFFER, null),
            e.bindVertexArray(null))
        }
        static resetGl() {
            delete n.shaderProgram
        }
        dispose() {
            this.gl.deleteBuffer(this.buffer),
            this.gl.deleteBuffer(this.colorBuffer),
            this.vertexArray && this.gl.deleteVertexArray(this.vertexArray)
        }
        clear() {
            this.count = 0
        }
        begin() {
            if (this.begun)
                throw new Error("spriteBatch already began.");
            this.count = 0,
            this.begun = !0
        }
        add(e, t, a, i, o, r, s=0, l=0, u=255, d=255, p=255, c=255) {
            if (!this.begun)
                throw new Error("Cannot add to spritebatch without calling begin");
            if (this.count === this.capacity)
                return;
            let m = this.count * n.spriteLength;
            this.array[m + 0] = e,
            this.array[m + 1] = t,
            this.array[m + 2] = a,
            this.array[m + 3] = i,
            this.array[m + 4] = o,
            this.array[m + 5] = r,
            this.array[m + 6] = s,
            this.array[m + 7] = l,
            m = 4 * this.count,
            this.colorArray[m + 0] = u,
            this.colorArray[m + 1] = d,
            this.colorArray[m + 2] = p,
            this.colorArray[m + 3] = c,
            this.count++
        }
        end() {
            this.begun = !1;
            const e = this.gl;
            e.bindBuffer(e.ARRAY_BUFFER, this.buffer),
            e.bufferSubData(e.ARRAY_BUFFER, 0, this.array.subarray(0, this.count * n.spriteLength)),
            e.bindBuffer(e.ARRAY_BUFFER, this.colorBuffer),
            e.bufferSubData(e.ARRAY_BUFFER, 0, this.colorArray.subarray(0, 4 * this.count))
        }
        render(e, t, i, o, r) {
            if (!this.texSprites || 0 === this.count)
                return;
            if (this.begun)
                throw new Error("Cannot render sprite batch.  Make sure you call spriteBatch.end() after adding sprites");
            const s = this.gl
              , l = n.shaderProgram;
            s.useProgram(l.program),
            s.depthFunc(s.LEQUAL),
            s.activeTexture(s.TEXTURE0),
            s.uniform1i(l.uniforms.sprites, 0),
            s.bindTexture(s.TEXTURE_2D, this.texSprites);
            const u = a.subTileSize;
            s.uniform1f(l.uniforms.zoom, i),
            s.uniform1f(l.uniforms.tileSize, 2 * u),
            s.uniform2f(l.uniforms.inverseViewportSize, 2 * i / o, 2 * i / r),
            s.uniform2f(l.uniforms.viewOffset, e, t),
            s.uniform2f(l.uniforms.inverseSourceTextureSize, this.inverseSpriteTextureSize.x, this.inverseSpriteTextureSize.y),
            s.uniform1f(l.uniforms.depthOffset, this.depthOffset),
            this.vertexArray ? s.bindVertexArray(this.vertexArray) : (s.enableVertexAttribArray(l.attribs.a_position),
            s.enableVertexAttribArray(l.attribs.a_offset),
            s.enableVertexAttribArray(l.attribs.a_pointSize),
            s.enableVertexAttribArray(l.attribs.a_sourcePosition),
            s.enableVertexAttribArray(l.attribs.a_sourceSize),
            s.enableVertexAttribArray(l.attribs.a_color),
            s.bindBuffer(s.ARRAY_BUFFER, this.buffer),
            s.vertexAttribPointer(l.attribs.a_position, 2, s.FLOAT, !1, 32, 0),
            s.vertexAttribPointer(l.attribs.a_pointSize, 1, s.FLOAT, !1, 32, 8),
            s.vertexAttribPointer(l.attribs.a_sourcePosition, 2, s.FLOAT, !1, 32, 12),
            s.vertexAttribPointer(l.attribs.a_sourceSize, 1, s.FLOAT, !1, 32, 20),
            s.vertexAttribPointer(l.attribs.a_offset, 2, s.FLOAT, !1, 32, 24),
            s.bindBuffer(s.ARRAY_BUFFER, this.colorBuffer),
            s.vertexAttribPointer(l.attribs.a_color, 4, s.UNSIGNED_BYTE, !0, 0, 0)),
            s.drawArrays(s.POINTS, 0, this.count),
            this.vertexArray ? s.bindVertexArray(null) : (s.disableVertexAttribArray(l.attribs.a_position),
            s.disableVertexAttribArray(l.attribs.a_offset),
            s.disableVertexAttribArray(l.attribs.a_pointSize),
            s.disableVertexAttribArray(l.attribs.a_sourcePosition),
            s.disableVertexAttribArray(l.attribs.a_sourceSize),
            s.disableVertexAttribArray(l.attribs.a_color))
        }
    }
    n.spriteLength = 8,
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/Notifier", ["require", "exports", "Enums", "renderer/RendererConstants", "renderer/SpriteBatch", "utilities/math/Vector2"], function(e, t, a, i, n, o) {
    var r, s, l;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Item = 0] = "Item",
        e[e.Stat = 1] = "Stat"
    }(r || (r = {})),
    function(e) {
        e[e.Life = 32] = "Life",
        e[e.Delay = 4] = "Delay"
    }(s || (s = {})),
    function(e) {
        e[e.Count = 15] = "Count",
        e[e.Size = 8] = "Size",
        e[e.SourceSize = 12] = "SourceSize",
        e[e.MissSize = 32] = "MissSize"
    }(l || (l = {}));
    const u = [];
    u[a.StatType.EnemyHealth] = {
        pos: {
            r: 178,
            g: 0,
            b: 178
        },
        neg: {
            r: 255,
            g: 242,
            b: 46
        }
    },
    u[a.StatType.Health] = {
        pos: {
            r: 255,
            g: 0,
            b: 0
        },
        neg: {
            r: 255,
            g: 0,
            b: 0
        }
    },
    u[a.StatType.Metabolism] = {
        pos: {
            r: 137,
            g: 0,
            b: 254
        },
        neg: {
            r: 137,
            g: 0,
            b: 254
        }
    },
    u[a.StatType.Stamina] = {
        pos: {
            r: 0,
            g: 255,
            b: 12
        },
        neg: {
            r: 0,
            g: 255,
            b: 12
        }
    },
    u[a.StatType.Thirst] = {
        pos: {
            r: 0,
            g: 180,
            b: 255
        },
        neg: {
            r: 0,
            g: 180,
            b: 255
        }
    },
    u[a.StatType.Stat] = {
        pos: {
            r: 255,
            g: 153,
            b: 0
        },
        neg: {
            r: 255,
            g: 153,
            b: 0
        }
    },
    u[a.StatType.Zero] = {
        pos: {
            r: 178,
            g: 0,
            b: 255
        },
        neg: {
            r: 178,
            g: 0,
            b: 255
        }
    },
    u[a.StatType.Miss] = {
        pos: {
            r: 178,
            g: 0,
            b: 255
        },
        neg: {
            r: 178,
            g: 0,
            b: 255
        }
    };
    class d {
        constructor(e, t) {
            this.capacity = t,
            this.notifications = new Array(t),
            this.count = 0,
            this.mostRecent = 0,
            this.mostRecentLife = 0,
            this.nextUpdate = 0,
            this.spriteBatch = new n.default(e,t)
        }
        setTexture(e, t) {
            this.spriteBatch.texSprites = e,
            this.spriteBatch.inverseSpriteTextureSize = t
        }
        clear() {
            for (let e = 0; e < this.count; e++)
                this.notifications[e].life = 0;
            this.mostRecent = 0,
            this.mostRecentLife = 0,
            this.nextUpdate = 0
        }
        addItem(e, t, a, i) {
            if (!game.playing || a !== localPlayer.z)
                return;
            const n = this.addNote(e, t, r.Item);
            n && (n.itemType = i)
        }
        addStat(e, t, a, i, n) {
            if (!game.playing || a !== localPlayer.z)
                return;
            const o = this.addNote(e, t, r.Stat);
            o && (o.statType = i,
            o.value = n)
        }
        update() {
            if (game.absoluteTime > this.nextUpdate) {
                const e = Math.min((game.absoluteTime - this.nextUpdate) / 24, 10);
                this.nextUpdate = game.absoluteTime + 24;
                for (let t = 0; t < e; t++) {
                    for (let e = 0; e < this.count; e++) {
                        const t = this.notifications[e];
                        t.life > 0 && (t.life < s.Life ? t.pos.y -= .0625 : t.life - 1 <= s.Life && (t.pos.x = t.pos.x ? t.pos.x : localPlayer.x,
                        t.pos.y = t.pos.y ? t.pos.y : localPlayer.y,
                        t.type === r.Item && audio.queueEffect(a.SfxType.PickUp, t.pos.x, t.pos.y, localPlayer.z)),
                        t.life--)
                    }
                    this.mostRecentLife > 0 && this.mostRecentLife--
                }
            }
        }
        render(e, t, a, i, n, o) {
            const r = this.spriteBatch
              , l = this.notifications;
            let u, d;
            for (r.begin(),
            u = this.mostRecent; u < this.count; u++)
                (d = l[u]).life > 0 && d.life <= s.Life && this.renderNote(d);
            for (u = 0; u < this.mostRecent; u++)
                (d = l[u]).life > 0 && d.life <= s.Life && this.renderNote(d);
            r.end(),
            r.render(e, t, i, n, o)
        }
        addNote(e, t, a) {
            if (!localPlayer.canSeePosition(e, t, localPlayer.z, !0))
                return;
            e === localPlayer.x && t === localPlayer.y && (e = t = NaN),
            this.mostRecent === this.capacity && (this.mostRecent = 0);
            const i = this.mostRecentLife < s.Life - s.Delay ? s.Life : this.mostRecentLife + s.Delay;
            if (this.mostRecent === this.count) {
                const n = {
                    type: a,
                    pos: new o.default(e,t),
                    life: i
                };
                return this.notifications[this.mostRecent] = n,
                this.count++,
                this.mostRecent++,
                this.mostRecentLife = i,
                n
            }
            const n = this.notifications[this.mostRecent];
            return n.life <= 0 ? (n.type = a,
            n.pos.x = e,
            n.pos.y = t,
            n.life = i,
            this.mostRecent++,
            this.mostRecentLife = i,
            n) : void 0
        }
        renderNote(e) {
            let t;
            if (e.type === r.Item) {
                const a = e
                  , i = spriteAtlas.items[a.itemType];
                if (!i)
                    return;
                if (!(t = i.texCoord))
                    return;
                this.spriteBatch.add(e.pos.x, e.pos.y, 16, t.x, t.y, 16, 0, 0, 255, 255, 255, Math.floor(255 * Math.min(e.life / 8, 1)))
            } else if (e.type === r.Stat) {
                let n, o;
                const r = e;
                r.value <= 0 ? (o = u[r.statType].neg,
                n = 0 === r.value ? `-${r.value.toString()}` : r.value.toString()) : (o = u[r.statType].pos,
                n = `+${r.value.toString()}`);
                const s = (l.Size - 2) / i.subTileSize * .5;
                if (r.statType === a.StatType.Miss) {
                    const a = -.5 * s;
                    t = spriteAtlas.miss.texCoord,
                    this.spriteBatch.add(e.pos.x + a + .5 * s, e.pos.y, l.MissSize - 10, t.x, t.y, l.MissSize, 0, 0, o.r, o.g, o.b, Math.floor(255 * Math.min(e.life / 8, 1)))
                } else {
                    const a = n.length * s * -.5;
                    t = spriteAtlas.text.texCoord;
                    for (let i = n.length - 1; i >= 0; i--) {
                        const r = n[i];
                        this.spriteBatch.add(e.pos.x + a + (i + .5) * s, e.pos.y, l.Size, t.x + 1 + (r.charCodeAt(0) - 43) * l.SourceSize, t.y + 1, l.SourceSize, 0, 0, o.r, o.g, o.b, Math.floor(255 * Math.min(e.life / 8, 1)))
                    }
                }
            }
        }
    }
    t.default = d
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/particle/Particle", ["require", "exports", "renderer/RendererConstants", "renderer/Shaders", "utilities/math/Math2"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o {
        constructor(e, t=256) {
            this.gl = e,
            this.particleSize = 10,
            this.lastUsedParticle = 0,
            this.count = 0,
            this.capacity = t,
            this.particles = new Float32Array(this.particleSize * t),
            this.positionSizeData = new Float32Array(3 * t),
            this.colorData = new Uint8Array(4 * t);
            const a = e.createBuffer()
              , n = e.createBuffer()
              , r = e instanceof WebGL2RenderingContext ? e.createVertexArray() : void 0;
            if (!a || !n)
                throw new Error("Unable to create buffers");
            o.shaderProgram = new i.CompiledProgram(e,"particle-shader-vertex","particle-shader-fragment"),
            this.positionSizeBuf = a,
            e.bindBuffer(e.ARRAY_BUFFER, this.positionSizeBuf),
            e.bufferData(e.ARRAY_BUFFER, this.positionSizeData.byteLength, e.STREAM_DRAW),
            e.bindBuffer(e.ARRAY_BUFFER, null),
            this.colorBuf = n,
            e.bindBuffer(e.ARRAY_BUFFER, this.colorBuf),
            e.bufferData(e.ARRAY_BUFFER, this.colorData.byteLength, e.STREAM_DRAW),
            e.bindBuffer(e.ARRAY_BUFFER, null),
            r && (this.vertexArray = r,
            e.bindVertexArray(this.vertexArray),
            e.bindBuffer(e.ARRAY_BUFFER, this.positionSizeBuf),
            e.enableVertexAttribArray(o.shaderProgram.attribs.a_position),
            e.vertexAttribPointer(o.shaderProgram.attribs.a_position, 2, e.FLOAT, !1, 12, 0),
            e.enableVertexAttribArray(o.shaderProgram.attribs.a_pointSize),
            e.vertexAttribPointer(o.shaderProgram.attribs.a_pointSize, 1, e.FLOAT, !1, 12, 8),
            e.bindBuffer(e.ARRAY_BUFFER, this.colorBuf),
            e.enableVertexAttribArray(o.shaderProgram.attribs.a_color),
            e.vertexAttribPointer(o.shaderProgram.attribs.a_color, 4, e.UNSIGNED_BYTE, !0, 0, 0),
            e.bindBuffer(e.ARRAY_BUFFER, null),
            e.bindVertexArray(null))
        }
        create(e, t, a, i) {
            this.createMultiple(e, t, a, i, 1)
        }
        createMultiple(e, t, a, i, n, o=5, r=!1) {
            !game.isRealTimeMode() && localPlayer.isResting() && !localPlayer.isRestingCancelled() || localPlayer.z !== a || (e = game.wrapCoordinate(e, localPlayer.x),
            t = game.wrapCoordinate(t, localPlayer.y),
            (r || localPlayer.canSeePosition(e, t, a, !0)) && this.spawn(e, t, i.r, i.g, i.b, o, n))
        }
        clear() {
            this.count = 0,
            this.lastUsedParticle = 0;
            for (let e = 0; e < this.capacity; e++)
                this.particles[e * this.particleSize] = 0
        }
        simulate() {
            this.count = 0;
            for (let e = 0; e < this.capacity; e++) {
                const t = e * this.particleSize
                  , a = this.particles[t];
                a > 0 && (this.particles[t]--,
                a > 36 && (this.particles[t + 1] += .005 * this.particles[t + 3],
                this.particles[t + 2] += .005 * this.particles[t + 4]),
                this.particles[t + 9] -= 3.25,
                this.positionSizeData[3 * this.count + 0] = this.particles[t + 1],
                this.positionSizeData[3 * this.count + 1] = this.particles[t + 2],
                this.positionSizeData[3 * this.count + 2] = this.particles[t + 5],
                this.colorData[4 * this.count + 0] = this.particles[t + 6],
                this.colorData[4 * this.count + 1] = this.particles[t + 7],
                this.colorData[4 * this.count + 2] = this.particles[t + 8],
                this.colorData[4 * this.count + 3] = this.particles[t + 9],
                this.count++)
            }
        }
        render(e, t) {
            if (0 === this.count)
                return;
            const i = this.gl;
            i.bindBuffer(i.ARRAY_BUFFER, this.positionSizeBuf),
            this.vertexArray || i.bufferData(i.ARRAY_BUFFER, this.positionSizeData.byteLength, i.STREAM_DRAW),
            i.bufferSubData(i.ARRAY_BUFFER, 0, new DataView(this.positionSizeData.buffer,0,12 * this.count)),
            this.vertexArray && i.bindBuffer(i.ARRAY_BUFFER, null),
            i.bindBuffer(i.ARRAY_BUFFER, this.colorBuf),
            this.vertexArray || i.bufferData(i.ARRAY_BUFFER, this.colorData.byteLength, i.STREAM_DRAW),
            i.bufferSubData(i.ARRAY_BUFFER, 0, new DataView(this.colorData.buffer,0,4 * this.count)),
            this.vertexArray && i.bindBuffer(i.ARRAY_BUFFER, null);
            const n = o.shaderProgram;
            i.useProgram(n.program);
            const r = a.subTileSize
              , s = renderer.getTileScale()
              , l = renderer.getViewport();
            i.uniform1f(n.uniforms.lightAmbient, 1 - .75 * game.time.getBrightness()),
            i.uniform1f(n.uniforms.zoom, s),
            i.uniform1f(n.uniforms.tileSize, 2 * r),
            i.uniform2f(n.uniforms.inverseViewportSize, 2 * s / l.x, 2 * s / l.y),
            i.uniform2f(n.uniforms.viewOffset, e, t),
            i.enable(i.BLEND),
            this.vertexArray ? i.bindVertexArray(this.vertexArray) : (i.enableVertexAttribArray(n.attribs.a_position),
            i.bindBuffer(i.ARRAY_BUFFER, this.positionSizeBuf),
            i.vertexAttribPointer(n.attribs.a_position, 2, i.FLOAT, !1, 12, 0),
            i.enableVertexAttribArray(n.attribs.a_pointSize),
            i.vertexAttribPointer(n.attribs.a_pointSize, 1, i.FLOAT, !1, 12, 8),
            i.enableVertexAttribArray(n.attribs.a_color),
            i.bindBuffer(i.ARRAY_BUFFER, this.colorBuf),
            i.vertexAttribPointer(n.attribs.a_color, 4, i.UNSIGNED_BYTE, !0, 0, 0)),
            i.drawArrays(i.POINTS, 0, this.count),
            this.vertexArray ? i.bindVertexArray(null) : (i.disableVertexAttribArray(n.attribs.a_position),
            i.disableVertexAttribArray(n.attribs.a_pointSize),
            i.disableVertexAttribArray(n.attribs.a_color))
        }
        findUnusedParticle() {
            let e;
            for (e = this.lastUsedParticle; e < this.capacity; e++)
                if (this.particles[e * this.particleSize] <= 0)
                    return this.lastUsedParticle = e,
                    e;
            for (e = 0; e < this.lastUsedParticle; e++)
                if (this.particles[e * this.particleSize] <= 0)
                    return this.lastUsedParticle = e,
                    e;
            return 0
        }
        spawn(e, t, a, i, o, r, s) {
            for (let l = 1; l <= r; l++) {
                const r = Math.floor(100 * Math.random() - 75)
                  , l = [.8, .7, 0]
                  , u = [a + r, i + r, o + r]
                  , d = game.getAmbientLightLevel(localPlayer.z)
                  , p = world.layers[localPlayer.z].lightLevelMap.get(e, t) / 255
                  , c = renderer.getAmbientColor();
                for (let e = 0; e < 3; e++) {
                    const t = Math.max(d, p * l[e] * (1 - d));
                    u[e] *= Math.max(c[e], 1.25 * t) + Math.floor(t / 2) + p
                }
                for (let a = 0; a < s; a++) {
                    const a = this.findUnusedParticle() * this.particleSize;
                    this.particles[a + 0] = 75,
                    this.particles[a + 1] = e,
                    this.particles[a + 2] = t,
                    this.particles[a + 3] = Math.floor(8 * Math.random() - 4),
                    this.particles[a + 4] = Math.floor(8 * Math.random() - 4),
                    this.particles[a + 5] = Math.floor(3 * Math.random() + 1),
                    this.particles[a + 6] = n.default.clamp255(u[0]),
                    this.particles[a + 7] = n.default.clamp255(u[1]),
                    this.particles[a + 8] = n.default.clamp255(u[2]),
                    this.particles[a + 9] = 255
                }
            }
        }
    }
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/SpriteAtlas", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor() {
            this.corpses = {},
            this.creatures = {},
            this.items = {},
            this.itemsEquipped = {},
            this.itemsSmall = {},
            this.npcs = {},
            this.overlay = {},
            this.playerHairstyles = {},
            this.sleeps = {},
            this.statusEffects = {},
            this.tileEvents = {}
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/TileAtlas", ["require", "exports", "Enums", "renderer/TerrainTileInfo", "tile/Terrains"], function(e, t, a, i, n) {
    var o;
    function r(e, t) {
        return e >= o.CenterTopLeft ? (e - o.CenterTopLeft + t) % 4 + o.CenterTopLeft : e >= o.Q4TopLeft ? (e - o.Q4TopLeft + t) % 4 + o.Q4TopLeft : (e + 2 * t) % 8
    }
    function s(e, t, a=0) {
        switch (e) {
        case o.CenterTopLeft:
            return t.getCenterTopLeft(a);
        case o.CenterTopRight:
            return t.getCenterTopRight(a);
        case o.CenterBottomLeft:
            return t.getCenterBottomLeft(a);
        case o.CenterBottomRight:
            return t.getCenterBottomRight(a);
        case o.Q2TopRightQ1TopLeft:
            return t.getTop(a);
        case o.Q2BottomLeftQ3TopLeft:
            return t.getLeft(a);
        case o.Q1BottomRightQ4TopRight:
            return t.getRight(a);
        case o.Q3BottomRightQ4BottomLeft:
            return t.getBottom(a);
        default:
            {
                let a = o[e];
                if ((a = a[0].toLowerCase() + a.slice(1))in t)
                    return t[a]
            }
        }
        throw new Error("invalid tileType")
    }
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Q2TopRightQ1TopLeft = 0] = "Q2TopRightQ1TopLeft",
        e[e.Q2TopLeft = 1] = "Q2TopLeft",
        e[e.Q2BottomLeftQ3TopLeft = 2] = "Q2BottomLeftQ3TopLeft",
        e[e.Q3BottomLeft = 3] = "Q3BottomLeft",
        e[e.Q3BottomRightQ4BottomLeft = 4] = "Q3BottomRightQ4BottomLeft",
        e[e.Q4BottomRight = 5] = "Q4BottomRight",
        e[e.Q1BottomRightQ4TopRight = 6] = "Q1BottomRightQ4TopRight",
        e[e.Q1TopRight = 7] = "Q1TopRight",
        e[e.Q4TopLeft = 8] = "Q4TopLeft",
        e[e.Q1BottomLeft = 9] = "Q1BottomLeft",
        e[e.Q2BottomRight = 10] = "Q2BottomRight",
        e[e.Q3TopRight = 11] = "Q3TopRight",
        e[e.CenterTopLeft = 12] = "CenterTopLeft",
        e[e.CenterBottomLeft = 13] = "CenterBottomLeft",
        e[e.CenterBottomRight = 14] = "CenterBottomRight",
        e[e.CenterTopRight = 15] = "CenterTopRight",
        e[e.CenterQ1TopRight = 16] = "CenterQ1TopRight",
        e[e.CenterQ1TopLeft = 17] = "CenterQ1TopLeft",
        e[e.CenterQ1BottomLeft = 18] = "CenterQ1BottomLeft",
        e[e.CenterQ1BottomRight = 19] = "CenterQ1BottomRight",
        e[e.CenterQ2TopRight = 20] = "CenterQ2TopRight",
        e[e.CenterQ2TopLeft = 21] = "CenterQ2TopLeft",
        e[e.CenterQ2BottomLeft = 22] = "CenterQ2BottomLeft",
        e[e.CenterQ2BottomRight = 23] = "CenterQ2BottomRight",
        e[e.CenterQ3TopRight = 24] = "CenterQ3TopRight",
        e[e.CenterQ3TopLeft = 25] = "CenterQ3TopLeft",
        e[e.CenterQ3BottomLeft = 26] = "CenterQ3BottomLeft",
        e[e.CenterQ3BottomRight = 27] = "CenterQ3BottomRight",
        e[e.CenterQ4TopRight = 28] = "CenterQ4TopRight",
        e[e.CenterQ4TopLeft = 29] = "CenterQ4TopLeft",
        e[e.CenterQ4BottomLeft = 30] = "CenterQ4BottomLeft",
        e[e.CenterQ4BottomRight = 31] = "CenterQ4BottomRight",
        e[e.Q1TopLeft = 32] = "Q1TopLeft",
        e[e.Q1BottomRight = 33] = "Q1BottomRight",
        e[e.Q2TopRight = 34] = "Q2TopRight",
        e[e.Q2BottomLeft = 35] = "Q2BottomLeft",
        e[e.Q3TopLeft = 36] = "Q3TopLeft",
        e[e.Q3BottomRight = 37] = "Q3BottomRight",
        e[e.Q4TopRight = 38] = "Q4TopRight",
        e[e.Q4BottomLeft = 39] = "Q4BottomLeft"
    }(o = t.TileType || (t.TileType = {})),
    t.rotateTileType90Deg = r,
    t.getTileLoc = s;
    class l {
        constructor() {
            this.terrain = {},
            this.terrainTilled = {},
            this.doodads = {},
            this.doodadItems = {},
            this.mounds = {}
        }
        isMountain(e) {
            return this.terrain[e]instanceof i.MountainTileInfo
        }
        isOre(e) {
            const t = n.default[e];
            return !(!t || !t.isOre)
        }
        isLava(e) {
            return e === a.TerrainType.Lava || e === a.TerrainType.CoolingLava || e === a.TerrainType.Obsidian
        }
        isWater(e) {
            return e <= a.TerrainType.ShallowFreshWater
        }
        isFloor(e) {
            return e === a.TerrainType.WoodenFlooring || e === a.TerrainType.SandstoneFlooring || e === a.TerrainType.CobblestoneFlooring || e === a.TerrainType.ClayBrickFlooring || e === a.TerrainType.RedCarpet
        }
    }
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/WorldLayer", ["require", "exports", "doodad/Doodads", "Enums", "renderer/ExploreMap", "tile/Terrains", "utilities/TileHelpers"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class s {
        constructor(e, t, a) {
            this.width = e,
            this.height = t,
            this.level = a,
            this.terrainMap = new Uint32Array(e * t),
            this.instance = new Module.WorldLayer(e,t,a),
            this.lightBlockMap = this.instance.getLightBlockMap(),
            this.lightLevelMap = this.instance.getLightLevelMap(),
            this.exploredMap = new n.default(this.width,this.height),
            this.resetExploredMap()
        }
        delete() {
            this.instance.delete()
        }
        resetExploredMap() {
            this.exploredMap.clear()
        }
        getTileType(e, t) {
            return this.terrainMap[this.mapIndex(e, t)] & i.TerrainMask.Type
        }
        getTile(e, t) {
            return this.terrainMap[this.mapIndex(e, t)]
        }
        getType(e) {
            return e & i.TerrainMask.Type
        }
        isWall(e) {
            return 0 != (e & i.TerrainMask.Wall)
        }
        isFence(e) {
            return 0 != (e & i.TerrainMask.Fence)
        }
        isTilled(e) {
            return 0 != (e & i.TerrainMask.Tilled)
        }
        setTile(e, t, a, n=i.TerrainMask.None) {
            this.terrainMap[this.mapIndex(e, t)] = a | n
        }
        updateAll() {
            const e = game.mapSize
              , t = game.mapSize;
            let a, i;
            for (a = 0; a < e; a++)
                for (i = 0; i < t; i++) {
                    const e = game.getTile(a, i, this.level);
                    e && this.setTileInternal(a, i, e)
                }
        }
        updateTile(e, t, a, i=!1) {
            if (this.setTileInternal(e, t, a),
            !i || !this.onTileUpdate)
                return;
            const n = world.isLoaded();
            this.onTileUpdate(e, t, n),
            this.onTileUpdate(e - 1, t, n),
            this.onTileUpdate(e + 1, t, n),
            this.onTileUpdate(e, t - 1, n),
            this.onTileUpdate(e, t + 1, n),
            this.onTileUpdate(e, t, n),
            this.onTileUpdate(e - 1, t - 1, n),
            this.onTileUpdate(e - 1, t + 1, n),
            this.onTileUpdate(e + 1, t - 1, n),
            this.onTileUpdate(e + 1, t + 1, n)
        }
        mapIndex(e, t) {
            return e - this.width * Math.floor(e / this.width) + (t - this.height * Math.floor(t / this.height)) * this.width
        }
        setTileInternal(e, t, n) {
            let s = i.TerrainType.Dirt, l, u = 0, d = !1, p = !1, c = i.TerrainMask.None;
            const m = r.default.getType(n)
              , h = o.default[m];
            let y;
            h && (h.noLos && (p = !0),
            s = h.terrainType,
            h.doodad && (l = h.doodad,
            u = r.default.getGfx(n)));
            const g = n.doodad;
            if (g) {
                l = g.type;
                const e = a.default[l];
                if (e) {
                    e.graphicVariation && (d = !0,
                    u = void 0 !== g.gfx ? g.gfx : r.default.getGfx(n)),
                    g.gatherReady && e.isWaterSource && (u += 1),
                    g.isEmbers() && (u += 3);
                    const t = g.getGrowingStage();
                    switch (void 0 !== t ? (u -= 3,
                    t === i.GrowingStage.Germinating ? (u = 0,
                    y = tileAtlas.mounds[s] || tileAtlas.mounds[i.TerrainType.Dirt]) : t !== i.GrowingStage.Seedling && t !== i.GrowingStage.Vegetative && t !== i.GrowingStage.Dead && e.blockLos && (p = !0)) : e.blockLos && (p = !0),
                    l) {
                    case i.DoodadType.WoodenFence:
                    case i.DoodadType.WoodenGate:
                    case i.DoodadType.WoodenGateOpen:
                        c |= i.TerrainMask.Fence;
                        break;
                    case i.DoodadType.WoodenDoorOpen:
                        c |= i.TerrainMask.Wall;
                        break;
                    case i.DoodadType.WoodenWall:
                    case i.DoodadType.StoneWall:
                    case i.DoodadType.ClayBrickWall:
                    case i.DoodadType.SandstoneWall:
                    case i.DoodadType.WoodenDoor:
                        p = !0,
                        c |= i.TerrainMask.Wall
                    }
                }
                const t = g.getDoodadInfo();
                t && (y = t,
                u = 0)
            }
            y || (y = void 0 !== l ? tileAtlas.doodads[l] : void 0),
            r.default.isTilled(n) && (c |= i.TerrainMask.Tilled);
            const f = this.lightBlockMap.get(e, t);
            this.lightBlockMap.set(e, t, p ? 127 : 0),
            this.instance.updateLightBlockValue(e, t, f),
            this.setTile(e, t, s, c),
            this.onDoodadUpdate && this.onDoodadUpdate(e, t, l, y, u, d, world.isLoaded())
        }
    }
    t.default = s
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/World", ["require", "exports", "renderer/WorldLayer", "save/clientStore/IClientStore"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        constructor(e, t) {
            this.width = e,
            this.height = t,
            this.layers = new Array,
            this.loaded = !1
        }
        delete() {
            for (const e of this.layers)
                e.delete();
            this.layers = []
        }
        toLocal(e, t) {
            const a = this.width
              , i = this.width / 2;
            return (t = (e - t) % a) > i ? t -= a : t < -1 * i && (t += a),
            t
        }
        addLayer(e) {
            this.layers[e] = new a.default(this.width,this.height,e)
        }
        load() {
            this.updateAll(),
            this.loaded = !0
        }
        isLoaded() {
            return this.loaded
        }
        updateAll() {
            this.loaded = !1;
            for (const e of this.layers)
                e.updateAll()
        }
        setupExploredMap() {
            const e = localPlayer.clientStore.get(i.ClientDataType.ExploredMap)
              , t = e.exploredMap;
            for (const e of this.layers) {
                const a = t ? t[e.level] : void 0;
                a ? e.exploredMap = a : e.resetExploredMap()
            }
            delete e.exploredMap
        }
        resetExploredMap() {
            for (const e of this.layers)
                e.resetExploredMap()
        }
        updateTile(e, t, a, i) {
            const n = this.layers[a];
            n.updateTile(e, t, i, this.loaded),
            game.updateFlowFieldTile(i, e, t, a)
        }
        serializeObject(e) {
            for (const t of this.layers)
                t.exploredMap.encode(),
                e.writeProperty(t.exploredMap, "encodedData")
        }
        deserializeObject(e) {
            for (const t of this.layers)
                e.readProperty(t.exploredMap, "encodedData"),
                t.exploredMap.decode()
        }
    }
    t.default = n
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/tileAdaptors/Default", ["require", "exports", "Enums", "renderer/TileAdaptors", "renderer/TileAtlas", "tile/Terrains", "utilities/math/Vector2", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l {
        adapt(e, t, a, l, u) {
            const d = Math.floor(4 * s.default.getTileVariation(t, a))
              , p = e.getTile(t, a - 1)
              , c = e.getTile(t, a + 1)
              , m = e.getTile(t - 1, a)
              , h = e.getTile(t + 1, a)
              , y = e.getType(p) === l
              , g = e.getType(c) === l
              , f = e.getType(m) === l
              , T = e.getType(h) === l;
            let S = n.TileType.Q2TopLeft
              , I = n.TileType.Q1TopRight
              , v = n.TileType.Q3BottomLeft
              , w = n.TileType.Q4BottomRight;
            const M = tileAtlas.terrain[l];
            if (!M)
                return u.TLBG = u.TRBG = u.BLBG = u.BRBG = r.default.ZERO,
                void (u.TLFG = u.TRFG = u.BLFG = u.BRFG = r.default.ZERO);
            if (y && f) {
                const i = e.getTile(t - 1, a - 1);
                S = e.getType(i) === l ? n.TileType.CenterTopLeft : n.TileType.Q4TopLeft
            } else
                y && !f ? S = n.TileType.Q2BottomLeftQ3TopLeft : !y && f && (S = n.TileType.Q2TopRightQ1TopLeft);
            if (y && T) {
                const i = e.getTile(t + 1, a - 1);
                I = e.getType(i) === l ? n.TileType.CenterTopRight : n.TileType.Q3TopRight
            } else
                y && !T ? I = n.TileType.Q1BottomRightQ4TopRight : !y && T && (I = n.TileType.Q2TopRightQ1TopLeft);
            if (g && f) {
                const i = e.getTile(t - 1, a + 1);
                v = e.getType(i) === l ? n.TileType.CenterBottomLeft : n.TileType.Q1BottomLeft
            } else
                g && !f ? v = n.TileType.Q2BottomLeftQ3TopLeft : !g && f && (v = n.TileType.Q3BottomRightQ4BottomLeft);
            if (g && T) {
                const i = e.getTile(t + 1, a + 1);
                w = e.getType(i) === l ? n.TileType.CenterBottomRight : n.TileType.Q2BottomRight
            } else
                g && !T ? w = n.TileType.Q1BottomRightQ4TopRight : !g && T && (w = n.TileType.Q3BottomRightQ4BottomLeft);
            const b = o.default[l];
            if (b)
                if (b.noBackground)
                    u.TLBG = u.TRBG = u.BLBG = u.BRBG = r.default.ZERO;
                else {
                    const e = b.background
                      , t = e ? tileAtlas.terrain[e] : i.defaultBackground;
                    u.TLBG = t.getCenterTopLeft(d),
                    u.TRBG = t.getCenterTopRight(d),
                    u.BLBG = t.getCenterBottomLeft(d),
                    u.BRBG = t.getCenterBottomRight(d)
                }
            u.TLFG = n.getTileLoc(S, M, d),
            u.TRFG = n.getTileLoc(I, M, d),
            u.BLFG = n.getTileLoc(v, M, d),
            u.BRFG = n.getTileLoc(w, M, d)
        }
        getTerrainBeneathTile(e, t) {
            e = game.getWrappedCoord(e),
            t = game.getWrappedCoord(t);
            const i = game.getTileData(e, t, localPlayer.z);
            if (i && i.length > 1) {
                const e = i[1].type;
                if (tileAtlas.isWater(e))
                    return e
            }
            return a.TerrainType.Dirt
        }
    }
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/tileAdaptors/Dirt", ["require", "exports", "renderer/TileAtlas", "utilities/math/Vector2", "utilities/TileHelpers"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o {
        adapt(e, t, o, r, s) {
            const l = Math.floor(4 * n.default.getTileVariation(t, o))
              , u = tileAtlas.terrain[r];
            s.TLFG = a.getTileLoc(a.TileType.CenterTopLeft, u, l),
            s.TRFG = a.getTileLoc(a.TileType.CenterTopRight, u, l),
            s.BLFG = a.getTileLoc(a.TileType.CenterBottomLeft, u, l),
            s.BRFG = a.getTileLoc(a.TileType.CenterBottomRight, u, l),
            s.TLBG = i.default.ZERO,
            s.TRBG = i.default.ZERO,
            s.BLBG = i.default.ZERO,
            s.BRBG = i.default.ZERO
        }
    }
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/tileAdaptors/Floor", ["require", "exports", "Enums", "renderer/TileAdaptors", "renderer/tileAdaptors/Default", "renderer/TileAtlas", "utilities/math/Vector2", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l extends n.default {
        adapt(e, t, n, l, u) {
            const d = Math.floor(4 * s.default.getTileVariation(t, n))
              , p = e.isWall(e.getTile(t, n))
              , c = tileAtlas.isFloor(e.getTileType(t, n - 1))
              , m = tileAtlas.isFloor(e.getTileType(t, n + 1))
              , h = tileAtlas.isFloor(e.getTileType(t - 1, n))
              , y = tileAtlas.isFloor(e.getTileType(t + 1, n))
              , g = tileAtlas.isFloor(e.getTileType(t - 1, n - 1))
              , f = tileAtlas.isFloor(e.getTileType(t + 1, n - 1))
              , T = tileAtlas.isFloor(e.getTileType(t - 1, n + 1))
              , S = tileAtlas.isFloor(e.getTileType(t + 1, n + 1));
            let I = o.TileType.Q2TopLeft
              , v = o.TileType.Q1TopRight
              , w = o.TileType.Q3BottomLeft
              , M = o.TileType.Q4BottomRight;
            const b = tileAtlas.terrain[l];
            c && h ? I = g ? o.TileType.CenterTopLeft : o.TileType.Q4TopLeft : c && !h ? I = o.TileType.Q2BottomLeftQ3TopLeft : !c && h && (I = o.TileType.Q2TopRightQ1TopLeft),
            c && y ? v = f ? o.TileType.CenterTopRight : o.TileType.Q3TopRight : c && !y ? v = o.TileType.Q1BottomRightQ4TopRight : !c && y && (v = o.TileType.Q2TopRightQ1TopLeft),
            m && h ? w = T ? o.TileType.CenterBottomLeft : o.TileType.Q1BottomLeft : m && !h ? w = o.TileType.Q2BottomLeftQ3TopLeft : !m && h && (w = o.TileType.Q3BottomRightQ4BottomLeft),
            m && y ? M = S ? o.TileType.CenterBottomRight : o.TileType.Q2BottomRight : m && !y ? M = o.TileType.Q1BottomRightQ4TopRight : !m && y && (M = o.TileType.Q3BottomRightQ4BottomLeft),
            u.TLFG = o.getTileLoc(I, b, d),
            u.TRFG = o.getTileLoc(v, b, d),
            u.BLFG = o.getTileLoc(w, b, d),
            u.BRFG = o.getTileLoc(M, b, d);
            const k = this.getTerrainBeneathTile(t, n)
              , C = tileAtlas.terrain[k];
            if (C === i.defaultBackground)
                u.TLBG = C.getCenterTopLeft(d),
                u.TRBG = C.getCenterTopRight(d),
                u.BLBG = C.getCenterBottomLeft(d),
                u.BRBG = C.getCenterBottomRight(d);
            else {
                const a = {};
                renderer.waterAdaptor.adapt(e, t, n, k, a),
                u.TLBG = a.TLFG,
                u.TRBG = a.TRFG,
                u.BLBG = a.BLFG,
                u.BRBG = a.BRFG
            }
            if (p) {
                let i = !0;
                const o = game.getTile(t, n, e.level).doodad;
                if (o && (o.type === a.DoodadType.WoodenDoor || o.type === a.DoodadType.WoodenDoorOpen)) {
                    const e = o;
                    e.orientation === a.DoorOrientation.Default && (i = !1)
                }
                if (i) {
                    const a = !h && (!g || e.isWall(e.getTile(t - 1, n - 1))) && (!T || e.isWall(e.getTile(t - 1, n + 1)))
                      , i = !y && (!f || e.isWall(e.getTile(t + 1, n - 1))) && (!S || e.isWall(e.getTile(t + 1, n + 1)));
                    a && !i ? (u.TLFG = r.default.ZERO,
                    u.BLFG = r.default.ZERO) : i && !a && (u.TRFG = r.default.ZERO,
                    u.BRFG = r.default.ZERO)
                }
            }
        }
    }
    __decorate([Override], l.prototype, "adapt", null),
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/tileAdaptors/Lava", ["require", "exports", "renderer/TileAdaptors", "renderer/tileAdaptors/Default", "renderer/TileAtlas", "utilities/TileHelpers"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends i.default {
        adapt(e, t, i, r, s) {
            const l = Math.floor(4 * o.default.getTileVariation(t, i))
              , u = tileAtlas.terrain[r]
              , d = e.getTileType(t, i - 1)
              , p = e.getTileType(t, i + 1)
              , c = e.getTileType(t - 1, i)
              , m = e.getTileType(t + 1, i)
              , h = tileAtlas.isLava(d) && d <= r
              , y = tileAtlas.isLava(p) && p <= r
              , g = tileAtlas.isLava(c) && c <= r
              , f = tileAtlas.isLava(m) && m <= r;
            let T = n.TileType.Q2TopLeft, S = n.TileType.Q1TopRight, I = n.TileType.Q3BottomLeft, v = n.TileType.Q4BottomRight, w;
            h && g ? T = (w = a.getWaterType(e.getTileType(t - 1, i - 1))) <= r || tileAtlas.isFloor(w) && a.getWaterType(this.getTerrainBeneathTile(t - 1, i - 1)) <= r ? n.TileType.CenterTopLeft : n.TileType.Q4TopLeft : h && !g ? T = n.TileType.Q2BottomLeftQ3TopLeft : !h && g && (T = n.TileType.Q2TopRightQ1TopLeft),
            h && f ? S = (w = a.getWaterType(e.getTileType(t + 1, i - 1))) <= r || tileAtlas.isFloor(w) && a.getWaterType(this.getTerrainBeneathTile(t + 1, i - 1)) <= r ? n.TileType.CenterTopRight : n.TileType.Q3TopRight : h && !f ? S = n.TileType.Q1BottomRightQ4TopRight : !h && f && (S = n.TileType.Q2TopRightQ1TopLeft),
            y && g ? I = (w = a.getWaterType(e.getTileType(t - 1, i + 1))) <= r || tileAtlas.isFloor(w) && a.getWaterType(this.getTerrainBeneathTile(t - 1, i + 1)) <= r ? n.TileType.CenterBottomLeft : n.TileType.Q1BottomLeft : y && !g ? I = n.TileType.Q2BottomLeftQ3TopLeft : !y && g && (I = n.TileType.Q3BottomRightQ4BottomLeft),
            y && f ? v = (w = a.getWaterType(e.getTileType(t + 1, i + 1))) <= r || tileAtlas.isFloor(w) && a.getWaterType(this.getTerrainBeneathTile(t + 1, i + 1)) <= r ? n.TileType.CenterBottomRight : n.TileType.Q2BottomRight : y && !f ? v = n.TileType.Q1BottomRightQ4TopRight : !y && f && (v = n.TileType.Q3BottomRightQ4BottomLeft),
            s.TLBG = a.defaultBackground.getCenterTopLeft(l),
            s.TRBG = a.defaultBackground.getCenterTopRight(l),
            s.BLBG = a.defaultBackground.getCenterBottomLeft(l),
            s.BRBG = a.defaultBackground.getCenterBottomRight(l),
            s.TLFG = n.getTileLoc(T, u, l),
            s.TRFG = n.getTileLoc(S, u, l),
            s.BLFG = n.getTileLoc(I, u, l),
            s.BRFG = n.getTileLoc(v, u, l)
        }
    }
    __decorate([Override], r.prototype, "adapt", null),
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/tileAdaptors/Mountain", ["require", "exports", "renderer/TileAdaptors", "renderer/tileAdaptors/Default", "renderer/TileAtlas", "tile/Terrains", "utilities/math/Vector2", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class l extends i.default {
        adapt(e, t, i, l, u) {
            const d = Math.floor(4 * s.default.getTileVariation(t, i))
              , p = Math.floor(2 * s.default.getTileVariation(t, i))
              , c = tileAtlas.isMountain(e.getTileType(t, i - 1))
              , m = tileAtlas.isMountain(e.getTileType(t, i + 1))
              , h = tileAtlas.isMountain(e.getTileType(t - 1, i))
              , y = tileAtlas.isMountain(e.getTileType(t + 1, i))
              , g = tileAtlas.isMountain(e.getTileType(t - 1, i - 1))
              , f = tileAtlas.isMountain(e.getTileType(t + 1, i - 1))
              , T = tileAtlas.isMountain(e.getTileType(t - 1, i + 1))
              , S = tileAtlas.isMountain(e.getTileType(t + 1, i + 1))
              , I = c << 0 | g << 1 | h << 2 | T << 3 | m << 4 | S << 5 | y << 6 | f << 7
              , v = tileAtlas.terrain[l]
              , w = o.default[l]
              , M = w && w.background ? tileAtlas.terrain[w.background] : a.defaultBackground;
            let b;
            b = this.getTileType(I),
            this.mountainTopFlag ? (b = n.TileType.Q4BottomRight,
            255 == (255 & I) ? b = n.TileType.CenterTopLeft : 127 == (127 & I) ? b = n.TileType.Q3TopRight : 87 == (223 & I) ? b = n.TileType.Q4BottomRight : 223 == (223 & I) ? b = n.TileType.Q2BottomRight : 212 == (244 & I) || 212 == (220 & I) || 196 == (212 & I) ? b = n.TileType.Q3BottomRightQ4BottomLeft : 29 == (29 & I) && (b = n.TileType.Q1BottomRightQ4TopRight),
            u.TLFG = n.getTileLoc(b, v.extendedInfo, p + 2 * p),
            u.TLBG = v.getCenterTopLeft(d)) : (b === n.TileType.Q4TopLeft && 0 == (64 & I) ? (b = n.TileType.Q1TopRight,
            u.TLFG = n.getTileLoc(b, v.extendedInfo, p + 2 * p)) : 4 == (69 & I) ? (b = n.TileType.Q1TopRight,
            u.TLFG = n.getTileLoc(b, v.extendedInfo, p + 2 * p)) : u.TLFG = n.getTileLoc(b, v, p + 2 * p),
            u.TLBG = M.getCenterTopLeft(d));
            let k = I << 2 & 255 | I >> 6;
            b = n.rotateTileType90Deg(this.getTileType(k), 3),
            this.mountainTopFlag ? (b = n.TileType.Q3BottomLeft,
            255 == (255 & I) ? b = n.TileType.CenterTopRight : 253 == (253 & I) ? b = n.TileType.Q4TopLeft : 213 == (247 & I) ? b = n.TileType.Q3BottomLeft : 247 == (247 & I) ? b = n.TileType.Q1BottomLeft : 86 == (118 & I) || 86 == (118 & I) || 70 == (86 & I) ? b = n.TileType.Q3BottomRightQ4BottomLeft : 113 == (113 & I) && (b = n.TileType.Q2BottomLeftQ3TopLeft),
            u.TRFG = n.getTileLoc(b, v.extendedInfo, p + 2 * p),
            u.TRBG = v.getCenterTopRight(d)) : (b === n.TileType.Q3TopRight && 0 == (4 & I) ? (b = n.TileType.Q2TopLeft,
            u.TRFG = n.getTileLoc(b, v.extendedInfo, p + 2 * p)) : 64 == (69 & I) ? (b = n.TileType.Q2TopLeft,
            u.TRFG = n.getTileLoc(b, v.extendedInfo, p + 2 * p)) : u.TRFG = n.getTileLoc(b, v, p + 2 * p),
            u.TRBG = M.getCenterTopRight(d)),
            k = k << 2 & 255 | k >> 6,
            b = n.rotateTileType90Deg(this.getTileType(k), 2),
            this.mountainTopFlag ? (b = n.TileType.Q2BottomLeftQ3TopLeft,
            124 == (124 & I) && (b = n.TileType.CenterBottomRight),
            u.BRFG = n.getTileLoc(b, v.extendedInfo, p + 2 * p),
            u.BRBG = v.getCenterBottomRight(d)) : (u.BRFG = n.getTileLoc(b, v, p + 2 * p),
            u.BRBG = M.getCenterBottomRight(d)),
            k = k << 2 & 255 | k >> 6,
            b = n.rotateTileType90Deg(this.getTileType(k), 1),
            this.mountainTopFlag ? (b = n.TileType.Q1BottomRightQ4TopRight,
            124 == (124 & I) && (b = n.TileType.CenterBottomLeft),
            u.BLFG = n.getTileLoc(b, v.extendedInfo, p + 2 * p),
            u.BLBG = v.getCenterBottomLeft(d)) : (u.BLFG = n.getTileLoc(b, v, p + 2 * p),
            u.BLBG = M.getCenterBottomLeft(d)),
            w && w.noBackground && (u.TLBG = u.TRBG = u.BLBG = u.BRBG = r.default.ZERO)
        }
        getTileType(e) {
            return this.mountainTopFlag = !1,
            5 == (5 & e) ? 2 & e ? (this.mountainTopFlag = !0,
            n.TileType.CenterTopLeft) : n.TileType.Q4TopLeft : 1 == (5 & e) ? n.TileType.Q2BottomLeftQ3TopLeft : 4 == (5 & e) ? n.TileType.Q2TopRightQ1TopLeft : n.TileType.Q2TopLeft
        }
    }
    __decorate([Override], l.prototype, "adapt", null),
    t.default = l
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/tileAdaptors/Till", ["require", "exports", "renderer/TileAtlas", "utilities/math/Vector2", "utilities/TileHelpers"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class o {
        adapt(e, t, o, r, s) {
            const l = Math.floor(4 * n.default.getTileVariation(t, o))
              , u = e.getTile(t, o - 1)
              , d = e.getTile(t, o + 1)
              , p = e.getTile(t - 1, o)
              , c = e.getTile(t + 1, o)
              , m = e.getTile(t + 1, o - 1)
              , h = e.getTile(t - 1, o - 1)
              , y = e.getTile(t + 1, o + 1)
              , g = e.getTile(t - 1, o + 1)
              , f = e.getType(u) === r && e.isTilled(u)
              , T = e.getType(d) === r && e.isTilled(d)
              , S = e.getType(p) === r && e.isTilled(p)
              , I = e.getType(c) === r && e.isTilled(c)
              , v = e.getType(m) === r && e.isTilled(m)
              , w = e.getType(h) === r && e.isTilled(h)
              , M = e.getType(y) === r && e.isTilled(y)
              , b = e.getType(g) === r && e.isTilled(g);
            let k = a.TileType.Q4BottomRight
              , C = a.TileType.Q1TopRight
              , D = a.TileType.Q3BottomLeft
              , A = a.TileType.Q4BottomRight;
            const P = tileAtlas.terrainTilled[r];
            if (!P)
                return s.TLBG = s.TRBG = s.BLBG = s.BRBG = i.default.ZERO,
                void (s.TLFG = s.TRFG = s.BLFG = s.BRFG = i.default.ZERO);
            k = f ? S ? w ? a.TileType.CenterTopLeft : a.TileType.Q4TopLeft : a.TileType.Q3TopLeft : S ? a.TileType.Q1TopLeft : a.TileType.Q2TopLeft,
            C = f ? I ? v ? a.TileType.CenterTopRight : a.TileType.Q3TopRight : a.TileType.Q4TopRight : I ? a.TileType.Q2TopRight : a.TileType.Q1TopRight,
            D = T ? S ? b ? a.TileType.CenterBottomLeft : a.TileType.Q1BottomLeft : a.TileType.Q2BottomLeft : S ? a.TileType.Q4BottomLeft : a.TileType.Q3BottomLeft,
            A = T ? I ? M ? a.TileType.CenterBottomRight : a.TileType.Q2BottomRight : a.TileType.Q1BottomRight : I ? a.TileType.Q3BottomRight : a.TileType.Q4BottomRight,
            s.TLFG = a.getTileLoc(k, P, l),
            s.TRFG = a.getTileLoc(C, P, l),
            s.BLFG = a.getTileLoc(D, P, l),
            s.BRFG = a.getTileLoc(A, P, l)
        }
    }
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/tileAdaptors/Water", ["require", "exports", "renderer/TileAdaptors", "renderer/tileAdaptors/Default", "renderer/TileAtlas", "utilities/TileHelpers"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r extends i.default {
        adapt(e, t, i, r, s) {
            const l = Math.floor(4 * o.default.getTileVariation(t, i))
              , u = tileAtlas.terrain[r];
            r = a.getWaterType(r);
            const d = a.getWaterType(e.getTileType(t, i - 1))
              , p = a.getWaterType(e.getTileType(t, i + 1))
              , c = a.getWaterType(e.getTileType(t - 1, i))
              , m = a.getWaterType(e.getTileType(t + 1, i));
            let h = d <= r;
            !h && tileAtlas.isFloor(d) && (h = a.getWaterType(this.getTerrainBeneathTile(t, i - 1)) <= r);
            let y = p <= r;
            !y && tileAtlas.isFloor(p) && (y = a.getWaterType(this.getTerrainBeneathTile(t, i + 1)) <= r);
            let g = c <= r;
            !g && tileAtlas.isFloor(c) && (g = a.getWaterType(this.getTerrainBeneathTile(t - 1, i)) <= r);
            let f = m <= r;
            !f && tileAtlas.isFloor(m) && (f = a.getWaterType(this.getTerrainBeneathTile(t + 1, i)) <= r);
            let T = n.TileType.Q2TopLeft, S = n.TileType.Q1TopRight, I = n.TileType.Q3BottomLeft, v = n.TileType.Q4BottomRight, w;
            h && g ? T = (w = a.getWaterType(e.getTileType(t - 1, i - 1))) <= r || tileAtlas.isFloor(w) && a.getWaterType(this.getTerrainBeneathTile(t - 1, i - 1)) <= r ? n.TileType.CenterTopLeft : n.TileType.Q4TopLeft : h && !g ? T = n.TileType.Q2BottomLeftQ3TopLeft : !h && g && (T = n.TileType.Q2TopRightQ1TopLeft),
            h && f ? S = (w = a.getWaterType(e.getTileType(t + 1, i - 1))) <= r || tileAtlas.isFloor(w) && a.getWaterType(this.getTerrainBeneathTile(t + 1, i - 1)) <= r ? n.TileType.CenterTopRight : n.TileType.Q3TopRight : h && !f ? S = n.TileType.Q1BottomRightQ4TopRight : !h && f && (S = n.TileType.Q2TopRightQ1TopLeft),
            y && g ? I = (w = a.getWaterType(e.getTileType(t - 1, i + 1))) <= r || tileAtlas.isFloor(w) && a.getWaterType(this.getTerrainBeneathTile(t - 1, i + 1)) <= r ? n.TileType.CenterBottomLeft : n.TileType.Q1BottomLeft : y && !g ? I = n.TileType.Q2BottomLeftQ3TopLeft : !y && g && (I = n.TileType.Q3BottomRightQ4BottomLeft),
            y && f ? v = (w = a.getWaterType(e.getTileType(t + 1, i + 1))) <= r || tileAtlas.isFloor(w) && a.getWaterType(this.getTerrainBeneathTile(t + 1, i + 1)) <= r ? n.TileType.CenterBottomRight : n.TileType.Q2BottomRight : y && !f ? v = n.TileType.Q1BottomRightQ4TopRight : !y && f && (v = n.TileType.Q3BottomRightQ4BottomLeft),
            s.TLBG = a.defaultBackground.getCenterTopLeft(l),
            s.TRBG = a.defaultBackground.getCenterTopRight(l),
            s.BLBG = a.defaultBackground.getCenterBottomLeft(l),
            s.BRBG = a.defaultBackground.getCenterBottomRight(l),
            s.TLFG = n.getTileLoc(T, u, l),
            s.TRFG = n.getTileLoc(S, u, l),
            s.BLFG = n.getTileLoc(I, u, l),
            s.BRFG = n.getTileLoc(v, u, l)
        }
    }
    __decorate([Override], r.prototype, "adapt", null),
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("renderer/WorldRenderer", ["require", "exports", "creature/corpse/Corpses", "creature/Creatures", "entity/IEntity", "entity/StatusEffects", "Enums", "item/Items", "mod/IHookManager", "player/Customizations", "player/Player", "renderer/fieldofview/FieldOfView", "renderer/RendererConstants", "renderer/Shaders", "renderer/SpriteBatch", "renderer/StatusEffectRenderer", "renderer/tileAdaptors/Default", "renderer/tileAdaptors/Dirt", "renderer/tileAdaptors/Fence", "renderer/tileAdaptors/Floor", "renderer/tileAdaptors/Lava", "renderer/tileAdaptors/Mountain", "renderer/tileAdaptors/Till", "renderer/tileAdaptors/Wall", "renderer/tileAdaptors/Water", "renderer/WorldLayerRenderer", "tile/Terrains", "tile/TileEvents", "utilities/Color", "utilities/enum/Enums", "utilities/math/Math2", "utilities/math/Vector2", "utilities/PriorityList", "utilities/TileHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const E = A.default(50, 100, 255);
    class L {
        constructor(e) {
            this.gl = e,
            this.ambientIntensity = 1,
            this.ambientColorDay = [1, 1, 1],
            this.ambientColorDawn = [.92, .59, .55],
            this.ambientColorNight = [.4, .4, 1],
            this.ambientColorCave = [.5, .5, .5],
            this.entitiesInViewport = new Array,
            this.viewportSpritesDirty = !0,
            this.zoom = 1,
            this.tileScale = 1,
            this.screenspaceViewport = new R.default,
            this.worldspaceViewport = new R.default;
            const t = e.createTexture()
              , a = e.createFramebuffer()
              , i = e.createTexture()
              , n = e.createRenderbuffer()
              , o = e.createFramebuffer()
              , s = e.createTexture()
              , l = e.createFramebuffer()
              , u = e.createTexture()
              , d = e.createBuffer()
              , p = e.createBuffer()
              , c = e.createTexture()
              , m = e instanceof WebGL2RenderingContext ? e.createVertexArray() : void 0
              , h = e instanceof WebGL2RenderingContext ? e.createVertexArray() : void 0;
            if (!(t && a && i && n && o && s && l && u && d && p && c))
                throw new Error("Unable to create textures / buffers");
            this.compositeTexture = t,
            e.bindTexture(e.TEXTURE_2D, this.compositeTexture),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            this.compositeFramebuffer = a,
            e.bindFramebuffer(e.FRAMEBUFFER, this.compositeFramebuffer),
            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.compositeTexture, 0),
            this.layerTexture = i,
            e.bindTexture(e.TEXTURE_2D, this.layerTexture),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            this.depthBuffer = n,
            e.bindRenderbuffer(e.RENDERBUFFER, this.depthBuffer),
            this.layerFramebuffer = o,
            e.bindFramebuffer(e.FRAMEBUFFER, this.layerFramebuffer),
            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.layerTexture, 0),
            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, this.depthBuffer),
            this.fogTexture = s,
            e.bindTexture(e.TEXTURE_2D, this.fogTexture),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            this.fogFramebuffer = l,
            e.bindFramebuffer(e.FRAMEBUFFER, this.fogFramebuffer),
            e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, this.fogTexture, 0),
            this.fogTextureStorage = u,
            e.bindTexture(e.TEXTURE_2D, this.fogTextureStorage),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            this.defaultAdaptor = new g.default,
            this.waterAdaptor = new b.default,
            this.lavaAdaptor = new I.default,
            this.mountainAdaptor = new v.default,
            this.dirtAdaptor = new f.default,
            this.tillAdaptor = new w.default,
            this.wallAdaptor = new M.default,
            this.floorAdaptor = new S.default,
            this.fenceAdaptor = new T.default;
            for (const e of P.default.values(r.SpriteBatchLayer))
                this.initializeSpriteBatch(e);
            if (!this.positionTextureBuffer) {
                let t = [-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, -1, 0, 0, 1, 1, 1, 1, -1, 1, 0, 1];
                this.positionTextureBuffer = d,
                e.bindBuffer(e.ARRAY_BUFFER, this.positionTextureBuffer),
                e.bufferData(e.ARRAY_BUFFER, new Float32Array(t), e.STATIC_DRAW),
                t = [-1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1],
                this.positionBuffer = p,
                e.bindBuffer(e.ARRAY_BUFFER, this.positionBuffer),
                e.bufferData(e.ARRAY_BUFFER, new Float32Array(t), e.STATIC_DRAW)
            }
            if (!this.ditherTexture) {
                const t = [0, 32, 8, 40, 2, 34, 10, 42, 48, 16, 56, 24, 50, 18, 58, 26, 12, 44, 4, 36, 14, 46, 6, 38, 60, 28, 52, 20, 62, 30, 54, 22, 2, 35, 11, 43, 1, 33, 9, 41, 51, 19, 59, 27, 49, 17, 57, 25, 15, 47, 7, 39, 13, 45, 5, 37, 63, 31, 55, 23, 61, 29, 53, 21];
                this.ditherTexture = c,
                e.bindTexture(e.TEXTURE_2D, this.ditherTexture),
                e.texImage2D(e.TEXTURE_2D, 0, e.ALPHA, 8, 8, 0, e.ALPHA, e.UNSIGNED_BYTE, new Uint8Array(t)),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)
            }
            m && (this.vertexArraySingle = m,
            e.bindVertexArray(this.vertexArraySingle),
            e.bindBuffer(e.ARRAY_BUFFER, this.positionTextureBuffer),
            e.vertexAttribPointer(0, 2, e.FLOAT, !1, 16, 0),
            e.enableVertexAttribArray(0),
            e.bindBuffer(e.ARRAY_BUFFER, null),
            e.bindVertexArray(null)),
            h && (this.vertexArrayDouble = h,
            e.bindVertexArray(this.vertexArrayDouble),
            e.bindBuffer(e.ARRAY_BUFFER, this.positionTextureBuffer),
            e.vertexAttribPointer(0, 2, e.FLOAT, !1, 16, 0),
            e.vertexAttribPointer(1, 2, e.FLOAT, !1, 16, 8),
            e.enableVertexAttribArray(0),
            e.enableVertexAttribArray(1),
            e.bindBuffer(e.ARRAY_BUFFER, null),
            e.bindVertexArray(null)),
            this.layers = new Array;
            for (const t of world.layers)
                this.layers[t.level] = new k.default(e,this,t,t.width,t.height,this.positionBuffer);
            this.renderStatusEffect = this.renderStatusEffect.bind(this)
        }
        static compileShaders(e) {
            L.textureShaderProgram = new m.CompiledProgram(e,"basic-texture-vertex","basic-texture-fragment"),
            L.worldShaderProgram = new m.CompiledProgram(e,"world-texture-vertex","world-texture-fragment"),
            L.fogShaderProgram = new m.CompiledProgram(e,"fog-vertex","fog-fragment")
        }
        dispose() {
            for (const e of P.default.values(r.SpriteBatchLayer)) {
                const t = this.spriteBatchForLayer(e);
                t && t.dispose()
            }
        }
        initializeSpriteBatch(e, t=!1) {
            const a = this.spriteBatchForLayer(e);
            switch (a && a.dispose(),
            e) {
            case r.SpriteBatchLayer.Item:
                this.itemBatch = new h.default(this.gl,modManager.getHook(l.Hook.GetMaxSpritesForLayer, 16384).call(e, 16384));
                break;
            case r.SpriteBatchLayer.Corpse:
                this.corpseBatch = new h.default(this.gl,modManager.getHook(l.Hook.GetMaxSpritesForLayer, 512).call(e, 512),.1);
                break;
            case r.SpriteBatchLayer.Creature:
                this.creatureBatch = new h.default(this.gl,modManager.getHook(l.Hook.GetMaxSpritesForLayer, 512).call(e, 512));
                break;
            case r.SpriteBatchLayer.OverTrees:
                this.overTreesBatch = new h.default(this.gl,modManager.getHook(l.Hook.GetMaxSpritesForLayer, 64).call(e, 64));
                break;
            case r.SpriteBatchLayer.CreatureFlying:
                this.creatureFlyingBatch = new h.default(this.gl,modManager.getHook(l.Hook.GetMaxSpritesForLayer, 512).call(e, 512),-.1);
                break;
            case r.SpriteBatchLayer.Overlay:
                this.overlayBatch = new h.default(this.gl,modManager.getHook(l.Hook.GetMaxSpritesForLayer, 1024).call(e, 1024))
            }
            t && this.setSpriteTexture(game.spriteTexture, game.spriteTextureSizeInversed)
        }
        updateAll() {
            for (const e of this.layers)
                e.updateAll()
        }
        setSpriteTexture(e, t) {
            this.creatureBatch.texSprites = e,
            this.creatureBatch.inverseSpriteTextureSize = t,
            this.creatureFlyingBatch.texSprites = e,
            this.creatureFlyingBatch.inverseSpriteTextureSize = t,
            this.overTreesBatch.texSprites = e,
            this.overTreesBatch.inverseSpriteTextureSize = t,
            this.corpseBatch.texSprites = e,
            this.corpseBatch.inverseSpriteTextureSize = t,
            this.itemBatch.texSprites = e,
            this.itemBatch.inverseSpriteTextureSize = t,
            this.overlayBatch.texSprites = e,
            this.overlayBatch.inverseSpriteTextureSize = t
        }
        getPixelSize() {
            return c.subTileSize * this.tileScale
        }
        getZoom() {
            return this.zoom
        }
        getTileScale() {
            return this.tileScale
        }
        setTileScale(e) {
            this.tileScale = e,
            this.tileScale <= 0 && (this.tileScale = 1),
            this.worldspaceViewport.x = this.screenspaceViewport.x / (c.subTileSize * this.tileScale) / 2,
            this.worldspaceViewport.y = this.screenspaceViewport.y / (c.subTileSize * this.tileScale) / 2
        }
        setZoom(e) {
            this.zoom = e,
            this.setTileScale(e)
        }
        setViewport(e) {
            e.x = 2 * Math.round(e.x / 2),
            e.y = 2 * Math.round(e.y / 2),
            this.screenspaceViewport.x = e.x,
            this.screenspaceViewport.y = e.y,
            this.tileScale = Math.floor(Math.max(e.x, e.y) / (25 * this.zoom * c.subTileSize * .5)),
            this.tileScale <= 0 && (this.tileScale = 1),
            this.worldspaceViewport.x = e.x / (c.subTileSize * this.tileScale) / 2,
            this.worldspaceViewport.y = e.y / (c.subTileSize * this.tileScale) / 2;
            const t = this.gl;
            t.bindTexture(t.TEXTURE_2D, this.compositeTexture),
            t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e.x, e.y, 0, t.RGBA, t.UNSIGNED_BYTE, c.emptyUint8Array),
            t.bindTexture(t.TEXTURE_2D, this.layerTexture),
            t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e.x, e.y, 0, t.RGBA, t.UNSIGNED_BYTE, c.emptyUint8Array),
            t.bindRenderbuffer(t.RENDERBUFFER, this.depthBuffer),
            t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, e.x, e.y),
            t.bindTexture(t.TEXTURE_2D, this.fogTexture),
            t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e.x, e.y, 0, t.RGBA, t.UNSIGNED_BYTE, c.emptyUint8Array),
            t.bindTexture(t.TEXTURE_2D, this.fogTextureStorage),
            t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e.x, e.y, 0, t.RGBA, t.UNSIGNED_BYTE, c.emptyUint8Array)
        }
        getViewport() {
            return this.screenspaceViewport
        }
        getTileViewport() {
            return this.worldspaceViewport
        }
        getAmbientColor() {
            const e = [1, 1, 1];
            if (localPlayer.z === r.WorldZ.Cave) {
                const t = modManager.getHook(l.Hook.GetAmbientColorCave, this.ambientColorCave).call();
                e[0] = t[0] * this.ambientIntensity,
                e[1] = t[1] * this.ambientIntensity,
                e[2] = t[2] * this.ambientIntensity
            } else {
                const t = this.ambientColorDawn
                  , a = modManager.getHook(l.Hook.GetAmbientColorDay, this.ambientColorDay).call()
                  , i = modManager.getHook(l.Hook.GetAmbientColorNight, this.ambientColorNight).call()
                  , n = game.time.getBrightness()
                  , o = .5 * (Math.sin(2 * Math.PI * (G.default.clamp1(2.5 * (n - .4)) - .25)) + 1);
                for (let r = 0; r < 3; r++) {
                    const s = G.default.lerp(a[r], i[r], n);
                    e[r] = G.default.lerp(s, t[r], o)
                }
                e[0] *= this.ambientIntensity,
                e[1] *= this.ambientIntensity,
                e[2] *= this.ambientIntensity
            }
            return modManager.getHook(l.Hook.GetAmbientColor, e).call(e)
        }
        getFogColor() {
            const e = [0, 0, 0];
            return modManager.getHook(l.Hook.GetFogColor, e).call(e)
        }
        renderWorld(e, t, a) {
            if (!world.isLoaded())
                return;
            const i = this.gl
              , n = this.layers[a]
              , o = this.tileScale
              , s = this.screenspaceViewport.x
              , u = this.screenspaceViewport.y;
            let d;
            i.bindFramebuffer(i.FRAMEBUFFER, this.layerFramebuffer),
            i.viewport(0, 0, s, u),
            i.clearColor(98 / 255, 67 / 255, 30 / 255, 1),
            i.clear(i.COLOR_BUFFER_BIT | i.DEPTH_BUFFER_BIT),
            i.enable(i.BLEND),
            i.blendFunc(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA),
            modManager.getHook(l.Hook.PreRenderWorld).call(o, s, u);
            const m = game.shouldRender();
            (m & r.RenderFlag.Terrain) === r.RenderFlag.Terrain && n.renderFullbright(e, t, o, s, u, !1),
            i.enable(i.DEPTH_TEST),
            (m & r.RenderFlag.Corpse) === r.RenderFlag.Corpse && this.corpseBatch.render(e, t, o, s, u),
            (m & r.RenderFlag.Item) === r.RenderFlag.Item && this.itemBatch.render(e, t, o, s, u),
            0 != (m & (r.RenderFlag.Creature | r.RenderFlag.Player)) && this.creatureBatch.render(e, t, o, s, u),
            (m & r.RenderFlag.Overlay) === r.RenderFlag.Overlay && this.overlayBatch.render(e, t, o, s, u),
            (m & r.RenderFlag.Terrain) === r.RenderFlag.Terrain && n.renderFullbright(e, t, o, s, u, !0),
            0 != (m & (r.RenderFlag.OverTrees | r.RenderFlag.Player)) && this.overTreesBatch.render(e, t, o, s, u),
            0 != (m & (r.RenderFlag.Creature | r.RenderFlag.Player)) && this.creatureFlyingBatch.render(e, t, o, s, u),
            i.disable(i.DEPTH_TEST),
            i.bindFramebuffer(i.FRAMEBUFFER, this.fogFramebuffer),
            i.disable(i.BLEND),
            fieldOfView.disabled ? (i.clearColor(1, 1, 1, 1),
            i.clear(i.COLOR_BUFFER_BIT)) : (d = L.fogShaderProgram,
            i.useProgram(d.program),
            i.activeTexture(i.TEXTURE0),
            i.bindTexture(i.TEXTURE_2D, n.texExplored),
            i.uniform1i(d.uniforms.fog, 0),
            i.uniform2f(d.uniforms.viewportSize, s / o, u / o),
            i.uniform2f(d.uniforms.viewOffset, Math.floor(e * c.subTileSize * 2), Math.floor(t * c.subTileSize * 2)),
            i.uniform1f(d.uniforms.tileSize, c.subTileSize),
            i.uniform1f(d.uniforms.inverseTileSize, 1 / (2 * c.subTileSize)),
            i.uniform2f(d.uniforms.inverseTileDataTextureSize, 1 / world.layers[a].exploredMap.width, 1 / world.layers[a].exploredMap.height),
            this.vertexArraySingle ? i.bindVertexArray(this.vertexArraySingle) : (i.bindBuffer(i.ARRAY_BUFFER, this.positionBuffer),
            i.vertexAttribPointer(d.attribs.position, 2, i.FLOAT, !1, 0, 0),
            i.enableVertexAttribArray(d.attribs.position)),
            i.drawArrays(i.TRIANGLES, 0, 6),
            this.vertexArraySingle && i.bindVertexArray(null),
            i.bindTexture(i.TEXTURE_2D, this.fogTextureStorage),
            i.copyTexSubImage2D(i.TEXTURE_2D, 0, 0, 0, 0, 0, s, u),
            i.clear(i.COLOR_BUFFER_BIT),
            d = p.default.hBlurProgram,
            i.useProgram(d.program),
            i.activeTexture(i.TEXTURE0),
            i.bindTexture(i.TEXTURE_2D, this.fogTextureStorage),
            i.uniform1i(d.uniforms.data, 0),
            i.uniform1f(d.uniforms.blurSize, 1 / (s / o / 4)),
            this.vertexArrayDouble ? i.bindVertexArray(this.vertexArrayDouble) : (i.bindBuffer(i.ARRAY_BUFFER, this.positionTextureBuffer),
            i.vertexAttribPointer(d.attribs.position, 2, i.FLOAT, !1, 16, 0),
            i.vertexAttribPointer(d.attribs.texture, 2, i.FLOAT, !1, 16, 8),
            i.enableVertexAttribArray(d.attribs.position),
            i.enableVertexAttribArray(d.attribs.texture)),
            i.drawArrays(i.TRIANGLES, 0, 6),
            this.vertexArrayDouble ? i.bindVertexArray(null) : (i.disableVertexAttribArray(d.attribs.position),
            i.disableVertexAttribArray(d.attribs.texture))),
            i.bindFramebuffer(i.FRAMEBUFFER, this.compositeFramebuffer),
            i.disable(i.BLEND),
            d = L.worldShaderProgram,
            i.useProgram(d.program),
            i.activeTexture(i.TEXTURE0),
            i.bindTexture(i.TEXTURE_2D, this.layerTexture),
            i.uniform1i(d.uniforms.data, 0),
            i.activeTexture(i.TEXTURE1),
            i.bindTexture(i.TEXTURE_2D, this.fogTexture),
            i.uniform1i(d.uniforms.fog, 1),
            i.activeTexture(i.TEXTURE2),
            i.bindTexture(i.TEXTURE_2D, fieldOfView.texLight),
            i.uniform1i(d.uniforms.vision, 2),
            i.activeTexture(i.TEXTURE3),
            i.bindTexture(i.TEXTURE_2D, fieldOfView.texLightOld),
            i.uniform1i(d.uniforms.visionOld, 3),
            i.activeTexture(i.TEXTURE4),
            i.bindTexture(i.TEXTURE_2D, this.ditherTexture),
            i.uniform1i(d.uniforms.bayerMatrix, 4),
            i.uniform1f(d.uniforms.blackness, game.getBlackness()),
            i.uniform1f(d.uniforms.transition, localPlayer.isMovingClientside ? localPlayer.movementProgress : fieldOfView.transitionProgress),
            i.uniform2f(d.uniforms.transitionOffset, .5 * +fieldOfView.computeOffset.x / (fieldOfView.maxRadius + .5), .5 * +fieldOfView.computeOffset.y / (fieldOfView.maxRadius + .5)),
            i.uniform2f(d.uniforms.viewportSize, s / o, u / o),
            i.uniform2f(d.uniforms.viewOffset, Math.floor(e * c.subTileSize * 2), Math.floor(t * c.subTileSize * 2)),
            i.uniform2f(d.uniforms.visionOffset, Math.floor(fieldOfView.maxRadius - localPlayer.x), Math.floor(fieldOfView.maxRadius - localPlayer.y)),
            i.uniform2f(d.uniforms.inverseVisionTextureSize, fieldOfView.getSubdivisions() / fieldOfView.getTextureSize(), fieldOfView.getSubdivisions() / fieldOfView.getTextureSize()),
            i.uniform1f(d.uniforms.tileSize, c.subTileSize),
            i.uniform1f(d.uniforms.inverseTileSize, 1 / (2 * c.subTileSize)),
            i.uniform1f(d.uniforms.ditherEnabled, saveDataGlobal.options.visionMode ? 1 : 0),
            i.uniform3f(d.uniforms.colorAmbient, ...this.getAmbientColor()),
            i.uniform3f(d.uniforms.colorFog, ...this.getFogColor()),
            this.vertexArrayDouble ? i.bindVertexArray(this.vertexArrayDouble) : (i.bindBuffer(i.ARRAY_BUFFER, this.positionTextureBuffer),
            i.vertexAttribPointer(d.attribs.position, 2, i.FLOAT, !1, 16, 0),
            i.vertexAttribPointer(d.attribs.texture, 2, i.FLOAT, !1, 16, 8),
            i.enableVertexAttribArray(d.attribs.position),
            i.enableVertexAttribArray(d.attribs.texture)),
            i.drawArrays(i.TRIANGLES, 0, 6),
            this.vertexArrayDouble ? i.bindVertexArray(null) : (i.disableVertexAttribArray(d.attribs.position),
            i.disableVertexAttribArray(d.attribs.texture)),
            modManager.getHook(l.Hook.PostRenderWorld).call(o, s, u),
            i.bindFramebuffer(i.FRAMEBUFFER, null)
        }
        render() {
            const e = this.gl
              , t = L.textureShaderProgram;
            e.useProgram(t.program),
            e.activeTexture(e.TEXTURE0),
            e.bindTexture(e.TEXTURE_2D, this.compositeTexture),
            e.uniform1i(t.uniforms.data, 0),
            this.vertexArrayDouble ? e.bindVertexArray(this.vertexArrayDouble) : (e.bindBuffer(e.ARRAY_BUFFER, this.positionTextureBuffer),
            e.vertexAttribPointer(t.attribs.position, 2, e.FLOAT, !1, 16, 0),
            e.vertexAttribPointer(t.attribs.texture, 2, e.FLOAT, !1, 16, 8),
            e.enableVertexAttribArray(t.attribs.position),
            e.enableVertexAttribArray(t.attribs.texture)),
            modManager.getHook(l.Hook.PreRenderPostProcess).call(),
            e.drawArrays(e.TRIANGLES, 0, 6),
            modManager.getHook(l.Hook.PostRenderPostProcess).call(),
            this.vertexArrayDouble ? e.bindVertexArray(null) : (e.disableVertexAttribArray(t.attribs.position),
            e.disableVertexAttribArray(t.attribs.texture))
        }
        screenToTile(e, t) {
            const a = this.screenspaceViewport.x / this.tileScale
              , i = this.screenspaceViewport.y / this.tileScale
              , n = 2 * c.subTileSize
              , o = game.getCameraPosition()
              , r = Math.floor(o.x * n)
              , s = Math.floor(o.y * n)
              , l = ((e = e / ui.getWidth() * a) + r - .5 * a) / n
              , u = ((t = t / ui.getHeight() * i) + s - .5 * i) / n;
            return new R.default([game.getWrappedCoord(Math.round(l)), game.getWrappedCoord(Math.round(u))])
        }
        getViewportBounds() {
            const e = new R.default(game.getCameraPosition()).floor()
              , t = new R.default([e.x - Math.ceil(.5 * this.worldspaceViewport.x), e.y - Math.ceil(.5 * this.worldspaceViewport.y)])
              , a = new R.default([e.x + Math.ceil(.5 * this.worldspaceViewport.x), e.y + Math.ceil(.5 * this.worldspaceViewport.y)]);
            return {
                min: t,
                max: a,
                z: localPlayer.z
            }
        }
        computeSpritesInViewport() {
            this.viewportSpritesDirty = !0
        }
        batchCreatures() {
            this.viewportSpritesDirty && this.computeSpritesInViewportInternal();
            const e = modManager.getHook(l.Hook.GetPlayerSpriteBatchLayer, r.SpriteBatchLayer.Creature).call(localPlayer, r.SpriteBatchLayer.Creature);
            if (this.creatureBatch.begin(),
            this.creatureFlyingBatch.begin(),
            this.overTreesBatch.begin(),
            (game.shouldRender() & r.RenderFlag.Creature) !== r.RenderFlag.Creature)
                this.batchPlayers(e);
            else {
                const t = game.mapSize / 2;
                let a, o, s, u, d, p, c, m, h, y, g, f, T, S, I, v;
                const w = fieldOfView;
                if (!w)
                    return;
                const M = w.disabled ? this.getViewportBounds() : w.getBounds(localPlayer)
                  , b = M.min.x
                  , k = M.max.x
                  , A = M.min.y
                  , P = M.max.y;
                for (let e = A; e <= P; e++)
                    for (let a = b; a <= k; a++) {
                        if (!localPlayer.canSeePosition(a, e, localPlayer.z, !0))
                            continue;
                        const i = game.getTile(a, e, localPlayer.z)
                          , n = i.events;
                        if (n)
                            for (const i of n) {
                                const n = D.default[i.type]
                                  , o = spriteAtlas.tileEvents[i.type];
                                if (!o)
                                    continue;
                                let r = 0;
                                void 0 !== i.gfx ? r = i.gfx * o.texSize : n && n.animated && (r = Math.floor((game.time.ticks + 3 * B.default.getTileVariation(a, e)) % 3) * o.texSize),
                                h = i.fromX,
                                y = i.fromY,
                                g = i.x,
                                f = i.y,
                                d = tileEventManager.getMovementProgress(i),
                                localPlayer.x < t ? (h = h - localPlayer.x > t ? h - game.mapSize : h,
                                g = g - localPlayer.x > t ? g - game.mapSize : g) : (h = localPlayer.x - h > t ? h + game.mapSize : h,
                                g = localPlayer.x - g > t ? g + game.mapSize : g),
                                localPlayer.y < t ? (y = y - localPlayer.y > t ? y - game.mapSize : y,
                                f = f - localPlayer.y > t ? f - game.mapSize : f) : (y = localPlayer.y - y > t ? y + game.mapSize : y,
                                f = localPlayer.y - f > t ? f + game.mapSize : f),
                                this.creatureBatch.add(G.default.lerp(h, g, d), G.default.lerp(y, f, d), o.texSize, o.texCoord.x + r, o.texCoord.y, o.texSize)
                            }
                    }
                for (let w = this.entitiesInViewport.length - 1; w >= 0; w--) {
                    switch ((s = this.entitiesInViewport[w]).entityType) {
                    case n.EntityType.Player:
                        this.batchPlayers(e);
                        continue;
                    case n.EntityType.Creature:
                        u = spriteAtlas.creatures[s.type];
                        break;
                    case n.EntityType.NPC:
                        this.batchHuman(s, e);
                        continue
                    }
                    if (!u || 0 != (s.ai & n.AiType.Hidden))
                        continue;
                    if (d = s.getMovementProgress(),
                    c = !(!(p = i.default[s.type]) || !p.waterAnimations),
                    m = u.texSize / (c ? 8 : 4),
                    h = s.fromX,
                    y = s.fromY,
                    g = s.x,
                    f = s.y,
                    localPlayer.x < t ? (h = h - localPlayer.x > t ? h - game.mapSize : h,
                    g = g - localPlayer.x > t ? g - game.mapSize : g) : (h = localPlayer.x - h > t ? h + game.mapSize : h,
                    g = localPlayer.x - g > t ? g + game.mapSize : g),
                    localPlayer.y < t ? (y = y - localPlayer.y > t ? y - game.mapSize : y,
                    f = f - localPlayer.y > t ? f - game.mapSize : f) : (y = localPlayer.y - y > t ? y + game.mapSize : y,
                    f = localPlayer.y - f > t ? f + game.mapSize : f),
                    a = (s.anim ? m : 0) + (s.aberrant ? 2 * m : 0),
                    o = s.facingDirection * m,
                    T = 0,
                    c) {
                        const e = C.default[B.default.getType(game.getTile(g, f, s.z))];
                        e && e.water && (o += 4 * m),
                        T = u.texOffsetY
                    }
                    const M = !(!p || (p.moveType & r.MoveType.Flying) !== r.MoveType.Flying)
                      , b = M ? r.SpriteBatchLayer.CreatureFlying : r.SpriteBatchLayer.Creature;
                    v = modManager.getHook(l.Hook.GetCreatureSpriteBatchLayer, b).call(s, b),
                    M && (this.batchShadow(h, y, g, f, d, s.anim),
                    S = 0,
                    I = 0,
                    this.isFlyingOffset(game.getTile(Math.round(h), Math.round(y), localPlayer.z)) && (S -= .5),
                    this.isFlyingOffset(game.getTile(Math.round(g), Math.round(f), localPlayer.z)) && (I -= .5),
                    S -= .5,
                    I -= .5,
                    T = G.default.lerp(S, I, d)),
                    this.spriteBatchForLayer(v).add(G.default.lerp(h, g, d), G.default.lerp(y, f, d), m, u.texCoord.x + a, u.texCoord.y + o, m, 0, T - u.texOffsetY)
                }
            }
            this.overTreesBatch.end(),
            this.creatureBatch.end(),
            this.creatureFlyingBatch.end()
        }
        isFlyingOffset(e) {
            const t = C.default[B.default.getType(e)];
            let a = !1;
            if (void 0 !== e.doodad) {
                const t = e.doodad.description()
                  , i = e.doodad.getGrowingStage();
                a = !!(t && t.isTree && void 0 !== i && i >= r.GrowingStage.Budding)
            }
            return !((!t || t.passable || t.water) && !a)
        }
        batchShadow(e, t, a, i, n, o) {
            const r = spriteAtlas.shadow
              , s = r.texSize;
            this.creatureBatch.add(G.default.lerp(e, a, n), G.default.lerp(t, i, n) - r.texOffsetY, s, r.texCoord.x + o * s, r.texCoord.y, s, 0, 0, 0, 0, 0, 100)
        }
        batchPlayers(e) {
            for (const t of players)
                (t.isLocalPlayer() || !t.isServer() && localPlayer.canSeePosition(t.x, t.y, t.z, !0)) && this.batchHuman(t, e)
        }
        batchHuman(e, t) {
            if ((game.shouldRender() & r.RenderFlag.Player) !== r.RenderFlag.Player)
                return;
            let a = e.anim;
            e.swimming && (a += 8);
            let i = !1, n;
            if (void 0 !== e.restData) {
                i = !0;
                const t = e.restData.itemId
                  , a = e.restData.doodadId;
                if (void 0 !== t) {
                    const e = game.items[t];
                    e && (n = e ? spriteAtlas.sleeps[e.type] : void 0)
                } else if (void 0 !== a) {
                    const e = game.doodads[a];
                    if (e) {
                        const t = e.getPickupTypes();
                        t && 1 === t.length && (n = e ? spriteAtlas.sleeps[t[0]] : void 0)
                    }
                }
            }
            n ? a += 4 : (i && (a -= e.anim),
            1 === e.direction.x ? a += 6 : 1 === e.direction.y ? a += 4 : -1 === e.direction.y && (a += 2));
            const l = 24;
            let p = 0
              , c = 0;
            const m = e instanceof d.default && e.isGhost()
              , h = m ? 150 : 255
              , g = e.getMovementProgress();
            let f = e.fromX
              , T = e.fromY
              , S = e.x
              , I = e.y;
            e !== localPlayer && (S - localPlayer.x > 255 ? (S -= game.mapSize,
            f -= game.mapSize) : localPlayer.x - S > 255 && (S += game.mapSize,
            f += game.mapSize),
            I - localPlayer.y > 255 ? (I -= game.mapSize,
            T -= game.mapSize) : localPlayer.y - I > 255 && (I += game.mapSize,
            T += game.mapSize));
            const v = game.getTile(f, T, e.z)
              , w = game.getTile(S, I, e.z);
            (m || e.moveType === r.MoveType.Flying) && (m || this.batchShadow(f, T, S, I, g, e.anim),
            this.shouldOffsetFlying(v) && (p -= .5),
            this.shouldOffsetFlying(w) && (c -= .5),
            p -= .5,
            c -= .5);
            const M = G.default.lerp(f, S, g)
              , b = G.default.lerp(T, I, g)
              , k = 0;
            let C = G.default.lerp(p, c, g);
            const D = this.spriteBatchForLayer(t);
            if (!D)
                return;
            const R = void 0 !== e.raft;
            if (R) {
                1 === e.anim && (C -= .0625),
                a -= e.anim,
                C -= .25;
                const t = 16;
                D.add(M, b, t, Math.abs(e.direction.y) * t + spriteAtlas.raft.texCoord.x, spriteAtlas.raft.texCoord.y, t, 0, C + .25, 255, 255, 255, h)
            }
            const x = 24 * a
              , B = spriteAtlas.playerBody.texCoord.x + x
              , L = spriteAtlas.playerBody.texCoord.y;
            let O = u.getColorDescription(u.ColorType.Skin, e.customization.skinColor).color
              , F = u.getColorDescription(u.ColorType.Hair, e.customization.hairColor).color;
            if (m)
                O = A.default.blend(O, E),
                F = A.default.blend(F, E);
            else {
                const t = [];
                for (const a of P.default.values(r.StatusType))
                    if (e.hasStatus(a)) {
                        const e = o.default[a];
                        e && t.push(...e.renderer.getTints())
                    }
                t.length > 0 && (O = A.default.blend(O, A.default.blend(...t), .3))
            }
            if (n) {
                const t = R ? 24 : 24 * (1 - e.anim);
                n.texSize > 16 && (C -= .25),
                D.add(M, b, n.texSize, n.texCoord.x, n.texCoord.y, n.texSize, 0, C, 255, 255, 255, h),
                C -= .2,
                D.add(M, b, 24, spriteAtlas.playerSleeping.texCoord.x + t, spriteAtlas.playerSleeping.texCoord.y, 24, 0, C, O.r, O.g, O.b, h),
                C += .1
            } else {
                let t = L;
                m && (t += 48),
                D.add(M, b, 24, B, t, 24, 0, C, O.r, O.g, O.b, h),
                D.add(M, b, 24, B, L + 24, 24, 0, C, 255, 255, 255, h),
                this.renderStatusEffects(y.StatusEffectRenderLayer.Body, D, e, x, M, b, 24, 0, C, h)
            }
            let _ = !0
              , H = !0
              , W = !1;
            const N = []
              , q = Object.keys(e.equipped);
            for (const t of q) {
                const a = parseInt(t, 10)
                  , i = e.equipped[a];
                if (void 0 === i)
                    continue;
                const n = game.items[i]
                  , o = {
                    item: n,
                    equipSlot: a
                };
                switch (a) {
                case r.EquipType.LeftHand:
                    1 === e.direction.x ? N.unshift(o) : N.push(o);
                    continue;
                case r.EquipType.RightHand:
                    -1 === e.direction.x ? N.unshift(o) : N.push(o);
                    continue;
                case r.EquipType.Back:
                    {
                        const e = s.default[n.type];
                        e && (e.showOverHair && (_ = !1,
                        W = !0),
                        e.hideHelmet && (H = !1));
                        break
                    }
                case r.EquipType.Head:
                    if (localPlayer === e && localPlayer.options.hideEquippedHeadgear)
                        continue;
                    _ = !1
                }
                N.push(o)
            }
            let U = D;
            if (H || _ || W) {
                let t = !1;
                if (v.doodad) {
                    const e = v.doodad.description();
                    t = !!e && (!0 === e.isTall || !0 === e.isDoor)
                }
                let a = !1;
                if (w.doodad) {
                    const e = w.doodad.description();
                    a = !!e && (!0 === e.isTall || !0 === e.isDoor)
                }
                m || e.moveType === r.MoveType.Flying || (a ? U = this.spriteBatchForLayer(r.SpriteBatchLayer.OverTrees) : t && (U = 1 === g ? D : this.spriteBatchForLayer(r.SpriteBatchLayer.CreatureFlying)))
            }
            let z = A.default(255);
            m && (z = A.default.blend(z, E));
            for (const t of N) {
                const a = t.item
                  , i = t.equipSlot
                  , o = spriteAtlas.itemsEquipped[a.type];
                if (!o)
                    continue;
                if (e.direction.y >= 0 && (i === r.EquipType.LeftHand || i === r.EquipType.RightHand))
                    continue;
                if (m && (i === r.EquipType.Legs || i === r.EquipType.Feet))
                    continue;
                const l = s.default[a.type]
                  , u = i === r.EquipType.Head || i === r.EquipType.Back && l && l.showOverHair;
                if (e.swimming && !u)
                    continue;
                if (i === r.EquipType.Head && !H)
                    continue;
                if (n && i !== r.EquipType.Head)
                    continue;
                const d = u ? U : D
                  , p = o.texCoord.y + (i === r.EquipType.RightHand ? 24 : 0);
                d.add(M, b, 24, o.texCoord.x + x, p, 24, 0, C, z.r, z.g, z.b, h)
            }
            if (this.renderStatusEffects(y.StatusEffectRenderLayer.Clothes, D, e, x, M, b, 24, 0, C, h),
            _) {
                const t = r.HairStyle[e.customization.hairStyle];
                if (t === r.HairStyle.None) {
                    if (!e.swimming && U !== D) {
                        const t = 24 * (a + 8)
                          , i = spriteAtlas.playerBody.texCoord.x + t
                          , n = spriteAtlas.playerBody.texCoord.y + 2;
                        U.add(M, b, 24, i, n, 24, 0, C, O.r, O.g, O.b, h),
                        this.renderStatusEffects(y.StatusEffectRenderLayer.Body, U, e, t, M, b, 24, 0, C, h)
                    }
                } else {
                    const e = spriteAtlas.playerHairstyles[t];
                    e && (e.texSize >= 48 && U.add(M, b, 24, e.texCoord.x + x, e.texCoord.y + 24, 24, 0, C, O.r, O.g, O.b, h),
                    U.add(M, b, 24, e.texCoord.x + x, e.texCoord.y, 24, 0, C, F.r, F.g, F.b, h),
                    e.texSize >= 72 && U.add(M, b, 24, e.texCoord.x + x, e.texCoord.y + 48, 24, 0, C, 255, 255, 255, h))
                }
                this.renderStatusEffects(y.StatusEffectRenderLayer.Hair, U, e, x, M, b, 24, 0, C, h)
            }
            if (i && D.add(M, b, 24, spriteAtlas.zzz.texCoord.x + 24 * (1 - e.anim), spriteAtlas.zzz.texCoord.y, 24, .1, C - .1, 255, 255, 255, 255),
            !n && !e.swimming && e.direction.y >= 0)
                for (const e of N) {
                    const t = e.item
                      , a = e.equipSlot;
                    if (a !== r.EquipType.LeftHand && a !== r.EquipType.RightHand)
                        continue;
                    const i = spriteAtlas.itemsEquipped[t.type];
                    if (!i)
                        continue;
                    const n = i.texCoord.y + (a === r.EquipType.RightHand ? 24 : 0);
                    D.add(M, b, 24, i.texCoord.x + x, n, 24, 0, C, z.r, z.g, z.b, h)
                }
        }
        renderStatusEffects(e, t, a, i, n, r, s, l, u, d) {
            const p = new x.PriorityList;
            for (const e of a.statuses()) {
                const t = o.default[e];
                t && p.add([t.renderer.priority, [e, t]])
            }
            for (const [a,o] of p.reverse()) {
                const p = spriteAtlas.statusEffects[a];
                p && o.renderer.render(e, this.renderStatusEffect.bind(this, t, i, n, r, s, l, u, d, p))
            }
        }
        renderStatusEffect(e, t, a, i, n, o, r, s, l, u) {
            const d = l || u;
            if ("object" != typeof d)
                return;
            const p = "number" == typeof u ? u : 0;
            e.add(a, i, n, d.texCoord.x + t, d.texCoord.y + p, n, o, r, 255, 255, 255, s)
        }
        spriteBatchForLayer(e) {
            switch (e) {
            case r.SpriteBatchLayer.Corpse:
                return this.corpseBatch;
            case r.SpriteBatchLayer.Item:
                return this.itemBatch;
            case r.SpriteBatchLayer.Creature:
                return this.creatureBatch;
            case r.SpriteBatchLayer.CreatureFlying:
                return this.creatureFlyingBatch;
            case r.SpriteBatchLayer.OverTrees:
                return this.overTreesBatch;
            case r.SpriteBatchLayer.Overlay:
                return this.overlayBatch
            }
            throw new Error("Unknown sprite batch layer")
        }
        shouldOffsetFlying(e) {
            const t = C.default[B.default.getType(e)];
            if (t && !t.passable && !t.water && void 0 === e.doodad)
                return !0;
            const a = e.doodad;
            if (a) {
                const e = a.description();
                if (e && (void 0 !== e.weightCapacity || e.blockMove && !e.isLocked))
                    return !0
            }
            return !1
        }
        computeSpritesInViewportInternal() {
            if (!world.isLoaded())
                return;
            this.viewportSpritesDirty = !1;
            const e = fieldOfView;
            if (!e)
                return;
            this.overlayBatch.begin(),
            this.corpseBatch.begin(),
            this.itemBatch.begin();
            const t = this.getViewportBounds()
              , i = e.disabled ? t : e.getBounds(localPlayer)
              , n = i.min.x
              , o = i.max.x
              , r = i.min.y
              , s = i.max.y
              , u = 2 * c.subTileSize
              , d = 8;
            this.entitiesInViewport.length = 0;
            for (let e = r; e <= s; e++)
                for (let t = n; t <= o; t++) {
                    if (!localPlayer.canSeePosition(t, e, localPlayer.z, !0))
                        continue;
                    const i = game.getTile(t, e, localPlayer.z)
                      , n = i.containedItems;
                    if (n) {
                        let a = 0
                          , i = 0;
                        for (let o = 0; o < n.length; o++) {
                            const r = n[o];
                            ++a > 12 && (a = 1),
                            a % 3 == 0 ? i = 12 : a % 2 == 0 ? i = 4 : a % 1 == 0 && (i = 8);
                            const s = spriteAtlas.itemsSmall[r.type];
                            if (s) {
                                const n = s.texCoord;
                                this.itemBatch.add(t + (i - c.subTileSize) / u, e + (5 - a) / u, 8, n.x, n.y, 8)
                            }
                        }
                    }
                    t === localPlayer.x && e === localPlayer.y && this.entitiesInViewport.push(localPlayer),
                    i.creature && this.entitiesInViewport.length < this.creatureBatch.capacity && !1 !== modManager.getHook(l.Hook.CanSeeCreature).call(i.creature, i) && this.entitiesInViewport.push(i.creature),
                    i.npc && this.entitiesInViewport.length < this.creatureBatch.capacity && !1 !== modManager.getHook(l.Hook.CanSeeNPC).call(i.npc, i) && this.entitiesInViewport.push(i.npc);
                    const o = i.corpses;
                    if (o)
                        for (const n of o) {
                            const o = spriteAtlas.corpses[n.type];
                            let r = 0;
                            if (o) {
                                const s = a.default[n.type];
                                s && s.animated ? r = Math.floor((game.time.ticks + 3 * B.default.getTileVariation(t, e)) % 3) * o.texSize + (n.aberrant ? 3 * o.texSize : 0) : n.aberrant ? r = o.texSize : s && s.blood && (r = B.default.getGfx(i) % 3 * o.texSize),
                                this.corpseBatch.add(t, e, o.texSize, o.texCoord.x + r, o.texCoord.y, o.texSize)
                            }
                        }
                }
            const p = t.min.x
              , m = t.max.x
              , h = t.min.y
              , y = t.max.y;
            for (let e = h; e <= y; e++)
                for (let t = p; t <= m; t++) {
                    const a = game.getTile(t, e, localPlayer.z)
                      , i = a.overlays;
                    if (void 0 !== i)
                        for (const a of i) {
                            const i = spriteAtlas.overlay[a.type];
                            i && this.overlayBatch.add(t, e, void 0 !== a.size ? a.size : i.texSize, i.texCoord.x + (void 0 !== a.offsetX ? a.offsetX : 0), i.texCoord.y + (void 0 !== a.offsetY ? a.offsetY : 0), void 0 !== a.size ? a.size : i.texSize, (void 0 !== a.spriteOffsetX ? a.spriteOffsetX : 0) - (1 - (void 0 !== a.size ? a.size : i.texSize) / 16) / 2, (void 0 !== a.spriteOffsetY ? a.spriteOffsetY : 0) - (1 - (void 0 !== a.size ? a.size : i.texSize) / 16) / 2, void 0 !== a.red ? a.red : 255, void 0 !== a.green ? a.green : 255, void 0 !== a.blue ? a.blue : 255, void 0 !== a.alpha ? a.alpha : 255)
                        }
                }
            modManager.getHook(l.Hook.OnRenderOverlay).call(this.overlayBatch),
            this.itemBatch.end(),
            this.corpseBatch.end(),
            this.overlayBatch.end()
        }
    }
    t.default = L
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/SpriteInfo", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor(e, t, a, i) {
            this.texCoord = e,
            this.texSize = t,
            this.texOffsetY = a,
            this.animated = i
        }
    }
    t.default = a
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("renderer/TexturePacker", ["require", "exports", "renderer/RendererConstants", "renderer/SpriteInfo", "utilities/Async", "utilities/Log", "utilities/math/Vector2"], function(e, t, a, i, n, o, r) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const s = 20;
    class l {
        constructor(e, t, a, i) {
            this.left = e,
            this.top = t,
            this.right = a,
            this.bottom = i,
            this.used = !1
        }
        insert(e, t) {
            if (void 0 !== this.child0) {
                const a = this.child0.insert(e, t);
                return void 0 !== a ? a : void 0 !== this.child1 ? this.child1.insert(e, t) : void 0
            }
            if (this.used)
                return;
            const a = this.right - this.left
              , i = this.bottom - this.top;
            if (e.width > a || e.height > i)
                return;
            if (e.width === a && e.height === i)
                return this.used = !0,
                this;
            const n = a - e.width
              , o = i - e.height;
            return n > o ? (this.child0 = new l(this.left,this.top,this.left + e.width,this.bottom),
            this.child1 = new l(this.left + e.width + t,this.top,this.right,this.bottom)) : (this.child0 = new l(this.left,this.top,this.right,this.top + e.height),
            this.child1 = new l(this.left,this.top + e.height + t,this.right,this.bottom)),
            this.child0.insert(e, t)
        }
    }
    class u {
        constructor(e, t, i, n, o) {
            this.gl = e,
            this.width = t,
            this.height = i,
            this.loadedSprites = {},
            this.sprites = [],
            this.spriteLoadCount = 0,
            this.rootNode = new l(0,0,t,i),
            this.padding = o;
            const s = e.createTexture();
            if (!s)
                throw new Error("Unable to create texture");
            this.texture = s,
            e.bindTexture(e.TEXTURE_2D, this.texture),
            e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t, i, 0, e.RGBA, e.UNSIGNED_BYTE, a.emptyUint8Array),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            this.inverseTextureSize = new r.default([1 / t, 1 / i]),
            n && this.rootNode.insert({
                width: 16,
                height: 16
            }, o)
        }
        async load(e) {
            if (await this.checkFinished())
                e();
            else {
                const t = this.sprites.length;
                for (let a = 0; a < t; a++) {
                    const t = t=>()=>{
                        this.loadSprite(this.sprites[t], e)
                    }
                    ;
                    resourceLoader.takeLoadingSlot(t(a))
                }
            }
        }
        addSprite(e, t) {
            const a = resourceLoader.getImageOverride(e);
            if (a && (e = a.imagePath),
            this.loadedSprites[e])
                return void t(this.loadedSprites[e]);
            const i = {
                src: e,
                callback: t,
                padding: this.padding
            };
            a && a.animated && (i.animated = !0),
            this.sprites.push(i)
        }
        loadSprite(e, t, a=0) {
            const i = new Image;
            i.onload = (()=>{
                e.image = i,
                this.spriteLoaded(t)
            }
            ),
            i.onerror = (()=>{
                o.default.warn(o.LogSource.ResourceLoader)(`Failed to load ${i.src}`),
                steamworks.isElectron() && a < 3 ? setTimeout(()=>{
                    this.loadSprite(e, t, a + 1)
                }
                , 500 * (a + 1)) : this.spriteLoaded(t)
            }
            ),
            i.crossOrigin = "anonymous",
            i.src = e.src
        }
        async spriteLoaded(e) {
            setTimeout(resourceLoader.releaseLoadingSlot.bind(resourceLoader), 0),
            this.spriteLoadCount++,
            await this.checkFinished() && e()
        }
        async checkFinished() {
            return this.spriteLoadCount === this.sprites.length && (this.spriteLoadCount = 0,
            await this.pack(),
            !0)
        }
        async pack() {
            this.sprites = this.sprites.filter(e=>void 0 !== e.image),
            this.sprites.sort((e,t)=>{
                if (void 0 === e && void 0 === t)
                    return 0;
                if (void 0 === e)
                    return 1;
                if (void 0 === t)
                    return -1;
                if (e.image && t.image) {
                    const a = e.image.width * e.image.height
                      , i = t.image.width * t.image.height;
                    return a < i ? 1 : a > i ? -1 : 0
                }
                return 0
            }
            );
            let e = 0;
            for (const t of this.sprites)
                this.packSprite(this.gl, t),
                e++,
                void 0 === game.slot && e >= s && (e = 0,
                await n.sleep(1));
            this.sprites = []
        }
        packSprite(e, t) {
            if (void 0 === t || !t.image)
                return;
            const a = this.rootNode.insert(t.image, this.padding);
            if (a) {
                e.bindTexture(e.TEXTURE_2D, this.texture),
                e.texSubImage2D(e.TEXTURE_2D, 0, a.left, a.top, e.RGBA, e.UNSIGNED_BYTE, t.image);
                const n = new i.default(new r.default(a.left,a.top),a.bottom - a.top,0,t.animated);
                this.loadedSprites[t.src] = n,
                t.callback(n, t.image),
                t.image = void 0
            } else
                o.default.error(o.LogSource.ResourceLoader)("Couldn't pack sprite!", t)
        }
    }
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("resources/ResourceLoader", ["require", "exports", "creature/corpse/Corpses", "creature/Creatures", "doodad/DoodadInfo", "doodad/Doodads", "entity/StatusEffects", "Enums", "item/Items", "renderer/RendererConstants", "renderer/TerrainTileInfo", "renderer/TexturePacker", "renderer/TileAdaptors", "resources/IResourceLoader", "resources/ResourcePath", "tile/ITileEvent", "tile/Terrains", "utilities/enum/Enums", "utilities/Log", "utilities/promise/ResolvablePromise", "utilities/string/Strings"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class v {
        constructor() {
            this.maxConcurrent = 30
        }
        initialize(e) {
            this.spritePacker = new p.default(e,1536,1536,!1,1),
            this.tilePacker = new p.default(e,1536,1536,!0,0),
            this.loadingCount = 0,
            this.concurrent = 0,
            this.waitingSlots = []
        }
        loadResources(e) {
            return new S.default(t=>{
                this.callback = t,
                this.loadingCount++,
                this.loadingCount > 1 || this.loadResourcesInternal(e)
            }
            )
        }
        continueLoading() {
            if (0 === this.waitingSlots.length)
                return;
            let e;
            for (; this.waitingSlots.length > 0 && this.concurrent < this.maxConcurrent; )
                this.concurrent++,
                (e = this.waitingSlots.shift()) && e()
        }
        takeLoadingSlot(e) {
            this.waitingSlots.push(e)
        }
        releaseLoadingSlot() {
            this.concurrent--
        }
        getImageOverride(e) {
            return this.imageOverrides ? this.imageOverrides[e] : void 0
        }
        updateImageOverrides() {
            this.imageOverrides = {};
            const e = modManager.getLoadedMods()
              , t = modManager.getEnabledMods();
            for (const a of t) {
                const t = modManager.getModFromIndex(a);
                -1 === e.indexOf(t) && e.push(t)
            }
            for (const t of e) {
                const e = t.imageOverrides;
                if (e)
                    for (let a of e) {
                        const e = `static/image/${"string" == typeof (a = I.default.fixObjectCaseStyle(a, s.CaseStyle.CamelCase)) ? a : a.replace}`;
                        let i = "string" == typeof a ? a : a.imagePath;
                        i = void 0 === i ? e : I.default.stripParentDirectoryAccessorsFromPath(i),
                        this.imageOverrides[`${e}.png`] = {
                            imagePath: `${t.path}/${i}.png`,
                            animated: "string" != typeof a && a.animated
                        }
                    }
            }
        }
        loadResourcesInternal(e) {
            e.spriteTexture = this.spritePacker.texture,
            e.spriteTextureSizeInversed = this.spritePacker.inverseTextureSize,
            e.tileTexture = this.tilePacker.texture,
            e.tileTextureSizeInversed = this.tilePacker.inverseTextureSize;
            let t = 0;
            const a = ()=>{
                t++,
                T.default.info(T.LogSource.ResourceLoader)("loadResources packed", t),
                2 === t && (c.setDefaultBackground(tileAtlas.terrain[s.TerrainType.Dirt]),
                clearInterval(this.loadingInterval),
                this.loadingCount--,
                this.loadingCount > 0 ? this.loadResourcesInternal(e) : this.callback())
            }
            ;
            this.loadCharacter(),
            this.loadCreatures(),
            this.loadCorpses(),
            this.loadItems(),
            this.loadTerrains(),
            this.loadDoodads(),
            this.loadDoodadItems(),
            this.loadTileEvents(),
            this.loadHairstyles(),
            this.loadStatuses(),
            this.loadOverlays(),
            this.loadOthers(),
            this.spritePacker.load(a),
            this.tilePacker.load(a),
            this.loadingInterval = setInterval(this.continueLoading.bind(this), 10)
        }
        loadCharacter() {
            this.spritePacker.addSprite("static/image/character/raft.png", e=>{
                spriteAtlas.raft = e
            }
            ),
            this.spritePacker.addSprite("static/image/character/body.png", e=>{
                spriteAtlas.playerBody = e
            }
            ),
            this.spritePacker.addSprite("static/image/character/sleeping.png", e=>{
                spriteAtlas.playerSleeping = e
            }
            ),
            this.spritePacker.addSprite("static/image/character/zzz.png", e=>{
                spriteAtlas.zzz = e
            }
            )
        }
        loadCreatures() {
            for (const e of f.default.values(s.CreatureType))
                this.loadCreature(e);
            this.spritePacker.addSprite("static/image/creature/shadow.png", e=>{
                spriteAtlas.shadow = e
            }
            )
        }
        loadCreature(e) {
            i.default[e] && this.spritePacker.addSprite(`${h.default.getPath(m.PathType.Creature, e)}.png`, t=>{
                t.texOffsetY = (Math.ceil(t.texSize / 8) - u.subTileSize) / (2 * u.subTileSize),
                spriteAtlas.creatures[e] = t
            }
            )
        }
        loadCorpses() {
            for (const e of f.default.values(s.CreatureType))
                this.loadCorpse(e)
        }
        loadCorpse(e) {
            const t = i.default[e];
            (e === s.CreatureType.Blood || e === s.CreatureType.WaterBlood || t && !t.noCorpse) && this.spritePacker.addSprite(`${h.default.getPath(m.PathType.Corpse, e)}.png`, t=>{
                const i = a.default[e];
                i && (t.animated = !!i.animated),
                spriteAtlas.corpses[e] = t
            }
            )
        }
        loadItems() {
            for (const e of f.default.values(s.ItemType)) {
                const t = l.default[e];
                t && (this.loadItem(e, h.default.getPath(m.PathType.Item, e)),
                t.equip && this.loadEquip(e, h.default.getPath(m.PathType.Equip, e)),
                t.hasSleepImage && this.loadSleep(e, h.default.getPath(m.PathType.Sleep, e)))
            }
        }
        loadItem(e, t) {
            this.spritePacker.addSprite(`${t}.png`, (t,a)=>{
                spriteAtlas.items[e] = t
            }
            ),
            this.spritePacker.addSprite(`${t}_8.png`, t=>{
                spriteAtlas.itemsSmall[e] = t
            }
            )
        }
        loadEquip(e, t) {
            this.spritePacker.addSprite(`${t}.png`, (t,a)=>{
                spriteAtlas.itemsEquipped[e] = t
            }
            )
        }
        loadSleep(e, t) {
            this.spritePacker.addSprite(`${t}.png`, (t,a)=>{
                spriteAtlas.sleeps[e] = t
            }
            )
        }
        loadTerrains() {
            for (const e of f.default.values(s.TerrainType))
                this.loadTerrain(e)
        }
        loadTerrain(e) {
            const t = g.default[e];
            t && !t.doodad && t.terrainType === e && (this.tilePacker.addSprite(`${h.default.getPath(m.PathType.Terrain, e)}.png`, a=>{
                const i = !!a.animated || !(!t || !t.animated);
                t.isMountain ? tileAtlas.terrain[e] = new d.MountainTileInfo(a.texCoord.x / u.subTileSize,a.texCoord.y / u.subTileSize,i) : tileAtlas.terrain[e] = new d.TerrainTileInfo(a.texCoord.x / u.subTileSize,a.texCoord.y / u.subTileSize,i)
            }
            ),
            t.tillable && this.tilePacker.addSprite(`${h.default.getPath(m.PathType.Terrain, e)}_tilled.png`, a=>{
                const i = !!a.animated || !(!t || !t.animated);
                t.isMountain ? tileAtlas.terrainTilled[e] = new d.MountainTileInfo(a.texCoord.x / u.subTileSize,a.texCoord.y / u.subTileSize,i) : tileAtlas.terrainTilled[e] = new d.TerrainTileInfo(a.texCoord.x / u.subTileSize,a.texCoord.y / u.subTileSize,i)
            }
            ),
            t.hasMound && this.tilePacker.addSprite(`${h.default.getPath(m.PathType.Mound, e)}.png`, t=>{
                const a = t.texCoord.copy().scale(1 / u.subTileSize);
                tileAtlas.mounds[e] = new n.default(e,!1,a.x,a.y,!1)
            }
            ))
        }
        loadDoodads() {
            for (const e of f.default.values(s.DoodadType))
                e !== s.DoodadType.Item && this.loadDoodad(e)
        }
        loadDoodad(e) {
            const t = o.default[e];
            t && this.tilePacker.addSprite(`${h.default.getPath(m.PathType.Doodad, e)}.png`, a=>{
                const i = a.texCoord.copy().scale(1 / u.subTileSize);
                t && t.isTall && (i.y += 2);
                const o = !!a.animated || !(!t || !t.isAnimated);
                tileAtlas.doodads[e] = new n.default(e,!(!t || !t.isTall),i.x,i.y,o)
            }
            )
        }
        loadDoodadItems() {
            for (const e of f.default.values(s.ItemType)) {
                const t = l.default[e];
                t && t.doodad && this.loadDoodadItem(e)
            }
        }
        loadDoodadItem(e) {
            this.tilePacker.addSprite(`${h.default.getPath(m.PathType.DoodadItem, e)}.png`, t=>{
                const a = l.default[e]
                  , i = !!(a && a.doodad && a.doodad.isTall)
                  , o = t.texCoord.copy().scale(1 / u.subTileSize);
                i && (o.y += 2),
                tileAtlas.doodadItems[e] = new n.default(s.DoodadType.Item,i,o.x,o.y,!1)
            }
            )
        }
        loadTileEvents() {
            for (const e of f.default.values(y.TileEventType))
                this.loadTileEvent(e)
        }
        loadTileEvent(e) {
            e !== y.TileEventType.None && this.spritePacker.addSprite(`${h.default.getPath(m.PathType.TileEvent, e)}.png`, t=>{
                spriteAtlas.tileEvents[e] = t
            }
            )
        }
        loadHairstyles() {
            for (const e of f.default.values(s.HairStyle))
                this.loadHairstyle(e)
        }
        loadHairstyle(e) {
            e !== s.HairStyle.None && this.spritePacker.addSprite(`${h.default.getPath(m.PathType.Hairstyle, e)}.png`, t=>{
                spriteAtlas.playerHairstyles[e] = t
            }
            )
        }
        loadStatuses() {
            for (const e of f.default.values(s.StatusType))
                this.loadStatus(e)
        }
        loadStatus(e) {
            const t = r.default[e];
            t && t.renderer.hasLayer() && this.spritePacker.addSprite(`${h.default.getPath(m.PathType.StatusEffect, e)}.png`, t=>{
                spriteAtlas.statusEffects[e] = t
            }
            )
        }
        loadOverlays() {
            for (const e of f.default.values(s.OverlayType))
                this.loadOverlay(e)
        }
        loadOverlay(e) {
            this.spritePacker.addSprite(`${h.default.getPath(m.PathType.Overlay, e)}.png`, t=>{
                spriteAtlas.overlay[e] = t
            }
            )
        }
        loadOthers() {
            this.spritePacker.addSprite("static/image/ui/in-game/text.png", e=>{
                spriteAtlas.text = e
            }
            ),
            this.spritePacker.addSprite("static/image/ui/in-game/miss.png", e=>{
                spriteAtlas.miss = e
            }
            )
        }
    }
    t.default = v
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/clientStore/ClientData", ["require", "exports", "save/clientStore/clientData/ExploredMap", "save/clientStore/clientData/NewUiData", "save/clientStore/IClientStore"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const o = {
        [n.ClientDataType.ExploredMap]: a.default,
        [n.ClientDataType.NewUi]: i.default
    };
    t.default = o
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/clientStore/ClientStore", ["require", "exports", "save/clientStore/ClientData", "save/clientStore/IClientStore", "save/ISerializer", "utilities/enum/Enums"], function(e, t, a, i, n, o) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class r {
        constructor() {
            this.data = new Map;
            for (const e of o.default.values(i.ClientDataType))
                this.data.set(e, new a.default[e])
        }
        get(e) {
            let t = this.data.get(e);
            return t || (t = new a.default[e],
            this.data.set(e, t)),
            t
        }
    }
    __decorate([n.SaveProperty()], r.prototype, "data", void 0),
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("save/datastorage/IAsyncDataStorage", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("save/datastorage/IDataStorage", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    })
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/datastorage/LocalStorageDataStorage", ["require", "exports", "save/ISaveManager"], function(e, t, a) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class i {
        isEnabled() {
            return void 0 !== localStorage
        }
        isReady() {
            return !0
        }
        isSlotUsed(e, t) {
            return !!localStorage.getItem(`${e}version`)
        }
        saveToSlot(e, t) {
            localStorage.setItem(`${e}version`, t.version),
            localStorage.setItem(`${e}isCompressed`, t.isCompressed ? "1" : "0");
            let a = 0;
            const i = Object.keys(t.data);
            for (let n = 0; n < i.length; n++) {
                const o = i[n]
                  , r = t.data[o];
                a += 2 * r.length,
                localStorage.setItem(`${e}${o}`, r)
            }
            return a
        }
        loadFromSlot(e, t) {
            t.version = localStorage.getItem(`${e}version`),
            t.isCompressed = "0" !== localStorage.getItem(`${e}isCompressed`);
            const a = Object.keys(t.data);
            for (let i = 0; i < a.length; i++) {
                const n = a[i];
                t.data[n] = localStorage.getItem(`${e}${n}`)
            }
        }
        deleteSlot(e) {
            localStorage.removeItem(`${e}version`),
            localStorage.removeItem(`${e}isCompressed`);
            const t = e === a.SLOT_GLOBAL ? a.propertiesToSerializeGlobal : a.propertiesToSerialize;
            for (let a = 0; a < t.length; a++) {
                const i = t[a].key;
                localStorage.removeItem(`${e}${i}`)
            }
            return !0
        }
        deleteAllSlots() {
            for (let e = 0; e < a.SLOT_COUNT_MAX; e++)
                this.deleteSlot(e);
            return !0
        }
        deleteAllData() {
            localStorage.clear()
        }
    }
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("save/datastorage/IndexedDbDataStorage", ["require", "exports", "save/datastorage/LocalStorageDataStorage", "save/ISaveManager", "utilities/Log"], function(e, t, a, i, n) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const o = new n.default(n.LogSource.SaveManager);
    class r {
        constructor() {
            this.databaseName = "wayward",
            this.objectStoreNameSaves = "saves",
            this.ready = !1,
            this.dataStorageLocalStorage = new a.default,
            this.openIndexedDb()
        }
        isEnabled() {
            return void 0 !== indexedDB
        }
        isReady() {
            return this.ready
        }
        async isSlotUsed(e) {
            return await this.waitForDatabase(),
            new Promise(t=>{
                const a = ()=>{
                    try {
                        const i = this.database.transaction(this.objectStoreNameSaves).objectStore(this.objectStoreNameSaves).get(e);
                        i.onerror = (()=>{
                            t(!1)
                        }
                        ),
                        i.onsuccess = (()=>{
                            void 0 === i.result || null === i.result ? t(this.dataStorageLocalStorage.isSlotUsed(e)) : t(!0)
                        }
                        )
                    } catch (e) {
                        o.info("transaction exception", e),
                        setTimeout(a, 100)
                    }
                }
                ;
                a()
            }
            )
        }
        async saveToSlot(e, t, a=!1) {
            if (a)
                return this.dataStorageLocalStorage.saveToSlot(e, t),
                0;
            const i = this.database.transaction(this.objectStoreNameSaves, "readwrite").objectStore(this.objectStoreNameSaves)
              , n = {
                slot: e,
                isCompressed: t.isCompressed
            };
            let r = 0;
            const s = Object.keys(t.data);
            for (let e = 0; e < s.length; e++) {
                const a = s[e]
                  , i = t.data[a];
                i && i.length && (r += 2 * i.length,
                n[a] = i)
            }
            return new Promise(t=>{
                const a = i.put(n);
                a.onerror = (()=>{
                    o.error(`Save to slot ${e} failed`, a.error),
                    t(0)
                }
                ),
                a.onsuccess = (()=>{
                    t(r)
                }
                )
            }
            )
        }
        async loadFromSlot(e, t) {
            return new Promise((a,i)=>{
                this.waitForDatabase().then(()=>{
                    const n = this.database.transaction(this.objectStoreNameSaves).objectStore(this.objectStoreNameSaves).get(e);
                    n.onerror = (()=>{
                        i(n.error)
                    }
                    ),
                    n.onsuccess = (()=>{
                        const e = n.result;
                        if (e)
                            return t.version = e.version,
                            t.isCompressed = !1 !== e.isCompressed,
                            t.data = e,
                            void a();
                        i("No data")
                    }
                    )
                }
                )
            }
            )
        }
        async deleteSlot(e) {
            return this.dataStorageLocalStorage.deleteSlot(e),
            new Promise(t=>{
                if (this.database) {
                    const a = this.database.transaction(this.objectStoreNameSaves, "readwrite").objectStore(this.objectStoreNameSaves)
                      , i = a.delete(e);
                    i.onsuccess = (()=>{
                        setTimeout(()=>{
                            t(!0)
                        }
                        , 0)
                    }
                    ),
                    i.onerror = (()=>{
                        setTimeout(()=>{
                            t(!1)
                        }
                        , 0)
                    }
                    )
                }
            }
            )
        }
        async deleteAllSlots() {
            if (this.dataStorageLocalStorage.deleteAllSlots(),
            this.database) {
                const e = [];
                for (let t = 0; t < i.SLOT_COUNT_MAX; t++)
                    e.push(this.deleteSlot(t));
                await Promise.all(e)
            }
            return !0
        }
        async deleteAllData() {
            if (this.dataStorageLocalStorage.deleteAllData(),
            this.database) {
                const e = [];
                for (let t = 0; t < i.SLOT_COUNT_MAX; t++)
                    e.push(this.deleteSlot(t));
                return e.push(this.deleteSlot(i.SLOT_GLOBAL)),
                Promise.all(e)
            }
            return new Promise(e=>{
                const t = indexedDB.deleteDatabase(this.databaseName);
                t.onerror = e,
                t.onsuccess = e
            }
            )
        }
        openIndexedDb() {
            const e = indexedDB.open(this.databaseName, 1);
            e.onerror = (e=>{
                o.error("indexedDB failure", e, e.target.error, e.target.errorCode),
                o.error("This often occurs if multiple instances of wayward is running at the same time."),
                setTimeout(()=>{
                    this.openIndexedDb()
                }
                , 1e3)
            }
            ),
            e.onsuccess = (async e=>{
                this.database = e.target.result,
                await this.transferSaves(),
                this.ready = !0
            }
            ),
            e.onupgradeneeded = (e=>{
                o.info("indexedDB onupgradeneeded", e),
                this.database = e.target.result;
                const t = this.database.createObjectStore(this.objectStoreNameSaves, {
                    keyPath: "slot"
                });
                t.createIndex("slot", "slot", {
                    unique: !0
                })
            }
            )
        }
        async transferSaves() {
            const e = [];
            let t;
            for (let a = 0; a < i.SLOT_COUNT_MAX; a++)
                (t = this.dataStorageLocalStorage.isSlotUsed(a)) && e.push(this.transferFromLocalStorageToIndexedDb(a));
            return (t = this.dataStorageLocalStorage.isSlotUsed(i.SLOT_GLOBAL)) && e.push(this.transferFromLocalStorageToIndexedDb(i.SLOT_GLOBAL)),
            Promise.all(e)
        }
        async transferFromLocalStorageToIndexedDb(e) {
            o.info(`Transfering save ${e} from localstorage to indexeddb`);
            const t = new i.SaveObject
              , a = e === i.SLOT_GLOBAL ? i.propertiesToSerializeGlobal : i.propertiesToSerialize;
            for (let e = 0; e < a.length; e++) {
                const i = a[e].key;
                t.data[i] = void 0
            }
            try {
                this.dataStorageLocalStorage.loadFromSlot(e, t),
                await this.saveToSlot(e,t),
                this.dataStorageLocalStorage.deleteSlot(e)
            } catch (e) {
                o.info("Unable to load the saveObject")
            }
        }
        async waitForDatabase() {
            return new Promise(e=>{
                if (this.database)
                    e();
                else {
                    const t = window.setInterval(()=>{
                        this.database && (e(),
                        window.clearInterval(t))
                    }
                    , 5)
                }
            }
            )
        }
    }
    t.default = r
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/Serializer", ["require", "exports", "creature/Creature", "doodad/DoodadRegistrar", "doodad/doodads/Doodad", "Enums", "game/TimeManager", "item/Item", "language/dictionary/UiTranslation", "npc/BaseNPC", "npc/NPCS", "player/MessageManager", "player/Player", "save/clientStore/ClientStore", "save/ISerializer", "utilities/Log", "utilities/math/Vector2", "utilities/math/Vector3"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const T = new y.default(y.LogSource.Serializer)
      , S = new y.default(y.LogSource.SaveManager)
      , I = [{
        type: h.Types.Item,
        value: s.default
    }, {
        type: h.Types.Creature,
        value: a.default
    }, {
        type: h.Types.TimeManager,
        value: r.default
    }, {
        type: h.Types.Player,
        value: c.default
    }, {
        type: h.Types.NPC,
        value: {
            baseClass: u.default,
            registrar: d.registrar
        }
    }, {
        type: h.Types.DoodadV2,
        value: {
            baseType: h.Types.Doodad,
            baseClass: n.default,
            registrar: i.registrar
        }
    }, {
        type: h.Types.Doodad,
        value: n.default
    }, {
        type: h.Types.MessageManager,
        value: p.default
    }, {
        type: h.Types.ClientStore,
        value: m.default
    }, {
        type: h.Types.Vector3,
        value: f.default
    }, {
        type: h.Types.Vector2,
        value: g.default
    }]
      , v = new Map;
    for (const e of I)
        v.set(e.type, e.value);
    class w {
        constructor(e, t=!1) {
            this.version = e,
            this.skipOnUnserialized = t
        }
        saveToUint8Array(e, t) {
            try {
                if (w.usingBuffer)
                    throw new Error("The buffer is already being used");
                w.usingBuffer = !0,
                this.byteOffset = 0,
                this.dataView = new DataView(w.buffer),
                this.writeProperty(e, t);
                const a = w.buffer.slice(0, this.byteOffset);
                return new Uint8Array(a,0,this.byteOffset)
            } catch (e) {
                let a, i, n;
                T.error("Failed to save data. Please report this issue.", t, this.version, this.byteOffset, w.maxBytes),
                T.error("Exception", e);
                let r = 0;
                for (n = o.WorldZ.Min; n <= o.WorldZ.Max; n++)
                    for (a = 0; a < game.mapSize; a++)
                        for (i = 0; i < game.mapSize; i++) {
                            const e = game.getTileData(a, i, n);
                            e && (r += e.length)
                        }
                return T.error("Extra data", {
                    items: game.items.length,
                    doodads: game.doodads.length,
                    tileEvents: game.tileEvents.length,
                    tileData: r,
                    creatures: game.creatures.length,
                    corpses: game.corpses.length
                }),
                void newui.interruptWithInfo(l.default.GameInterruptSaveFailure, l.default.GameInterruptSaveFailureDescription).then(()=>{
                    steamworks.openLogsFolder()
                }
                )
            } finally {
                w.usingBuffer = !1
            }
        }
        saveToString(e, t) {
            const a = this.saveToUint8Array(e, t);
            if (void 0 !== a) {
                let e = "";
                const t = this.byteOffset;
                for (let i = 0; i < t; i += 2)
                    e += i + 1 < t ? String.fromCharCode(a[i] + (a[i + 1] << 8)) : String.fromCharCode(a[i]);
                return e
            }
        }
        load(e, t, a) {
            "string" == typeof a ? this.loadFromString(e, t, a) : this.loadFromUint8Array(e, t, a)
        }
        loadFromUint8Array(e, t, a) {
            if (!(null === a || void 0 === a || a.length <= 0)) {
                this.byteOffset = 0,
                this.dataView = new DataView(a.buffer);
                try {
                    this.readProperty(e, t)
                } catch (e) {
                    throw T.error("Failed to load data [loadFromUint8Array]. Please report this issue.", t, this.version, this.byteOffset, w.maxBytes, e),
                    e
                }
            }
        }
        loadFromString(e, t, a) {
            if (null === a || void 0 === a || a.length <= 0)
                return;
            const i = a
              , n = i.length
              , o = new Uint8Array(2 * n);
            for (let e = 0; e < n; e++)
                o[2 * e] = 255 & i.charCodeAt(e),
                o[2 * e + 1] = i.charCodeAt(e) >> 8 & 255;
            this.loadFromUint8Array(e, t, o)
        }
        readProperty(e, t) {
            const a = this.dataView.getUint8(this.byteOffset);
            let i;
            switch (this.byteOffset++,
            a) {
            case h.Types.Invalid:
                break;
            case h.Types.Undefined:
                e[t] = void 0;
                break;
            case h.Types.Null:
                e[t] = null;
                break;
            case h.Types.Boolean:
                e[t] = 1 === this.dataView.getUint8(this.byteOffset),
                this.byteOffset++;
                break;
            case h.Types.ByteSigned:
                e[t] = this.dataView.getInt8(this.byteOffset),
                this.byteOffset++;
                break;
            case h.Types.ByteUnsigned:
                e[t] = this.dataView.getUint8(this.byteOffset),
                this.byteOffset++;
                break;
            case h.Types.ShortSigned:
                e[t] = this.dataView.getInt16(this.byteOffset),
                this.byteOffset += 2;
                break;
            case h.Types.ShortUnsigned:
                e[t] = this.dataView.getUint16(this.byteOffset),
                this.byteOffset += 2;
                break;
            case h.Types.IntegerSigned:
                e[t] = this.dataView.getInt32(this.byteOffset),
                this.byteOffset += 4;
                break;
            case h.Types.IntegerUnsigned:
                e[t] = this.dataView.getUint32(this.byteOffset),
                this.byteOffset += 4;
                break;
            case h.Types.Float32:
                e[t] = this.dataView.getFloat32(this.byteOffset),
                this.byteOffset += 4;
                break;
            case h.Types.Float64:
                e[t] = this.dataView.getFloat64(this.byteOffset),
                this.byteOffset += 8;
                break;
            case h.Types.String:
                e[t] = this.readString();
                break;
            case h.Types.ArrayV2:
                t in e ? Array.isArray(e[t]) || S.warn("Loading array into non array object", e, t, e[t]) : e[t] = [],
                this.readArrayV2(e, t);
                break;
            case h.Types.Array:
            case h.Types.Object:
                if (!(t in e))
                    switch (a) {
                    case h.Types.Array:
                        e[t] = [];
                        break;
                    case h.Types.Object:
                        e[t] = {}
                    }
                this.readObject(e, t);
                break;
            case h.Types.ArrayBuffer:
                e[t] = this.readArrayBuffer();
                break;
            case h.Types.Map:
                e[t] = this.readMap(e, t);
                break;
            case h.Types.Function:
                break;
            default:
                if (i = v.get(a)) {
                    if (!(t in e)) {
                        const a = i;
                        if (a.registrar) {
                            const a = this.dataView.getUint8(this.byteOffset);
                            this.byteOffset++;
                            const n = i.registrar.get(a);
                            e[t] = n ? new n : {}
                        } else
                            e[t] = new i
                    }
                    this.readObject(e, t),
                    this.skipOnUnserialized || "function" != typeof e[t].onUnserialized || e[t].onUnserialized()
                } else
                    S.warn("readProperty default case", h.Types[a].toString(), e[t])
            }
        }
        writeProperty(e, t) {
            let a = e[t], i = h.Types.Invalid, n;
            if (null !== a && void 0 !== a)
                if ("containedWithin" === t)
                    a = itemManager.getContainerReference(a, e);
                else if ("containedItems" === t) {
                    const e = []
                      , t = a;
                    for (let a = 0; a < t.length; a++)
                        t[a] && e.push(t[a].id);
                    a = e
                }
            switch (typeof a) {
            case "undefined":
                i = h.Types.Undefined;
                break;
            case "boolean":
                i = h.Types.Boolean;
                break;
            case "number":
                i = h.Types.Float64,
                this.isInteger(a) && (this.isByteSigned(a) ? i = h.Types.ByteSigned : this.isByteUnsigned(a) ? i = h.Types.ByteUnsigned : this.isShortSigned(a) ? i = h.Types.ShortSigned : this.isShortUnsigned(a) ? i = h.Types.ShortUnsigned : this.isIntegerSigned(a) ? i = h.Types.IntegerSigned : this.isIntegerUnsigned(a) && (i = h.Types.IntegerUnsigned));
                break;
            case "string":
                i = h.Types.String;
                break;
            case "object":
                if (null === a)
                    i = h.Types.Null;
                else if (a instanceof Array)
                    i = h.Types.ArrayV2;
                else if (a instanceof Map)
                    i = h.Types.Map;
                else if (ArrayBuffer.isView(a))
                    i = h.Types.ArrayBuffer;
                else
                    for (const e of I) {
                        const t = e.value
                          , o = t;
                        if (o.registrar) {
                            if (a instanceof o.baseClass) {
                                const t = a.getRegistrarId();
                                void 0 !== o.baseType && o.registrar.usesBase(t) ? i = o.baseType : (i = e.type,
                                n = t);
                                break
                            }
                        } else if (a instanceof t) {
                            i = e.type;
                            break
                        }
                    }
                i === h.Types.Invalid && (i = h.Types.Object);
                break;
            case "function":
                i = h.Types.Function;
                break;
            default:
                S.warn("Unknown type", e, t, a, typeof a)
            }
            switch (this.dataView.setUint8(this.byteOffset, i),
            this.byteOffset++,
            void 0 !== n && (this.dataView.setUint8(this.byteOffset, n),
            this.byteOffset++),
            i) {
            case h.Types.Invalid:
            case h.Types.Undefined:
            case h.Types.Null:
                break;
            case h.Types.Boolean:
                this.dataView.setUint8(this.byteOffset, a ? 1 : 0),
                this.byteOffset++;
                break;
            case h.Types.ByteSigned:
                this.dataView.setInt8(this.byteOffset, a),
                this.byteOffset++;
                break;
            case h.Types.ByteUnsigned:
                this.dataView.setUint8(this.byteOffset, a),
                this.byteOffset++;
                break;
            case h.Types.ShortSigned:
                this.dataView.setInt16(this.byteOffset, a),
                this.byteOffset += 2;
                break;
            case h.Types.ShortUnsigned:
                this.dataView.setUint16(this.byteOffset, a),
                this.byteOffset += 2;
                break;
            case h.Types.IntegerSigned:
                this.dataView.setInt32(this.byteOffset, a),
                this.byteOffset += 4;
                break;
            case h.Types.IntegerUnsigned:
                this.dataView.setUint32(this.byteOffset, a),
                this.byteOffset += 4;
                break;
            case h.Types.Float32:
                this.dataView.setFloat32(this.byteOffset, a),
                this.byteOffset += 4;
                break;
            case h.Types.Float64:
                this.dataView.setFloat64(this.byteOffset, a),
                this.byteOffset += 8;
                break;
            case h.Types.String:
                this.writeString(a);
                break;
            case h.Types.ArrayV2:
                this.writeArrayV2(a);
                break;
            case h.Types.ArrayBuffer:
                this.writeArrayBuffer(a);
                break;
            case h.Types.Map:
                this.writeMap(a);
                break;
            case h.Types.Function:
                break;
            default:
                this.writeObject(a)
            }
        }
        getSerializationProperties(e, t) {
            if (e.constructor && !0 === e.constructor._saveAllProperties)
                return Object.keys(e);
            const a = e.constructor ? e.constructor._saveProperties : void 0;
            if (a)
                return a;
            const i = e.getSerializationProperties;
            return "function" == typeof i ? i(t) : (saveDataGlobal.options.developerMode && void 0 !== e.constructor && -1 === e.constructor.toString().indexOf("[native code]") && S.warn("Serializing all properties for class. You should use SaveProperty() or SaveAllProperties()", e.constructor.toString()),
            Object.keys(e))
        }
        readObject(e, t) {
            let a = e[t];
            if (a && "function" == typeof a.deserializeObject)
                return void a.deserializeObject(this);
            const i = this.dataView.getUint32(this.byteOffset);
            this.byteOffset += 4;
            for (let n = 0; n < i; n++) {
                const i = this.readString();
                void 0 !== a && null !== a || (S.warn("readObject object[key] is invalid", e, t, a),
                a = e[t] = {});
                try {
                    this.readProperty(a, i)
                } catch (n) {
                    const o = this.dataView.getUint8(this.byteOffset - 1);
                    switch (S.error(`readObject failed to read property. Tried reading property '${i}' (type '${h.Types[o]}') into [key: ${t} - `, a, "]", e, n),
                    o) {
                    case h.Types.Invalid:
                    case h.Types.Undefined:
                    case h.Types.Null:
                        break;
                    case h.Types.Boolean:
                    case h.Types.ByteSigned:
                    case h.Types.ByteUnsigned:
                        this.byteOffset++;
                        break;
                    case h.Types.ShortSigned:
                    case h.Types.ShortUnsigned:
                        this.byteOffset += 2;
                        break;
                    case h.Types.IntegerSigned:
                    case h.Types.IntegerUnsigned:
                    case h.Types.Float32:
                        this.byteOffset += 4;
                        break;
                    case h.Types.Float64:
                        this.byteOffset += 8
                    }
                }
            }
        }
        readString() {
            const e = this.dataView.getUint32(this.byteOffset);
            this.byteOffset += 4;
            let t = "";
            for (let a = 0; a < e; a++)
                t += String.fromCharCode(this.dataView.getUint16(this.byteOffset)),
                this.byteOffset += 2;
            return t
        }
        readArrayV2(e, t) {
            const a = this.dataView.getUint32(this.byteOffset);
            this.byteOffset += 4,
            e[t].length = a;
            const i = this.dataView.getUint32(this.byteOffset);
            this.byteOffset += 4;
            for (let a = 0; a < i; a++) {
                const a = this.dataView.getUint32(this.byteOffset);
                this.byteOffset += 4,
                this.readProperty(e[t], a)
            }
        }
        readArrayBuffer() {
            const e = this.dataView.getUint8(this.byteOffset);
            this.byteOffset++;
            const t = this.dataView.getUint32(this.byteOffset);
            this.byteOffset += 4;
            let a = null;
            switch (e) {
            case 1:
                a = new Uint8Array(this.dataView.buffer.slice(this.byteOffset, this.byteOffset + t));
                break;
            default:
                S.warn("Unknown array buffer", e, t)
            }
            return this.byteOffset += t,
            a
        }
        readMap(e, t) {
            let a = e[t];
            const i = this.dataView.getUint32(this.byteOffset);
            this.byteOffset += 4,
            a || (a = new Map);
            for (let e = 0; e < i; e++) {
                const e = [];
                this.readProperty(e, 0);
                const t = a.get(e[0]);
                t && (e[1] = t),
                this.readProperty(e, 1),
                a.set(e[0], e[1])
            }
            return a
        }
        writeObject(e) {
            if ("function" == typeof e.serializeObject)
                return void e.serializeObject(this);
            "function" == typeof e.preSerializeObject && e.preSerializeObject();
            let t = this.getSerializationProperties(e, this.version);
            t = t.filter(t=>void 0 !== e[t]),
            this.dataView.setUint32(this.byteOffset, t.length),
            this.byteOffset += 4;
            for (const a of t)
                this.writeString(a),
                this.writeProperty(e, a)
        }
        writeString(e) {
            this.dataView.setUint32(this.byteOffset, e.length),
            this.byteOffset += 4;
            for (let t = 0; t < e.length; t++)
                this.dataView.setUint16(this.byteOffset, e.charCodeAt(t)),
                this.byteOffset += 2
        }
        writeArrayV2(e) {
            this.dataView.setUint32(this.byteOffset, e.length),
            this.byteOffset += 4;
            const t = Object.keys(e).map(e=>parseInt(e, 10));
            this.dataView.setUint32(this.byteOffset, t.length),
            this.byteOffset += 4;
            for (let a = 0; a < t.length; a++) {
                const i = t[a];
                this.dataView.setUint32(this.byteOffset, i),
                this.byteOffset += 4,
                this.writeProperty(e, i)
            }
        }
        writeArrayBuffer(e) {
            const t = e.BYTES_PER_ELEMENT
              , a = e.byteLength;
            this.dataView.setUint8(this.byteOffset, t),
            this.byteOffset++,
            this.dataView.setUint32(this.byteOffset, a),
            this.byteOffset += 4;
            for (let i = 0; i < a; i++) {
                switch (t) {
                case 1:
                    this.dataView.setUint8(this.byteOffset, e[i]);
                    break;
                default:
                    S.warn("unknown array buffer", e)
                }
                this.byteOffset++
            }
        }
        writeMap(e) {
            this.dataView.setUint32(this.byteOffset, e.size),
            this.byteOffset += 4;
            for (const t of e.entries())
                this.writeProperty(t, 0),
                this.writeProperty(t, 1)
        }
        isInteger(e) {
            return "number" == typeof e && isFinite(e) && e > -9007199254740992 && e < 9007199254740992 && Math.floor(e) === e
        }
        isByteSigned(e) {
            return -1 * Math.pow(2, 7) <= e && e <= Math.pow(2, 7) - 1
        }
        isByteUnsigned(e) {
            return 0 <= e && e <= Math.pow(2, 8) - 1
        }
        isShortSigned(e) {
            return -1 * Math.pow(2, 15) <= e && e <= Math.pow(2, 15) - 1
        }
        isShortUnsigned(e) {
            return 0 <= e && e <= Math.pow(2, 16) - 1
        }
        isIntegerSigned(e) {
            return -1 * Math.pow(2, 31) <= e && e <= Math.pow(2, 31) - 1
        }
        isIntegerUnsigned(e) {
            return 0 <= e && e <= Math.pow(2, 32) - 1
        }
    }
    w.maxBytes = 1e8,
    w.buffer = new ArrayBuffer(w.maxBytes),
    w.usingBuffer = !1,
    t.default = w
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("save/SaveManager", ["require", "exports", "save/clientStore/ClientStore", "save/datastorage/IndexedDbDataStorage", "save/ISaveManager", "save/Serializer", "utilities/Log", "utilities/Objects"], function(e, t, a, i, n, o, r, s) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const l = new r.default(r.LogSource.SaveManager);
    class u {
        constructor() {
            this.loadedGlobalSlot = !1,
            this.dataStorage = new i.default,
            this.serializer = new o.default("")
        }
        isEnabled() {
            return this.dataStorage && this.dataStorage.isEnabled()
        }
        async initialize() {
            if (this.dataStorage.isReady()) {
                const e = await this.load(n.SLOT_GLOBAL);
                this.loadedGlobalSlot = !0,
                game.onGlobalSlotLoaded(n.SLOT_GLOBAL, e)
            } else
                window.setTimeout(this.initialize.bind(this), 10)
        }
        async getSlots() {
            if (!this.isEnabled())
                return [];
            const e = [];
            for (let t = 0; t < n.SLOT_COUNT_MAX; t++)
                e.push(this.dataStorage.isSlotUsed(t));
            return Promise.all(e)
        }
        async getUsedSlots() {
            const e = await this.getSlots()
              , t = [];
            for (let a = 0; a < e.length; a++)
                e[a] && t.push(a);
            return t
        }
        async isSlotUsed(e) {
            return e === n.SLOT_MULTIPLAYER && void 0 !== this.multiplayerSlotData || this.dataStorage.isSlotUsed(e)
        }
        async getSaveCount() {
            const e = await this.getSlots();
            return e.filter(e=>e).length
        }
        async getFirstFreeSlot() {
            const e = await this.getSlots()
              , t = e.findIndex(e=>!e);
            return -1 !== t ? t : void 0
        }
        getClientStore(e=localPlayer) {
            const t = e.identifier;
            let i = saveData.clientStore.get(t);
            return i || (i = new a.default,
            saveData.clientStore.set(t, i)),
            i
        }
        async getUsedSlotsSorted(e, t=n.SortDirection.More) {
            const a = await this.getUsedSlots()
              , i = {};
            for (const t of a) {
                const a = await this.loadPartial(t)
                  , o = {};
                let r = "";
                switch (e) {
                case n.SaveSort.SaveTime:
                    r = "saveTime";
                    break;
                case n.SaveSort.Name:
                    r = "gameSlotName";
                    break;
                case n.SaveSort.CreatedTime:
                    r = "creationTime";
                    break;
                case n.SaveSort.TurnCount:
                    r = "ticks"
                }
                this.loadPartialData(a, o, r),
                i[t] = e === n.SaveSort.SaveTime || e === n.SaveSort.CreatedTime ? new Date(o[r]) : o[r]
            }
            return a.sort((a,o)=>{
                switch (e) {
                case n.SaveSort.Name:
                    return i[a].localeCompare(i[o]) * t;
                case n.SaveSort.TurnCount:
                case n.SaveSort.CreatedTime:
                case n.SaveSort.SaveTime:
                    return (i[o] - i[a]) * t
                }
            }
            ),
            a
        }
        async getMostRecentSlot() {
            const e = await this.getUsedSlotsSorted(n.SaveSort.SaveTime);
            return e[0]
        }
        async save(e, t=!1) {
            return l.info("Saving", e, t),
            this.loadedGlobalSlot && (t ? this.saveSlot(n.SLOT_GLOBAL, !0) : await this.saveSlot(n.SLOT_GLOBAL)),
            e !== n.SLOT_GLOBAL ? (game.setupSave(e),
            this.saveSlot(e, t)) : {
                slot: e
            }
        }
        async load(e) {
            try {
                l.info("Load", e);
                const t = await this.loadPartial(e)
                  , a = this.getPropertiesToSerialize(e);
                let i;
                for (i = 0; i < a.length; i++) {
                    const e = a[i].property
                      , n = s.default.windowKeysToParentObject(e)
                      , o = e[e.length - 1];
                    null !== n && void 0 !== n && this.loadPartialData(t, n, o, a[i].key, a[i].skipCompression)
                }
                return e !== n.SLOT_GLOBAL && game.onSaveLoaded(e),
                !0
            } catch (e) {
                return r.default.error(r.LogSource.SaveManager)("Error loading save", e),
                !1
            }
        }
        async loadPartial(e) {
            if (e === n.SLOT_MULTIPLAYER) {
                if (void 0 === this.multiplayerSlotData)
                    throw new Error("Invalid multiplayer slot data");
                return this.multiplayerSlotData
            }
            {
                const t = new n.SaveObject
                  , a = this.getPropertiesToSerialize(e);
                let i, o;
                for (i = 0; i < a.length; i++)
                    o = a[i].key,
                    t.data[o] = void 0;
                return await this.dataStorage.loadFromSlot(e,t),
                t
            }
        }
        loadPartialData(e, t, a, i=a, n=!1, r=!1) {
            const s = new o.default(e.version);
            s.load(t, a, n ? e.data[i] : this.decompressString(e, e.data[i], r))
        }
        loadPartialDataInside(e, t, a) {
            const i = {};
            return this.loadPartialData(e, i, t),
            void 0 === a ? i[t] : i[t][a]
        }
        async savePartialData(e, t, a, i) {
            const n = await this.loadPartial(e)
              , r = new o.default(n.version)
              , s = r.saveToString(t, a);
            return void 0 !== s && (n.data[i] = this.compressString(n, s)),
            this.dataStorage.saveToSlot(e, n)
        }
        async savePartialDataInside(e, t, a, i) {
            const n = await this.loadPartial(e)
              , r = {}
              , s = new o.default(n.version);
            s.loadFromString(r, t, this.decompressString(n, n.data[t])),
            r[t][a] = i;
            const l = new o.default(n.version)
              , u = l.saveToString(r, t);
            return void 0 !== u && (n.data[t] = this.compressString(n, u)),
            this.dataStorage.saveToSlot(e, n)
        }
        async exportSave(e) {
            l.info(`Exporting save slot ${e}`);
            const t = await this.loadPartial(e);
            return this.decompressSave(e, t),
            this.compressSave(e, t, !0),
            t
        }
        async importSave(e, t) {
            try {
                return l.info(`Importing save to slot ${e}`),
                "string" == typeof t && (t = JSON.parse(t)),
                e !== n.SLOT_MULTIPLAYER && (t.isCompressed = !0,
                this.decompressSave(e, t, !0)),
                this.saveObjectToSlot(e, t)
            } catch (e) {
                return void l.warn("Failed to import save", e)
            }
        }
        async deleteSlot(e) {
            if (this.isEnabled())
                return l.info(`Deleting slot ${e}`),
                this.dataStorage.deleteSlot(e)
        }
        async deleteAllSlots() {
            if (this.isEnabled())
                return l.info("Deleting all slots"),
                this.dataStorage.deleteAllSlots()
        }
        async deleteAllData() {
            if (this.isEnabled())
                return l.info("Deleting all data"),
                this.dataStorage.deleteAllData()
        }
        compressSave(e, t, a=!1) {
            if (t.isCompressed)
                return void l.info(`Skipping compression for slot ${e}`);
            t.isCompressed = !0;
            const i = this.getPropertiesToSerialize(e);
            for (let e = 0; e < i.length; e++) {
                const n = i[e]
                  , o = n.key;
                n.skipCompression && !a || (t.data[o] = this.compressString(t, t.data[o], a))
            }
        }
        decompressSave(e, t, a=!1) {
            if (!t.isCompressed)
                return void l.info(`Skipping decompression slot for ${e}`);
            const i = this.getPropertiesToSerialize(e);
            for (let e = 0; e < i.length; e++) {
                const n = i[e]
                  , o = n.key;
                n.skipCompression && !a || (t.data[o] = this.decompressString(t, t.data[o], a))
            }
            t.isCompressed = !1
        }
        getSerializer() {
            return this.serializer
        }
        getGameStateAsJson(e=!0) {
            const t = new n.SaveObject;
            t.version = game.version,
            game.setupSave(n.SLOT_MULTIPLAYER);
            const a = this.getPropertiesToSerialize(n.SLOT_MULTIPLAYER);
            for (let i = 0; i < a.length; i++) {
                const n = a[i].property
                  , l = s.default.windowKeysToParentObject(n);
                null !== l && void 0 !== l || r.default.error(r.LogSource.SaveManager)("Trying to export an invalid object", a[i], n);
                const u = n[n.length - 1]
                  , d = new o.default(t.version)
                  , p = d.saveToString(l, u);
                if (void 0 === p)
                    throw new Error(`Unable to serialize game state object ${u}`);
                switch (u) {
                case "game":
                    t.data[u] = {};
                    break;
                case "players":
                    t.data[u] = [];
                    for (let e = 0; e < players.length; e++)
                        t.data[u].push({});
                    break;
                case "absentPlayers":
                    t.data[u] = [];
                    for (let e = 0; e < absentPlayers.length; e++)
                        t.data[u].push({});
                    break;
                default:
                    continue
                }
                r.default.info(r.LogSource.SaveManager)(`Save string length: ${p.length}`);
                const c = new o.default(t.version,!0);
                try {
                    c.loadFromString(t.data, u, p)
                } catch (e) {
                    r.default.info(r.LogSource.SaveManager)(`Failed to load "${u}" from string`)
                }
                if (e)
                    switch (u) {
                    case "game":
                        const e = t.data[u];
                        if (delete e.seeds,
                        !multiplayer.isConnected() && (delete e.worldId,
                        e.npcs))
                            for (const t of e.npcs)
                                t && delete t.identifier;
                        break;
                    case "players":
                    case "absentPlayers":
                        const a = ["autoGatherHarvest", "autoPickup", "directionTurnDelay", "dropLocation", "dropOnGatherHarvest", "hideEquippedHeadgear", "leftHand", "mouseTurnDelay", "protectedCraftingItems", "rightHand", "useAdjacentContainers", "warnOnDangerousActions"];
                        for (const e of t.data[u])
                            delete e.isMoving,
                            delete e.noInputReceived,
                            delete e.movementComplete,
                            delete e.containerSortInfo,
                            delete e.dialogContainerInfo,
                            delete e.dialogInfo,
                            delete e.quickSlotInfo,
                            delete e.absentLastUsedTime,
                            delete e.messages,
                            delete e.notes,
                            e.options = Object.keys(e.options).filter(e=>a.includes(e)).reduce((t,a)=>(t[a] = e.options[a],
                            t), {});
                        break;
                    default:
                        continue
                    }
            }
            return s.default.stringify(t)
        }
        getPropertiesToSerialize(e) {
            let t = e === n.SLOT_GLOBAL ? n.propertiesToSerializeGlobal : n.propertiesToSerialize;
            return e === n.SLOT_MULTIPLAYER && ((t = JSON.parse(JSON.stringify(t)))[1] = {
                key: "players",
                property: ["players"]
            }),
            t
        }
        compressString(e, t, a=!1) {
            return e.isCompressed ? a ? LZString.compressToBase64(t) : LZString.compressToUTF16(t) : t
        }
        decompressString(e, t, a=!1) {
            return e.isCompressed ? a ? LZString.decompressFromBase64(t) : LZString.decompressFromUTF16(t) : t
        }
        createSaveObject(e) {
            const t = new n.SaveObject;
            t.version = game.version;
            const a = this.getPropertiesToSerialize(e);
            for (let i = 0; i < a.length; i++) {
                const l = a[i].property
                  , u = s.default.windowKeysToParentObject(l);
                null !== u && void 0 !== u || r.default.error(r.LogSource.SaveManager)("Trying to save invalid object", a[i], l);
                const d = l[l.length - 1]
                  , p = new o.default(t.version)
                  , c = e === n.SLOT_MULTIPLAYER ? p.saveToUint8Array(u, d) : p.saveToString(u, d);
                void 0 !== c && (t.data[a[i].key] = c)
            }
            return t
        }
        async saveSlot(e, t=!1) {
            const a = this.createSaveObject(e);
            let i = 0;
            return t ? this.saveObjectToSlot(e, a, !0) : i = await this.saveObjectToSlot(e,a),
            {
                slot: e,
                bytes: i,
                saveObject: a
            }
        }
        async saveObjectToSlot(e, t, a=!1) {
            if (e === n.SLOT_MULTIPLAYER)
                return this.multiplayerSlotData = t,
                1;
            a && this.compressSave(e, t);
            let i = 0;
            return a ? (this.dataStorage.saveToSlot(e, t, !0),
            i = 0) : i = await this.dataStorage.saveToSlot(e,t),
            l.info("Saved", e, i),
            i
        }
    }
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("steamworks/Steamworks", ["require", "exports", "Enums", "game/Difficulty", "language/dictionary/UiTranslation", "language/Translation", "mod/IModInfo", "multiplayer/IMultiplayer", "newui/screen/IScreen", "newui/screen/screens/menu/component/IMenu", "steamworks/ISteamworks", "utilities/Async", "utilities/Emitter", "utilities/Log", "utilities/Objects", "utilities/string/Strings", "utilities/UUID", "utilities/Version"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const T = "undefined" != typeof electron ? electron : void 0;
    T && (electron = void 0,
    delete window.electron);
    const S = new m.default(m.LogSource.Steamworks);
    function I(e, t) {
        try {
            const a = t.toLowerCase()
              , i = a.indexOf(`+${e.toLowerCase()}`);
            if (-1 !== i) {
                let a = t.substring(i + e.length + 1).trim();
                const n = a.indexOf("+");
                return -1 !== n && (a = a.substring(0, n)),
                a.trim()
            }
        } catch (a) {
            S.error(`Failed to parse "${e}" argument`, t, a)
        }
    }
    class v extends c.default {
        constructor() {
            super(...arguments),
            this.initializingMods = !1,
            this.loadedMods = {},
            this.workshopUrl = "https://steamcommunity.com/app/379210/workshop/",
            this.workshopFileUrl = "https://steamcommunity.com/sharedfiles/filedetails/?id=",
            this.ignoredDirectories = [".git", ".gitmodules", ".vscode", "mod-reference"],
            this.importingSaveGameMod = !1
        }
        isElectron() {
            return !!T
        }
        reload() {
            steamworks.isElectron() ? steamworks.sendMessage("reload") : location.reload()
        }
        closeWindow() {
            if (T) {
                m.default.info(m.LogSource.Game)("Closing window");
                try {
                    T.api.napi.discord.shutdown()
                } catch (e) {}
                T.api.remote.getCurrentWindow().destroy()
            }
        }
        isOverlayWorking() {
            return this.overlayWorks
        }
        isGreenworksEnabled() {
            return !(!T || !T.api.greenworks)
        }
        isNapiEnabled() {
            return !(!T || !T.api.napi)
        }
        getAbsolutePath(...e) {
            if (!T)
                throw new Error("This method requires electron");
            return T.api.path.join(T.installPath, ...e)
        }
        getAppPath(...e) {
            if (!T)
                throw new Error("This method requires electron");
            return T.api.path.join(T.appPath, ...e)
        }
        isUsingAsar() {
            return !!T && T.appPath.endsWith(".asar")
        }
        isTestMode() {
            return !!T && T.isTestMode
        }
        isDedicatedServer() {
            return void 0 !== this._dedicatedServerInfo
        }
        getDedicatedServerInfo() {
            return this._dedicatedServerInfo
        }
        getMatchmakingServer() {
            return T ? T.api.matchmakingServer : void 0
        }
        initialize() {
            if (!T)
                return S.info("Steamworks.initialize: Not running in Electron"),
                void this.setOverlayWorks(!1);
            if (!T.api.fileSystem)
                return void S.error("Steamworks.initialize: couldn't load fileSystem");
            if (!T.api.path)
                return void S.error("Steamworks.initialize: couldn't load path");
            if (!T.api.os)
                return void S.error("Steamworks.initialize: couldn't load os");
            if (!T.api.ipc)
                return void S.error("Steamworks.initialize: couldn't load ipc");
            if (!T.api.remote)
                return void S.error("Steamworks.initialize: couldn't load remote");
            if (!T.api.shell)
                return void S.error("Steamworks.initialize: couldn't load shell");
            if (!T.api.webFrame)
                return void S.error("Steamworks.initialize: couldn't load webFrame");
            T.api.matchmakingServer || S.warn("Steamworks.initialize: couldn't load matchmaking server component"),
            m.default.setCallback((...e)=>{
                this.sendMessage("log", ...e)
            }
            );
            const e = T.api.remote.process ? T.api.remote.process.argv : void 0;
            if (void 0 !== e) {
                S.info("argv", e);
                try {
                    const t = e.splice(1)
                      , n = t.join(" ").trim();
                    if (n.length > 0) {
                        S.info("Args string", n);
                        const e = -1 !== t.indexOf("+server");
                        if (e) {
                            document.title += " - Dedicated Server",
                            this._dedicatedServerInfo = {
                                name: "Default",
                                port: s.defaultServerPort,
                                backup: !1,
                                backupInterval: 10,
                                maxBackups: 24,
                                load: void 0,
                                console: -1 !== t.indexOf("+console")
                            };
                            let e = I("name", n);
                            const o = I("description", n)
                              , r = I("port", n)
                              , l = I("backup", n)
                              , u = I("backupInterval", n)
                              , p = I("maxBackups", n)
                              , c = I("load", n)
                              , h = I("seed", n)
                              , g = I("difficulty", n)
                              , f = I("turnMode", n)
                              , v = I("realTimeTickSpeed", n)
                              , w = I("maxPlayers", n)
                              , M = t.includes("+pvp")
                              , b = t.includes("+private")
                              , k = t.includes("+new");
                            if (void 0 !== e && e.length > 0 && (document.title += ` - ${e}`,
                            (e = e.replace("win32" === T.api.os.platform() ? y.matchInvalidPathLettersWindows : y.matchInvalidPathLettersUnix, " ").trim()).length > 0 && (this._dedicatedServerInfo.name = e)),
                            void 0 !== r && r.length > 0) {
                                const e = parseInt(r, 10);
                                !isNaN(e) && e > 0 && (this._dedicatedServerInfo.port = e)
                            }
                            if (void 0 !== l && (this._dedicatedServerInfo.backup = !0),
                            void 0 !== u) {
                                const e = parseInt(u, 10);
                                !isNaN(e) && e > 0 && (this._dedicatedServerInfo.backupInterval = e)
                            }
                            if (void 0 !== p) {
                                const e = parseInt(p, 10);
                                !isNaN(e) && e > 0 && (this._dedicatedServerInfo.maxBackups = e)
                            }
                            if (void 0 !== c || k) {
                                this._dedicatedServerInfo.load = c;
                                let e = void 0 !== v ? parseInt(v, 10) : 0;
                                (isNaN(e) || e <= 0) && (e = a.TickSpeed.Default);
                                let t = void 0 !== w ? parseInt(w, 10) : 0;
                                (isNaN(t) || t <= 0) && (t = s.maxPlayers);
                                const n = void 0 !== g ? "hardcore" === g.toLowerCase() ? i.Difficulty.Hardcore : "casual" === g.toLowerCase() ? i.Difficulty.Casual : "dailychallenge" === g.toLowerCase() ? i.Difficulty.Challenge : "challenge" === g.toLowerCase() ? i.Difficulty.Challenge : "custom" === g.toLowerCase() ? i.Difficulty.Custom : i.Difficulty.Hardcore : i.Difficulty.Hardcore
                                  , r = void 0 !== f && "realtime" === f.toLowerCase() ? a.TurnMode.RealTime : a.TurnMode.Simulated
                                  , l = s.getDefaultMultiplayerOptions();
                                l.tickSpeed = e,
                                l.turnMode = r,
                                l.pvp = M,
                                l.lobbyType = b ? d.LobbyType.Private : d.LobbyType.Public,
                                l.maxPlayers = t,
                                l.description = o,
                                this._dedicatedServerInfo.newGameOptions = {
                                    slot: void 0,
                                    name: c,
                                    seed: h || void 0,
                                    difficulty: n,
                                    turnMode: l.turnMode,
                                    realTimeTickSpeed: l.tickSpeed,
                                    multiplayer: l,
                                    multiplayerServerToJoin: void 0,
                                    dailyChallenge: !!g && "dailychallenge" === g.toLowerCase()
                                }
                            }
                            if (S.info("Dedicated server mode", this._dedicatedServerInfo),
                            this._dedicatedServerInfo.console && !this._dedicatedServerInfo.load && !k)
                                return S.error("You must provide the +new argument or an argument for +load when running in console mode. Exiting..."),
                                setTimeout(()=>{
                                    window.close()
                                }
                                , 0),
                                void m.default.setCallback(void 0)
                        } else
                            this._serverToJoin = I("connect_lobby", n),
                            void 0 !== this._serverToJoin && (this._serverToJoin.startsWith(s.steamLobbyPrefix) || (this._serverToJoin = `${s.steamLobbyPrefix}${this._serverToJoin}`),
                            S.info("Going to join", this._serverToJoin))
                    }
                } catch (e) {
                    S.warn("Error parsing arguments", e, e.message)
                }
            }
            try {
                const e = T.api.fileSystem.readFileSync(T.api.path.join(T.appPath, "build.txt"), {
                    encoding: "utf8"
                })
                  , t = e.split("\n")
                  , a = parseInt(t[0], 10);
                isNaN(a) || (this.buildTime = a)
            } catch (e) {
                S.warn("Failed to read build.txt", e),
                this.buildTime = void 0
            }
            const t = this.getDedicatedServerInfo();
            if (void 0 !== t) {
                if (this.logsPath = this.getAbsolutePath("servers", t.name, "logs"),
                this.backupPath = this.getAbsolutePath("servers", t.name, "backups"),
                S.info("Dedicated server logs path", this.logsPath),
                t.backup) {
                    S.info("Dedicated server backup path", this.backupPath);
                    try {
                        this.createFolderIfNotExists(this.backupPath)
                    } catch (e) {
                        t.backup = !1,
                        S.error("Failed to create backup folder. Disabling backups", e)
                    }
                }
            } else
                this.logsPath = this.getAbsolutePath("logs");
            if (this.logFilePath = T.api.path.join(this.logsPath, "wayward.log"),
            T.api.winston && m.default.setWinston(T.api.winston, this.logFilePath),
            T.api.matchmakingServer) {
                const e = new m.default(m.LogSource.MatchmakingServer);
                T.api.matchmakingServer.setLogCallback(e.info.bind(S))
            }
            this.logDebugInfo(),
            this.initializeGreenworks(T),
            this.initializeNapi(T),
            void 0 !== overlayWorks && this.setOverlayWorks(overlayWorks),
            this.modsPath = this.getAbsolutePath("mods"),
            this.workshopPath = this.getAbsolutePath("workshop"),
            this.workshopModsPath = T.api.path.join(this.workshopPath, "mods"),
            this.workshopSyncPath = T.api.path.join(this.workshopPath, "sync"),
            this.workshopSharePath = T.api.path.join(this.workshopPath, "share"),
            this.createFolderIfNotExists(this.logsPath),
            this.createFolderIfNotExists(this.modsPath),
            this.createFolderIfNotExists(this.workshopPath),
            this.createFolderIfNotExists(this.workshopModsPath),
            this.createFolderIfNotExists(this.workshopSyncPath),
            this.createFolderIfNotExists(this.workshopSharePath);
            const o = this.openUrl.bind(this)
              , r = this.isGreenworksEnabled.bind(this);
            $("html").delegate("a:not(#export)", "click", function() {
                const e = $(this).attr("href");
                return o(e),
                r() || newui.interruptWithInfo(n.default.SteamworksInterruptURLOpenedInBrowser, n.default.SteamworksInterruptURLOpenedInBrowserDescription),
                !1
            })
        }
        onUnload() {
            this.isGreenworksEnabled() && this.clearSteamRichPresence()
        }
        setOverlayWorks(e) {
            this.overlayWorks = this.isGreenworksEnabled() && e,
            this.overlayWorks || $("#overlay-refresh-1, #overlay-refresh-2").remove(),
            S.info(`OverlayWorks: ${this.overlayWorks}`)
        }
        async setupMods() {
            S.info("Steamworks.setupMods"),
            this.initializingMods = !0,
            await Promise.all([...this.isGreenworksEnabled()?[this.processDisabledFailures(),this.refreshPublishedMods()]:[],this.initializeModsFromFolder(this.modsPath,r.ModType.Local)]),
            this.initializingMods = !1,
            this.refreshSetupMods()
        }
        getSteamId() {
            return this.steamId
        }
        getFriends() {
            return T && T.api.greenworks ? T.api.greenworks.getFriends() : void 0
        }
        getScreenName() {
            return this.steamId ? this.steamId.screenName : void 0
        }
        getBetaName() {
            return this.betaName
        }
        getBuildTime() {
            return this.buildTime
        }
        getPublishedMods() {
            return this.publishedMods
        }
        getStatInt(e) {
            if (T && T.api && T.api.greenworks)
                return T.api.greenworks.getStatInt(e)
        }
        incrementStat(e) {
            T && T.api && T.api.greenworks && (T.api.greenworks.setStat(e, 1),
            T.api.greenworks.storeStats(()=>{}
            , e=>{}
            ))
        }
        getGlobalStatInt(e) {
            if (T && T.api && T.api.greenworks)
                return T.api.greenworks.getGlobalStatInt(e, 1)
        }
        startPlaytimeTracking() {
            if (!T || !T.api || !T.api.greenworks)
                return;
            const e = modManager.getLoadedMods().map(e=>e.publishedFileId).filter(e=>void 0 !== e).map(e=>parseInt(e, 10)).filter(e=>!isNaN(e));
            if (e.length > 0)
                try {
                    T.api.greenworks.startPlaytimeTracking(e)
                } catch (e) {
                    S.error("Failed to start playtime tracking", e)
                }
        }
        stopPlaytimeTracking() {
            if (T && T.api && T.api.greenworks)
                try {
                    T.api.greenworks.stopPlaytimeTracking()
                } catch (e) {
                    S.error("Failed to stop playtime tracking", e)
                }
        }
        setSteamRichPresence(e, t) {
            return T.api.greenworks.setRichPresence(e, t)
        }
        clearSteamRichPresence() {
            T.api.greenworks.clearRichPresence()
        }
        updateDiscordPresence() {
            if (!T || !T.api || !T.api.napi)
                return;
            const e = {
                details: ""
            };
            if (newui && newui.isScreenVisible(l.ScreenId.MainMenu))
                e.details = "In Main Menu",
                e.largeImageKey = "largeimagekey-menus";
            else if (game && game.playing) {
                const t = multiplayer.getOptions()
                  , a = multiplayer.getConnectedGameCode();
                void 0 !== t && void 0 !== a ? (e.details = "Playing Multiplayer",
                e.largeImageKey = t.pvp ? "largeimagekey-pvp" : "largeimagekey-mp",
                e.state = "In Server",
                e.multiplayerServerId = a,
                e.multiplayerCurrentPlayers = players.length,
                e.multiplayerMaxPlayers = t.maxPlayers) : e.details = "Playing Singleplayer",
                e.smallImageKey = "smallimagekey",
                e.smallImageText = `${localPlayer.getName().getString()} - Reputation: ${game.getReputation()}`
            }
            this.setDiscordPresence(e)
        }
        setDiscordPresence(e) {
            if (T && T.api && T.api.napi) {
                if (void 0 === e.state && (e.state = ""),
                void 0 === e.largeImageKey && (e.largeImageKey = "largeimagekey-sp"),
                void 0 === e.largeImageText)
                    try {
                        e.largeImageText = f.default.getVersionDisplayString(),
                        "development" === this.getBetaName() && (e.largeImageText += " (Development)")
                    } catch (t) {
                        e.largeImageText = ""
                    }
                void 0 === e.smallImageKey && (e.smallImageKey = ""),
                void 0 === e.smallImageText && (e.smallImageText = ""),
                T.api.napi.discord.updatePresence(e)
            }
        }
        getLobbyId() {
            return this._currentLobbyId
        }
        isInLobby() {
            return void 0 !== this._currentLobbyId
        }
        createLobby(e) {
            this.leaveLobby(),
            T.api.greenworks.createLobby(e)
        }
        setLobbyType(e) {
            return void 0 !== this._currentLobbyId && T.api.greenworks.setLobbyType(this._currentLobbyId, e)
        }
        leaveLobby() {
            const e = this._currentLobbyId;
            void 0 !== e && (T.api.greenworks.leaveLobby(e),
            this._currentLobbyId = void 0,
            multiplayer.onLobbyExited(e))
        }
        joinLobby(e) {
            this.leaveLobby(),
            T.api.greenworks.joinLobby(e)
        }
        getLobbyData(e) {
            if (void 0 !== this._currentLobbyId)
                return T.api.greenworks.getLobbyData(this._currentLobbyId, e)
        }
        setLobbyData(e, t) {
            return void 0 !== this._currentLobbyId && T.api.greenworks.setLobbyData(this._currentLobbyId, e, t)
        }
        getLobbyMembers() {
            if (void 0 !== this._currentLobbyId)
                return T.api.greenworks.getLobbyMembers(this._currentLobbyId)
        }
        getPublishedMod(e) {
            if (this.publishedMods)
                for (const t of this.publishedMods)
                    if (t.publishedFileId === e)
                        return t
        }
        fillOutWorkshopMod(e, t) {
            t || (t = this.loadedMods[modManager.getFolderName(e)]),
            modManager.setPublishId(e, t.publishedFileId),
            modManager.setSteamIdOwner(e, t.steamIDOwner),
            modManager.setLastUpdated(e, t.timeUpdated),
            modManager.getType(e) === r.ModType.Workshop && modManager.setInstallDate(e, t.timeAddedToUserList),
            modManager.setCreatedDate(e, t.timeCreated)
        }
        async publishMod(e) {
            const t = T.api.path.join(this.modsPath, modManager.getFolderName(e))
              , a = T.api.path.join(t, "mod.json");
            if (!T.api.fileSystem.pathExistsSync(a))
                throw new Error("missing mod.json");
            const i = g.default.create()
              , n = T.api.path.join(this.workshopSharePath, i);
            let o = modManager.getPublishFileId(e);
            const r = void 0 !== o ? "" : modManager.getName(e)
              , s = void 0 !== o ? "" : modManager.getDescription(e)
              , l = Array.from(modManager.getTags(e));
            S.info("Publishing step 1 - copying folder", t, n),
            await this.copyFolder(t,n),
            S.info("Publishing step 2 - creating archive"),
            await this.createArchive(i,n),
            S.info("Publishing step 3 - saving files to cloud"),
            await this.saveFilesToCloud(i),
            S.info("Publishing step 4 - fetching cloud file share id"),
            await this.getFileShareId(i),
            S.info("Publishing step 5 - publishing file to workshop", i, r, s, l, o),
            o = await this.publishFileToWorkshop(i,r,s,l,o),
            S.info(`Publishing step 6 - publishedFileId: ${o} - removing temp folders`);
            try {
                await this.removeTempFolders(n,i)
            } catch (e) {
                S.info("Unable to remove temp folders")
            }
            const u = JSON.parse(T.api.fileSystem.readFileSync(a));
            return u.publishedFileId !== o && (u.publishedFileId = o,
            modManager.setPublishId(e, o),
            T.api.fileSystem.writeFileSync(a, JSON.stringify(u, void 0, "\t"))),
            await this.refreshPublishedMods(),
            o
        }
        async createArchive(e, t) {
            return new Promise((a,i)=>{
                T.api.greenworks.Utils.createArchive(this.getSharePathForModZip(e), t, a, e=>{
                    S.error("createArchive", e),
                    i(e)
                }
                )
            }
            )
        }
        async getPublishedItems() {
            return new Promise((e,t)=>{
                T.api.greenworks.ugcGetUserItems(T.api.greenworks.UGCMatchingType.Items, T.api.greenworks.UserUGCListSortOrder.CreationOrderAsc, T.api.greenworks.UserUGCList.Published, t=>{
                    e(t)
                }
                , e=>{
                    S.error("getPublishedItems", e),
                    t(e)
                }
                )
            }
            )
        }
        openUrl(e) {
            if (this.overlayWorks)
                T.api.greenworks.activateGameOverlayToWebPage(e);
            else {
                let t = !1;
                this.isElectron() && (t = T.api.shell.openExternal(e)),
                t || window.open(e)
            }
        }
        async openWorkshop(e) {
            if (S.info("openWorkshop", e),
            this.overlayWorks)
                void 0 === e ? T.api.greenworks.ugcShowOverlay() : T.api.greenworks.ugcShowOverlay(e);
            else {
                let t = this.workshopUrl;
                void 0 !== e && (t = this.workshopFileUrl + e),
                this.openUrl(t),
                this.isGreenworksEnabled() && (await newui.interruptWithInfo(n.default .SteamworksInterruptWorkshopOpenedInBrowser,n.default .SteamworksInterruptWorkshopOpenedInBrowserDescription),
                await this.onGameOverlayActive(!1))
            }
        }
        openInviteDialog() {
            const e = this.getLobbyId();
            this.overlayWorks && void 0 !== e && T.api.greenworks.activateGameOverlayInviteDialog(e)
        }
        openSaveFolder() {
            this.isElectron() && this.safeOpenFolder(this.getAbsolutePath("save"))
        }
        openModsFolder() {
            if (this.isElectron()) {
                const e = this.getModPath("", r.ModType.Local);
                e && this.safeOpenFolder(e.path)
            }
        }
        openLogsFolder() {
            this.isElectron() && this.safeOpenFolder(this.logsPath)
        }
        async unsubscribe(e) {
            return new Promise((t,a)=>{
                T.api.greenworks.ugcUnsubscribe(e, async()=>{
                    await this.onGameOverlayActive(!1),
                    t()
                }
                , e=>{
                    S.error("unsubscribe", e),
                    a(e)
                }
                )
            }
            )
        }
        sendMessage(e, ...t) {
            return !!T && (T.api.ipc.send(e, ...t),
            !0)
        }
        onMessage(e, t) {
            return !!T && (T.api.ipc.on(e, t),
            !0)
        }
        toggleDeveloperTools() {
            this.sendMessage("devtools", "1")
        }
        getModPath(e, t, a, i=!1) {
            let n, o, s = "mods/mods";
            switch (t) {
            case r.ModType.Local:
                s = this.modsPath;
                break;
            case r.ModType.Workshop:
                s = this.workshopModsPath
            }
            T ? void 0 === a ? (n = T.api.path.join(s, e),
            o = T.api.path.join(s, e)) : (n = T.api.path.join(s, e, a),
            o = T.api.path.join(s, e, a)) : void 0 === a ? (n = `${s}/${e}`,
            o = `${s}/${e}`) : (n = `${s}/${e}/${a}`,
            o = `${s}/${e}/${a}`),
            n = n.replace(/\\/g, "/");
            const l = (o = o.replace(/\\/g, "/")).split("/");
            if (l.length > 0) {
                o = l.shift();
                for (const e of l)
                    o += `/${y.default.encodeURIComponentPath(e)}`
            }
            if (!i)
                return {
                    path: n,
                    uriEncodedPath: o
                };
            try {
                const e = T.api.fileSystem.lstatSync(n);
                if (e && e.isFile())
                    return {
                        path: n,
                        uriEncodedPath: o
                    }
            } catch (e) {
                S.warn(`lstat failed for ${n}`, e)
            }
        }
        async createSaveGameMod(e, t) {
            const a = this.getModPath(e, r.ModType.Local);
            if (S.info("createSaveGameMod", e, t, a),
            !a)
                return S.error("Invalid mod path", a),
                !1;
            if (T.api.fileSystem.pathExistsSync(a.path))
                return S.error("Mod path already exists"),
                await newui.interruptWithInfo(n.default .SteamworksInterruptModWithNameAlreadyExists,n.default .SteamworksInterruptModWithNameAlreadyExistsDescription),
                steamworks.openModsFolder(),
                !1;
            let i;
            try {
                i = await saveManager.exportSave(t)
            } catch (e) {
                return S.error(`Unable to export save. Err: ${e}`),
                !1
            }
            T.api.fileSystem.mkdirSync(a.path);
            const o = JSON.stringify(i)
              , s = this.getModPath(e, r.ModType.Local, "mod.json")
              , l = this.getModPath(e, r.ModType.Local, "mod.js")
              , u = this.getModPath(e, r.ModType.Local, "mod.png");
            if (!s || !l || !u)
                return !1;
            const d = `\ndefine(["require", "exports", "language/ILanguage", "language/Messages", "mod/Mod"], function (require, exports, ILanguage_1, Messages_1, Mod_1) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\tclass SaveGameMod extends Mod_1.Mod {\n\t\tonInitialize(saveDataGlobal) {\n\t\t\tthis.saveDataGlobal = saveDataGlobal;\n\t\t\tif (!this.saveDataGlobal || this.saveDataGlobal.saved !== true) {\n\t\t\t\tvar json = "${o.replace(/\"/g, '\\"')}";\n\t\t\t\tsteamworks.importFromSaveGameMod(this.getIndex(), json).then((success) => {\n\t\t\t\t\tthis.saveDataGlobal = { saved: success };\n\t\t\t\t});\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tonUninitialize() {\n\t\t\treturn this.saveDataGlobal || { };\n\t\t}\n\t\t\n\t\tonLoad() { }\n\t\t\n\t\tonUnload() { }\n\t\t\n\t\tonSave() { }\n\t}\n\texports.default = SaveGameMod;\n});`
              , p = `\n{\n\t"name": "Save Game - ${e}",\n\t"description": "A save game",\n\t"version": "1.0.0",\n\t"author": "${this.steamId.screenName.replace(/\"/g, '\\"')}",\n\t"unloadable": true,\n\t"compatibleMinorVersions": [\n\t\t${gameVersionMinor}\n\t],\n\t"file": "mod.js"\n}`;
            T.api.fileSystem.writeFileSync(l.path, d),
            T.api.fileSystem.writeFileSync(s.path, p);
            const c = {};
            saveManager.loadPartialData(i, c, "gameThumbnail", "gameThumbnail", !1, !0);
            const m = c.gameThumbnail;
            if (m && m.length > 22) {
                const e = m.substr(22);
                T.api.fileSystem.writeFileSync(u.path, e, {
                    encoding: "base64"
                })
            } else
                S.warn("Unable to write game thumbnail to mod.json");
            return !0
        }
        async importFromSaveGameMod(e, t, a) {
            for (; this.importingSaveGameMod || !newui.isScreenVisible(l.ScreenId.MainMenu); )
                await p.sleep(100);
            let i;
            this.importingSaveGameMod = !0,
            S.info("Importing save game from mod", e);
            const r = await saveManager.getFirstFreeSlot();
            if (void 0 !== r) {
                S.info(`Importing save game from mod into slot ${r}`, e);
                const a = await saveManager.importSave(r,t);
                i = void 0 !== a && a > 0,
                await newui.interruptWithInfo(()=>o.default .ui(i?n.default .SteamworksInterruptModImportedSaveGame:n.default .SteamworksInterruptModImportSaveGameFailure).get(modManager.getName(e)),i?n.default .SteamworksInterruptModImportedSaveGameDescription:n.default .SteamworksInterruptModImportSaveGameFailureDescription),
                S.info("Finished import save game from mod", e, i)
            } else
                i = !1,
                S.warn("Failed to import save game from mod. No free slots", e),
                await newui.interruptWithInfo(()=>o.default .ui(n.default .SteamworksInterruptModImportSaveGameFailure).get(modManager.getName(e)),n.default .SteamworksInterruptModImportSaveGameFailureDescription),
                S.warn("Failed to import save game from mod", e);
            return this.importingSaveGameMod = !1,
            a && a(i),
            i
        }
        deleteSaveGameMod(e) {
            const t = this.getModPath(e, r.ModType.Local);
            t && T.api.fileSystem.remove(t.path, ()=>{}
            )
        }
        debugLog(...e) {
            T && T.api.winston.info(e.join(" "))
        }
        hasServerToJoin() {
            return void 0 !== this._serverToJoin
        }
        onReady() {
            S.info("Ready");
            const e = this._serverToJoin;
            void 0 !== e && (ui.switchToScreen(l.ScreenId.MainMenu, u.MenuId.CharacterSelection, t=>t.gameOptions.multiplayerServerToJoin = e),
            this._serverToJoin = void 0)
        }
        processBackups() {
            const e = this.getDedicatedServerInfo();
            if (void 0 === e || !e.backup)
                return !1;
            const t = this.backupPath;
            if (void 0 === t)
                return !1;
            const i = Date.now();
            return void 0 === this._nextBackupTime ? this._nextBackupTime = i + 60 * e.backupInterval * 1e3 : this._nextBackupTime <= i && (this._nextBackupTime = i + 60 * e.backupInterval * 1e3,
            newui.interrupt(n.default.GameInterruptLoadingAutoSaving).withDescription(n.default.GameInterruptLoadingAutoSavingDescription).withLoading(async()=>{
                const i = await game.saveGame(a.SaveType.InGame);
                if (void 0 !== i && void 0 !== i.saveObject) {
                    saveManager.decompressSave(i.slot, i.saveObject),
                    saveManager.compressSave(i.slot, i.saveObject, !0);
                    const a = (saveData.gameSlotName || "Wayward-").replace(y.matchNotLanguageLetters, "_")
                      , n = new Date
                      , o = [a, "-", n.getFullYear(), `${101 + n.getMonth()}`.slice(-2), `${100 + n.getDate()}`.slice(-2), "-", `${100 + n.getHours()}`.slice(-2), `${100 + n.getMinutes()}`.slice(-2), ".json"].join("")
                      , r = T.api.path.join(t, a);
                    this.createFolderIfNotExists(r);
                    const s = await this.getFilesInFolder(r);
                    if (s.length >= e.maxBackups) {
                        const t = s.sort((e,t)=>e.ctime > t.ctime ? 1 : -1)
                          , a = t[0].path;
                        S.info(`Reached max backup limit (${e.maxBackups}). Deleting oldest backup ${a}`),
                        T.api.fileSystem.unlinkSync(t[0].path)
                    }
                    const l = T.api.path.join(r, o);
                    S.info(`Saving backup to ${l}`),
                    T.api.fileSystem.writeFileSync(l, JSON.stringify(i.saveObject))
                }
                "undefined" != typeof gc && gc()
            }
            )),
            !0
        }
        setupMultiplayerLog() {
            this._multiplayerLogs = ""
        }
        getMultiplayerLogs() {
            return this._multiplayerLogs
        }
        multiplayerLog(...e) {
            multiplayer.isClient() && (this._multiplayerLogs += `[Log] ${h.default.stringify(e)}\n`),
            m.default.info(m.LogSource.Multiplayer)(...e)
        }
        multiplayerLogError(...e) {
            multiplayer.isClient() && (this._multiplayerLogs += `[Error] ${h.default.stringify(e)}\n`),
            m.default.error(m.LogSource.Multiplayer)(...e)
        }
        initializeGreenworks(e) {
            try {
                if (this.isDedicatedServer())
                    e.api.greenworks = void 0;
                else {
                    if ("function" != typeof e.api.greenworks.initAPI)
                        throw new Error("Invalid greenworks property");
                    if (!e.api.greenworks.initAPI())
                        throw new Error("initAPI failed")
                }
            } catch (t) {
                S.warn("error initializing steam api.", t, e.api.greenworks),
                e.api.greenworks = void 0
            }
            e.api.greenworks && (e.installPath = e.api.greenworks.getCurrentGameInstallDir(),
            this.steamId = e.api.greenworks.getSteamId(),
            this.betaName = e.api.greenworks.getCurrentBetaName ? e.api.greenworks.getCurrentBetaName() : "public",
            S.info("initialized", this.steamId, e.installPath),
            S.info("wayward.branch", this.betaName),
            e.api.greenworks.onGameOverlayActive(this.onGameOverlayActive.bind(this)),
            e.api.greenworks.onLobbyCreated(this.onLobbyCreated.bind(this)),
            e.api.greenworks.onLobbyEntered(this.onLobbyEntered.bind(this)),
            e.api.greenworks.onLobbyChatUpdate(this.onLobbyChatUpdate.bind(this)),
            e.api.greenworks.onLobbyJoinRequested(this.onLobbyJoinRequested.bind(this)),
            this.clearSteamRichPresence())
        }
        initializeNapi(e) {
            try {
                this.isDedicatedServer() ? delete e.api.napi : (e.api.napi.discord.initialize(),
                setInterval(()=>{
                    e.api.napi.discord.runCallbacks()
                }
                , 50),
                setInterval(()=>{
                    this.updateDiscordPresence()
                }
                , 5e3),
                this.updateDiscordPresence())
            } catch (t) {
                S.warn("error initializing napi.", t, e.api.napi),
                delete e.api.napi
            }
            e.api.napi && (S.info("napi initialized"),
            e.api.napi.discord.setOnJoinCallback(e=>{
                S.info("discord setOnJoinCallback", e),
                this.showCharacterSelectionForMultiplayer(multiplayer.convertGameCodeToServerInfo(e))
            }
            ))
        }
        async setupAndInitializeWorkshopMods(e, t=!1) {
            const a = await this.syncWorkshopItems();
            S.info("Sync result", a);
            let i = a.changedItems;
            this.initializingMods && (i = a.items);
            for (const e of a.removedItems) {
                const t = this.getModPath(e, r.ModType.Workshop);
                if (t) {
                    const e = modManager.getIndexFromPath(t.path);
                    void 0 !== e && modManager.removeMod(e, !0)
                }
            }
            return new Promise((a,n)=>{
                const o = [];
                let s = i.length;
                const l = ()=>{
                    --s <= 0 && a(o)
                }
                ;
                0 === s && l();
                for (const a of i) {
                    const i = this.getIdFromWorkshopItem(a);
                    if (this.loadedMods[i] = a,
                    t) {
                        const e = this.getModPath(i, r.ModType.Workshop);
                        if (e) {
                            const t = modManager.getIndexFromPath(e.path);
                            if (void 0 !== t) {
                                l();
                                continue
                            }
                        }
                    }
                    const n = modManager.setupMod(i, r.ModType.Workshop, e);
                    void 0 !== n ? l() : (o.push(`${n}`),
                    l())
                }
            }
            )
        }
        async processDisabledFailures() {
            const e = await this.setupAndInitializeWorkshopMods(r.ModState.Disabled);
            if (e && e.length) {
                const t = e.map(async e=>new Promise(t=>{
                    T.api.fileSystem.remove(T.api.path.join(this.workshopModsPath, e), t)
                }
                ));
                await Promise.all(t);
                try {
                    await this.setupAndInitializeWorkshopMods(r.ModState.Disabled,!0)
                } catch (e) {
                    S.error("setupMods retry error", e)
                }
            }
        }
        async initializeModsFromFolder(e, t) {
            return new Promise(a=>{
                T.api.fileSystem.readdir(e, (i,n)=>{
                    if (void 0 !== i && null !== i)
                        return S.warn(i),
                        void a();
                    let o = n.length;
                    const r = ()=>{
                        --o <= 0 && a()
                    }
                    ;
                    0 === o && r();
                    for (let a = 0; a < n.length; a++) {
                        const i = n[a]
                          , o = e=>async(a,i)=>{
                            void 0 !== a && null !== a && S.warn(a),
                            void 0 !== a && null !== a || !i.isDirectory() && !i.isSymbolicLink() ? r() : (await modManager.setupMod(e,t),
                            r())
                        }
                        ;
                        T.api.fileSystem.lstat(T.api.path.join(e, i), o(i))
                    }
                }
                )
            }
            )
        }
        async enumerateInstalledWorkshopMods() {
            return new Promise((e,t)=>{
                const a = [];
                T.api.fileSystem.readdir(this.workshopModsPath, (i,n)=>{
                    if (void 0 !== i && null !== i)
                        return S.warn(i),
                        void t(i);
                    let o = n.length;
                    const r = ()=>{
                        --o <= 0 && e(a)
                    }
                    ;
                    0 === o && r();
                    for (let e = 0; e < n.length; e++) {
                        const t = e=>{
                            T.api.fileSystem.lstat(T.api.path.join(this.workshopModsPath, e), (t,i)=>{
                                void 0 !== t && null !== t && S.warn(t),
                                i.isDirectory() && a.push(e),
                                r()
                            }
                            )
                        }
                        ;
                        t(n[e])
                    }
                }
                )
            }
            )
        }
        refreshSetupMods() {
            const e = modManager.getMods();
            for (let t = 0; t < e.length; t++) {
                if (!modManager.isValid(t))
                    continue;
                const a = e[t];
                if (a.type === r.ModType.Workshop || void 0 === a.publishedFileId)
                    continue;
                const i = this.getPublishedMod(a.publishedFileId);
                void 0 !== i && this.fillOutWorkshopMod(t, i)
            }
        }
        async removeTempFolders(e, t) {
            return new Promise((a,i)=>{
                T.api.fileSystem.remove(e, e=>{
                    T.api.fileSystem.remove(this.getSharePathForModZip(t), t=>{
                        e ? i(e) : a()
                    }
                    )
                }
                )
            }
            )
        }
        async refreshPublishedMods() {
            S.info("refreshPublishedMods");
            const e = await Promise.race([p.sleep(1e4),this.getPublishedItems()]);
            if (!e)
                throw S.info("refreshPublishedMods timed out"),
                new Error("timed out");
            this.publishedMods = [];
            for (let t = 0; t < e.length; t++)
                this.publishedMods.push(e[t]);
            S.info("refreshPublishedMods", this.publishedMods)
        }
        getIdFromWorkshopItem(e) {
            return e.fileName.substring(0, e.fileName.length - 4)
        }
        async syncWorkshopItems() {
            S.info("syncWorkshopItems");
            const e = await this.ugcSynchronizeItems()
              , t = await this.enumerateInstalledWorkshopMods();
            S.info("enumerateInstalledWorkshopMods", t);
            const a = []
              , i = []
              , n = t=>{
                for (const a of e)
                    if (this.getIdFromWorkshopItem(a) === t)
                        return !1;
                return !0
            }
              , o = e=>{
                const a = this.getIdFromWorkshopItem(e);
                for (const i of t)
                    if (i === a)
                        return e.isUpdated;
                return !0
            }
            ;
            for (const e of t)
                n(e) && (i.push(e),
                T.api.fileSystem.remove(T.api.path.join(this.workshopModsPath, e), ()=>{}
                ),
                T.api.fileSystem.remove(this.getSyncPath(e), ()=>{}
                ));
            const r = [];
            for (const t of e)
                o(t) && (a.push(t),
                r.push(this.extractArchive(this.getIdFromWorkshopItem(t), this.workshopModsPath)));
            return await Promise.all(r),
            {
                items: e,
                changedItems: a,
                removedItems: i
            }
        }
        async ugcSynchronizeItems() {
            return new Promise((e,t)=>{
                const a = setTimeout(()=>{
                    S.info("ugcSynchronizeItems timed out"),
                    t("timed out")
                }
                , 1e4);
                T.api.greenworks.ugcSynchronizeItems(this.workshopSyncPath, t=>{
                    S.info("ugcSynchronizeItems", t),
                    clearTimeout(a),
                    e(t)
                }
                , e=>{
                    S.error("ugcSynchronizeItems", e),
                    clearTimeout(a),
                    t(e)
                }
                )
            }
            )
        }
        async copyFolder(e, t) {
            return new Promise((a,i)=>{
                S.info("copyFolder", e, t),
                T.api.fileSystem.emptyDir(t, n=>{
                    n ? i(n) : T.api.fileSystem.copy(e, t, e=>-1 === this.ignoredDirectories.indexOf(T.api.path.basename(e)), e=>{
                        e ? i(e) : a()
                    }
                    )
                }
                )
            }
            )
        }
        async saveFilesToCloud(e) {
            const t = [this.getSharePathForModZip(e)]
              , a = this.getSharePathForModImage(e);
            return a.length > 0 && t.push(a),
            new Promise((e,a)=>{
                T.api.greenworks.saveFilesToCloud(t, e, e=>{
                    S.error("saveFilesToCloud", e),
                    a(e)
                }
                )
            }
            )
        }
        async getFileShareId(e) {
            return new Promise((t,a)=>{
                const i = this.getSharePathForModZip(e);
                T.api.greenworks.fileShare(this.getSharePathForModZip(e), ()=>{
                    const a = this.getSharePathForModImage(e);
                    a.length > 0 ? T.api.greenworks.fileShare(a, t, ()=>{
                        t()
                    }
                    ) : t()
                }
                , e=>{
                    S.error("getFileShareId", i, e),
                    a(e)
                }
                )
            }
            )
        }
        async publishFileToWorkshop(e, t, a, i, n) {
            return new Promise((o,r)=>{
                void 0 === n ? T.api.greenworks.publishWorkshopFile(this.getSharePathForModZip(e), this.getSharePathForModImage(e), t, a, i, e=>{
                    o(e)
                }
                , e=>{
                    S.error("publishWorkshopFile", e),
                    r(e)
                }
                ) : T.api.greenworks.updatePublishedWorkshopFile(n, this.getSharePathForModZip(e), this.getSharePathForModImage(e), t, a, i, ()=>{
                    o(n)
                }
                , e=>{
                    S.error("updatePublishedWorkshopFile", e),
                    r(e)
                }
                )
            }
            )
        }
        async extractArchive(e, t) {
            return new Promise((a,i)=>{
                T.api.greenworks.Utils.extractArchive(this.getSyncPath(e), t, ()=>{
                    a()
                }
                , e=>{
                    S.error("extractArchive", e),
                    i(e)
                }
                )
            }
            )
        }
        safeOpenFolder(e) {
            let t = !1;
            try {
                t = T.api.shell.openItem(e)
            } catch (e) {
                S.warn(e)
            } finally {
                t || newui.interruptWithInfo(n.default.SteamworksInterruptOpenFolderFailure, n.default.SteamworksInterruptOpenFolderFailureDescription)
            }
        }
        async onGameOverlayActive(e) {
            S.info("onGameOverlayActive", e),
            void 0 === this._serverToJoin && (e || game.playing || !ui.shouldRefreshMods() || await newui.interrupt(n.default .SteamworksInterruptLoadingRefreshingMods).withDescription(n.default .SteamworksInterruptLoadingRefreshingModsDescription).withLoading(async()=>{try {await Promise.all([this.refreshPublishedMods(),this.setupAndInitializeWorkshopMods(r.ModState.Enabled)]),this.refreshSetupMods()}catch (e){S.error("onGameOverlayActive error",e)}}),
            this.emit(e ? d.SteamworksEvent.OverlayShown : d.SteamworksEvent.OverlayHidden))
        }
        onLobbyCreated(e, t, a) {
            S.info("onLobbyCreated", e, t, a)
        }
        onLobbyEntered(e, t, a) {
            S.info("onLobbyEntered", e, t, a),
            e && (this._currentLobbyId = t),
            multiplayer.onLobbyEntered(e, t)
        }
        onLobbyChatUpdate(e, t, a) {
            S.info("onLobbyChatUpdate", e, t, a)
        }
        async onLobbyJoinRequested(e) {
            S.info("onLobbyJoinRequested", e),
            void 0 !== e && this.showCharacterSelectionForMultiplayer(`${s.steamLobbyPrefix}${e}`)
        }
        async showCharacterSelectionForMultiplayer(e) {
            if (this._serverToJoin = e,
            !ui || !newui)
                return;
            if (ui.isInGameScreenShown()) {
                const e = await newui.interrupt(game.isChallenge?n.default .GameInterruptReturnToTitleScreenChallenge:n.default .GameInterruptReturnToTitleScreen).withDescription(game.isChallenge?n.default .GameInterruptReturnToTitleScreenChallengeDescription:n.default .GameInterruptReturnToTitleScreenDescription).withConfirmation();
                if (!e)
                    return void (this._serverToJoin = void 0);
                for (await newui.interrupt(game.isChallenge?n.default .GameInterruptLoadingQuitting:n.default .GameInterruptLoadingSaving).withDescription(game.isChallenge?n.default .GameInterruptLoadingQuittingDescription:n.default .GameInterruptLoadingSavingDescription).withLoading(),
                await p.sleep(100),
                await game.resetGameState(); !newui.isScreenVisible(l.ScreenId.MainMenu); )
                    await p.sleep(100)
            } else
                newui.isScreenVisible(l.ScreenId.Interrupt) && (newui.hideScreen(l.ScreenId.Interrupt),
                newui.showScreen(l.ScreenId.MainMenu));
            const t = newui.getVisibleScreen();
            t && t.visibleMenu ? (t.visibleMenu.menuId !== u.MenuId.Main && (t.backToFirstMenu(),
            await p.sleep(800)),
            await p.sleep(300),
            t.showMenu(u.MenuId.CharacterSelection, t=>{
                t.gameOptions.multiplayerServerToJoin = e
            }
            )) : ui.switchToScreen(l.ScreenId.MainMenu, u.MenuId.CharacterSelection, t=>t.gameOptions.multiplayerServerToJoin = e),
            this._serverToJoin = void 0
        }
        createFolderIfNotExists(e) {
            const t = T.api.fileSystem.pathExistsSync(e);
            t || T.api.fileSystem.mkdirSync(e)
        }
        getSyncPath(e) {
            return T.api.path.join(this.workshopSyncPath, `${e}.zip`)
        }
        getSharePathForModZip(e) {
            return T.api.path.join(this.workshopSharePath, `${e}.zip`)
        }
        getSharePathForModImage(e) {
            const t = T.api.path.join(this.workshopSharePath, e, "mod.png");
            return T.api.fileSystem.pathExistsSync(t) ? t : ""
        }
        async getFilesInFolder(e) {
            return new Promise((t,a)=>{
                T.api.fileSystem.readdir(e, (i,n)=>{
                    if (void 0 !== i && null !== i)
                        return void a(i);
                    const o = [];
                    for (let t = 0; t < n.length; t++) {
                        const a = n[t];
                        o.push(new Promise((t,i)=>{
                            const n = a
                              , o = T.api.path.join(e, n);
                            T.api.fileSystem.lstat(o, (e,a)=>{
                                void 0 !== e && null !== e ? i(e) : a.isFile() && t(Object.assign({
                                    name: n,
                                    path: o
                                }, a))
                            }
                            )
                        }
                        ))
                    }
                    t(Promise.all(o))
                }
                )
            }
            )
        }
        logDebugInfo() {
            if (!T || !T.api || !T.api.remote)
                return;
            let e = "Unknown";
            try {
                const t = document.getElementById("game")
                  , a = t.getContext("webgl");
                if (a) {
                    const t = a.getExtension("WEBGL_debug_renderer_info");
                    t && (e = {
                        vendor: a.getParameter(t.UNMASKED_VENDOR_WEBGL),
                        renderer: a.getParameter(t.UNMASKED_RENDERER_WEBGL)
                    })
                }
            } catch (t) {
                e = t.toString()
            }
            let t = "Unknown";
            const a = T.api.remote.app;
            if (a)
                try {
                    t = a.getGPUFeatureStatus()
                } catch (e) {
                    t = e.toString()
                }
            S.info("Information", {
                wayward: {
                    version: gameVersion,
                    build: this.buildTime
                },
                versions: {
                    chromium: T.api.remote.process.versions.chrome,
                    electron: T.api.remote.process.versions.electron,
                    node: T.api.remote.process.versions.node
                },
                hardware: {
                    cpus: T.api.os.cpus(),
                    arch: T.api.remote.process.arch,
                    gpu: {
                        info: e,
                        features: t
                    }
                },
                operatingSystem: {
                    platform: T.api.os.platform(),
                    type: T.api.os.type(),
                    release: T.api.os.release()
                },
                performance: {
                    totalMemoryInMb: T.api.os.totalmem() / 1048576,
                    freeMemoryInMb: T.api.os.freemem() / 1048576
                },
                path: {
                    install: T.installPath,
                    app: T.appPath
                }
            })
        }
    }
    t.default = v
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("tile/TileEventManager", ["require", "exports", "Enums", "game/inspection/Inspections", "language/Dictionaries", "language/dictionary/Message", "language/Translation", "player/IMessageManager", "player/MessageManager", "renderer/particle/IParticle", "renderer/particle/Particles", "tile/ITileEvent", "tile/TileEvents", "utilities/enum/Enums", "utilities/Log", "utilities/math/Vector3", "utilities/Misc", "utilities/Random"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class T {
        create(e, t, a, i) {
            const n = c.default[e];
            if (!n)
                return;
            const o = game.getTile(t, a, i);
            if (this.get(o, e))
                return;
            const r = g.findUnusedId(h.LogSource.TileEventManager, game.tileEvents)
              , s = n.decayMax
              , l = {
                id: r,
                type: e,
                x: t,
                y: a,
                fromX: t,
                fromY: a,
                z: i,
                decay: s ? s + f.default.int(Math.floor(s / 15)) : void 0
            };
            n.spreadMax && (l.spread = f.default.intInRange(-1, n.spreadMax)),
            n.graphicVariation && (l.gfx = f.default.int(3)),
            game.tileEvents[r] = l,
            this._addToTile(l, t, a, i, o);
            const u = c.default[e];
            return u && u.create && u.create(l),
            world.updateTile(t, a, i, o),
            l
        }
        remove(e) {
            const t = e.x
              , a = e.y
              , i = e.z
              , n = c.default[e.type];
            n && n.remove && n.remove(e),
            this._removeFromTile(e, t, a, i, !0),
            delete game.tileEvents[e.id]
        }
        moveTo(e, t, a, i) {
            this._removeFromTile(e, e.x, e.y, e.z, !1),
            e.x = t,
            e.y = a,
            e.z = i,
            e.movementFinishTime = game.getMovementFinishTime(),
            this._addToTile(e, t, a, i, game.getTile(t, a, i))
        }
        get(e, t) {
            return e.events && e.events.find(e=>e.type === t)
        }
        canGather(e) {
            if (e.events)
                for (const t of e.events) {
                    const e = c.default[t.type];
                    if (e && e.items)
                        return t
                }
        }
        updateAll() {
            const e = game.tileEvents
              , t = e.length;
            for (let a = 0; a < t; a++) {
                const t = e[a];
                if (!t)
                    continue;
                t.fromX = t.x,
                t.fromY = t.y;
                const i = c.default[t.type];
                i && i.update && i.update(t),
                void 0 !== t.decay && t.decay <= 0 && this.remove(t)
            }
        }
        fireOverflow(e, t, i) {
            const n = e + f.default.int(3) - 1
              , r = t + f.default.int(3) - 1;
            game.isFlammable(n, r, i) && (tileEventManager.create(p.TileEventType.Fire, n, r, i),
            game.particle.create(n, r, i, d.default[u.ParticleType.Fire]),
            l.default.toAll(e=>e.ifVisible(new y.default(n,r,i)).type(l.MessageType.Bad).source(s.Source.Item).send(o.default.FireOverflowed)),
            audio.queueEffect(a.SfxType.Throw, e, t, i))
        }
        getMovementProgress(e) {
            if (game.isRealTimeMode()) {
                if (void 0 === e.movementFinishTime)
                    return 1;
                const t = 1 - Math.min(1, Math.max(0, (e.movementFinishTime - game.absoluteTime) / (10 * game.interval)));
                return 1 === t && (e.movementFinishTime = void 0),
                t
            }
            return localPlayer.movementProgress
        }
        inspect(e, ...t) {
            return t.map(t=>(new i.InspectionSection).add({
                title: !0,
                name: !0,
                text: r.default.nameOf(n.Dictionary.TileEvent, t.type)
            }).add(new r.default(n.Dictionary.TileEvent,t.type,1).setFailWith("")).addIf(t.type === p.TileEventType.Fire, ()=>e.inspectFire(t.decay, !0)))
        }
        is(e) {
            return "object" == typeof e && "number" == typeof e.id && "number" == typeof e.type && "number" == typeof e.fromX && "number" == typeof e.fromY && void 0 !== game.tileEvents[e.id] && m.default.isValid(p.TileEventType, e.type)
        }
        _addToTile(e, t, a, i, n) {
            n.events || (n.events = []),
            n.events.push(e)
        }
        _removeFromTile(e, t, a, i, n) {
            const o = game.getTile(t, a, i);
            if (o.events) {
                const r = o.events.indexOf(e);
                void 0 !== r && (o.events.splice(r, 1),
                0 === o.events.length && delete o.events,
                n && world.updateTile(t, a, i, o))
            }
        }
    }
    t.default = T
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("ui/functional/FunctionalSortable", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class a {
        constructor(e, t) {
            this._options = t,
            this.items = [],
            $(document).on("mousemove touchmove", e=>{
                this._onMouseMove(e)
            }
            )
        }
        start(e) {
            if (!this.item)
                return;
            this.initialContainer = this.item.parent(),
            this.refreshItems(),
            this.placeholder = this.item.clone(),
            this.helper = this.item.clone(),
            this.helper.addClass("sortable-helper"),
            this.helper.css("position", "absolute"),
            this.helper.css("list-style", "none"),
            this.helper.css("pointer-events", "none"),
            this.helper.css("user-select", "none"),
            this.scrollParent = this.initialContainer,
            void 0 !== this._options.zIndex && this.helper.css("z-index", this._options.zIndex);
            const t = this._getMousePosition(e);
            this._updateHelperPosition(t.x, t.y),
            this.item.after(this.placeholder),
            (this._options.appendTo || $("body")).append(this.helper),
            this.item.css("display", "none"),
            this.placeholder.css("visibility", "hidden"),
            this._options.onStart && this._options.onStart(this._createEvent())
        }
        stop() {
            this.item && (this.placeholder && this.helper && this._options.onStop && this._options.onStop(this._createEvent()),
            this.item = void 0,
            this.placeholder = void 0,
            this.helper = void 0,
            this.targetContainer = void 0,
            this.scrollParent = void 0,
            this.initialEvent = void 0)
        }
        cancel() {
            this.item && (this.placeholder && this.helper && (this.item.css("display", ""),
            this.placeholder.remove(),
            this.helper.remove()),
            this.stop())
        }
        refreshItems() {
            if (!this.initialContainer)
                return;
            let e = this.initialContainer.children("li");
            this._options.connectWith && (e = e.add($(this._options.connectWith).children("li"))),
            this.items = [],
            e.each((e,t)=>{
                const a = $(t)
                  , i = a.offset();
                this.items.push({
                    element: a,
                    left: i.left,
                    top: i.top,
                    width: a.outerWidth(),
                    height: a.outerHeight()
                })
            }
            )
        }
        runAction(e, ...t) {
            switch (e) {
            case "stop":
                this.stop();
                break;
            case "cancel":
                this.cancel();
                break;
            case "refreshItems":
                this.refreshItems();
                break;
            case "mouseDown":
                this._onMouseDown(t[0]);
                break;
            case "mouseUp":
                this._onMouseUp(t[0])
            }
        }
        _refreshItemPositions() {
            for (const e of this.items) {
                const t = e.element.offset();
                e.left = t.left,
                e.top = t.top
            }
        }
        _updateHelperPosition(e, t) {
            this.helper && (this._options.cursorAt && (e -= this._options.cursorAt.left,
            t -= this._options.cursorAt.top),
            this.helper.css("left", e),
            this.helper.css("top", t))
        }
        _onMouseDown(e) {
            if (!e.target || "mousedown" === e.type && 1 !== e.which)
                return;
            let t = $(e.target);
            (t.is("li") || (t = t.parent()).is("li")) && (this.item = t,
            void 0 === this._options.distance ? (this.start(e),
            e.stopPropagation(),
            e.preventDefault()) : this.initialEvent = e)
        }
        _onMouseMove(e) {
            if (!this.item)
                return;
            this._scroll(e);
            const t = this._getMousePosition(e);
            if (!this.placeholder && !this.helper && this.initialEvent && void 0 !== this._options.distance) {
                const e = this._getMousePosition(this.initialEvent);
                Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) >= this._options.distance && (this.start(this.initialEvent),
                this.initialEvent = void 0)
            }
            if (!this.placeholder || !this.helper)
                return;
            this._updateHelperPosition(t.x, t.y);
            const a = "touchmove" === e.type ? document.elementFromPoint(t.x, t.y) : e.target;
            if (!a)
                return;
            const i = $(a);
            let n, o;
            if (i.is(this._options.connectWith))
                n = i;
            else {
                const e = i.parent();
                e.is(this._options.connectWith) && (n = e)
            }
            if (n) {
                if (this.targetContainer && this.targetContainer.get(0) === n.get(0) || (this.targetContainer && this._options.onOut && this._options.onOut(this._createEvent()),
                this.targetContainer = n,
                this._options.onOver && this._options.onOver(this._createEvent())),
                0 !== this.items.length) {
                    for (const e of this.items)
                        if (e.left <= t.x && e.left + e.width >= t.x && e.top <= t.y && e.top + e.height >= t.y) {
                            this._updatePosition(e, e.left + e.width / 2 > t.x);
                            break
                        }
                    for (let e = this.items.length - 1; e >= 0; e--) {
                        const t = this.items[e];
                        if (t.element.parent().get(0) === this.targetContainer.get(0) && 0 !== t.top && 0 !== t.left && t.element.get(0) !== this.helper.get(0) && t.element.get(0) !== this.placeholder.get(0)) {
                            o = t;
                            break
                        }
                    }
                    void 0 !== o && (t.y >= o.top && t.x > o.left || t.y >= o.top + o.height) && this._updatePosition(o, !0)
                }
            } else
                this.targetContainer && this._options.onOut && (this._options.onOut(this._createEvent()),
                this.targetContainer = void 0)
        }
        _scroll(e) {
            if (this.scrollParent) {
                const t = this.scrollParent.offset();
                if (!t)
                    return;
                const a = 10
                  , i = 20;
                t.top + this.scrollParent.outerHeight() - e.pageY < i ? this.scrollParent.scrollTop(this.scrollParent.scrollTop() + a) : e.pageY - t.top < i && this.scrollParent.scrollTop(this.scrollParent.scrollTop() - a),
                t.left + this.scrollParent.outerWidth() - e.pageX < i ? this.scrollParent.scrollLeft(this.scrollParent.scrollLeft() + a) : e.pageX - t.left < i && this.scrollParent.scrollLeft(this.scrollParent.scrollLeft() - a)
            }
        }
        _onMouseUp(e) {
            !this.item || "mouseup" === e.type && 1 !== e.which || (this.initialEvent ? this.stop() : (this._options.onReceive && this.placeholder && this.targetContainer && this.initialContainer.get(0) !== this.targetContainer.get(0) && this._options.onReceive(this._createEvent()),
            this._options.onlyReceive ? this.cancel() : this.stop(),
            e.stopPropagation(),
            e.preventDefault()))
        }
        _getMousePosition(e) {
            const t = e.type.startsWith("touch");
            return {
                x: t ? e.originalEvent.touches[0].pageX : e.pageX,
                y: t ? e.originalEvent.touches[0].pageY : e.pageY
            }
        }
        _createEvent() {
            return {
                item: this.item,
                placeholder: this.placeholder,
                helper: this.helper,
                initialContainer: this.initialContainer,
                targetContainer: this.targetContainer
            }
        }
        _updatePosition(e, t) {
            t ? this.placeholder.insertAfter(e.element) : this.placeholder.insertBefore(e.element),
            this._refreshItemPositions(),
            this._options.onChange && this._options.onChange(this._createEvent())
        }
    }
    t.default = a,
    (e=>{
        e.fn.functionalSortable = function(t, ...i) {
            if ("string" == typeof t) {
                let a;
                return this.each((n,o)=>{
                    const r = e(o).data("sortable-object");
                    if (r) {
                        const e = r.runAction(t, ...i);
                        void 0 !== e && (a = e)
                    }
                }
                ),
                a
            }
            return this.data("sortable-object", new a(this,t)),
            this
        }
    }
    )(jQuery)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 *
 *
 */
define("ui/functional/FunctionalTooltip", ["require", "exports"], function(e, t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const a = {}
      , i = {};
    let n = 0;
    var o;
    (o = jQuery).fn.functionalTooltip = function(e, ...t) {
        let r = this.get(0), s;
        this.is(document) && ((r = document.body).id || (r.id = `"functional-tooltip-${n}`));
        let l = i[r.id];
        if ("string" == typeof e) {
            if (void 0 === l)
                return;
            if (!(s = a[l]))
                return;
            let n;
            switch (e) {
            case "instance":
                return s;
            case "enable":
                s.disabled = !1;
                break;
            case "show":
                return !s.visible && (n = t.shift(),
                s.show.apply(n, t),
                !0);
            case "update-position":
                return n = t.shift(),
                s.visible === n && (s.updateTooltipPosition.apply(n, t),
                !0);
            case "disable":
                s.visible && s.onClose && s.onClose(o(this)),
                s.disabled = !0,
                s.visible = void 0,
                s.element.style.display = "none";
                break;
            case "hide":
                s.visible = void 0,
                s.element.style.display = "none";
                break;
            case "refresh":
                s.visible && s.show.call(s.visible, void 0);
                break;
            case "destroy":
                s.element.remove(),
                delete i[l],
                delete a[l],
                this.off("mouseenter"),
                this.off("mouseleave"),
                this.off("mousemove"),
                this.off("touchstart"),
                this.off("touchmove"),
                this.off("touchend"),
                this.off("remove")
            }
        } else {
            if (void 0 !== l)
                return;
            s = e,
            l = n,
            n++,
            i[r.id] = l,
            a[l] = s,
            s.visible = void 0,
            s.element = document.createElement("div"),
            s.element.id = `tooltip-${l}`,
            s.element.className = "ui-tooltip ui-widget ui-corner-all ui-widget-content",
            s.element.style.display = "none",
            r.appendChild(s.element),
            s.updateTooltipPosition = function(e, t, a, i) {
                const n = s.position;
                n && (n.startAtRight && (e += this.clientWidth),
                n.startAtBottom ? t += this.clientHeight : n.centerY && (t -= s.element.clientHeight / 2 - this.clientHeight / 2),
                n.leftOffset && (e += n.leftOffset),
                n.topOffset && (t += n.topOffset),
                e + s.width > document.body.clientWidth && (n.clampRight ? e = document.body.clientWidth - s.width : (e -= s.width,
                n.leftOffset && (e -= 2 * n.leftOffset))),
                t + s.height > document.body.clientHeight && (t -= s.height,
                n.topOffset && (t -= 2 * n.topOffset)),
                e < 0 && (e = 0),
                t < 0 && (t = 0),
                s.element.style.left = `${e}px`,
                s.element.style.top = `${t}px`,
                void 0 !== a && void 0 !== i && e < a && e + s.width > a && t < i && t + s.height > i ? (s.visible = void 0,
                s.element.style.display = "none") : s.visible || (s.visible = this,
                s.element.style.display = "block"))
            }
            ,
            s.show = function(e, t=!1) {
                if (e && "touchstart" === s.lastEvent)
                    return;
                const a = o(this)
                  , i = s.content.call(a);
                if (0 === i.length)
                    return;
                const n = `<div class="ui-tooltip-content">${i}</div>`;
                if (e)
                    s.visible = this,
                    s.element.style.left = "0px",
                    s.element.style.top = "0px",
                    s.element.style.visibility = "hidden",
                    s.element.style.display = "block";
                else if (s.element.innerHTML === n)
                    return;
                if (s.element.innerHTML = n,
                s.width = s.element.clientWidth,
                s.height = s.element.clientHeight,
                e) {
                    let i = e.pageX
                      , n = e.pageY;
                    if ("touchstart" !== e.type && "touchend" !== e.type && "touchmove" !== e.type || (i = e.originalEvent.touches[0].pageX,
                    n = e.originalEvent.touches[0].pageY),
                    s.trackMouse || t)
                        s.updateTooltipPosition.call(this, i, n);
                    else {
                        const e = this.getBoundingClientRect();
                        s.updateTooltipPosition.call(this, e.left, e.top, i, n)
                    }
                    s.element.style.visibility = "visible",
                    s.onOpen && s.onOpen.call(this, a)
                }
            }
            ;
            const t = function() {
                s.visible = void 0,
                s.element.style.display = "none",
                s.onClose && s.onClose.call(this, o(this))
            };
            this.on("mouseenter touchstart", s.selector, function(e) {
                s.disabled || (s.visible || s.show.call(this, e),
                s.lastEvent = e.type,
                "touchstart" !== e.type && e.stopPropagation())
            }),
            this.on("mouseleave touchend", s.selector, function(e) {
                s.disabled || (s.visible && t.call(this),
                s.lastEvent = e.type,
                "touchend" !== e.type && e.stopPropagation())
            }),
            this.on("mousemove touchmove", s.selector, function(e) {
                if (!s.disabled) {
                    if (s.trackMouse)
                        if (s.visible === this) {
                            let t = e.pageX
                              , a = e.pageY;
                            "touchmove" === e.type && (t = e.originalEvent.touches[0].pageX,
                            a = e.originalEvent.touches[0].pageY),
                            s.updateTooltipPosition.call(this, t, a)
                        } else
                            s.show.call(this, e);
                    else
                        s.visible || s.show.call(this, e);
                    e.preventDefault()
                }
            }),
            this.on("remove", s.selector, function() {
                s.disabled || s.visible === this && t.call(this)
            })
        }
    }
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("ui/Ui", ["require", "exports", "Enums", "language/dictionary/Message", "language/dictionary/UiTranslation", "newui/BindingManager", "newui/screen/IScreen", "newui/screen/screens/menu/component/IMenu", "player/IMessageManager", "player/MessageManager", "resources/IResourceLoader", "resources/ResourcePath", "ui/screens/InGameScreen", "utilities/Async", "utilities/Emitter", "utilities/Log", "ui/functional/FunctionalSortable", "ui/functional/FunctionalTooltip"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const g = {};
    function f(e, t, a) {
        void 0 !== g[e] && clearTimeout(g[e]),
        g[e] = setTimeout(t, a)
    }
    class T extends h.default {
        constructor() {
            super(),
            this.elementDocument = $(document),
            this.elementWindow = $(window),
            this.elementBody = $("body"),
            this.unloading = 0,
            this.updateScrollableContainersList(),
            this.elementWindow.on("blur", ()=>{
                localPlayer && localPlayer.resetMovementStates()
            }
            ).on("resize", e=>{
                f("WindowResize", ()=>{
                    this.elementScrollableContainers.each(this.updateScrollableContainer),
                    this.onWindowResize()
                }
                , 200)
            }
            ).on("error", e=>{
                e && e.originalEvent && e.originalEvent.error ? y.default.error(y.LogSource.Game)(e.originalEvent.message, e.originalEvent.error.stack) : y.default.error(y.LogSource.Game)(e),
                localPlayer && localPlayer.messages && localPlayer.messages.source(l.Source.Meta).type(u.MessageType.Bad).send(i.default.ErrorHasOccured)
            }
            ),
            steamworks.isElectron() ? window.onbeforeunload = this.onBeforeUnloadElectron.bind(this) : window.onbeforeunload = this.onBeforeUnloadBrowser.bind(this),
            this.elementDocument.on("mouseup", "button, .clickable", e=>{
                e && e.target && $(e.target).hasClass("silent") || this.playClickSound()
            }
            ),
            this.elementDocument.on("dragstart", "img, p, #container-messages", e=>{
                e.preventDefault()
            }
            ),
            this.elementDocument.on("mouseenter", ".highlight", function() {
                $(this).removeClass("current-highlight continue-highlight")
            }),
            "development" === steamworks.getBetaName() && this.setVersionExtra("(Development)")
        }
        initialize() {
            this.screenInGame = new c.default
        }
        initializeGameState() {
            this.screenInGame.initializeGameState()
        }
        getBody() {
            return this.elementBody
        }
        getWidth() {
            return this.elementBody.width()
        }
        getHeight() {
            return this.elementBody.height()
        }
        removeStyle(e) {
            $(`style[data-style-id="${e}"]`).remove()
        }
        appendStyle(e, t) {
            this.removeStyle(e);
            const a = document.createElement("style");
            a.setAttribute("data-style-id", e),
            a.textContent = t,
            document.getElementsByTagName("head")[0].appendChild(a)
        }
        setCheckboxValue(e, t, a) {
            const i = e.find(`div[data-checkbox-id='${t}']`).find(".filledin");
            a ? i.quickShow() : i.quickHide()
        }
        playClickSound() {
            audio.queueEffect(a.SfxType.Click, 0, 0, 0, void 0, void 0, !0)
        }
        hideInGameScreen() {
            this.screenInGame.hide(),
            this.screenInGame.unbindElements()
        }
        async switchToScreen(e, t, a) {
            if (e === r.ScreenId.Game ? this.screenInGame.show() : this.hideInGameScreen(),
            e === r.ScreenId.MainMenu) {
                await newui.hideLoadingInterrupt();
                const e = newui.showScreen(r.ScreenId.MainMenu);
                t && (o.bindingManager.disableBindsUntil(1500),
                await m.sleep(1e3),
                e.showMenu(t, a))
            } else
                newui.showScreen(e)
        }
        toggleOptions() {
            this.screenInGame.tooltipHide(),
            this.isOptionsOverlayEnabled() && this.showOptionsScreen()
        }
        async showOptionsScreen() {
            await newui.interrupt().withMenu(s.MenuId.Options)
        }
        onWindowResize() {
            game && (game.setGlContextSize(this.elementWindow.width(), this.elementWindow.height()),
            game.resizeRenderer()),
            this.isInGameScreenShown() && this.screenInGame.clampDialogs()
        }
        isInGameScreenShown() {
            return this.screenInGame.isVisible()
        }
        setupItemBackgrounds() {
            let e = "", t;
            for (t in a.ItemType)
                isNaN(t) || (t = parseInt(t, 10)) !== a.ItemType.None && (e += `.item-${t}::before { background-image: url("${p.default.getPath(d.PathType.Item, t)}.png"); }\n`);
            this.appendStyle("stylebackgrounds", e)
        }
        refreshStats() {
            this.screenInGame.refreshStats()
        }
        loadQuickSlots() {
            this.screenInGame.loadQuickSlots()
        }
        isContextMenuOpen() {
            return this.screenInGame.contextMenuOpen
        }
        isOptionsOverlayShown() {
            const e = newui.getVisibleScreen();
            return !!e && e.visibleMenu && e.visibleMenu.menuId === s.MenuId.Options
        }
        isOptionsOverlayEnabled() {
            return !0
        }
        tooltipRefresh() {
            this.screenInGame.tooltipRefresh()
        }
        updateCraftingDialog(e, t) {
            this.screenInGame.updateCraftingDialog(e, t)
        }
        updateDismantleTab(e) {
            this.screenInGame.updateDismantleTab(e)
        }
        getInventoryItemOrder() {
            return this.screenInGame.getInventoryItemsInOrder()
        }
        updateItem(e) {
            this.screenInGame.updateItem(e)
        }
        hideContextMenu() {
            this.screenInGame.hideContextMenu()
        }
        hideActionsMenu() {
            this.screenInGame.hideActionsMenu()
        }
        setFontStyle() {
            this.elementBody.toggleClass("font-style", !saveDataGlobal.options.fontStyle || languageManager.shouldUseAlternateFontStyle())
        }
        setEquipSlot(e, t, a=!1) {
            this.screenInGame.setEquipSlot(e, t, a)
        }
        setQuickSlot(e, t, a=!1) {
            this.screenInGame.setQuickSlot(e, t, a)
        }
        refreshQuickSlots() {
            this.screenInGame.refreshQuickSlots()
        }
        getUsedQuickSlots() {
            return this.screenInGame.getUsedQuickSlots()
        }
        removeItemFromQuickSlot(e) {
            this.screenInGame.removeItemFromQuickSlot(e)
        }
        removeItemFromEquipSlot(e) {
            this.screenInGame.removeItemFromEquipSlot(e)
        }
        shouldRefreshMods() {
            return newui.isScreenVisible(r.ScreenId.MainMenu)
        }
        setObjectUrl(e) {
            this.objectUrl && (URL.revokeObjectURL(this.objectUrl),
            this.objectUrl = void 0),
            this.objectUrl = e
        }
        onGameEnd() {
            this.screenInGame.onGameEnd()
        }
        onUpdateDirection() {
            this.screenInGame.onUpdateDirection()
        }
        highlightUnique(e=10, ...t) {
            $(".current-highlight").removeClass("current-highlight");
            let a = !1;
            for (const i of t) {
                const t = $(i).addClass("highlight current-highlight");
                t.css("animation-iteration-count", e),
                t.on("animationend", function() {
                    $(this).off("animationend"),
                    $(this).removeClass("highlight current-highlight")
                }),
                t.on("animationiteration", function() {
                    $(this).hasClass("current-highlight") || ($(this).off("animationiteration"),
                    $(this).removeClass("highlight"))
                }),
                t.length > 0 && !a && (t.get(0).scrollIntoView(),
                a = !0)
            }
        }
        highlight(e=10, ...t) {
            for (const a of t) {
                const t = $(a).addClass("highlight continue-highlight");
                t.css("animation-iteration-count", e),
                t.on("animationend", function() {
                    $(this).off("animationend"),
                    $(this).removeClass("highlight continue-highlight")
                }),
                t.on("animationiteration", function() {
                    $(this).hasClass("continue-highlight") || ($(this).off("animationiteration"),
                    $(this).removeClass("highlight"))
                })
            }
        }
        toggleUIDisplay(e) {
            game.playing && (e ? (this.screenInGame.elementStats.quickHide(),
            this.screenInGame.elementVersion.quickHide(),
            this.screenInGame.elementQuickSlotsContainer.quickHide(),
            $(".ui-dialog").quickHide()) : (this.screenInGame.elementStats.quickShow(),
            this.screenInGame.elementVersion.quickShow(),
            this.screenInGame.elementQuickSlotsContainer.quickShow(),
            $(".ui-dialog").quickShow()))
        }
        getSerializationProperties(e) {
            return []
        }
        onMove() {
            this.screenInGame.onMove()
        }
        changeEquipmentOption(e) {
            this.screenInGame.changeEquipmentOption(e)
        }
        closeAllContainers() {
            this.screenInGame.closeAllContainers()
        }
        openContainer(e, t) {
            this.screenInGame.openContainer(e, t)
        }
        closeContainer(e) {
            this.screenInGame.closeContainer(e)
        }
        refreshContainerName(e) {
            this.screenInGame.refreshContainerName(e)
        }
        isContainerOpen(e) {
            return this.screenInGame.isContainerOpen(e)
        }
        addItemToContainer(e, t, a=!1, i=!1) {
            this.screenInGame.addItemToContainer(e, t, a, i)
        }
        afterAddingMultipleItemsToContainer(e) {
            this.screenInGame.afterAddingMultipleItemsToContainer(e)
        }
        removeItemFromContainer(e, t) {
            this.screenInGame.removeItemFromContainer(e, t)
        }
        updateInventorySort() {
            this.screenInGame.updateInventorySort()
        }
        getDialogInfo(e) {
            return localPlayer.dialogInfo[e]
        }
        setVersionExtra(e) {
            $("#version .extra").text(e)
        }
        openDialogs() {
            this.screenInGame.openDialogs()
        }
        updateScrollableContainersList() {
            this.elementScrollableContainers = this.elementBody.find(".scrollable-container:not(.connected)").addClass("scrolltop connected").scroll(this.updateScrollableContainer)
        }
        updateScrollableContainer() {
            const e = $(this)
              , t = e.scrollTop()
              , a = Math.ceil(t + e.innerHeight());
            e.toggleClass("scrolltop", 0 === t),
            e.toggleClass("scrollbottom", a >= this.scrollHeight)
        }
        cancelSorting() {
            this.screenInGame.cancelSorting()
        }
        async onBeforeUnloadElectron(e) {
            switch (this.unloading) {
            case 0:
                this.unloading = 1;
                try {
                    steamworks.onUnload(),
                    modManager.uninitializeAll(),
                    game ? (e.returnValue = !1,
                    y.default.info(y.LogSource.Game)("Preventing the window from closing while unloading..."),
                    await newui.interrupt(n.default .GameInterruptLoadingQuitting).withDescription(n.default .GameInterruptLoadingQuittingDescription).withLoading(),
                    await m.sleep(150),
                    await game.saveGame(a.SaveType.Quit),
                    game.playing = !1,
                    this.unloading = 2,
                    steamworks.closeWindow()) : this.unloading = 2
                } catch (e) {
                    y.default.error(y.LogSource.Game)("An error occured while quitting the game", e),
                    game && steamworks.closeWindow()
                }
                break;
            case 1:
                e.returnValue = !1,
                y.default.info(y.LogSource.Game)("Preventing the window from closing while unloading...")
            }
        }
        onBeforeUnloadBrowser(e) {
            switch (this.unloading) {
            case 0:
                this.unloading = 1,
                steamworks.onUnload(),
                modManager.uninitializeAll(),
                game && game.saveGame(a.SaveType.Quit)
            }
        }
    }
    function S(e) {
        return e instanceof jQuery
    }
    t.default = T,
    $.fn.reflow = function() {
        return this.each(function() {
            this.offsetWidth
        }),
        this
    }
    ,
    $.fn.repaint = function() {
        return this.each(function() {
            const e = this.style.display;
            this.style.display = "none",
            this.offsetWidth,
            this.style.display = e
        }),
        this
    }
    ,
    $.fn.filterByData = function(e, t) {
        return this.filter(function() {
            return $(this).data(e) === t
        })
    }
    ,
    $.fn.isVisible = function() {
        return this.is(":visible")
    }
    ,
    $.fn.quickShow = function() {
        this.hasClass("fade") ? (this.removeClass("hidden").removeClass("fade-out"),
        setTimeout(()=>{
            this.addClass("fade-in")
        }
        , 1)) : this.hasClass("loading") ? (this.addClass("show").removeClass("hide"),
        $(this).children("span").hide().height(),
        $(this).children("span").show()) : this.hasClass("ui-dialog") ? this.removeClass("hide") : this.addClass("show").removeClass("hide")
    }
    ,
    $.fn.quickHide = function() {
        if (this.hasClass("fade")) {
            const e = setTimeout(()=>{
                this.hasClass("fade-in") || (this.removeData("quickHideTimeoutId"),
                this.addClass("hidden").removeClass("disabled"))
            }
            , 300);
            this.data("quickHideTimeoutId", e),
            this.addClass("fade-out").removeClass("fade-in").addClass("disabled")
        } else
            this.addClass("hide").removeClass("show")
    }
    ,
    $.fn.quickHideNow = function() {
        if (this.hasClass("fade-out")) {
            const e = this.data("quickHideTimeoutId");
            void 0 !== e && (clearTimeout(e),
            this.removeData("quickHideTimeoutId"),
            this.addClass("hidden").removeClass("disabled"))
        }
    }
    ,
    $.fn.preload = function() {
        this.each(function() {
            $("<img/>").attr("src", this)
        })
    }
    ,
    $.fn.getItemType = function() {
        return parseInt(this.attr("data-item-type"), 10)
    }
    ,
    $.fn.getQuickSlot = function() {
        return parseInt(this.attr("data-quick-slot"), 10)
    }
    ,
    $.fn.getEquipSlot = function() {
        return this.attr("data-equip-slot")
    }
    ,
    $.fn.import = function(e) {
        const t = S(e) ? e[0] : e;
        return this.each(function() {
            this.appendChild(document.importNode(t.content, !0))
        }),
        this
    }
    ,
    $.ui.menu.prototype._activate = function(e) {
        const t = $.ui.menu.prototype._activate;
        return function() {
            this.active && t.apply(this, arguments)
        }
    }(void 0),
    $.ui.menu.prototype._keydown = function(e) {
        const t = $.ui.menu.prototype._keydown;
        return function() {
            this.active && t.apply(this, arguments)
        }
    }(void 0)
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/WebAssemblyHelpers", ["require", "exports", "utilities/Log"], function(e, t, a) {
    var i;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        let t;
        !function(e) {
            e[e.FlowField = 0] = "FlowField",
            e[e.FieldOfView = 1] = "FieldOfView"
        }(t = e.Module || (e.Module = {}));
        const i = {};
        function n() {
            return "object" == typeof WebAssembly
        }
        function o() {
            n()
        }
        function r(e, n, o) {
            const r = i[e];
            if (!r)
                return;
            const s = new WebAssembly.Memory({
                initial: 256,
                maximum: 512
            })
              , l = r.instances[n] = {
                imports: {
                    env: Object.assign({
                        memoryBase: 0,
                        tableBase: 0,
                        memory: s,
                        table: new WebAssembly.Table({
                            initial: 256,
                            maximum: 512,
                            element: "anyfunc"
                        }),
                        _consoleLog: e=>{
                            a.default.info(a.LogSource.WebAssembly)(e)
                        }
                    }, o)
                },
                exports: void 0,
                instance: void 0,
                memoryBuffer: s.buffer
            };
            return l.instance = new WebAssembly.Instance(r.module,l.imports),
            l.exports = l.instance.exports,
            a.default.info(a.LogSource.Utilities)(`Initialized web assembly module ${t[e]}`, l.exports),
            l
        }
        e.isAvailable = n,
        e.loadAndCompileModules = o,
        e.initializeInstance = r
    }(i || (i = {})),
    t.default = i
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("game/Game", ["require", "exports", "action/IAction", "audio/Audio", "command/CommandManager", "creature/corpse/CorpseManager", "creature/corpse/Corpses", "creature/Creature", "creature/CreatureManager", "creature/Creatures", "creature/ICreature", "DedicatedServer", "doodad/DoodadManager", "doodad/Doodads", "doodad/doodads/Doodad", "entity/IEntity", "entity/IStats", "entity/StatFactory", "Enums", "flowfield/FlowFieldManager", "game/Difficulty", "game/IGame", "game/TimeManager", "item/Item", "item/ItemManager", "item/Items", "language/Dictionaries", "language/dictionary/InterruptChoice", "language/dictionary/Message", "language/dictionary/Note", "language/dictionary/UiTranslation", "language/LanguageManager", "language/Messages", "language/Translation", "mapgen/MapGen", "mod/IHookManager", "mod/IModInfo", "mod/ModManager", "multiplayer/IMultiplayer", "multiplayer/Multiplayer", "multiplayer/packets/client/PausePacket", "multiplayer/packets/client/SetPlayerZPacket", "multiplayer/packets/client/TickPacket", "multiplayer/packets/shared/UpdateOptionPacket", "newui/NewUi", "newui/screen/IScreen", "newui/screen/screens/menu/component/IMenu", "npc/NPCManager", "OldEnums", "player/Customizations", "player/IMessageManager", "player/IMilestone", "player/IPlayer", "player/MessageManager", "player/Player", "player/quest/quest/Challenge", "renderer/fieldofview/FieldOfView", "renderer/Notifier", "renderer/particle/IParticle", "renderer/particle/Particle", "renderer/particle/Particles", "renderer/RendererConstants", "renderer/Shaders", "renderer/SpriteAtlas", "renderer/SpriteBatch", "renderer/TileAtlas", "renderer/TileLayer", "renderer/World", "renderer/WorldRenderer", "resources/ResourceLoader", "save/clientStore/IClientStore", "save/data/SaveData", "save/data/SaveDataGlobal", "save/ISaveManager", "save/ISerializer", "save/SaveManager", "steamworks/Steamworks", "tile/ITileEvent", "tile/TerrainResources", "tile/Terrains", "tile/TileEventManager", "tile/TileEvents", "ui/Ui", "utilities/Async", "utilities/Emitter", "utilities/enum/EnumManager", "utilities/enum/Enums", "utilities/Log", "utilities/math/Vector2", "utilities/math/Vector3", "utilities/Objects", "utilities/Random", "utilities/TileHelpers", "utilities/UUID", "utilities/Version", "utilities/WebAssemblyHelpers"], function(e, t, a, i, n, o, r, s, l, u, d, p, c, m, h, y, g, f, T, S, I, v, w, M, b, k, C, D, A, P, G, R, x, B, E, L, O, F, _, H, W, N, q, U, z, V, j, Q, $, Y, J, K, X, Z, ee, te, ae, ie, ne, oe, re, se, le, ue, de, pe, ce, me, he, ye, ge, fe, Te, Se, Ie, ve, we, Me, be, ke, Ce, De, Ae, Pe, Ge, Re, xe, Be, Ee, Le, Oe, Fe, _e, He, We, Ne) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    const qe = new Be.default(Be.LogSource.Game);
    class Ue extends Ge.default {
        constructor() {
            super(...arguments),
            this.interval = v.interval,
            this.mapSize = 512,
            this.mapSizeSq = this.mapSize * this.mapSize,
            this.mapGenVersion = gameVersion,
            this.seeds = {
                base: 0,
                saved: 0
            },
            this.version = gameVersion,
            this.glContext = null,
            this.visible = !0,
            this._updateRender = !1,
            this.renderingEnabled = !0,
            this.ambientLightLevelCache = {},
            this.gameLoop = (e=>{
                if (requestAnimationFrame(this.gameLoop),
                audio.processEffects(),
                !this.playing)
                    return;
                this.notifier && this.notifier.update();
                let t = !1;
                if (this.paused && !(t = !!(void 0 !== this.fadeInAmount || this.thumbnailResolve || this.updateFieldOfView || this._updateRender)))
                    return;
                const a = this.getAndUpdateAmbientLightLevel(localPlayer.z);
                let i = !1;
                if (!t) {
                    this.absoluteTime = e;
                    const t = this.isRealTimeMode();
                    if (t && (void 0 === this.nextTickTime && players.some(e=>e.isResting()) && (this.nextTickTime = this.absoluteTime + this.getTickSpeed() * this.interval),
                    void 0 !== this.nextTickTime && this.nextTickTime <= this.absoluteTime && (this.lastTickTime = this.absoluteTime,
                    this.getTurnMode() === T.TurnMode.Simulated ? this.nextTickTime = void 0 : this.nextTickTime = this.absoluteTime + this.getTickSpeed() * this.interval,
                    t && (this.visible && !multiplayer.isConnected() || multiplayer.isServer())))) {
                        if (multiplayer.isServer()) {
                            if (!steamworks.isDedicatedServer() || players.length > 1) {
                                const e = new q.default;
                                e.isMoving = players.map(e=>e.isMoving),
                                e.noInputReceived = players.map(e=>e.noInputReceived),
                                e.movementComplete = players.map(e=>e.movementComplete),
                                e.processAndSend()
                            }
                        } else
                            this.tickRealtime();
                        if (!this.playing)
                            return
                    }
                    for (const e of players) {
                        1 !== e.movementProgress && this.updateRenderInternal(v.RenderSource.MovementPlayerPre);
                        const t = 10 + e.getWeightMovementPenalty();
                        if (e.movementProgress = 1 - Math.min(1, Math.max(0, (e.movementFinishTime - this.absoluteTime) / (t * this.interval))),
                        1 !== e.movementProgress)
                            this.updateRenderInternal(v.RenderSource.MovementPlayerPost);
                        else if (e.isMovingClientside) {
                            e.isMovingClientside = !1,
                            e.fromX = e.x,
                            e.fromY = e.y,
                            e.isLocalPlayer() && fieldOfView.resetTransitionProgress(),
                            multiplayer.isConnected() && multiplayer.isServer() && (e.isMoving = !1);
                            const t = e.movementCompleteZ;
                            if (void 0 !== t) {
                                if (multiplayer.isConnected()) {
                                    if (multiplayer.isServer()) {
                                        const a = new N.default;
                                        a.pid = e.id,
                                        a.z = t,
                                        a.processAndSend()
                                    }
                                } else
                                    e.setZ(t);
                                e.isLocalPlayer() && (i = !0),
                                e.movementCompleteZ = void 0
                            }
                            multiplayer.isConnected() ? e.movementComplete = !0 : modManager.getHook(L.Hook.OnMoveComplete).call(e)
                        }
                    }
                    if (!this.playing)
                        return;
                    if (t && !this._updateRender) {
                        for (const e of this.creatures)
                            if (e) {
                                const t = e.getMovementFinishTime();
                                if (void 0 !== t && 1 !== t && (localPlayer.canSeePosition(e.x, e.y, e.z, !0) || localPlayer.canSeePosition(e.fromX, e.fromY, e.z, !0))) {
                                    this.updateRenderInternal(v.RenderSource.MovementCreature);
                                    break
                                }
                            }
                        if (!this._updateRender) {
                            for (const e of this.tileEvents)
                                if (e) {
                                    const t = e.movementFinishTime;
                                    if (void 0 !== t && 1 !== t && (localPlayer.canSeePosition(e.x, e.y, e.z, !0) || localPlayer.canSeePosition(e.fromX, e.fromY, e.z, !0))) {
                                        this.updateRenderInternal(v.RenderSource.MovementTileEvent);
                                        break
                                    }
                                }
                            if (!this._updateRender)
                                for (const e of this.npcs)
                                    if (e) {
                                        const t = e.getMovementFinishTime();
                                        if (void 0 !== t && 1 !== t && (localPlayer.canSeePosition(e.x, e.y, e.z, !0) || localPlayer.canSeePosition(e.fromX, e.y, e.z, !0))) {
                                            this.updateRenderInternal(v.RenderSource.MovementNPC);
                                            break
                                        }
                                    }
                        }
                    }
                }
                if (steamworks.isDedicatedServer())
                    this.updateFieldOfView && (this.updateFieldOfView = !1,
                    fieldOfView.compute(void 0, a));
                else if (this.renderingEnabled && (fieldOfView.updateTransitionProgress() && this.updateRenderInternal(v.RenderSource.FovTransition),
                modManager.getHook(L.Hook.PreRender).call(),
                this.render(a),
                modManager.getHook(L.Hook.PostRender).call(),
                i && this.updateView(v.RenderSource.MovementPlayerZPost, !0),
                this.thumbnailResolve && this.glContext && this.gameCanvas)) {
                    const e = document.createElement("canvas");
                    e.width = 512,
                    e.height = 512;
                    const t = e.getContext("2d");
                    if (!t)
                        return;
                    t.drawImage(this.gameCanvas, this.glContext.canvas.width / 2 - 256, this.glContext.canvas.height / 2 - 256, 512, 512, 0, 0, 512, 512),
                    saveData.gameThumbnail = e.toDataURL(),
                    this.thumbnailResolve(),
                    this.thumbnailResolve = void 0
                }
                if (!t)
                    for (const e of players) {
                        const t = e.hasDelay();
                        e.processInput(),
                        e.noInputReceived = !t && !e.isMovingClientside && !e.hasDelay(),
                        !multiplayer.isConnected() && e.noInputReceived && modManager.getHook(L.Hook.OnNoInputReceived).call(e)
                    }
            }
            )
        }
        get isChallenge() {
            return this.difficulty === I.Difficulty.Challenge
        }
        get updateRender() {
            return this.updateRenderInternal
        }
        set updateRender(e) {
            !0 === e && this.updateRenderInternal(v.RenderSource.Mod, !1)
        }
        initialize() {
            if (steamworks.isDedicatedServer())
                return this.notifier = p.notifier,
                void (this.particle = p.particle);
            this.gameCanvas = document.getElementById("game"),
            this.gameCanvas.addEventListener("webglcontextlost", e=>{
                e.preventDefault(),
                this.renderingEnabled = !1,
                multiplayer.isConnected() || this.setPaused(!0),
                qe.error("Lost gl context", e.statusMessage || "Unknown error"),
                newui.showLoadingInterrupt(G.default.GameInterruptLoadingLostGLContext, G.default.GameInterruptLoadingLostGLContextDescription)
            }
            , !1),
            this.gameCanvas.addEventListener("webglcontextrestored", ()=>{
                qe.warn("Restored gl context"),
                this.setupGl(!0),
                !multiplayer.isConnected() && this.paused && this.setPaused(!1)
            }
            , !1)
        }
        async initGl() {
            if (!this.gameCanvas)
                return void qe.info("No game canvas, not initializing webgl");
            let e, t;
            switch ("low-power" !== saveDataGlobal.options.powerPreference && "high-performance" !== saveDataGlobal.options.powerPreference || (t = {
                powerPreference: saveDataGlobal.options.powerPreference
            }),
            qe.info(`Initializing webgl version ${webGlVersion}`, t),
            webGlVersion) {
            case 2:
                try {
                    if (t || (t = {}),
                    t.antialias = !0,
                    e = this.gameCanvas.getContext("webgl2", t))
                        break;
                    qe.warn("Failed to get webgl 2 context. Falling back to webgl 1")
                } catch (e) {
                    qe.warn("Failed to get webgl 2 context. Falling back to webgl 1", e)
                } finally {
                    t && delete t.antialias
                }
            default:
                e = this.gameCanvas.getContext("webgl", t) || this.gameCanvas.getContext("experimental-webgl", t)
            }
            if (!e)
                throw new Error("Invalid WebGl game canvas context");
            return this.glContext = e,
            ui.onWindowResize(),
            this.setupGl(!1)
        }
        async setupGl(e) {
            this.glContext ? (de.default.resetGl(),
            resourceLoader.initialize(this.glContext),
            he.default.compileShaders(this.glContext),
            ce.default.compileShaders(this.glContext),
            ae.default.compileShaders(this.glContext),
            this.notifier = new ie.default(this.glContext,16),
            this.particle = new oe.default(this.glContext),
            fieldOfView && fieldOfView.resetGl(this.glContext),
            this.playing ? (await this.loadResources(),
            this.createWorldRenderer(),
            world.load(),
            renderer.updateAll(),
            this.updateFieldOfView = !0,
            this.updateRenderInternal(v.RenderSource.SetupGl),
            this.renderingEnabled = !0,
            e && newui.hideLoadingInterrupt()) : e && newui.hideLoadingInterrupt()) : e && newui.hideLoadingInterrupt()
        }
        resetWebGL() {
            if (this.glContext) {
                const e = this.glContext.getExtension("WEBGL_lose_context");
                e && (e.loseContext(),
                setTimeout(()=>{
                    e.restoreContext()
                }
                , 1e3))
            }
        }
        setGlContextSize(e, t) {
            const a = window.devicePixelRatio || 1;
            this.glContext && (this.glContext.canvas.width = Math.round(e * a),
            this.glContext.canvas.height = Math.round(t * a))
        }
        resizeRenderer() {
            renderer && this.glContext && (renderer.setViewport(new Ee.default(this.glContext.canvas.width,this.glContext.canvas.height)),
            this.updateZoomLevel(),
            this.playing && localPlayer && this.updateView(v.RenderSource.Resize, !1))
        }
        checkWaterFill(e, t, a, i) {
            if (this.fillCount >= i)
                return;
            const n = this.getTile(e, t, a);
            if (!n)
                return;
            const o = _e.default.getType(this.getTile(e, t, a))
              , r = ke.default[o];
            if (r && (r.shallowWater || r.water)) {
                if (this.fillTile[e] && this.fillTile[e][t])
                    return;
                r.deepWater ? this.fillCount += 3 : r.water ? this.fillCount += 2 : this.fillCount++,
                this.fillTile[e] = this.fillTile[e] || [],
                this.fillTile[e][t] = !0,
                this.checkWaterFill(e - 1, t, a, i),
                this.checkWaterFill(e, t - 1, a, i),
                this.checkWaterFill(e + 1, t, a, i),
                this.checkWaterFill(e, t + 1, a, i)
            }
        }
        consumeWaterTile(e, t, a) {
            const i = this.getTile(e, t, a)
              , n = _e.default.getType(i);
            let o;
            const r = 50;
            if (this.fillCount = 0,
            this.fillTile = [],
            this.checkWaterFill(e, t, a, 50),
            this.fillCount < 50) {
                const i = ke.default[n];
                n === T.TerrainType.DeepFreshWater || n === T.TerrainType.DeepSeawater ? o = i && i.freshWater ? T.TerrainType.FreshWater : T.TerrainType.Seawater : n === T.TerrainType.FreshWater || n === T.TerrainType.Seawater ? (o = i && i.freshWater ? T.TerrainType.ShallowFreshWater : T.TerrainType.ShallowSeawater,
                50 * Fe.default.float() + this.fillCount <= 25 && (o = i && i.tileOnConsume ? i.tileOnConsume : T.TerrainType.Dirt)) : o = i && i.tileOnConsume ? i.tileOnConsume : T.TerrainType.Dirt,
                this.changeTile(o, e, t, a, !1)
            }
        }
        checkForHiddenMob(e, t, a, i) {
            const n = this.getTile(t, a, i).creature;
            n && n.isHidden() && (n.ai |= y.AiType.Hostile,
            n.ai &= ~y.AiType.Hidden,
            Z.default.get(e).source(J.Source.Combat, J.Source.Creature).send(A.default.CreatureAppears, n.getName()),
            this.updateView(v.RenderSource.HiddenMob, !1))
        }
        animateSkeletalRemains(e, t, a, i) {
            const n = this.getTile(t, a, i);
            if (!n)
                return;
            const o = n.doodad;
            o && o.type === T.DoodadType.SkeletalRemains && creatureManager.spawn(T.CreatureType.Skeleton, t, a, i, !0) && (doodadManager.remove(o),
            e.messages.source(J.Source.Creature).send(A.default.ReturnsToLife, B.default.nameOf(C.Dictionary.Creature, T.CreatureType.Skeleton)))
        }
        getWrappedCoord(e) {
            return e - this.mapSize * Math.floor(e / this.mapSize)
        }
        getTileFromPoint(e) {
            return this.getTile(e.x, e.y, e.z)
        }
        getTile(e, t, a) {
            return this.tile[a * this.mapSizeSq + this.getWrappedCoord(t) * this.mapSize + this.getWrappedCoord(e)]
        }
        getTileUnsafe(e, t, a) {
            return this.tile[a * this.mapSizeSq + t * this.mapSize + e]
        }
        setTile(e, t, a, i) {
            return this.tile[a * this.mapSizeSq + t * this.mapSize + e] = i,
            i
        }
        getOrCreateTile(e, t, a) {
            const i = a * this.mapSizeSq + t * this.mapSize + e;
            let n = this.tile[i];
            return n || (n = {},
            this.tile[i] = n,
            n)
        }
        setPaused(e, t=!1) {
            if (this.paused === e)
                return;
            if (qe.info(e ? "Paused game" : "Unpaused game"),
            this.paused = e,
            multiplayer.isConnected() && multiplayer.isServer()) {
                const a = new W.default;
                a.paused = e,
                a.showChatMessage = t,
                a.send()
            }
            const a = this.paused ? A.default.MultiplayerGamePaused : A.default.MultiplayerGameResumed;
            Be.default.info(Be.LogSource.Chat)(B.default.message(a).getString()),
            this.emit(this.paused ? v.GameEvent.Pause : v.GameEvent.Resume)
        }
        async saveGame(e) {
            if (this.saveClear)
                return;
            qe.info("Saving game", T.SaveType[e]);
            const t = e === T.SaveType.Quit;
            let a = !1;
            if ((!multiplayer.isConnected() || multiplayer.isServer()) && (this.seeds.saved = Fe.default.generator.getSeed(),
            (!this.isChallenge || e === T.SaveType.Challenge || e === T.SaveType.Multiplayer) && (multiplayer.isServer() && t && multiplayer.disconnect(void 0, void 0, !0),
            e === T.SaveType.InGame || e === T.SaveType.Death || e === T.SaveType.Multiplayer || e === T.SaveType.Challenge ? modManager.saveAll() : await modManager.unloadAll(),
            this.playing))) {
                a = !0;
                const i = e === T.SaveType.Multiplayer ? Se.SLOT_MULTIPLAYER : this.slot;
                if (t)
                    return saveManager.save(i, !0),
                    {
                        slot: i
                    };
                e !== T.SaveType.Multiplayer && await this.updateThumbnail();
                const n = performance.now();
                modManager.getHook(L.Hook.PreSaveGame).call();
                const o = await saveManager.save(i);
                modManager.getHook(L.Hook.PostSaveGame).call();
                const r = performance.now() - n;
                if (qe.info(`Saving took ${(r / 1e3).toPrecision(2)} seconds`),
                void 0 !== o.bytes && e !== T.SaveType.Multiplayer && e !== T.SaveType.Death) {
                    const e = (o.bytes / 1024 / 1024).toFixed(3);
                    localPlayer.messages.source(J.Source.Meta).send(A.default.GameHasBeenSavedIsTakingUpMB, e)
                }
                return o
            }
            a || saveManager.save(Se.SLOT_GLOBAL, t)
        }
        async updateThumbnail() {
            if (steamworks.isDedicatedServer())
                return;
            const e = await Promise.race([new Promise((e,t)=>{this.thumbnailResolve=(()=>{e(!0)})}),Pe.sleep(5e3)]);
            e || (this.thumbnailResolve = void 0)
        }
        addZoomLevel(e) {
            const t = Math.max(Math.min(saveDataGlobal.options.zoomLevel + e, 8), 1);
            t !== saveDataGlobal.options.zoomLevel && (saveDataGlobal.options.zoomLevel = Math.round(t),
            this.updateZoomLevel())
        }
        updateZoomLevel() {
            renderer && (renderer.setZoom(modManager.getHook(L.Hook.GetZoomLevel, saveDataGlobal.options.zoomLevel).call()),
            this.playing && this.updateView(v.RenderSource.OptionZoomLevel, !1))
        }
        async requestPlay(e) {
            const t = e.slot
              , a = await saveManager.loadPartial(t)
              , i = {};
            saveManager.loadPartialData(a, i, "modsUnloadable");
            const n = i.modsUnloadable;
            if (void 0 !== n) {
                const e = Object.keys(n);
                if (e.length > 0) {
                    let t = "CanLoad";
                    const a = []
                      , i = [];
                    for (const o of e) {
                        if (n[o].unloadable)
                            continue;
                        let e = "Error";
                        const r = modManager.canLoadFromIdentifier(o);
                        if (r.loadable) {
                            e = "NotEnabled";
                            for (const t of modManager.getIndexFromIdentifier(o))
                                if (modManager.isEnabled(t)) {
                                    e = "Enabled";
                                    break
                                }
                        }
                        "Error" === e ? (t = "MissingMod",
                        a.push(r.name)) : "NotEnabled" === e && ("MissingMod" !== t && (t = "CanEnable"),
                        i.push(r.name))
                    }
                    if ("MissingMod" === t || "CanEnable" === t) {
                        const e = await newui.interrupt(G.default .MenuLoadGameInterruptMissingMod).withDescription(()=>B.default .ui(G.default .MenuLoadGameInterruptMissingModDescription).get(0===a.length?"":B.default .ui(G.default .MenuLoadGameInterruptMissingModDescriptionLabelModsMissing).get(B.default .formatList(a)),0===i.length?"":B.default .ui(G.default .MenuLoadGameInterruptMissingModDescriptionLabelModsDisabled).get(B.default .formatList(i)))).withConfirmation();
                        if (!e)
                            return !1
                    }
                }
            }
            return this.play(Object.assign({}, e, {
                slot: t
            }))
        }
        async play(e) {
            if (void 0 !== e.multiplayerServerToJoin)
                return multiplayer.joinServer(e.multiplayerServerToJoin, e.character),
                !0;
            if (void 0 === e.slot && e.difficulty !== I.Difficulty.Challenge) {
                const t = await saveManager.getFirstFreeSlot();
                if (void 0 === t)
                    return qe.error("No free game slots available. Try deleting some saves"),
                    !1;
                e.slot = t
            }
            const t = e.multiplayerWorld || e.difficulty !== I.Difficulty.Challenge ? e.slot : Se.SLOT_CHALLENGE;
            if (qe.info("play", t, e),
            "number" != typeof t)
                return !1;
            if (newui.showLoadingInterrupt(G.default.GameInterruptLoadingGame, G.default.GameInterruptLoadingGameDescription),
            this.initializeGameState(),
            this.slot = t,
            this.createWorld(),
            this.difficulty = void 0 !== e.difficulty ? e.difficulty : I.Difficulty.Hardcore,
            this.difficultyOptions = void 0 !== e.difficultyOptions ? e.difficultyOptions : I.getDefaultDifficultyOptions(this.difficulty, void 0 === e.seed ? void 0 : Fe.convertStringToSeed(`${e.seed}`)),
            this.tickSpeed = void 0 !== e.realTimeTickSpeed ? e.realTimeTickSpeed : T.TickSpeed.Default,
            this.turnMode = void 0 !== e.turnMode ? e.turnMode : T.TurnMode.Manual,
            !e.multiplayerWorld && this.isChallenge && (!localPlayer || localPlayer.state !== T.PlayerState.Traveling))
                return await saveManager.deleteSlot(Se.SLOT_CHALLENGE),
                this.prePlay(!1, {
                    seed: `${e.seed || Date.now()}`,
                    name: e.name,
                    character: e.character,
                    turnMode: e.turnMode,
                    multiplayer: e.multiplayer
                });
            const a = await saveManager.isSlotUsed(this.slot);
            if (a) {
                if (e.multiplayerWorld) {
                    qe.info(`Adding players. Local id: ${e.multiplayerWorld.pid}. Multiplayer player count: ${e.multiplayerWorld.playerCount}`);
                    for (let t = 0; t < e.multiplayerWorld.playerCount; t++) {
                        const t = this.addPlayer({
                            options: {}
                        });
                        t.id === e.multiplayerWorld.pid && this.setLocalPlayer(t)
                    }
                } else
                    this.setLocalPlayer(this.addPlayer({
                        options: {},
                        identifier: multiplayer.getPlayerIdentifier()
                    }));
                await saveManager.load(this.slot),
                localPlayer.state === T.PlayerState.Traveling && this.initializeGameState(!0),
                e.seed = localPlayer.state === T.PlayerState.Traveling ? void 0 : `${this.seeds.base}`
            }
            return this.prePlay(a, e)
        }
        setLocalPlayer(e) {
            localPlayer = e,
            e.canSendMessage = !0
        }
        addPlayer(e) {
            let t;
            qe.info(`Adding player with pid ${e ? e.id : void 0}, identifier: ${e ? e.identifier : void 0}`);
            let a = !1;
            if (e && e.identifier) {
                for (let e = 0; e < players.length; e++)
                    qe.info(`players id ${e}, identifier ${players[e].identifier}`);
                for (let i = 0; i < absentPlayers.length; i++) {
                    const n = absentPlayers[i];
                    if (qe.info(`absentPlayer id ${i}, identifier ${n.identifier}`),
                    n.identifier === e.identifier) {
                        _e.default.isOpenTile(n, n.getTile()) || (a = !0),
                        (t = n).wasAbsentPlayer = !0;
                        const e = t.getStat(g.Stat.Health);
                        e.value <= 0 && (qe.info("Fixing invalid health value"),
                        t.setStat(e, 20)),
                        this.removeAndFixPids(absentPlayers, i),
                        qe.info("Restored absent player", i),
                        t.state === T.PlayerState.Ghost && this.getDifficultyOptions().respawn && (t.state = T.PlayerState.None,
                        qe.info("Updated player state from ghost to none"));
                        break
                    }
                }
            }
            if (void 0 === t && (t = new ee.default(e && e.identifier ? e.identifier : He.default.create())),
            e && (e.options && t.setOptions(e.options),
            t.wasAbsentPlayer && !a || !e.position || (t.x = e.position.x,
            t.y = e.position.y,
            t.z = e.position.z,
            t.fromX = e.position.x,
            t.fromY = e.position.y),
            !t.wasAbsentPlayer && e.character && (t.customization = e.character.customization,
            t.name = e.character.name),
            void 0 !== e.id))
                return t.setId(e.id),
                players[t.id] = t,
                this.playing && modManager.getHook(L.Hook.OnTileUpdate).call(t.getTile(), t.x, t.y, t.z),
                t;
            !t.wasAbsentPlayer && multiplayer.isConnected() && void 0 !== multiplayer.getOptions().newPlayerState && (t.state = multiplayer.getOptions().newPlayerState);
            const i = players.push(t);
            return t.setId(i - 1),
            this.playing && (modManager.getHook(L.Hook.OnTileUpdate).call(t.getTile(), t.x, t.y, t.z),
            this.updateView(v.RenderSource.TileUpdate, !1)),
            t
        }
        removePlayer(e) {
            const t = players[e];
            if (t) {
                if (qe.info("Removing player", e),
                t.absentLastUsedTime = Date.now(),
                absentPlayers.push(t),
                t.resetMovementStates(),
                this.removeAndFixPids(players, e),
                this.playing && this.updateView(v.RenderSource.PlayerRemove, !1),
                multiplayer.isServer()) {
                    const e = steamworks.getDedicatedServerInfo();
                    e && e.console && this.saveGame(T.SaveType.InGame)
                }
            } else
                qe.warn("Unable to remove player", e)
        }
        deletePlayer(e, t) {
            for (let a = 0; a < e.length; a++) {
                const i = e[a];
                if (i.identifier === t) {
                    e.splice(a, 1);
                    const n = itemManager.getItemsInContainer(i.inventory, !0);
                    qe.info(`Deleting player '${i.name}' [${t}] - ${n.length} items`);
                    for (const e of n)
                        itemManager.remove(e);
                    const o = e.find(e=>e.identifier === t);
                    for (const e of this.items)
                        e && e.containedWithin === i.inventory && (qe.info("Fixing duplicate identifier issue", e),
                        void 0 !== o ? (qe.info(`Moving item into '${i.name}'s inventory`),
                        itemManager.moveToContainer(o, e, o.inventory)) : itemManager.remove(e));
                    if (void 0 !== o)
                        for (const e of o.inventory.containedItems)
                            e.containedWithin !== o.inventory && (e.containedWithin = o.inventory,
                            qe.info("Fixing invalid contained within for another player"));
                    break
                }
            }
        }
        isRealTimeMode() {
            return this.getTurnMode() !== T.TurnMode.Manual
        }
        getTurnMode() {
            return this.turnMode
        }
        setTurnMode(e) {
            this.turnMode = e,
            this.getTurnMode() === T.TurnMode.RealTime && (this.nextTickTime = 0),
            multiplayer.isServer() && multiplayer.updateOptions({
                turnMode: e
            })
        }
        getTickSpeed() {
            return this.tickSpeed
        }
        setTickSpeed(e) {
            this.tickSpeed = e,
            multiplayer.isServer() && multiplayer.updateOptions({
                tickSpeed: e
            })
        }
        synchronizeFlowFields(e) {
            qe.info(this.time.ticks, this.flowFieldSyncCount, "synchronizeFlowFields", e.length, e.map(e=>e.id).join(",")),
            flowFieldManager.setPlayers(e),
            this.updateEntityFov(),
            flowFieldManager.reset(),
            this.flowFieldSyncCount++
        }
        enableFlowFieldDebug() {
            this.glContext
        }
        async resetGameState(e=!1) {
            qe.info("resetGameState", saveData.gameSlotName, T.PlayerState[localPlayer.state]),
            modManager.getHook(L.Hook.OnGameEnd).call(localPlayer.state),
            steamworks.stopPlaytimeTracking(),
            multiplayer.isConnected() && (e = multiplayer.isClient(),
            multiplayer.disconnect(),
            e || (saveData.multiplayerState.enable = !0)),
            this.isChallenge ? localPlayer.state === T.PlayerState.Traveling && await this.saveGame(T.SaveType.Challenge) : e || await this.saveGame(T.SaveType.BackToMainMenu),
            this.playing = !1,
            this.notifier.clear(),
            fieldOfView = void 0,
            renderer && renderer.dispose(),
            audio.updateMusicSpeed(1),
            await modManager.unloadAll(!0),
            Re.default.reset(),
            localPlayer.state === T.PlayerState.Traveling ? this.play({
                slot: this.slot
            }) : ui.switchToScreen(V.ScreenId.MainMenu)
        }
        shouldRender() {
            const e = modManager.getHook(L.Hook.ShouldRender).call();
            return void 0 === e ? 65535 : e
        }
        makeLavaPassage(e) {
            const {x: t, y: a, z: i} = e.getFacingPoint()
              , n = this.getTile(t, a, i)
              , o = _e.default.getType(n);
            if (i === T.WorldZ.Overworld && o !== T.TerrainType.Lava) {
                const n = this.getTile(t, a, T.WorldZ.Cave)
                  , o = _e.default.getType(n);
                if (o === T.TerrainType.Lava) {
                    this.changeTile(T.TerrainType.Lava, t, a, i, !1),
                    Fe.default.bool() && this.changeTile(T.TerrainType.CoolingLava, t, a, T.WorldZ.Cave, !1),
                    e.messages.source(J.Source.Action).send(A.default.DiscoveredLavaPassage),
                    e.queueSoundEffectInFront(T.SfxType.Water);
                    const n = ke.default[o];
                    return n && this.particle.create(t, a, i, n.particles),
                    T.TerrainType.Lava
                }
            }
        }
        makeCaveEntrance(e) {
            if (e.z === T.WorldZ.Cave)
                return;
            const t = e.getFacingPoint()
              , a = {
                x: 0,
                y: 0
            };
            for (a.x = t.x - 1; a.x < t.x + 2; a.x++)
                for (a.y = t.y - 1; a.y < t.y + 2; a.y++)
                    if (_e.default.getType(this.getTile(a.x, a.y, T.WorldZ.Overworld)) === T.TerrainType.CaveEntrance)
                        return;
            if (0 === Fe.default.int(50)) {
                e.addDelay(40),
                e.messages.source(J.Source.Action).send(A.default.DiscoveredCaveEntrance),
                this.changeTile(T.TerrainType.CaveEntrance, t.x, t.y, e.z, !1),
                this.changeTile(T.TerrainType.CaveEntrance, t.x, t.y, T.WorldZ.Cave, !1, !0);
                const a = this.getTile(t.x, t.y, T.WorldZ.Cave).doodad;
                return a && a.damage(!0),
                T.TerrainType.CaveEntrance
            }
        }
        getTileData(e, t, a) {
            const i = this.tileData[e];
            if (i) {
                const e = i[t];
                if (e)
                    return e[a]
            }
        }
        getOrCreateTileData(e, t, a) {
            let i = this.tileData[e];
            i || (i = this.tileData[e] = {});
            let n = i[t];
            n || (n = i[t] = {});
            let o = n[a];
            return o || (o = n[a] = []),
            o
        }
        updateTablesAndWeightNextTick() {
            this.shouldUpdateTablesAndWeight = !0
        }
        makeMiniMap(e) {
            const t = document.createElement("canvas");
            t.width = 456,
            t.height = 456;
            const a = t.getContext("2d");
            if (!a)
                throw new Error("Invalid map canvas context");
            const i = 38
              , n = 456
              , o = 12
              , r = this.glContext;
            if (!this.cartographyTexture) {
                const e = r.createTexture();
                if (!e)
                    throw new Error("Unable to create map texture");
                this.cartographyTexture = e,
                r.bindTexture(r.TEXTURE_2D, this.cartographyTexture),
                r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST),
                r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST),
                r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
                r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
                r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, 456, 456, 0, r.RGBA, r.UNSIGNED_BYTE, se.emptyUint8Array)
            }
            const s = r.createFramebuffer();
            r.bindFramebuffer(r.FRAMEBUFFER, s),
            r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, this.cartographyTexture, 0);
            const l = 456 / (38 * se.subTileSize * 2);
            r.viewport(0, 0, 456, 456),
            r.clearColor(98 / 255, 67 / 255, 30 / 255, 1),
            r.clear(r.COLOR_BUFFER_BIT),
            r.enable(r.BLEND),
            r.blendFunc(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA),
            renderer.layers[e.tilePosition.z].renderFullbright(e.tilePosition.x - .5, e.tilePosition.y - .5, l, 456, 456, !1),
            renderer.layers[e.tilePosition.z].renderFullbright(e.tilePosition.x - .5, e.tilePosition.y - .5, l, 456, 456, !0);
            const u = new Uint8Array(831744);
            r.readPixels(0, 0, 456, 456, r.RGBA, r.UNSIGNED_BYTE, u),
            r.deleteFramebuffer(s),
            r.bindFramebuffer(r.FRAMEBUFFER, null);
            const d = a.createImageData(456, 456);
            let p, c;
            for (p = 0; p < 456; p++)
                for (c = 0; c < 456; c++) {
                    const e = 4 * (456 * p + c)
                      , t = 4 * (456 * (456 - p) + c);
                    d.data[e] = u[t],
                    d.data[e + 1] = u[t + 1],
                    d.data[e + 2] = u[t + 2],
                    d.data[e + 3] = u[t + 3]
                }
            if (a.putImageData(d, 0, 0),
            e.skillCheck) {
                const e = this.getSkillPercent(T.SkillType.Cartography);
                if (void 0 !== e)
                    for (a.fillStyle = "rgba(0,0,0,0)",
                    c = 0; c < 38; c++)
                        for (p = 0; p < 38; p++) {
                            const t = e / 100
                              , i = Fe.generalRandom.weightedChoice([[Math.pow(4 * (1 - Math.abs(t - 0)), 2), [[20, 1], [8, .8], [4, .6], [.25, .4], [.1, .2]]], [Math.pow(4 * (1 - Math.abs(t - .2)), 2), [[12, 1], [6, .8], [4, .6], [.25, .25], [.1, .1]]], [Math.pow(4 * (1 - Math.abs(t - .4)), 2), [[4, .8], [4, .6], [1, .25], [.1, .1]]], [Math.pow(4 * (1 - Math.abs(t - .6)), 2), [[1, .8], [4, .6], [2, .25], [1, .1]]], [Math.pow(4 * (1 - Math.abs(t - .8)), 2), [[1, .8], [3, .25], [3, .1]]], [Math.pow(4 * (1 - Math.abs(t - 1)), 2), [[1, .8], [3, .25], [5, .1]]]])
                              , n = Fe.generalRandom.weightedChoice(i)
                              , o = 6;
                            for (let e = 0; e < o; e++)
                                for (let t = 0; t < o; t++)
                                    Fe.generalRandom.chance(n) && a.clearRect(12 * c + 12 * e / o, 12 * p + 12 * t / o, 12 / o, 12 / o)
                        }
                a.fillStyle = "#00ff00",
                a.fillRect(228, 228, 12, 12)
            }
            return t
        }
        getBlackness() {
            return void 0 !== this.fadeInAmount ? 1 - this.fadeInAmount : 1
        }
        getAmbientLightLevel(e) {
            return this.ambientLightLevelCache[e]
        }
        getAndUpdateAmbientLightLevel(e) {
            const t = this.getAmbientLightLevel(e)
              , a = e !== T.WorldZ.Cave ? 1 - this.time.getBrightness() : .05
              , i = modManager.getHook(L.Hook.GetAmbientLightLevel).setDefault(a).call(a, e);
            return t !== i && (this.updateFieldOfView = !0,
            this.ambientLightLevelCache[e] = i),
            i
        }
        updateReputation(e) {
            if (1 === players.length)
                return void (localPlayer.isGhost() || localPlayer.updateReputation(e));
            const t = this.getPlayers();
            if (0 === t.length)
                return;
            const a = Math.floor(e / t.length);
            for (const e of t)
                e.updateReputation(a)
        }
        getDifficulty() {
            return this.difficulty
        }
        getDifficultyOptions() {
            return this.difficultyOptions
        }
        getReputation() {
            return this.getPlayerAverage(e=>e.getReputation(), !0)
        }
        getMalignity() {
            return this.getPlayerAverage(e=>e.getStat(g.Stat.Malignity).value, !0)
        }
        getBenignity() {
            return this.getPlayerAverage(e=>e.getStat(g.Stat.Benignity).value, !0)
        }
        getMaxHealth() {
            return this.getPlayerAverage(e=>e.getMaxHealth())
        }
        getMaxWeight() {
            return this.getPlayerAverage(e=>e.getMaxWeight())
        }
        getTactics() {
            return this.getPlayerAverage(e=>e.skills[T.SkillType.Tactics].core)
        }
        getSkillPercent(e) {
            return this.getPlayerAverage(t=>t.getSkill(e))
        }
        getPlayerAverage(e, t) {
            if (1 === players.length) {
                if (localPlayer.isGhost())
                    return 0;
                const t = e(localPlayer);
                return void 0 !== t ? t : 0
            }
            const a = this.getPlayers();
            if (0 === a.length)
                return 0;
            let i = 0;
            for (const t of a) {
                const a = e(t);
                void 0 !== a && (i += a)
            }
            if (0 === i)
                return 0;
            const n = i / a.length;
            return t ? Math.round(n) : n
        }
        changeTile(e, t, a, i, n, o, r) {
            t = this.getWrappedCoord(t),
            a = this.getWrappedCoord(a);
            const s = "number" == typeof e ? {
                type: e
            } : e;
            if (void 0 === s.type)
                return;
            let l = Fe.default.int(3);
            const u = this.getTile(t, a, i);
            if (!u)
                return;
            const d = ke.default[_e.default.getType(u)];
            d && d.noGfxSwitch && (l = _e.default.getGfx(u));
            let p = this.getOrCreateTileData(t, a, i);
            if (o) {
                const e = p.length - 1;
                for (let n = e; n >= 0; n--) {
                    const o = p[n];
                    if ((!r || !(n === e || n === e - 1 && p[e] && p[e].type === T.TerrainType.CaveEntrance)) && o.type !== T.TerrainType.CaveEntrance) {
                        const e = be.default[o.type];
                        if (e && e.defaultItem) {
                            let n, r;
                            o.minDur && o.maxDur && (n = o.minDur - 1,
                            r = o.maxDur);
                            let s = T.ItemQuality.Random;
                            void 0 !== o.quality && (s = o.quality);
                            const l = itemManager.create(e.defaultItem, itemManager.getTileContainer(t, a, i), s);
                            void 0 !== n && (l.minDur = n),
                            void 0 !== r && (l.maxDur = r),
                            void 0 === n && void 0 === r || ui.updateItem(l)
                        }
                    }
                }
                this.tileData[t][a][i] = [],
                p = this.getOrCreateTileData(t, a, i)
            }
            if (n)
                _e.default.getType(u) === T.TerrainType.Grass ? p.length > 0 ? p[0].type = T.TerrainType.Dirt : p.push({
                    type: T.TerrainType.Dirt
                }) : p.length <= 0 && p.push({
                    type: _e.default.getType(u)
                }),
                p.unshift(s);
            else {
                p.length <= 0 && p.push(s),
                p[0].type = s.type,
                p[0].gfx = l;
                const e = ke.default[s.type];
                if (e) {
                    const t = e.durability;
                    void 0 === p[0].minDur && void 0 !== t && (p[0].minDur = t),
                    void 0 === p[0].maxDur && void 0 !== t && (p[0].maxDur = t)
                }
            }
            _e.default.setGfx(u, l),
            _e.default.setType(u, s.type),
            world.updateTile(t, a, i, u)
        }
        isPositionFull(e, t, a) {
            const i = this.getTile(e, t, a);
            return !i || this.isTileFull(i)
        }
        isTileFull(e) {
            const t = e;
            return !(!t.containedItems || !t.containedItems.length) && itemManager.getItemsWeight(t.containedItems) >= 36
        }
        isOnFire(e) {
            const t = e.doodad;
            if (t) {
                const e = t.description();
                if (e && e.providesFire)
                    return T.FireType.Doodad
            }
            if (tileEventManager.get(e, Me.TileEventType.Fire))
                return T.FireType.Fire;
            const a = _e.default.getType(e);
            return a === T.TerrainType.Lava ? T.FireType.Lava : a === T.TerrainType.CoolingLava ? T.FireType.CoolingLava : T.FireType.None
        }
        isTileEmpty(e) {
            const t = e
              , a = ke.default[_e.default.getType(e)]
              , i = !(a && !a.passable || void 0 !== e.doodad || void 0 !== t.containedItems && t.containedItems.length > 0 || e.creature || e.npc || e.corpses || e.events || this.isPlayerAtTile(e));
            return multiplayer.addSyncCheck(_.MultiplayerSyncCheck.IsTileEmpty, {
                doodad: void 0 !== e.doodad,
                creature: void 0 !== e.creature,
                corpses: void 0 !== e.corpses,
                events: void 0 !== e.events,
                items: void 0 !== t.containedItems && t.containedItems.length > 0,
                hasPlayer: this.isPlayerAtTile(e),
                ret: i
            }),
            i
        }
        isPositionEmpty(e, t, a) {
            const i = this.getTile(e, t, a);
            return i ? this.isTileEmpty(i) : (multiplayer.addSyncCheck(_.MultiplayerSyncCheck.IsTileEmpty, {
                x: e,
                y: t,
                z: a
            }),
            !1)
        }
        processWaterContamination() {
            if (0 === this.contaminatedWater.length)
                return;
            const e = [];
            for (; this.contaminatedWater.length > 0; ) {
                const t = this.contaminatedWater.pop();
                if (!t)
                    return;
                const a = world.layers[t.z]
                  , i = a.getTileType(t.x, t.y);
                if (i > T.TerrainType.ShallowFreshWater)
                    continue;
                i > T.TerrainType.ShallowSeawater && this.changeTile(i - 3, t.x, t.y, t.z, !1);
                let n = a.getTileType(t.x + 1, t.y);
                n > T.TerrainType.ShallowSeawater && n <= T.TerrainType.ShallowFreshWater && e.push({
                    x: t.x + 1,
                    y: t.y,
                    z: t.z
                }),
                (n = a.getTileType(t.x - 1, t.y)) > T.TerrainType.ShallowSeawater && n <= T.TerrainType.ShallowFreshWater && e.push({
                    x: t.x - 1,
                    y: t.y,
                    z: t.z
                }),
                (n = a.getTileType(t.x, t.y + 1)) > T.TerrainType.ShallowSeawater && n <= T.TerrainType.ShallowFreshWater && e.push({
                    x: t.x,
                    y: t.y + 1,
                    z: t.z
                }),
                (n = a.getTileType(t.x, t.y - 1)) > T.TerrainType.ShallowSeawater && n <= T.TerrainType.ShallowFreshWater && e.push({
                    x: t.x,
                    y: t.y - 1,
                    z: t.z
                })
            }
            this.contaminatedWater = e
        }
        getMovementFinishTime() {
            return this.absoluteTime + 10 * this.interval
        }
        passTurn(e, t) {
            e.passTurn(t);
            const a = this.isRealTimeMode();
            a && e.isResting() ? e.tick(!0) : a || (e.tick(!0),
            this.tick()),
            this.getTurnMode() === T.TurnMode.Simulated && !e.isGhost() && (void 0 === this.lastTickTime || this.lastTickTime + this.getTickSpeed() * this.interval < this.absoluteTime) && (this.nextTickTime = 0),
            e.updateStatsAndAttributes(),
            this.updateView(v.RenderSource.GamePassTurn, !e.isResting() && (e.isLocalPlayer() || 0 !== e.lightBonus))
        }
        tickRealtime() {
            this.tick();
            for (const e of players)
                e.isServer() || e.tick();
            for (const e of this.getPlayers())
                e.updateStatsAndAttributes();
            this.updateView(v.RenderSource.GameTick, !localPlayer.isResting() && (localPlayer.isLocalPlayer() || 0 !== localPlayer.lightBonus))
        }
        updateView(e, t) {
            "boolean" == typeof e && (t = e,
            e = v.RenderSource.Mod),
            t && (this.updateFieldOfView = !0),
            !renderer || localPlayer.isResting() && !multiplayer.isConnected() || (this.updateRenderInternal(e, !0),
            renderer.computeSpritesInViewport())
        }
        updateRenderInternal(e, t=!1) {
            this._updateRender = !0
        }
        updateTablesAndWeight() {
            this.shouldUpdateTablesAndWeight = !1;
            for (const e of this.getPlayers())
                e.updateTablesAndWeight()
        }
        rangeFinder(e, t) {
            0 === e && (e = 1),
            0 === t && (t = 1);
            const a = Math.ceil(t / 100 * 6) - 1;
            let i = a;
            a > e && (i = e);
            const n = Fe.default.intInRange(i, e);
            let o = n + a;
            return 1 === e && (o = Math.floor(o / 2)),
            o < 1 && o++,
            o
        }
        damage(e, t, a=!0) {
            let i = B.default.message(A.default.YourFist)
              , n = B.default.message(A.default.TheirFist);
            t.weaponName instanceof B.default ? i = n = t.weaponName : "number" == typeof t.weaponName && t.weaponName !== A.default.YourFist && (i = n = B.default.message(t.weaponName));
            const o = e.getName();
            let r = !1, l, d = B.default.message(A.default.None), p;
            switch (e.entityType) {
            case y.EntityType.Player:
                p = modManager.getHook(L.Hook.OnPlayerDamage).call(e, t);
                break;
            case y.EntityType.NPC:
                p = modManager.getHook(L.Hook.OnNPCDamage).call(e, t);
                break;
            case y.EntityType.Creature:
                p = modManager.getHook(L.Hook.OnCreatureDamage).call(e, t)
            }
            if (void 0 !== p) {
                if (p <= 0)
                    return;
                void 0 !== p && (l = p)
            }
            if (t.legacy && (l = t.amount) < 0 && (l *= -1),
            void 0 === l) {
                let a;
                if (e instanceof s.default) {
                    const t = e.description();
                    t && (a = t.defense)
                } else
                    a = e.defense;
                if (!a)
                    return;
                let u = a.base;
                e instanceof s.default && e.aberrant && (u = Math.ceil(u * Math.max(this.getTactics() / 30, 2))) > 15 && (u = 15);
                const p = a.resist;
                let c = 0;
                const m = []
                  , h = a.vulnerable;
                let y = 0;
                const f = [];
                for (const a of xe.default.values(T.DamageType)) {
                    if (t.type & a && p[a]) {
                        const n = p[a];
                        switch (n) {
                        case 99:
                            t.weaponName && Z.default.get(t.human).source(J.Source.Combat, J.Source.Action, J.Source.Item).type(Z.MessageType.Bad).send(A.default.DidNotSeemToBeHurting, i, o),
                            r = !0;
                            break;
                        case 100:
                            t.weaponName && Z.default.get(t.human).source(J.Source.Combat, J.Source.Action, J.Source.Item).type(Z.MessageType.Bad).send(A.default.SeemsToHaveDrawnEnergy, o, i),
                            e instanceof s.default && e.increaseStat(g.Stat.Health, t.amount) && (this.notifier.addStat(e.x, e.y, e.z, T.StatType.EnemyHealth, t.amount),
                            e.queueSoundEffect(T.SfxType.Miss)),
                            r = !0;
                            break;
                        default:
                            m.push(a),
                            c += n
                        }
                    }
                    t.type & a && h[a] && (f.push(a),
                    y += h[a])
                }
                const S = t.amount + y;
                if (l = S - (u + c),
                y && c) {
                    const e = m.concat(f.filter(function(e) {
                        return -1 === m.indexOf(e)
                    }));
                    d = B.default.message(A.default.DamageAppeared).addArgs(x.fullDamageType(e), B.default.message(A.default.BothEffectiveIneffective))
                } else
                    y ? d = B.default.message(A.default.DamageAppeared).addArgs(x.fullDamageType(f), B.default.message(A.default.Effective)) : c && (d = B.default.message(A.default.DamageAppeared).addArgs(x.fullDamageType(m), B.default.message(A.default.Ineffective)));
                if (l <= 0 && !r) {
                    l = 0;
                    const a = Fe.default.percent();
                    a <= 10 ? l = 1 : (this.notifier.addStat(e.x, e.y, e.z, T.StatType.Zero, 0),
                    t.weaponName && (Z.default.get(t.human).source(J.Source.Combat, J.Source.Action).type(Z.MessageType.Miss).send(A.default.FailedToCauseDamage, o, i, d),
                    e instanceof ee.default && Z.default.get(e).source(J.Source.Combat).type(Z.MessageType.Good).send(A.default.FailedToCauseYouDamage, t.human.getName(), n, d)))
                }
            }
            if (e instanceof s.default || (l = Math.ceil(l * e.getDamageModifier())),
            e instanceof ee.default && (e.lastAttackedBy = void 0),
            l >= 1 && !r) {
                if (e.reduceStat(g.Stat.Health, l),
                !(e instanceof s.default)) {
                    const a = e;
                    if (a.cancelResting(T.RestCancelReason.CreatureDamaged),
                    t.damageMessage && (a.deathBy = ("number" == typeof t.damageMessage ? B.default.message(t.damageMessage) : t.damageMessage).serialize()),
                    e instanceof ee.default)
                        if (e.healthSyncCheck(),
                        t.human)
                            t.human.updateReputation(e.getReputation() > 0 ? -25 : 25),
                            e.lastAttackedBy = t.human;
                        else if (t.creature) {
                            const a = t.creature.getOwner();
                            a && (a.updateReputation(e.getReputation() > 0 ? -25 : 25),
                            e.lastAttackedBy = t.creature)
                        }
                    e.queueSoundEffect(T.SfxType.Hurt, void 0 === t.soundDelay ? 0 : t.soundDelay)
                }
                if (t.weaponName && (Z.default.get(t.human).source(J.Source.Combat, J.Source.Action).type(Z.MessageType.Attack).send(A.default.HitForDamage, o, l, i, d),
                e instanceof ee.default && Z.default.get(e).source(J.Source.Combat, J.Source.Wellbeing).type(Z.MessageType.Bad).send(A.default.HitYouForDamage, t.human.getName(), l, n, d)),
                e instanceof s.default) {
                    if (!t.human && void 0 !== e.enemy) {
                        const t = this.creatures[e.enemy];
                        if (t) {
                            const a = t.getOwner();
                            if (a) {
                                const t = e.description();
                                t && a.updateReputation(t.reputation < 0 ? -25 : 25)
                            }
                        }
                    }
                    if (e.type === T.CreatureType.Slime && 0 === Fe.default.int(7)) {
                        const t = Math.floor(Fe.default.float() + e.x - Fe.default.float())
                          , a = Math.floor(Fe.default.float() + e.y - Fe.default.float())
                          , i = creatureManager.spawn(T.CreatureType.Slime, t, a, e.z, !1, !!e.aberrant || void 0);
                        if (void 0 !== i) {
                            Z.default.toAll(i=>i.ifVisible(new Le.default(t,a,e.z)).source(J.Source.Creature).send(A.default.HasSplit, o));
                            const i = u.default[T.CreatureType.Slime];
                            i && i.blood && this.particle.create(t, a, e.z, i.blood),
                            audio.queueEffect(T.SfxType.Water, t, a, e.z)
                        }
                    }
                    if (a) {
                        let t;
                        const a = e.description();
                        e.aberrant && a && a.aberrantBlood ? t = a.aberrantBlood : a && a.blood ? t = a.blood : (t = re.default[ne.ParticleType.Blood],
                        0 === Fe.default.int(10) && corpseManager.createBlood(e.x, e.y, e.z)),
                        this.particle.create(e.x, e.y, e.z, t)
                    }
                } else if (a) {
                    const t = re.default[ne.ParticleType.Blood];
                    0 === Fe.default.int(10) && corpseManager.createBlood(e.x, e.y, e.z),
                    this.particle.create(e.x, e.y, e.z, t)
                }
                this.notifier.addStat(e.x, e.y, e.z, e instanceof ee.default ? T.StatType.Health : T.StatType.EnemyHealth, -1 * l),
                e.queueSoundEffect(e instanceof s.default ? T.SfxType.CreatureHit : T.SfxType.Hurt)
            }
            const c = t.human || t.creature;
            return c && e.getStatValue(g.Stat.Health) <= 0 && modManager.getHook(L.Hook.OnEntityKill).call(c, e),
            l
        }
        getPlayers(e, t) {
            const a = [];
            for (const i of players)
                i.isServer() || i.isGhost() && !e || i.isConnecting && !t || a.push(i);
            return a
        }
        isPlayerAtTile(e, t, a) {
            return 0 !== this.getPlayersAtTile(e, t, a).length
        }
        isPlayerAtPosition(e, t, a, i, n) {
            return 0 !== this.getPlayersAtPosition(e, t, a, i, n).length
        }
        getPlayersAtTile(e, t, a) {
            const i = [];
            for (const n of players)
                n.isServer() || n.isGhost() && !t || n.isConnecting && !a || n.getTile() !== e || i.push(n);
            return i
        }
        getPlayersAtPosition(e, t, a, i, n) {
            "object" == typeof e && (n = a,
            i = t,
            a = e.z,
            t = e.y,
            e = e.x);
            const o = [];
            for (const r of players)
                r.isServer() || r.isGhost() && !i || r.isConnecting && !n || r.x !== e || r.y !== t || r.z !== a || o.push(r);
            return o
        }
        getPlayersThatSeePosition(e, t, a) {
            const i = [];
            for (const n of this.getPlayers())
                n.canSeePosition(e, t, a) && i.push(n);
            return i
        }
        canASeeB(e, t, a, i, n, o, r) {
            if (multiplayer.isConnected() && !r) {
                const r = this.getLightSourceAt(e, t, a)
                  , s = fieldOfView && fieldOfView.canASeeB(e, t, a, i, n, o, r);
                return multiplayer.addSyncCheck(_.MultiplayerSyncCheck.CanASeeB, `${e},${t},${a}:${s},${r}`),
                s
            }
            return !fieldOfView || fieldOfView.disabled ? a === o : fieldOfView.canASeeB(e, t, a, i, n, o)
        }
        getNearestPlayer(e, t, a) {
            if (1 === players.length) {
                if (localPlayer.isGhost())
                    return;
                if (void 0 !== a && localPlayer.z !== a)
                    return;
                return localPlayer
            }
            let i, n;
            for (const o of this.getPlayers()) {
                if (void 0 !== a && o.z !== a)
                    continue;
                const r = Math.sqrt(Math.pow(e - o.x, 2) + Math.pow(t - o.y, 2));
                (void 0 === n || void 0 === i || i > r) && (i = r,
                n = o)
            }
            return n
        }
        getPlayerByPid(e) {
            for (const t of players)
                if (t.id === e)
                    return t
        }
        getPlayerByIdentifier(e, t=!0) {
            for (const t of players)
                if (t.identifier === e)
                    return t;
            if (t)
                for (const t of absentPlayers)
                    if (t.identifier === e)
                        return t
        }
        getPlayerByName(e) {
            for (const t of players)
                if (t.name && t.name.toLowerCase() === e.toLowerCase())
                    return t
        }
        getValidPlayerName(e) {
            let t = e ? e.trim() : "";
            0 === t.length ? t = B.default.ui(G.default.MiscPlayerNameDefault).getString() : t.length > 32 && (t = t.substring(0, 32));
            let a = 2
              , i = t;
            for (; void 0 !== this.getPlayerByName(i); )
                i = `${t} (${a})`,
                a++;
            return i
        }
        getHeight(e, t, a) {
            const i = a * Fe.default.float() - .5 * a;
            return .5 * (e + t) + i
        }
        getLightSourceAt(e, t, a) {
            const i = this.getTile(e, t, a);
            if (!i)
                return 0;
            let n = modManager.getHook(L.Hook.GetTileLightLevel).call(i, e, t, a);
            if (void 0 !== n)
                return n;
            n = 0;
            const o = i.doodad;
            if (o) {
                const e = o.description();
                if (e && e.providesFire) {
                    let t = e.providesLight;
                    t && o.isEmbers() && (t /= 2),
                    void 0 !== t && (n = 25 + 12 * Fe.default.float() + 17 * t),
                    o.legendary && o.legendary.type === T.LegendaryType.Illumination && (n += o.legendary.value),
                    void 0 !== o.decay && (n += Math.min(Math.floor(o.decay / 10), 50))
                }
            }
            const s = tileEventManager.get(i, Me.TileEventType.Fire);
            s && void 0 !== s.decay && (n = 75 + 12 * Fe.default.float() + Math.min(Math.floor(s.decay / 10), 50));
            const l = i.creature;
            if (l) {
                const e = l.description();
                e && e.lightSource && (n = Math.max(85 + Fe.default.int(12), n))
            }
            const u = i.corpses;
            if (u)
                for (const e of u) {
                    const t = r.default[e.type];
                    t && t.lightSource && (n = Math.max(85 + Fe.default.int(12), n))
                }
            const d = _e.default.getType(i);
            d === T.TerrainType.Lava ? n = Math.max(85 + Fe.default.int(12), n) : d === T.TerrainType.CoolingLava && (n = Math.max(40 + Fe.default.int(12), n)),
            a === T.WorldZ.Cave && d === T.TerrainType.CaveEntrance && (n = Math.max(6 * (1 - this.time.getBrightness()) * 17, n));
            const p = this.getPlayersAtPosition(e, t, a);
            if (p.length > 0) {
                let e = 0;
                for (const t of p)
                    t.lightBonus > 0 && (e += 25 + 12 * Fe.default.float() + t.lightBonus);
                n = Math.max(Math.floor(e), n)
            }
            return n
        }
        setupSave(e) {
            itemManager.saveTileReferences(),
            saveData.saveManagerSaveTime = Date.now(),
            saveData.saveManagerTicks = this.time && this.time.ticks || 0,
            saveData.saveManagerOriginalVersion = this.version,
            saveData.saveManagerDifficulty = this.getDifficulty(),
            saveData.saveManagerScore = localPlayer.score,
            saveData.saveManagerDeathBy = localPlayer.deathBy
        }
        async onGlobalSlotLoaded(e, t) {
            qe.info("onGlobalSlotLoaded", t),
            t && (this.upgradeGlobalSave(We.default.getVersionInfo(saveDataGlobal.gameLastPlayedVersion ? saveDataGlobal.gameLastPlayedVersion : "beta2.0.5")),
            Be.default.refresh(),
            ui.setFontStyle(),
            steamworks.isElectron() && newui.toggleFullscreen(saveDataGlobal.options.fullscreen),
            audio.updateVolume()),
            languageManager.initialize();
            try {
                await this.initGl()
            } catch (e) {
                return qe.error("Failed to initialize gl", e),
                void newui.interrupt(B.default.generator("Wayward cannot be run on this system or browser.")).withDescription(B.default.generator(e.message)).withChoice(D.default.Quit).then(()=>{
                    window.close(),
                    document.body.innerHTML = ""
                }
                )
            }
            this.emit(v.GameEvent.GlobalSlotLoaded),
            await modManager.setupMods(),
            qe.info("Finished setting up mods"),
            this.loadResources(),
            saveDataGlobal.options.muteMusic || audio.playMusic(),
            requestAnimationFrame(this.gameLoop),
            void 0 !== this.simulateInterval && clearInterval(this.simulateInterval);
            const a = steamworks.getDedicatedServerInfo();
            if (void 0 !== a ? this.initializeDedicatedServer(a) : (this.simulateInterval = setInterval(()=>{
                this.simulate()
            }
            , this.interval),
            newui.showScreen(V.ScreenId.Splash)),
            steamworks.onReady(),
            t) {
                const e = We.default.getVersionInfo(gameVersion)
                  , t = saveDataGlobal.gameLastPlayedVersion ? We.default.getVersionInfo(saveDataGlobal.gameLastPlayedVersion) : void 0;
                if (qe.info(`Current version: ${gameVersion}. Last played version: ${saveDataGlobal.gameLastPlayedVersion}`),
                !t || t.minor < e.minor) {
                    const e = modManager.getMods();
                    for (let t = 0; t < e.length; t++)
                        modManager.isValid(t) && modManager.getType(t) !== O.ModType.Internal && modManager.isEnabled(t) && modManager.setState(t, O.ModState.Disabled);
                    hookManager.cacheHooks()
                }
            }
        }
        onSaveLoaded(e) {
            e !== Se.SLOT_MULTIPLAYER && (this.saveVersion || (this.saveVersion = "beta2.0.5"),
            this.upgradeSave(We.default.getVersionInfo(this.saveVersion)))
        }
        directionToMovement(e) {
            return {
                x: e === T.Direction.West ? -1 : e === T.Direction.East ? 1 : 0,
                y: e === T.Direction.North ? -1 : e === T.Direction.South ? 1 : 0
            }
        }
        fireBreath(e, t, a, i, n, o) {
            for (let r = 0; r < 3; r++) {
                let s = e
                  , l = t;
                i === T.Direction.West ? s -= 1 + r : i === T.Direction.East ? s += 1 + r : i === T.Direction.North ? l -= 1 + r : i === T.Direction.South && (l += 1 + r);
                const u = this.getTile(s, l, a)
                  , d = ke.default[_e.default.getType(u)];
                if (!d || !d.passable || d.water || d.shallowWater)
                    break;
                const p = u.doodad;
                if (p) {
                    const e = p.description();
                    if (e && !e.isFlammable)
                        break
                }
                if (void 0 !== u.creature) {
                    const e = Fe.default.intInRange(4, 6);
                    n && u.creature.damage({
                        amount: e,
                        type: T.DamageType.Fire,
                        weaponName: n
                    })
                }
                o && u.npc && u.npc.makeHostile(),
                tileEventManager.create(Me.TileEventType.Fire, s, l, a),
                this.particle.create(s, l, a, re.default[ne.ParticleType.Fire])
            }
        }
        updateOption(e, t, a) {
            if (e) {
                const i = new U.default;
                i.pid = e.id,
                i.id = t,
                i.value = a,
                multiplayer.syncPacket(i, ()=>{
                    this.updateOptionInternal(t, a, e),
                    e && e.isLocalPlayer() && (saveDataGlobal.options = e.options)
                }
                )
            } else
                this.updateOptionInternal(t, a)
        }
        updateFlowFieldTile(e, t, a, i) {
            flowFieldManager && (flowFieldManager.updateTile(t, a, i),
            modManager.getHook(L.Hook.OnTileUpdate).call(e, t, a, i))
        }
        getCompletedMilestoneCount() {
            let e = 0;
            if (saveDataGlobal.playerMilestoneData) {
                const t = Object.keys(saveDataGlobal.playerMilestoneData);
                for (let a = 0; a < t.length; a++) {
                    const i = t[a]
                      , n = saveDataGlobal.playerMilestoneData[i];
                    n && -1 === n.amount && e++
                }
            }
            return e
        }
        packGround(e, t, a) {
            const i = this.getTile(e, t, a);
            if (_e.default.isTilled(i)) {
                const n = this.getTileData(e, t, a);
                n && (n[0].tilled = !1,
                _e.default.setTilled(i, !1),
                world.updateTile(e, t, a, i))
            }
        }
        getRandomQuality(e, t=0) {
            const a = Fe.default.int(600 - t);
            return a <= 1 ? T.ItemQuality.Legendary : a <= 8 ? T.ItemQuality.Exceptional : a <= 40 ? T.ItemQuality.Remarkable : T.ItemQuality.None
        }
        getMaxDurability(e, t) {
            return e === T.ItemQuality.Remarkable ? Math.floor(1.3 * t) + Fe.default.int(3) + 6 : e === T.ItemQuality.Exceptional ? Math.floor(1.5 * t) + Fe.default.int(6) + 12 : e === T.ItemQuality.Legendary ? Math.floor(1.8 * t) + Fe.default.int(9) + 24 : t
        }
        doLavaEvents(e, t, a) {
            const i = this.getTile(e, t, a);
            if (!i)
                return;
            const n = _e.default.getType(i)
              , o = Fe.default.percent();
            o <= 10 ? n === T.TerrainType.Lava ? this.changeTile(T.TerrainType.CoolingLava, e, t, a, !1) : n === T.TerrainType.CoolingLava && this.changeTile(T.TerrainType.Obsidian, e, t, a, !1) : o <= 65 && tileEventManager.fireOverflow(e, t, a)
        }
        wrapCoordinate(e, t) {
            return t - e > 255 ? e + this.mapSize : e - t > 255 ? e - this.mapSize : e
        }
        isFlammable(e, t, a) {
            const i = this.getTile(e, t, a);
            if (!i)
                return !1;
            if (tileEventManager.get(i, Me.TileEventType.Fire))
                return !1;
            const n = ke.default[_e.default.getType(i)];
            if (n && n.flammable && void 0 === i.doodad)
                return !0;
            if (i.doodad) {
                const e = i.doodad.description();
                if (e && (e.isFlammable || e.providesFire))
                    return !0
            }
            if (n && !n.water && !n.shallowWater) {
                const e = i;
                if (e.containedItems)
                    for (let t = 0; t < e.containedItems.length; t++) {
                        const a = e.containedItems[t]
                          , i = a.description();
                        if (i && i.flammable)
                            return !0
                    }
            }
            if (n && !n.water && !n.shallowWater) {
                const e = i.events;
                if (e)
                    for (const t of e) {
                        const e = De.default[t.type];
                        if (e && e.isFlammable)
                            return !0
                    }
            }
            return !1
        }
        getCameraPosition() {
            let e = this.getExactCameraPosition();
            e = modManager.getHook(L.Hook.GetCameraPosition, e).call(e);
            const t = 16 * renderer.getZoom();
            return t >= 16 ? e : new Ee.default(e).multiply(t).floor().divide(t)
        }
        getExactCameraPosition() {
            return new Ee.default(localPlayer.fromX,localPlayer.fromY).lerp(localPlayer, localPlayer.movementProgress)
        }
        restartDedicatedServer() {
            const e = steamworks.getDedicatedServerInfo();
            return !!e && (this.initializeDedicatedServer(e),
            !0)
        }
        updateOptionInternal(e, t, a) {
            const i = a ? a.options : saveDataGlobal.options;
            if (i[e] = t,
            this.playing && a) {
                switch (e) {
                case "protectedCraftingItems":
                case "protectedCraftingItemContainers":
                case "useAdjacentContainers":
                    a.updateTables();
                    break;
                case "hideEquippedHeadgear":
                    this.updateRenderInternal(v.RenderSource.OptionHeadgear);
                    break;
                case "leftHand":
                case "rightHand":
                    a.updateHandToUse()
                }
                a.emit("UpdateOption", e, t)
            }
        }
        tick() {
            modManager.getHook(L.Hook.OnGameTickStart).call(),
            audio.updatePosition();
            const e = this.getPlayers();
            multiplayer.addSyncCheck(_.MultiplayerSyncCheck.Tick, e.length),
            this.processTimers(e),
            multiplayer.isConnected() && !multiplayer.isServer() || this.processAutoSave(),
            this.processWaterContamination(),
            this.tickDayNightCycle(e),
            fieldOfView.tickSeed();
            for (const t of e)
                this.runRandomEvents(t);
            itemManager.decayItems() && (this.shouldUpdateTablesAndWeight = !0),
            this.updateEntityFov(),
            flowFieldManager.setPlayers(e),
            flowFieldManager.update(),
            creatureManager.updateAll(),
            npcManager.updateAll();
            for (const t of e) {
                const {x: e, y: a, z: i} = t.getFacingPoint();
                this.animateSkeletalRemains(t, e, a, i)
            }
            this.shouldUpdateTablesAndWeight && this.updateTablesAndWeight(),
            ui.tooltipRefresh(),
            modManager.getHook(L.Hook.OnGameTickEnd).call()
        }
        updateEntityFov() {
            const e = [];
            for (const t of this.getPlayers())
                if (flowFieldManager.isPlayerInFlowField(t)) {
                    const a = fieldOfView.getBounds(t, multiplayer.isConnected() ? v.lineOfSightMaxRadius : void 0);
                    a.min.x -= t.x,
                    a.min.y -= t.y,
                    a.max.x -= t.x,
                    a.max.y -= t.y,
                    a.min.scale(1.75),
                    a.max.scale(1.75),
                    a.min.x += t.x,
                    a.min.y += t.y,
                    a.max.x += t.x,
                    a.max.y += t.y,
                    e.push(a)
                }
            creatureManager.updateFov(e),
            npcManager.updateFov(e)
        }
        processTimers(e) {
            this.creatureSpawnTimer++;
            let t = Math.min(200, 350 / this.getMalignity() * 1e4) + this.getBenignity() / 320;
            if (multiplayer.isConnected() && e.length > 1 && (t -= t * ((e.length - 1) / 50)),
            this.isChallenge && (t -= t * (e.length * te.default.getCreaturesOfRequirements().length() / 50)),
            t <= 0 && (qe.warn(`Spawn rate is below expected worst case scenario. Malignity: ${this.getMalignity()}, Benignity: ${this.getBenignity()}, Players: ${e.length}, Quests: ${te.default.getCreaturesOfRequirements().length()}.`),
            t = 1),
            this.creatureSpawnTimer >= t) {
                const t = this.creatures.filter(e=>e).length;
                if (t >= (this.isChallenge ? 350 : 300))
                    this.creatureSpawnTimer = 0;
                else
                    for (const t of e) {
                        let e, a;
                        const i = Fe.default.int(4);
                        switch (i) {
                        case 0:
                            e = t.x + 10 + Fe.default.int(30),
                            a = t.y + 10 + Fe.default.int(30);
                            break;
                        case 1:
                            e = t.x - 10 - Fe.default.int(30),
                            a = t.y - 10 - Fe.default.int(30);
                            break;
                        case 2:
                            e = t.x + 10 + Fe.default.int(30),
                            a = t.y - 10 - Fe.default.int(-30);
                            break;
                        default:
                            e = t.x - 10 - Fe.default.int(30),
                            a = t.y + 10 + Fe.default.int(30)
                        }
                        if (e = this.getWrappedCoord(e),
                        a = this.getWrappedCoord(a),
                        multiplayer.addSyncCheck(_.MultiplayerSyncCheck.Random, `CS:${t.id},${e},${a}`),
                        !t.canSeePosition(e, a, t.z)) {
                            const i = this.getTile(e, a, t.z);
                            if (i) {
                                const n = ke.default[_e.default.getType(i)];
                                if (n && n.water && 0 === Fe.default.int(2)) {
                                    let i;
                                    if (i = n.freshWater ? d.SpawnGroup.FreshWater : t.z === T.WorldZ.Cave ? d.SpawnGroup.CaveWater : d.SpawnGroup.Seawater,
                                    creatureManager.spawnFromGroup(i, e, a, t.z)) {
                                        this.creatureSpawnTimer = 0;
                                        break
                                    }
                                } else if (creatureManager.spawnFromGroup(d.SpawnGroup.Any, e, a, t.z)) {
                                    this.creatureSpawnTimer = 0;
                                    break
                                }
                            }
                        }
                    }
            }
        }
        async processAutoSave() {
            this.isChallenge || !this.getDifficultyOptions().respawn && localPlayer.state === T.PlayerState.Ghost || steamworks.processBackups() || saveDataGlobal.options.enableAutoSave && (this.autoSaveTimer++,
            this.autoSaveTimer >= 5e3 && !localPlayer.isResting() && (this.autoSaveTimer = 0,
            await newui.showLoadingInterrupt(G.default .GameInterruptLoadingAutoSaving,G.default .GameInterruptLoadingAutoSavingDescription),
            await this.saveGame(T.SaveType.InGame),
            "undefined" != typeof gc && gc(),
            newui.hideLoadingInterrupt()))
        }
        tickDayNightCycle(e) {
            this.time.nextTick(),
            tileEventManager.updateAll(),
            doodadManager.updateAll(),
            corpseManager.updateAll();
            const t = this.time.ticks % 20 == 0;
            let a = !1;
            t && (multiplayer.isConnected() && multiplayer.isServer() && multiplayer.updateGlobalServerDirectory(),
            this.shouldUpdateTablesAndWeight = !0,
            a = this.time.isPast("6:30pm"));
            for (const t of e)
                t.z === T.WorldZ.Overworld && a && t.notes.write(P.default.Nightfall),
                t.updateStatuses()
        }
        runRandomEvents(e) {
            let t;
            const a = Fe.default.int(this.mapSize)
              , i = Fe.default.int(this.mapSize)
              , n = this.getTile(a, i, e.z)
              , o = _e.default.getType(n);
            if (multiplayer.addSyncCheck(_.MultiplayerSyncCheck.Random, `RE:${e.id},${a},${i},${o}`),
            o === T.TerrainType.Lava && 0 === Fe.default.int(10))
                this.changeTile(T.TerrainType.CoolingLava, a, i, e.z, !1),
                Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).send(A.default.YouNoticeLavaCooling));
            else if (o === T.TerrainType.CoolingLava && 0 === Fe.default.int(10))
                this.changeTile(T.TerrainType.Obsidian, a, i, e.z, !1),
                Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).send(A.default.YouNoticeLavaHardening));
            else if (void 0 !== n.creature) {
                t = Fe.default.int(4);
                const o = n.creature
                  , r = o.description()
                  , s = o.getStat(g.Stat.Health);
                0 === t && r && s.value < s.max ? (Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).source(J.Source.Creature).send(A.default.YouNoticeWoundsClosing, o.getName())),
                o.increaseStat(s, 1)) : 1 === t && r && !r.noStumble ? (Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).source(J.Source.Creature).send(A.default.YouNoticeStumbleInjureItself, o.getName())),
                o.damage({
                    amount: 1,
                    type: T.DamageType.True,
                    skipMilestones: !0
                })) : 2 !== t || o.isTamed() || void 0 !== o.renamed ? 3 !== t || o.aberrant || (Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).source(J.Source.Creature).send(A.default.YouNoticeBecomeEnraged, o.getName())),
                o.aberrant = !0,
                o.setStat(s, Math.ceil(s.value * Math.max(this.getMaxWeight() / 15, 2))),
                o.isTamed() || (o.ai |= y.AiType.Hostile,
                o.ai &= ~y.AiType.Scared)) : (Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).source(J.Source.Creature).send(A.default.YouNoticePerish, o.getName())),
                o.damage({
                    amount: 999,
                    type: T.DamageType.True,
                    skipMilestones: !0
                }))
            } else if (void 0 !== n.doodad) {
                const o = n.doodad
                  , r = o.description();
                r && r.spreadMax && void 0 !== o.spread && (0 === (t = Fe.default.int(3)) ? (Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).source(J.Source.Creature).send(A.default.YouNoticeDying, o.getName())),
                doodadManager.remove(o)) : 1 === t ? (o.spread++,
                Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).send(A.default.YouNoticeFertilityIncreasing, o.getName()))) : 2 === t && o.spread >= 1 && (o.spread--,
                Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).send(A.default.YouNoticeFertilityDecreasing, o.getName()))))
            } else if (this.isPositionEmpty(a, i, e.z) && 0 === Fe.default.int(750)) {
                const t = [];
                for (const n of xe.default.values(T.DoodadType)) {
                    const r = m.default[n];
                    if (r && r.canGrow && (e.z === T.WorldZ.Overworld || e.z === T.WorldZ.Cave && r.canGrowInCaves)) {
                        const e = r.allowedTiles;
                        if (e)
                            for (const a of e)
                                if (o === a) {
                                    t.push(n);
                                    break
                                }
                    }
                    if (t.length) {
                        const n = Fe.default.getElement(t)
                          , o = doodadManager.create(n, a, i, e.z);
                        if (o) {
                            Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).send(A.default.YouNoticeGrowing, B.default.nameOf(C.Dictionary.Doodad, n)));
                            break
                        }
                    }
                }
            } else if (this.getReputation() <= -6e3 && this.isPositionEmpty(a, i, e.z) && 0 === Fe.default.int(750) && !e.canSeePosition(a, i, e.z)) {
                creatureManager.spawn(T.CreatureType.Zombie, a, i, e.z);
                let t = !1;
                for (let n = -1; n <= 1; n++)
                    for (let o = -1; o <= 1; o++)
                        creatureManager.spawn(T.CreatureType.Zombie, a + n, i + o, e.z) && (t || (t = Z.default.toAll(t=>t.ifVisible(new Le.default(a,i,e.z)).send(A.default.YouNoticeZombieHorde))))
            }
        }
        upgradeToClasses(e, t, a) {
            let i = !1;
            if (e)
                for (let n = 0; n < e.length; n++) {
                    const o = e[n];
                    if (o && !(o instanceof t)) {
                        const r = new t
                          , s = Object.keys(o);
                        for (const e of s)
                            r[e] = o[e];
                        a && a(r),
                        e[n] = r,
                        i = !0
                    }
                }
            return i
        }
        async prePlay(e, t) {
            qe.info("prePlay", e, t),
            this.playOptions = t,
            this.isLoadingSave = e,
            this.isLoadingSave && localPlayer.state !== T.PlayerState.Traveling || (this.saveVersion = this.version),
            Re.default.restore(),
            newui.showLoadingInterrupt(G.default.GameInterruptLoadingMods, G.default.GameInterruptLoadingModsDescription);
            const a = await modManager.loadAll(t);
            return a ? (qe.error("modManager.loadAll", a),
            await multiplayer.disconnect(_.DisconnectReason.UnableToLoadMods,()=>B.default .ui(G.default .GameMultiplayerInterruptFailedToLoadMods).get(a)),
            this.resetGameState(!0),
            !1) : (steamworks.startPlaytimeTracking(),
            itemManager.generateLookups(),
            doodadManager.generateLookups(),
            qe.info("Creating world renderer..."),
            this.createWorldRenderer(),
            qe.info("Created world renderer"),
            this.playPostSeed(t))
        }
        async playPostSeed(e) {
            qe.info("playPostSeed 1", e.seed),
            void 0 !== e.seed ? (this.seeds.base = e.seed,
            Fe.default.generator.setSeed(Fe.convertStringToSeed(e.seed))) : this.seeds.base = Fe.default.generator.getSeed(),
            saveData.gameBaseSeed = this.seeds.base,
            qe.info("playPostSeed 2", this.seeds.base, Fe.default.generator.getSeed()),
            Fe.default.generator.pushSeed(),
            this.isLoadingSave ? e.multiplayerWorld || localPlayer.setOptions(saveDataGlobal.options) : (this.setLocalPlayer(this.addPlayer({
                options: saveDataGlobal.options,
                character: e.character,
                identifier: multiplayer.getPlayerIdentifier()
            })),
            saveData.gameSlotName = e.name,
            saveData.gameCreationTime = Date.now()),
            e.multiplayerWorld ? this.crafted = e.multiplayerWorld.crafted : this.crafted = saveDataGlobal.gameCrafted;
            const t = this.loadResources();
            return Fe.default.generator.popSeed(),
            await E.generateWorld(!this.isLoadingSave||localPlayer.state===T.PlayerState.Traveling),
            t.isResolved || newui.showLoadingInterrupt(G.default.GameInterruptLoadingSprites, G.default.GameInterruptLoadingSpritesDescription),
            await t,
            this.startGame(this.playOptions)
        }
        render(e) {
            const t = this.getCameraPosition();
            this.updateFieldOfView && (this.updateFieldOfView = !1,
            fieldOfView.compute(void 0, e),
            this.updateRenderInternal(v.RenderSource.FovUpdate)),
            this._updateRender && (this._updateRender = !1,
            renderer.batchCreatures(),
            renderer.renderWorld(t.x, t.y, localPlayer.z),
            void 0 !== this.fadeInAmount && (this.fadeInAmount = Math.max(this.fadeInAmount - .005, 0),
            0 === this.fadeInAmount && (delete this.fadeInAmount,
            this.updateThumbnail(),
            multiplayer.isConnected() && multiplayer.isClient() && (this.updateFieldOfView = !0)),
            this._updateRender = !0));
            const a = this.glContext;
            a.viewport(0, 0, 2 * Math.round(a.canvas.width / 2), 2 * Math.round(a.canvas.height / 2)),
            a.clear(a.COLOR_BUFFER_BIT),
            renderer.render(),
            this.particle.render(t.x, t.y),
            void 0 !== this.debugRenderer && this.debugRenderer.renderDebug(),
            this.notifier.render(t.x, t.y, 2 * se.subTileSize, renderer.getTileScale(), renderer.getViewport().x, renderer.getViewport().y)
        }
        simulate() {
            this.playing && !this.paused && this.particle && this.particle.simulate()
        }
        getPotentialRecipesInContainer(e, t, a) {
            for (let i = 0; i < e.containedItems.length; i++) {
                const n = e.containedItems[i];
                if (!t[n.type]) {
                    t[n.type] = !0;
                    const e = k.itemDescriptions[n.type]
                      , i = e ? e.recipes : void 0;
                    if (i)
                        for (let e = 0; e < i.length; e++)
                            i[e]in this.crafted && (a[i[e]] = !0)
                }
                const o = n;
                o.containedItems && o.containedItems.length > 0 && this.getPotentialRecipesInContainer(o, t, a)
            }
        }
        removeAndFixPids(e, t) {
            qe.info(`Remove and fix pids in ${e === players ? "players" : "absentPlayers"}. Current count: ${e.length}. Removing ${t} [${e[t].identifier}]`);
            for (let t = 0; t < e.length; t++) {
                const a = e[t];
                qe.info(`${t}: ${a.id} [${a.identifier}]`)
            }
            e.splice(t, 1);
            for (let t = 0; t < e.length; t++) {
                const a = e[t]
                  , i = a.id;
                i !== t && (a.setId(t),
                e === players && multiplayer.updatePlayerId(i, t))
            }
        }
        createWorld() {
            world && world.delete(),
            world = new me.default(this.mapSize,this.mapSize),
            world.addLayer(T.WorldZ.Cave),
            world.addLayer(T.WorldZ.Overworld)
        }
        createWorldRenderer() {
            modManager.getHook(L.Hook.OnCreateWorld).call(world);
            for (const e of players)
                e.clientStore.get(ge.ClientDataType.ExploredMap).restoreExploredMap();
            for (const e of absentPlayers)
                e.clientStore.get(ge.ClientDataType.ExploredMap).restoreExploredMap();
            this.glContext && (this.playOptions.multiplayerWorld && !multiplayer.isServer() && (qe.info("Setting up world map"),
            world.setupExploredMap(),
            qe.info("Finished resetting world map")),
            renderer = new he.default(this.glContext),
            renderer.setSpriteTexture(this.spriteTexture, this.spriteTextureSizeInversed),
            ce.default.setTileTexture(this.tileTexture, this.tileTextureSizeInversed),
            this.notifier.setTexture(this.spriteTexture, this.spriteTextureSizeInversed),
            this.resizeRenderer())
        }
        loadResources() {
            return resourceLoader.loadResources(this)
        }
        initializeGameState(e=!1) {
            qe.info("initializeGameState", e),
            this.version = gameVersion,
            delete this.saveVersion,
            delete this.mapGenVersion,
            delete this.previousSaveVersion,
            this.isLoadingSave = !1,
            this.absoluteTime = 0,
            this.autoSaveTimer = 0,
            this.contaminatedWater = [],
            this.corpses = [],
            this.creatures = [],
            this.creatureSpawnTimer = 0,
            this.doodads = [],
            this.fadeInAmount = 0,
            this.fillCount = 0,
            this.fillTile = [],
            this.flowFieldSyncCount = 0,
            this.lastCreationIds = {},
            this.npcs = [],
            this.paused = !1,
            this.playing = !1,
            this.nextTickTime = void 0,
            this.lastTickTime = void 0,
            this.saveClear = !1,
            this.shouldUpdateTablesAndWeight = !1,
            this.spawnCoords = {
                x: 0,
                y: 0,
                z: T.WorldZ.Overworld
            },
            this.tile = [],
            this.tileContainers = [],
            this.tileData = {},
            this.wellData = {},
            this.tileEvents = [],
            this.time = new w.default(0),
            this._updateRender = !1,
            this.ambientLightLevelCache = {},
            this.particle && this.particle.clear(),
            e ? world.resetExploredMap() : (delete this.slot,
            this.items = [],
            delete this.difficulty,
            this.turnMode = T.TurnMode.Manual,
            this.tickSpeed = T.TickSpeed.Default,
            this.worldId = He.default.create(),
            players = [],
            absentPlayers = [],
            saveData = new fe.default,
            ui.initializeGameState()),
            Re.default.initializeGameState(),
            "undefined" != typeof gc && gc()
        }
        async startGame(e) {
            qe.info("startGame", Fe.default.generator.getSeed()),
            ui.setupItemBackgrounds(),
            await newui.showLoadingInterrupt(G.default .GameInterruptLoadingFinalizingWorld,G.default .GameInterruptLoadingFinalizingWorldDescription);
            const t = steamworks.isDedicatedServer();
            if (this.isLoadingSave) {
                Fe.default.generator.setSeed(this.seeds.saved),
                qe.info("startGame - set seed from saved", this.seeds.saved),
                localPlayer.spawnPoint && void 0 !== localPlayer.spawnPoint.x || (localPlayer.spawnPoint = this.spawnCoords,
                localPlayer.spawnPoint.z = T.WorldZ.Overworld);
                const e = localPlayer.state === T.PlayerState.Traveling;
                e ? (localPlayer.addMilestone(K.MilestoneType.Operator, a.ActionType.TraverseTheSea),
                Fe.default.bool(),
                localPlayer.x = this.spawnCoords.x,
                localPlayer.y = this.spawnCoords.y,
                localPlayer.raft = void 0,
                localPlayer.swimming = !1,
                saveManager.deleteSlot(this.slot),
                itemManager.resetMapsInContainer(localPlayer.inventory),
                localPlayer.messages.type(Z.MessageType.Stat).send(A.default.TravelToFarOffLands)) : (localPlayer.restData = void 0,
                this.getDifficultyOptions().respawn && (localPlayer.state = T.PlayerState.None)),
                Fe.default.generator.pushSeed(),
                itemManager.loadTileReferences(),
                itemManager.loadReferences(e),
                this.slot !== Se.SLOT_MULTIPLAYER && doodadManager.verifyAndFixItemWeights(),
                Fe.default.generator.popSeed();
                const t = itemManager.getItemsInContainer(localPlayer.inventory, !0);
                for (const e of t) {
                    e.containedWithin === localPlayer.inventory && ui.addItemToContainer(e, localPlayer.inventory, !0, !0),
                    e.quickSlot && ui.setQuickSlot(e.quickSlot, e.id, !0);
                    const t = e.getEquipSlot();
                    void 0 !== t && ui.setEquipSlot(t, e.id, !0)
                }
                ui.afterAddingMultipleItemsToContainer(localPlayer.inventory),
                ui.loadQuickSlots()
            } else {
                t && (localPlayer.state = T.PlayerState.Server),
                localPlayer.setup(this.getCompletedMilestoneCount());
                for (let e = 0; e < 3; e++)
                    doodadManager.updateAll();
                const e = this.getDifficultyOptions().time;
                e.frozen && (this.time.frozenTime = e.initial),
                e.initial && this.time.setTime(e.initial),
                e.dayLength && (this.time.dayLength = e.dayLength),
                e.dayPercent && (this.time.dayPercent = e.dayPercent)
            }
            localPlayer.fromX = localPlayer.x,
            localPlayer.fromY = localPlayer.y,
            modManager.getHook(L.Hook.OnGameStart).call(this.isLoadingSave, saveDataGlobal.gamePlayedCount),
            world.layers[localPlayer.z] || (localPlayer.z = T.WorldZ.Overworld),
            qe.info("Loading world...", Fe.default.generator.getSeed()),
            world.load(),
            qe.info("Loaded world", Fe.default.generator.getSeed()),
            renderer && (qe.info("Updating renderer...", Fe.default.generator.getSeed()),
            renderer.updateAll(),
            qe.info("Renderer updated", Fe.default.generator.getSeed())),
            fieldOfView = new ae.default(this.glContext,v.lineOfSightRadius,v.lineOfSightMaxRadius,v.lineOfSightDetail),
            (localPlayer.isGhost() || t) && (fieldOfView.disabled = !0),
            modManager.getHook(L.Hook.PostFieldOfView).call(),
            localPlayer.isGhost() && (ui.onGameEnd(),
            saveData.gameState = T.PlayerState.Ghost),
            localPlayer.calculateEquipmentStats(),
            this.updateTablesAndWeight(),
            flowFieldManager = new S.default(2 * v.lineOfSightMaxRadius),
            e.multiplayerWorld ? (this.synchronizeFlowFields(e.multiplayerWorld.initialFlowFieldPids.map(e=>players[e])),
            this.flowFieldSyncCount -= 1) : this.synchronizeFlowFields(players),
            this.fadeInAmount = 1;
            for (const e of localPlayer.inventory.containedItems) {
                if (e.isEquipped()) {
                    const t = k.itemDescriptions[e.type];
                    t && t.onEquip && t.onEquip(e)
                }
                itemManager.checkMilestones(localPlayer, e)
            }
            localPlayer.checkReputationMilestones(),
            localPlayer.updateStatsAndAttributes(),
            await newui.hideLoadingInterrupt(),
            newui.hideScreen(V.ScreenId.MainMenu),
            newui.hideScreen(V.ScreenId.Interrupt),
            ui.isInGameScreenShown() || t || ui.switchToScreen(V.ScreenId.Game),
            localPlayer.travelData || !this.isLoadingSave || t || localPlayer.messages.type(Z.MessageType.Stat).send(A.default.LastPlaceYouLeftOff),
            t || ui.openDialogs(),
            localPlayer.updateTables(),
            localPlayer.addDelay(10, !0);
            const i = this.getTurnMode();
            if (i === T.TurnMode.RealTime && (this.nextTickTime = 0),
            this.playing = !0,
            saveDataGlobal.gamePlayedCount++,
            this.updateZoomLevel(),
            audio.updatePosition(),
            this.isLoadingSave && localPlayer.travelData) {
                if (localPlayer.travelData.dehydration && localPlayer.messages.source(J.Source.Wellbeing).type(Z.MessageType.Bad).send(A.default.DyingOfDehydration),
                localPlayer.travelData.starvation && localPlayer.messages.source(J.Source.Wellbeing).type(Z.MessageType.Bad).send(A.default.StarvingToDeath),
                localPlayer.travelData.dehydration || localPlayer.travelData.starvation) {
                    let e = localPlayer.travelData.dehydration + localPlayer.travelData.starvation;
                    e > localPlayer.travelData.originalHealth && (e = localPlayer.travelData.originalHealth - 1),
                    this.notifier.addStat(localPlayer.x, localPlayer.y, localPlayer.z, T.StatType.Health, -1 * e),
                    localPlayer.queueSoundEffect(T.SfxType.Hurt)
                }
                if (localPlayer.travelData.itemId) {
                    const e = this.items[localPlayer.travelData.itemId];
                    e.placeOnTile(localPlayer.x, localPlayer.y, localPlayer.z, !0, !0)
                }
                localPlayer.travelData.state === T.PlayerState.Traveling ? localPlayer.addMilestone(K.MilestoneType.Navigator) : localPlayer.travelData.state === T.PlayerState.Won && localPlayer.addMilestone(K.MilestoneType.Seafarer),
                localPlayer.updateMilestones(),
                localPlayer.state = T.PlayerState.None,
                delete localPlayer.travelData
            }
            if (e.multiplayerWorld && multiplayer.isConnected() && multiplayer.onPlaying(),
            qe.info("Playing", Fe.default.generator.getSeed(), players.length, e),
            t ? (localPlayer.state = T.PlayerState.Server,
            localPlayer.identifier = He.default.create(),
            localPlayer.name = localPlayer.identifier,
            qe.info(`Randomizing local player name and identifier to ${localPlayer.identifier}`),
            newui.interrupt().withMenu(j.MenuId.Pause)) : (await newui.hideLoadingInterrupt(),
            newui.hideScreen(V.ScreenId.Interrupt)),
            !e.multiplayerWorld) {
                let a = e.multiplayer || t
                  , n = e.multiplayer;
                !0 === n || !a && saveData.multiplayerState.enable && await newui.interrupt(G.default .GameMultiplayerInterruptRestartServerAfterLoadingSave).withDescription(G.default .GameMultiplayerInterruptRestartServerAfterLoadingSaveDescription).withConfirmation() ? (a = !0,
                n = saveData.multiplayerState.options) : saveData.multiplayerState.enable = !1,
                a && ((n || t) && multiplayer.createServer(He.default.create(), n),
                t || Pe.sleep(200).then(()=>{
                    this.setPaused(!0),
                    newui.interrupt().withMenu(j.MenuId.Pause, e=>e.schedule(600, e.showMultiplayerOptionsMenu))
                }
                )),
                multiplayer.isConnected() || i !== T.TurnMode.Simulated || a && n || this.setTurnMode(T.TurnMode.Manual)
            }
            return steamworks.updateDiscordPresence(),
            this.updateView(v.RenderSource.StartGame, !0),
            !0
        }
        async initializeDedicatedServer(e) {
            const t = document.getElementById("initial-load");
            if (t && t.remove(),
            e.newGameOptions && (e.newGameOptions.dailyChallenge ? (e.newGameOptions.seed = `${1e3 * Math.floor(Date.now() / 1e3 / 60 / 60 / 24)}`,
            e.newGameOptions.name || (e.newGameOptions.name = B.default.ui(G.default.MiscSaveNameDailyChallenge).getString((new Date).toLocaleDateString()))) : e.newGameOptions.difficulty !== I.Difficulty.Challenge || e.newGameOptions.name || (e.newGameOptions.name = B.default.ui(G.default.MiscSaveNameChallenge).getString())),
            e.newGameOptions && void 0 === e.load) {
                if (await this.dedicatedServerNewGame(e))
                    return;
                if (e.console)
                    return void this.dedicatedServerExit("Unable to start a new game")
            }
            if (void 0 !== e.load) {
                qe.info(`Going to load "${e.load}"`);
                const t = await saveManager.getUsedSlots();
                for (const a of t) {
                    const t = await saveManager.loadPartial(a)
                      , i = {};
                    if (saveManager.loadPartialData(t, i, "gameSlotName"),
                    i.gameSlotName && i.gameSlotName.toLocaleLowerCase() === e.load.toLocaleLowerCase())
                        return void this.play({
                            slot: a
                        })
                }
                if (qe.warn(`Unable to load "${e.load}" - save not found`),
                !e.newGameOptions && e.console)
                    return void this.dedicatedServerExit("Exiting because no save was loaded");
                if (await this.dedicatedServerNewGame(e))
                    return;
                if (e.console)
                    return void this.dedicatedServerExit("Unable to start a new game")
            }
            ui.switchToScreen(V.ScreenId.MainMenu)
        }
        dedicatedServerExit(e) {
            qe.error(e),
            setTimeout(()=>{
                window.close()
            }
            , 0),
            Be.default.setCallback(void 0)
        }
        async dedicatedServerNewGame(e) {
            return qe.info(`Generating a new world ${e.load || e.name ? `"${e.load || e.name}" ` : ""}with the following options`, e.newGameOptions),
            e.newGameOptions.character || (e.newGameOptions.character = Y.generateRandomCharacter()),
            e.console || ui.switchToScreen(V.ScreenId.MainMenu),
            this.play(e.newGameOptions)
        }
        upgradeSave(e) {
            let t = !1;
            const a = game;
            t = this.upgradePlayer(localPlayer, e) || t;
            for (const a of absentPlayers)
                t = this.upgradePlayer(a, e) || t;
            if (t = this.upgradeSaveMoveProperty(game, game, "monsters", "creatures") || t,
            2 === e.major && e.minor < 2)
                for (const e of this.doodads)
                    e && e.type >= 51 && e.type <= 61 && (e.type -= 1,
                    t = !0);
            if (2 === e.major && e.minor < 4) {
                const a = [];
                for (const i of this.doodads) {
                    if (!i)
                        continue;
                    const n = i
                      , o = i.type;
                    let r, s = !1;
                    switch (o) {
                    case $.Pre240DoodadType.GrowingMushroom:
                    case $.Pre240DoodadType.GrowingPlant:
                        if (t = !0,
                        n.growInto) {
                            let t = $.Pre240DoodadType[n.growInto];
                            2 === e.major && e.minor < 2 && n.growInto >= 51 && n.growInto <= 61 && (t = $.Pre240DoodadType[n.growInto - 1]);
                            const a = T.DoodadType[t];
                            void 0 === (r = a) && (r = T.DoodadType.MapleTree);
                            const o = m.default[n.growInto];
                            o && o.decayMax && (i.decay = o.decayMax),
                            i.gfx = 3 * T.GrowingStage.Seedling + Fe.default.int(3)
                        } else
                            s = !0;
                        break;
                    case $.Pre240DoodadType.Sapling:
                        t = !0,
                        r = T.DoodadType.MapleTree,
                        i.gfx = 3 * T.GrowingStage.Seedling + Fe.default.int(3);
                        break;
                    case $.Pre240DoodadType.GrowingGrass:
                        t = !0,
                        r = T.DoodadType.Grass,
                        i.gfx = T.GrowingStage.Vegetative + Fe.default.int(3)
                    }
                    if (s) {
                        t = !0,
                        a.push(i);
                        continue
                    }
                    let l = $.Pre240DoodadType[o];
                    void 0 === r && ("DeadBush" === l && (l = "Tumbleweed"),
                    r = T.DoodadType[l]),
                    void 0 === r ? qe.warn(`Unable to convert doodad type ${l}`) : r !== i.type && (i.type = r,
                    t = !0);
                    const u = m.default[i.type];
                    if (u) {
                        const e = u.canGrow;
                        e && void 0 === i.gfx && (i.gfx = 3 * T.GrowingStage.Ripening + Fe.default.int(3),
                        t = !0)
                    }
                }
                for (const e of a)
                    doodadManager.remove(e)
            }
            if (2 === e.major && e.minor < 6)
                for (const e of this.doodads)
                    if (e) {
                        if (e.type === T.DoodadType.Tumbleweed) {
                            const a = m.default[e.type];
                            a && (e.gfx = 3 * T.GrowingStage.Ripening + Fe.default.int(3),
                            e.decay = a.decayMax,
                            t = !0)
                        }
                        e.legendary && (e.legendary.type = T.LegendaryType.Skill,
                        t = !0)
                    }
            void 0 !== a.dayNight && (a.time = new w.default(0),
            a.time.restoreFromDayNight(a.dayNight, a.dayNightSwitch),
            delete a.dayNight,
            t = !0);
            const i = [];
            for (let a = 0; a < this.items.length; a++) {
                const n = this.items[a];
                if (null === n) {
                    this.items[a] = void 0,
                    t = !0;
                    continue
                }
                if (!n)
                    continue;
                null === n.containedWithin && (delete n.containedWithin,
                t = !0);
                const o = n;
                if (o.equipped && (n.equippedId = localPlayer.id,
                localPlayer.equipped[o.equipped] = n.id,
                n.equippedType = y.EntityType.Player,
                delete o.equipped,
                t = !0),
                void 0 !== o.equippedPid && (n.equippedId = o.equippedPid,
                n.equippedType = y.EntityType.Player,
                delete o.equippedPid,
                t = !0),
                2 === e.major && e.minor < 4 && (55 === n.type || 283 === n.type || 286 === n.type) && (i.push(n),
                t = !0),
                2 === e.major && e.minor < 6 && n.legendary && (n.legendary.type = T.LegendaryType.Skill,
                t = !0),
                2 === e.major && e.minor < 7 && n.legendary && n.legendary.type === T.LegendaryType.Stat) {
                    switch (n.legendary.stat) {
                    case T.StatType.Health:
                        n.legendary.stat = g.Stat.Health;
                        break;
                    case T.StatType.Stamina:
                        n.legendary.stat = g.Stat.Stamina;
                        break;
                    case T.StatType.Metabolism:
                        n.legendary.stat = g.Stat.Metabolism
                    }
                    t = !0
                }
            }
            for (const e of i)
                itemManager.remove(e);
            for (const e of this.doodads)
                e && null === e.containedWithin && (delete e.containedWithin,
                t = !0);
            for (let e = 0; e < this.creatures.length; e++) {
                const a = this.creatures[e];
                void 0 !== a && ("number" == typeof a.direction && (a.facingDirection = a.direction,
                a.direction = this.directionToMovement(a.facingDirection),
                t = !0))
            }
            if (2 === e.major && 5 === e.minor && 3 === e.patch)
                for (const e of this.doodads)
                    if (e) {
                        const a = m.default[e.type];
                        a && a.lit && !a.isUnlitTorch && void 0 !== e.decay && e.decay >= 0 && (e.decay = -1,
                        t = !0),
                        a && a.revert && !a.isLitTorch && -1 === e.decay && (e.decay = a.decayMax,
                        t = !0)
                    }
            if (2 === e.major && e.minor < 4) {
                t = !0;
                for (const e of this.doodads)
                    if (e && void 0 !== e.decay && e.decay > 0) {
                        const t = m.default[e.type];
                        t && (!t.isWaterSource && !t.lit || t.isWaterSource && !t.lit) && (e.decay *= 20)
                    }
                for (const e of this.corpses)
                    e && void 0 !== e.decay && e.decay > 0 && (e.decay *= 20);
                for (const e of this.tileEvents)
                    e && void 0 !== e.decay && e.decay > 0 && (e.decay *= 20)
            }
            t = this.upgradeSaveMoveProperty(game, localPlayer, "tamedCreatures") || t,
            t = this.upgradeSaveMoveProperty(ui, localPlayer, "dialogInfo") || t,
            t = this.upgradeSaveMoveProperty(ui, localPlayer, "dialogContainerInfo") || t,
            t = this.upgradeSaveMoveProperty(ui, localPlayer, "quickSlotInfo") || t,
            t = this.upgradeSaveMoveProperty(ui, localPlayer, "containerSortInfo") || t,
            localPlayer.dialogInfo[T.DialogId.Crafting] && 405 === localPlayer.dialogInfo[T.DialogId.Crafting].y && (localPlayer.dialogInfo[T.DialogId.Crafting].y = 445,
            t = !0),
            t = this.upgradeToClasses(this.items, M.default, e=>e.description()) || t,
            t = this.upgradeToClasses(this.creatures, s.default) || t,
            t = this.upgradeToClasses(this.doodads, h.default) || t;
            for (let e = 0; e < this.creatures.length; e++) {
                const a = this.creatures[e];
                void 0 !== a && (a.stats && a.getStat(g.Stat.Health) || (a.initializeStats(a.maxhp, a.hp),
                t = !0),
                void 0 !== a.happiness && (new f.default(g.Stat.Happiness,a.happiness).setChangeTimer(1, -1).initializeOn(a),
                delete a.happiness,
                t = !0),
                void 0 !== a.chickenEggCounter && (a.setStat(g.Stat.Produce, a.chickenEggCounter),
                delete a.chickenEggCounter,
                t = !0),
                void 0 !== a.goatMilkCounter && (a.setStat(g.Stat.Produce, a.goatMilkCounter),
                delete a.goatMilkCounter,
                t = !0))
            }
            for (let e = 0; e < this.npcs.length; e++) {
                const a = this.npcs[e];
                void 0 !== a && ("weightCapacity"in a.inventory && (delete a.inventory.weightCapacity,
                t = !0))
            }
            void 0 !== a.isRealTime && (this.turnMode = a.isRealTime ? T.TurnMode.RealTime : T.TurnMode.Manual,
            delete a.isRealTime,
            t = !0),
            void 0 !== a.realTimeTickSpeed && (this.tickSpeed = a.realTimeTickSpeed,
            delete a.realTimeTickSpeed,
            t = !0),
            void 0 === this.difficultyOptions && (this.difficultyOptions = I.getDefaultDifficultyOptions(this.difficulty),
            t = !0),
            t && qe.info(`Upgrading save from ${e.str} to ${gameVersion}`),
            this.previousSaveVersion = e,
            this.saveVersion = gameVersion
        }
        upgradePlayer(e, t) {
            const a = e;
            let i = !1;
            if ("containedWithin"in e.inventory && (delete e.inventory.containedWithin,
            i = !0),
            "weightCapacity"in e.inventory && (delete e.inventory.weightCapacity,
            i = !0),
            void 0 !== a.talent && (a.score = a.talent,
            a.malignity = a.talent,
            a.malignity > 64e3 && (a.malignity = 64e3),
            delete a.talent,
            i = !0),
            void 0 !== a.malignityPlus && (a.malignity = a.malignityPlus,
            delete a.malignityPlus,
            i = !0),
            void 0 !== a.malignityNegative && (a.benignity = -1 * a.malignityNegative,
            delete a.malignityNegative,
            i = !0),
            void 0 !== a.gender && (e.customization = {
                hairColor: T.HairColor[0 === a.gender ? T.HairColor["#7e4b1c"] : T.HairColor["#b84627"]],
                skinColor: T.SkinColor[T.SkinColor["#f0ceab"]],
                hairStyle: T.HairStyle[0 === a.gender ? T.HairStyle.Spike : T.HairStyle.Bun]
            },
            delete a.gender,
            i = !0),
            void 0 !== a.health) {
                const t = e.getStat(g.Stat.Health);
                e.setStat(t, a.health, y.StatChangeReason.Upgrade),
                t.changeTimer = a.healthTimer,
                delete a.health,
                delete a.healthTimer,
                i = !0
            }
            if (void 0 !== a.stamina) {
                const t = e.getStat(g.Stat.Stamina);
                e.setStat(t, a.stamina, y.StatChangeReason.Upgrade),
                t.changeTimer = a.staminaTimer,
                delete a.health,
                delete a.staminaTimer,
                i = !0
            }
            if (void 0 !== a.hunger) {
                const t = e.getStat(g.Stat.Hunger);
                e.setStat(t, a.hunger, y.StatChangeReason.Upgrade),
                t.changeTimer = a.hungerTimer,
                delete a.hunger,
                delete a.hungerTimer,
                i = !0
            }
            if (void 0 !== a.thirst) {
                const t = e.getStat(g.Stat.Thirst);
                e.setStat(t, a.thirst, y.StatChangeReason.Upgrade),
                t.changeTimer = a.thirstTimer,
                delete a.thirst,
                delete a.thirstTimer,
                i = !0
            }
            if (void 0 !== a.stats.health) {
                const t = e.getStat(g.Stat.Health);
                e.setStat(t, a.stats.health.value, y.StatChangeReason.Upgrade),
                t.changeTimer = a.stats.health.timer,
                delete a.stats.health,
                i = !0
            }
            if (void 0 !== a.stats.stamina) {
                const t = e.getStat(g.Stat.Stamina);
                e.setStat(t, a.stats.stamina.value, y.StatChangeReason.Upgrade),
                t.changeTimer = a.stats.stamina.timer,
                delete a.stats.stamina,
                i = !0
            }
            if (void 0 !== a.stats.hunger) {
                const t = e.getStat(g.Stat.Hunger);
                e.setStat(t, a.stats.hunger.value, y.StatChangeReason.Upgrade),
                t.changeTimer = a.stats.hunger.timer,
                delete a.stats.hunger,
                i = !0
            }
            if (void 0 !== a.stats.thirst) {
                const t = e.getStat(g.Stat.Thirst);
                e.setStat(t, a.stats.thirst.value, y.StatChangeReason.Upgrade),
                t.changeTimer = a.stats.thirst.timer,
                delete a.stats.thirst,
                i = !0
            }
            void 0 !== a.strength && (e.setStatMax(g.Stat.Health, a.strength),
            delete a.strength,
            i = !0),
            void 0 !== a.dexterity && (e.setStatMax(g.Stat.Stamina, a.dexterity),
            delete a.dexterity,
            i = !0),
            void 0 !== a.starvation && (e.setStatMax(g.Stat.Hunger, a.starvation),
            delete a.starvation,
            i = !0),
            void 0 !== a.dehydration && (e.setStatMax(g.Stat.Thirst, a.dehydration),
            delete a.dehydration,
            i = !0),
            void 0 !== a.weight && (e.setStat(g.Stat.Weight, a.weight),
            delete a.weight,
            i = !0),
            void 0 !== a.attack && (e.setStat(g.Stat.Attack, a.attack),
            delete a.attack,
            i = !0),
            void 0 !== a.malignity && (e.setStat(g.Stat.Malignity, a.malignity),
            delete a.malignity,
            i = !0),
            void 0 !== a.benignity && (e.setStat(g.Stat.Benignity, a.benignity),
            delete a.benignity,
            i = !0),
            "number" == typeof a.customization.hairStyle && (e.customization = {
                hairColor: T.HairColor[a.customization.hairColor],
                skinColor: T.SkinColor[a.customization.skinColor],
                hairStyle: T.HairStyle[a.customization.hairStyle]
            },
            i = !0),
            (e.getMaxHealth() !== e.getStatMax(g.Stat.Health) || t.major <= 2 && t.minor < 7) && (e.setStat(g.Stat.Strength, e.getStatMax(g.Stat.Health), y.StatChangeReason.Upgrade),
            e.setStatBonus(g.Stat.Strength, X.STRENGTH_BONUS, y.StatChangeReason.Upgrade),
            i = !0);
            try {
                const t = e.getStat(g.Stat.Health)
                  , a = e.getStat(g.Stat.Stamina)
                  , n = e.getStat(g.Stat.Hunger)
                  , o = e.getStat(g.Stat.Thirst);
                if (t && a && n && o && 0 === t.value && 0 === a.value && 0 === n.value && 0 === o.value) {
                    const t = 5;
                    e.setStatMax(a, Fe.default.int(10 + t) + 70),
                    e.setStat(g.Stat.Strength, Fe.default.int(5 + t) + 45, y.StatChangeReason.Upgrade),
                    e.setStatMax(n, Fe.default.int(5 + t) + 15),
                    e.setStatMax(o, Fe.default.int(5 + t) + 15),
                    e.setStat(g.Stat.Stamina, a.max - Fe.default.int(10), y.StatChangeReason.Upgrade),
                    e.setStat(g.Stat.Health, e.getMaxHealth() - Fe.default.int(5), y.StatChangeReason.Upgrade),
                    e.setStat(g.Stat.Hunger, n.max - Fe.default.int(2), y.StatChangeReason.Upgrade),
                    e.setStat(g.Stat.Thirst, o.max - Fe.default.int(2), y.StatChangeReason.Upgrade),
                    i = !0
                }
            } catch (e) {}
            return i = e.messages.pruneMessageHistory() || i,
            e.identifier || (e.identifier = He.default.create(),
            i = !0),
            a.exploredMapEncodedData && (e.clientStore.get(ge.ClientDataType.ExploredMap).exploredMapEncodedData = a.exploredMapEncodedData,
            delete a.exploredMapEncodedData,
            i = !0),
            i
        }
        upgradeSaveMoveProperty(e, t, a, i=a) {
            const n = e[a];
            return void 0 !== n && (t[i] = n,
            delete e[a],
            !0)
        }
        upgradeGlobalSave(e) {
            let t = !1;
            const a = game
              , i = saveDataGlobal.options;
            if (a.crafted && (saveDataGlobal.gameCrafted = a.crafted,
            delete a.crafted,
            t = !0),
            saveDataGlobal.gameCrafted && "object" == typeof saveDataGlobal.gameCrafted) {
                const e = Object.keys(saveDataGlobal.gameCrafted);
                for (const a of e) {
                    const e = parseInt(a, 10)
                      , i = saveDataGlobal.gameCrafted[e];
                    "object" != typeof i && (saveDataGlobal.gameCrafted[e] = {
                        newUnlock: !1,
                        unlockTime: Date.now()
                    },
                    t = !0)
                }
            }
            if (a.options && (saveDataGlobal.options = a.options,
            delete a.options,
            t = !0),
            a.highscores)
                for (const e of a.highscores)
                    void 0 !== e.talent && (e.score = e.talent,
                    delete e.talent,
                    t = !0);
            saveDataGlobal.playerMilestoneData || (saveDataGlobal.playerMilestoneData = {},
            t = !0),
            2 === e.major && e.minor <= 3 && e.patch <= 3 && (t = !0,
            saveDataGlobal.options.alternateContextMenu = !0,
            saveDataGlobal.options.rightClickInspect = !0),
            "boolean" == typeof saveDataGlobal.options.directionTurnDelay && (saveDataGlobal.options.directionTurnDelay = !0 === saveDataGlobal.options.directionTurnDelay ? 13 : 0),
            a.highscores && (saveDataGlobal.gameHighscores = a.highscores,
            delete a.highscores,
            t = !0),
            void 0 !== a.lastPlayedVersion && (saveDataGlobal.gameLastPlayedVersion = a.lastPlayedVersion,
            delete a.lastPlayedVersion,
            t = !0),
            void 0 !== a.playedCount && (saveDataGlobal.gamePlayedCount = a.playedCount,
            delete a.playedCount,
            t = !0);
            const n = saveDataGlobal.gameHighscores;
            for (const e of n)
                e && "boolean" == typeof e.dailyChallenge && (e.difficulty = e.dailyChallenge ? I.Difficulty.Challenge : I.Difficulty.Hardcore,
                delete e.dailyChallenge,
                t = !0);
            "boolean" == typeof i.developerLogging && (saveDataGlobal.options.developerMode = i.developerLogging,
            delete i.developerLogging,
            t = !0),
            "boolean" == typeof i.skipIntro && (saveDataGlobal.options.skipSplash = i.skipIntro,
            delete i.skipIntro,
            t = !0),
            "boolean" == typeof i.hints && (delete i.hints,
            t = !0),
            "boolean" == typeof i.openNotesAutomatically && (delete i.openNotesAutomatically,
            t = !0),
            "boolean" == typeof i.worldTooltips && (delete i.worldTooltips,
            t = !0),
            "boolean" == typeof i.allowDiagonalMovement && (saveDataGlobal.options.alternatingDirectionMovement = i.allowDiagonalMovement,
            delete i.allowDiagonalMovement,
            t = !0);
            for (const e of ["Doodads", "Items", "NPCs", "Terrain", "Creatures"])
                "boolean" == typeof i[`tooltips${e}`] && (delete i[`tooltips${e}`],
                t = !0);
            if ("boolean" == typeof i.dropUnderYourself && (saveDataGlobal.options.dropLocation = i.dropUnderYourself ? T.DropLocation.Feet : T.DropLocation.Facing,
            delete i.dropUnderYourself,
            t = !0),
            2 === e.major && 5 === e.minor && e.patch < 6) {
                const e = {};
                for (const t in i.bindings) {
                    const a = T.Bindable[t];
                    a && (e[a] = i.bindings[t])
                }
                saveDataGlobal.options.bindings = e
            }
            const o = saveDataGlobal.gameHighscores.filter(e=>"object" == typeof e && "number" == typeof e.score);
            saveDataGlobal.gameHighscores.length !== o.length && (saveDataGlobal.gameHighscores = o,
            t = !0),
            t && qe.info(`Upgrading global save from ${e.str} to ${gameVersion}`)
        }
    }
    __decorate([Ie.SaveProperty()], Ue.prototype, "contaminatedWater", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "corpses", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "creatures", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "creatureSpawnTimer", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "difficulty", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "difficultyOptions", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "doodads", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "flowFieldSyncCount", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "items", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "lastCreationIds", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "mapGenVersion", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "npcs", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "turnMode", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "tickSpeed", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "saveVersion", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "seeds", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "shouldUpdateTablesAndWeight", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "tileContainers", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "tileData", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "wellData", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "tileEvents", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "time", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "version", void 0),
    __decorate([Ie.SaveProperty()], Ue.prototype, "worldId", void 0),
    __decorate([Oe.Bound], Ue.prototype, "updateRenderInternal", null),
    t.default = Ue;
    const ze = async()=>{
        try {
            try {
                steamworks = new we.default,
                steamworks.initialize()
            } catch (e) {
                qe.info("Failed to initialize steamworks", e)
            } finally {
                void 0 !== e && (window.require = void 0),
                "undefined" != typeof requirejs && (window.requirejs = void 0)
            }
            steamworks.isDedicatedServer() ? (audio = p.audio,
            renderer = p.worldRenderer,
            resourceLoader = p.resourceLoader) : (await le.loadShaders(),
            audio = new i.default,
            resourceLoader = new ye.default),
            commandManager = new n.default,
            corpseManager = new o.default,
            creatureManager = new l.default,
            doodadManager = new c.default,
            itemManager = new b.default,
            languageManager = new R.default,
            modManager = new F.default,
            multiplayer = new H.default,
            multiplayerNetworkingOptions = _.networkingOptions,
            npcManager = new Q.default,
            saveData = new fe.default,
            saveDataGlobal = new Te.default,
            saveManager = new ve.default,
            spriteAtlas = new ue.default,
            tileAtlas = new pe.default,
            tileEventManager = new Ce.default,
            Re.default.initialize(),
            Ne.default.loadAndCompileModules(),
            game = new Ue,
            game.initialize(),
            ui = new Ae.default,
            ui.initialize(),
            newui = new z.default,
            ui.onWindowResize(),
            saveManager.initialize()
        } catch (e) {
            qe.error("Failed to load game", e)
        }
    }
    ;
    "complete" === document.readyState ? ze() : window.onload = ze,
    document.addEventListener("visibilitychange", ()=>{
        game && (game.visible = "visible" === document.visibilityState)
    }
    )
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("newui/component/EnumContextMenu", ["require", "exports", "newui/BindingManager", "newui/component/ContextMenu", "newui/component/Text", "utilities/enum/Enums", "utilities/iterable/Collectors", "utilities/iterable/Generators"], function(e, t, a, i, n, o, r, s) {
    var l;
    Object.defineProperty(t, "__esModule", {
        value: !0
    }),
    function(e) {
        e[e.Name = 0] = "Name",
        e[e.Id = 1] = "Id"
    }(l = t.EnumSort || (t.EnumSort = {}));
    class u {
        constructor(e, t, a) {
            this.api = e,
            this.translator = a,
            this.enumEntries = o.default.entries(t).collect(r.default.toArray)
        }
        setTranslator(e) {
            return this.translator = e,
            this
        }
        setSort(e) {
            return this._sort = e,
            this
        }
        async waitForChoice() {
            const e = newui.getVisibleScreen();
            if (!e || !this.translator)
                return;
            const t = a.bindingManager.getMouse();
            return this.enumEntries.sort(([,e],[,t])=>{
                switch (this._sort) {
                case l.Id:
                    return e - t;
                case l.Name:
                    return n.default.toString(this.translator(e)).localeCompare(n.default.toString(this.translator(t)));
                default:
                    return this._sort(e, t)
                }
            }
            ),
            new Promise(a=>{
                new i.default(this.api,...this.enumEntries.map(([e,t])=>s.tuple(e,{translation:this.translator(t),onActivate(){a(t)}}))).addAllDescribedOptions().setPosition(t.x, t.y).schedule(e.setContextMenu).on("Hide", ()=>{
                    a(void 0)
                }
                )
            }
            )
        }
    }
    t.default = u
}),
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
define("utilities/ServerDirectory", ["require", "exports", "multiplayer/IMultiplayer", "utilities/Files"], function(e, t, a, i) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    });
    class n {
        async getServerList() {
            const e = await i.default .getJson(`http://${a.networkingOptions.matchmakingServer}:38741/api/v1/servers`);
            return e.servers
        }
    }
    const o = new n;
    t.default = o
});
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */
/*!
 * Copyright Unlok, Vaughn Royko 2011-2018
 * http://www.unlok.ca
 *
 * Credits & Thanks:
 * http://www.unlok.ca/credits-thanks/
 *
 * Wayward is a copyrighted and licensed work. Modification and/or distribution of any source files is prohibited. If you wish to modify the game in any way, please refer to the modding guide:
 * https://waywardgame.github.io/
 */